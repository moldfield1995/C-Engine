//---------------------------------------------------------------------------------
// File Name: zpta002.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "../Physics/zpta000.h"
#include <memory.h>
namespace\

TA
{
#ifdef lOllllOlOlO
st\
atic
co\
nst\

u3\
2
lOl\
ll\
lOl\
Oll
[
256
]
=
{
0x00000000
,
0x00000001
,
0x00000011
,
0x00000082
,
0x00000021
,
0x00000102
,
0x00000112
,
0x00000883
,
0x00000031
,
0x00000182
,
0x00000192
,
0x00000c83
,
0x000001a2
,
0x00000d03
,
0x00000d13
,
0x00006884
,
0x00000041
,
0x00000202
,
0x00000212
,
0x00001083
,
0x00000222
,
0x00001103
,
0x00001113
,
0x00008884
,
0x00000232
,
0x00001183
,
0x00001193
,
0x00008c84
,
0x000011a3
,
0x00008d04
,
0x00008d14
,
0x00046885
,
0x00000051
,
0x00000282
,
0x00000292
,
0x00001483
,
0x000002a2
,
0x00001503
,
0x00001513
,
0x0000a884
,
0x000002b2
,
0x00001583
,
0x00001593
,
0x0000ac84
,
0x000015a3
,
0x0000ad04
,
0x0000ad14
,
0x00056885
,
0x000002c2
,
0x00001603
,
0x00001613
,
0x0000b084
,
0x00001623
,
0x0000b104
,
0x0000b114
,
0x00058885
,
0x00001633
,
0x0000b184
,
0x0000b194
,
0x00058c85
,
0x0000b1a4
,
0x00058d05
,
0x00058d15
,
0x002c6886
,
0x00000061
,
0x00000302
,
0x00000312
,
0x00001883
,
0x00000322
,
0x00001903
,
0x00001913
,
0x0000c884
,
0x00000332
,
0x00001983
,
0x00001993
,
0x0000cc84
,
0x000019a3
,
0x0000cd04
,
0x0000cd14
,
0x00066885
,
0x00000342
,
0x00001a03
,
0x00001a13
,
0x0000d084
,
0x00001a23
,
0x0000d104
,
0x0000d114
,
0x00068885
,
0x00001a33
,
0x0000d184
,
0x0000d194
,
0x00068c85
,
0x0000d1a4
,
0x00068d05
,
0x00068d15
,
0x00346886
,
0x00000352
,
0x00001a83
,
0x00001a93
,
0x0000d484
,
0x00001aa3
,
0x0000d504
,
0x0000d514
,
0x0006a885
,
0x00001ab3
,
0x0000d584
,
0x0000d594
,
0x0006ac85
,
0x0000d5a4
,
0x0006ad05
,
0x0006ad15
,
0x00356886
,
0x00001ac3
,
0x0000d604
,
0x0000d614
,
0x0006b085
,
0x0000d624
,
0x0006b105
,
0x0006b115
,
0x00358886
,
0x0000d634
,
0x0006b185
,
0x0006b195
,
0x00358c86
,
0x0006b1a5
,
0x00358d06
,
0x00358d16
,
0x01ac6887
,
0x00000071
,
0x00000382
,
0x00000392
,
0x00001c83
,
0x000003a2
,
0x00001d03
,
0x00001d13
,
0x0000e884
,
0x000003b2
,
0x00001d83
,
0x00001d93
,
0x0000ec84
,
0x00001da3
,
0x0000ed04
,
0x0000ed14
,
0x00076885
,
0x000003c2
,
0x00001e03
,
0x00001e13
,
0x0000f084
,
0x00001e23
,
0x0000f104
,
0x0000f114
,
0x00078885
,
0x00001e33
,
0x0000f184
,
0x0000f194
,
0x00078c85
,
0x0000f1a4
,
0x00078d05
,
0x00078d15
,
0x003c6886
,
0x000003d2
,
0x00001e83
,
0x00001e93
,
0x0000f484
,
0x00001ea3
,
0x0000f504
,
0x0000f514
,
0x0007a885
,
0x00001eb3
,
0x0000f584
,
0x0000f594
,
0x0007ac85
,
0x0000f5a4
,
0x0007ad05
,
0x0007ad15
,
0x003d6886
,
0x00001ec3
,
0x0000f604
,
0x0000f614
,
0x0007b085
,
0x0000f624
,
0x0007b105
,
0x0007b115
,
0x003d8886
,
0x0000f634
,
0x0007b185
,
0x0007b195
,
0x003d8c86
,
0x0007b1a5
,
0x003d8d06
,
0x003d8d16
,
0x01ec6887
,
0x000003e2
,
0x00001f03
,
0x00001f13
,
0x0000f884
,
0x00001f23
,
0x0000f904
,
0x0000f914
,
0x0007c885
,
0x00001f33
,
0x0000f984
,
0x0000f994
,
0x0007cc85
,
0x0000f9a4
,
0x0007cd05
,
0x0007cd15
,
0x003e6886
,
0x00001f43
,
0x0000fa04
,
0x0000fa14
,
0x0007d085
,
0x0000fa24
,
0x0007d105
,
0x0007d115
,
0x003e8886
,
0x0000fa34
,
0x0007d185
,
0x0007d195
,
0x003e8c86
,
0x0007d1a5
,
0x003e8d06
,
0x003e8d16
,
0x01f46887
,
0x00001f53
,
0x0000fa84
,
0x0000fa94
,
0x0007d485
,
0x0000faa4
,
0x0007d505
,
0x0007d515
,
0x003ea886
,
0x0000fab4
,
0x0007d585
,
0x0007d595
,
0x003eac86
,
0x0007d5a5
,
0x003ead06
,
0x003ead16
,
0x01f56887
,
0x0000fac4
,
0x0007d605
,
0x0007d615
,
0x003eb086
,
0x0007d625
,
0x003eb106
,
0x003eb116
,
0x01f58887
,
0x0007d635
,
0x003eb186
,
0x003eb196
,
0x01f58c87
,
0x003eb1a6
,
0x01f58d07
,
0x01f58d17
,
0x0fac6888
,
}
;
#endif
cons\
t\

float
lOOOl\
O\
OOl\
l
=
0.001f
;
#ifdef _DEBUG
#define lOllllOllOO() if (lOOlOOOllO){  lOllllOllOl(lOllllOlllO); lOllllOllll(); }
#define lOlllllOOOO(x, y) if (lOOlOOOllO) { TA_ASSERT(lOlllllOOOl(x, y)); }
#define lOlllllOOlO(x) if (lOOlOOOllO) { TA_ASSERT(lOlllllOOll(x)); }
#define lOlllllOlOO(x) if (lOOlOOOllO) { x }
#else
#define lOllllOllOO() 
#define lOlllllOOOO(x, y)
#define lOlllllOOlO(x)
#define lOlllllOlOO(x)
#endif
lOl\
ll\
llOlOl
::
lOlllll\
OlO\
l
(
)
{
lOl\
lll\
lO\
llO
.
Clear
(
)
;
lOlllllOlll\

=
0
;
lOl\
lll\
OlllO
=
0
;
lOlllll\
lOOO
=
0
;
#ifdef _DEBUG
lO\
lllll\
lOO\
l
=
0
;
lOllllllOl\
O
=
0
;
lOl\
l\
lll\
lOll
=
0
;
lOl\
lll\
ll\
lOO\

=
0
;
lO\
lll\
l\
l\
llOl
=
0
;
#endif //
}
lOl\
llllOlOl
::
~
lO\
ll\
ll\
lO\
lOl\

(
)
{
Fina\
li\
se\

(
)
;
}
voi\
d
lO\
lll\
l\
lO\
lOl
::
Initi\
ali\
se
(
const
Ve\
c3
&
v3C\
enter\

,
float
lOllllll\
l\
l\
O
)
{
lO\
OO\
OOO\
llO\

(
lOll\
llOlllO
==
0
,
"CTree::Initialise: Already initialised")
;
lOOO\
OOOl\
lO
(
lOlll\
lllOOO
==
0
,
"CTree::Initialise: Already initialised")
;
lOl\
llll\
Olll
=
1.0f
*
(
fl\
oat
)
(
1
<<
30
)
/
lO\
llll\
llllO
;
lOlllllO\
llO
.
x
=
lOllll\
ll\
l\
lO\

*
0.5f
;
lOl\
lll\
lO\
llO
.
y
=
lOll\
llllllO\

*
0.5f
;
lOlllll\
Ol\
lO
.
z
=
lOllllllllO\

*
0.5f
;
lOllll\
OlllO\

=
0
;
}
void
lOlllllOlOl
::
Fi\
nalis\
e\

(
)
{
lO\
l\
ll\
ll\
Ol\
lO\

.
Clear
(
)
;
lOlllllO\
l\
l\
l\

=
0
;
lO\
lll\
lOlll\
O\

=
0
;
lOllllllO\
OO
=
0
;
#ifdef _DEBUG
lO\
ll\
ll\
l\
lO\
O\
l
=
0
;
lO\
ll\
llllOl\
O\

=
0
;
lOllll\
l\
lOll
=
0
;
lO\
llllll\
lOO\

=
0
;
lO\
llll\
lllOl
=
0
;
#endif //
}
voi\
d\

lOll\
ll\
lO\
lO\
l
::
lO\
lllllllll
(
Spac\
eDivisio\
nO\
bje\
ct
&
ll\
OO\
O\
OO\
OOO\
O\

)
{
llO\
OOOOOOO\
l
*
lOOll\
lOO\
OO
=
(
ll\
OOOOO\
OOO\
l
*
)
ll\
OOOO\
O\
OOOO\

.
Ge\
tS\
pa\
c\
eD\
iv\
isionNod\
eMem\
ory
(
)
;
TA_\
ASSER\
T\

(
ll\
OOOOOOO\
O\
O
.
GetSpac\
eD\
ivisi\
onNode\
Memo\
r\
ySi\
ze\

(
)
>=
sizeo\
f
(
ll\
OOOOOOO\
Ol
)
)
;
TA_\
A\
SS\
ERT
(
lO\
Olll\
OO\
O\
O
)
;
lOO\
l\
l\
lO\
OOO
->
llOOOOOOOlO\

.
lOlO\
llOO\
l\
l\

=
llOOOOO\
O\
Oll
;
#ifdef _DEBUG
lOllllllOl\
l\

++
;
lOlllllllO\
l
++
;
#endif //
ll\
OOOOOOl\
O\
O\

(
&
lOOll\
lOO\
OO
->
ll\
OOOOO\
OOl\
O
)
;
lO\
OlllOO\
OO
->
llOOOOOO\
lO\
l\

.
lOlOllO\
Oll
=
llOOO\
OOOllO
;
lOll\
ll\
Oll\
OO
(
)
}
voi\
d
lOl\
llll\
O\
lOl
::
ll\
OOOO\
OOlll
(
Spa\
c\
eDiv\
is\
ion\
Obje\
ct\

&
ll\
OOOOOOOOO\

)
{
lOllllOllOO
(
)
llOOOOOOO\
O\
l
*
lOOll\
lOO\
OO
=
(
llOOOOOOO\
Ol\

*
)
llOOOOOO\
O\
OO
.
Ge\
t\
SpaceDiv\
isi\
onNo\
d\
e\
Memo\
r\
y\

(
)
;
TA_ASSER\
T
(
lOO\
l\
llO\
OOO\

)
;
ll\
OO\
O\
OOlOO\
O\

*
llOOO\
O\
OlOOl
=
&
lO\
Oll\
lOOOO\

->
llOO\
OOOOOlO\

;
if
(
llOOOO\
OlOOl
->
lOlOllOOll
&
llOO\
OO\
OlOlO
)
{
lO\
ll\
lll\
O\
OlO\

(
llOOO\
OOlO\
Ol
)
ll\
OOOOOl\
Ol\
l
*
llOO\
OOOl\
lOO
=
(
llOOOOOlOll
*
)
llOOO\
OOlOOl\

;
if
(
llOO\
OOOllOO
->
llO\
OOOOl\
lOl
)
{
ll\
O\
OO\
OOll\
OO
->
llO\
OO\
O\
OllO\
l
->
ll\
OOOOO\
l\
llO\

=
llO\
OOOOll\
OO\

->
llO\
OOOOlllO
;
}
else
{
TA_AS\
S\
ERT
(
lOll\
ll\
llO\
O\
O
==
llOOO\
OO\
llOO
)
;
lOllll\
ll\
OOO
=
llOOOOOllOO
->
llO\
OOOOlllO
;
}
if
(
ll\
OOO\
OO\
llO\
O
->
llOOO\
OOl\
ll\
O
)
llOOO\
O\
OllOO
->
llOOOOO\
l\
l\
lO
->
ll\
OO\
O\
OO\
llO\
l
=
ll\
OO\
OOOl\
lOO
->
llO\
O\
O\
O\
OllOl\

;
#ifdef _DEBUG
lO\
llll\
llOlO\

--
;
lOllllll\
lOl
--
;
#endif //
lOll\
llO\
llOO
(
)
lOlllllOlOO\

(
TA\
_ASSER\
T
(
!
lOlllll\
O\
Ol\
l
(
llOOO\
OOl\
OO\
l\

)
)
;
)
lOllll\
lOlOO
(
TA_ASSERT
(
!
lO\
ll\
lllOO\
Ol
(
ll\
OOOOO\
l\
O\
Ol
)
)
;
)
}
el\
se\

{
lOlllllO\
OO\
O
(
lOl\
l\
l\
lOll\
lO
,
llO\
O\
OOO\
lOO\
l
)
llO\
OOOOlOOO\

*
llOOO\
OOllll
=
llOOOOl\
O\
OO\
O
(
)
;
TA_AS\
S\
ER\
T\

(
llO\
OO\
O\
l\
OOOl
(
llOOOOOllll
)
)
;
mem\
cpy
(
ll\
OOO\
OO\
l\
l\
ll
,
llOO\
OOOlOOl
,
sizeof
(
ll\
O\
OOOOlOOO
)
)
;
TA_AS\
SERT\

(
(
llOOOOOlll\
l
->
lO\
lOllOOll
&
ll\
OOOOOl\
O\
lO
)
==
0
)
;
if
(
ll\
OOOOOllll
->
llOOO\
OOllOl
)
{
TA_\
A\
SSER\
T
(
llOOOOlO\
OOl
(
llOOOOO\
llll
->
ll\
OOOOOl\
lOl
)
)
;
TA_AS\
SE\
RT
(
llOOOOOllll\

->
llOO\
OOOl\
l\
Ol
->
llOO\
OOl\
OOlO
)
;
TA_ASSERT
(
llOOO\
OOllll\

->
llOOOOOllOl
->
llOOO\
OlO\
Oll
[
llOOOOOlll\
l
->
llOOOOlO\
lO\
O\

]
==
ll\
OOOOO\
lOO\
l
)
;
llOOOO\
Ol\
l\
ll
->
llO\
OO\
OO\
l\
lOl\

->
llOOOO\
lO\
Oll
[
ll\
OOO\
OOllll
->
llOO\
OOlOlO\
O\

]
=
llOOOOOll\
l\
l
;
}
el\
s\
e\

{
TA_AS\
SERT
(
lOllllOlllO
==
llOOOO\
O\
lOOl
)
;
lOllllOlllO
=
ll\
OOOO\
O\
llll
;
}
for\

(
int
llOOOOl\
OlOl
=
0
;
ll\
OOO\
Ol\
O\
lOl
<
8
;
llOOO\
Ol\
OlOl
++
)
{
if\

(
llO\
OO\
OOllll
->
ll\
OO\
OOlOOlO\

&
(
1
<<
llO\
O\
O\
Ol\
OlOl
)
)
{
TA_ASSERT
(
llOOOOOll\
l\
l
->
ll\
OO\
OO\
l\
O\
Oll
[
llO\
O\
OOlOl\
Ol
]
)
;
llO\
OOOOllll\

->
llO\
O\
O\
OlOOl\
l
[
llO\
OOOlOl\
Ol\

]
->
llOOOO\
Oll\
Ol\

=
ll\
OOOOOl\
lll
;
}
else\

{
TA_AS\
SERT
(
llOOOO\
Ol\
lll
->
llOOOOlOOll
[
llOOOOlOlO\
l\

]
==
0
)
;
}
}
if
(
ll\
OO\
O\
OOllll
->
ll\
OO\
OOlOllO
)
llOOOO\
Ollll
->
llO\
OOOl\
OllO
->
llOOOOlOl\
ll
=
&
llOOOOOll\
ll
->
ll\
O\
OO\
OlOl\
lO
;
#ifdef _DEBUG		
lO\
llll\
ll\
Oll
--
;
lOlll\
lll\
lOl
--
;
#endif //
lO\
lll\
lOll\
OO
(
)
lOll\
ll\
lO\
lO\
O\

(
TA_ASSE\
RT\

(
!
lOl\
ll\
l\
lO\
Oll
(
llOOOO\
O\
lO\
Ol
)
)
;
)
lOlllll\
Ol\
OO\

(
TA_ASS\
ERT
(
!
lOlll\
llO\
O\
Ol
(
ll\
OO\
OOOlOOl\

)
)
;
)
}
lOll\
llO\
l\
lOO\

(
)
}
void
lO\
lllllOlOl
::
lO\
lOlO\
OOOl
(
Sp\
aceD\
i\
v\
isionObject
&
ll\
OOO\
OOOOO\
O
)
{
SpaceD\
ivisio\
n\
Ob\
ject
*
ll\
O\
O\
O\
OllOOO\

=
&
ll\
OOO\
OOOOOO\

;
cons\
t
AAB\
B\

&
lO\
OO\
O\
OOlll
=
llOO\
OOll\
OO\
O
->
GetCollis\
i\
o\
nGri\
dWorldAA\
B\
B\

(
)
;
float
llO\
lllOOO\
l
=
lOO\
OOOOlll\

.
v3E\
xte\
nt
[
lOOOOOOlll
.
v3\
E\
xt\
ent\

.
GetG\
reatestAxis
(
)
]
*
lOll\
l\
ll\
Ol\
l\
l
;
con\
st
fl\
oat
ll\
OOOOl\
l\
OOl
=
1
<<
30
;
if\

(
llO\
lllOO\
Ol
>
llO\
O\
O\
OllOOl
*
0.5f
)
ll\
Ol\
l\
lOOOl
=
llOOOOl\
lOOl
*
0.5f
;
Vec3
ll\
OO\
llll\
lO
=
(
lO\
O\
OOOOlll
.
v3Ce\
nte\
r
+
lO\
ll\
ll\
lOll\
O\

)
*
lOl\
ll\
llOll\
l\

;
Cl\
amp\

(
llOO\
lllllO
.
x
,
0.0f
,
llOOOOll\
OOl
)
;
Clam\
p\

(
ll\
OOlllllO
.
y
,
0.0f
,
llOOO\
O\
llOOl
)
;
Cla\
mp
(
llOOl\
ll\
l\
lO\

.
z
,
0.0f
,
llOOOOllO\
O\
l
)
;
u32
llO\
O\
OOl\
lO\
lO\

=
ll\
OOOOl\
lOll
(
Fa\
stFloat\
To\
I\
nt
(
llOlllO\
O\
O\
l\

)
)
;
int
lOl\
lOlO\
l\
llO
=
~
(
(
llOOOOl\
l\
OlO
<<
1
)
+
0xFFFFFFFF
)
;
u3\
2\

llO\
OOOlllOO
=
FastF\
lo\
atToI\
nt
(
llOOlllllO\

.
x
)
&
lOl\
lOlO\
ll\
lO
;
u32
llO\
OOO\
lllO\
l\

=
Fa\
s\
t\
F\
loatToI\
nt\

(
llOOlllllO
.
y
)
&
lOl\
lOlOlllO
;
u32
llOO\
OOl\
lll\
O
=
Fas\
t\
Float\
ToI\
nt
(
llOOllll\
l\
O
.
z
)
&
lOllOlOl\
ll\
O\

;
llOOOOlllOO
+=
llOOO\
O\
llO\
l\
O
;
llOO\
OOlllOl
+=
ll\
OOOOll\
O\
lO
;
ll\
OO\
OOll\
l\
lO
+=
llOOOO\
llOlO
;
llO\
OOOOOOO\
l
*
lOOlllOOOO\

=
(
llOOOOOO\
OOl\

*
)
llOO\
O\
OllO\
OO
->
GetS\
p\
a\
ceDivi\
s\
ionNodeMe\
mory
(
)
;
TA\
_\
ASSERT\

(
lOO\
lllOOO\
O
)
;
ll\
OO\
OOl\
ll\
ll\

&
lO\
OlO\
Olll\
lO
=
lOOll\
lOOO\
O
->
llOOOO\
O\
O\
l\
Ol
;
if
(
llO\
O\
OOOOO\
O\
O
.
ll\
OO\
O\
OlOl\
l\
l
)
{
if
(
ll\
OO\
OOlllO\
O\

==
lOO\
lOO\
ll\
llO\

.
llOOOOll\
lO\
O
&&
llO\
OOOlll\
Ol
==
lOO\
lO\
O\
ll\
ll\
O
.
llO\
OOOll\
l\
Ol
&&
llOOO\
OllllO\

==
lO\
Ol\
OOl\
ll\
l\
O
.
llOOOOllllO
&&
llOOOOll\
Ol\
O\

==
lOOl\
OO\
lll\
l\
O
.
llO\
OO\
Ol\
lOlO\

)
re\
tur\
n\

;
lOOl\
llll\
l\
l
(
llOO\
OOOOO\
O\
O
)
;
}
TA_ASSE\
RT
(
!
lOlllllOOOl
(
(
llOOOOOlOOO
*
)
&
lOOlllOOOO
->
llOOO\
O\
O\
OlOl
)
)
;
lOO\
lOO\
llllO\

.
llOOOO\
l\
O\
llO
=
llOO\
O\
O\
l\
lOOO
;
lOOlOOll\
llO
.
llO\
O\
OOll\
OlO\

=
ll\
OOOOllOl\
O
;
lOOlOOll\
llO
.
llOOOOlllOO
=
llOOOOlllOO
;
lOOl\
OOll\
llO
.
ll\
OOOOlllOl
=
ll\
OOOO\
lllO\
l\

;
lO\
OlO\
Oll\
llO
.
llO\
OOO\
ll\
l\
lO
=
llO\
OOOllll\
O
;
lOOlOOllllO\

.
lO\
lO\
llO\
Oll
=
llOOOO\
OlOlO
|
llO\
OO\
OO\
OllO
;
#ifdef _DEBUG
lO\
llll\
llOOl\

++
;
#endif //
llO\
O\
OlO\
OOOO\

(
lOOlOOllllO\

)
;
}
voi\
d
lOlllllOlOl
::
lOOlllllll\

(
SpaceDivi\
sion\
Obj\
ect
&
llOOOOOOOOO
)
{
if
(
!
llOOOOOO\
OO\
O
.
llOO\
O\
OlO\
lll
)
{
TA_ASSERT\

(
llOOOOOOOOO
.
llOOOl\
OOO\
O\
l
==
0
)
;
return\

;
}
lO\
l\
lllOl\
l\
OO\

(
)
Sp\
ac\
eDiv\
is\
ionObject
*
llOOOOl\
l\
OOO
=
&
llOOOOO\
OOOO\

;
TA\
_ASSERT
(
ll\
OO\
OOl\
lOOO
)
;
TA\
_A\
SSE\
RT\

(
llOOOOllOOO\

->
ll\
O\
OOOlOl\
ll
)
;
TA_ASS\
E\
RT
(
*
ll\
OOO\
OllOO\
O
->
llO\
OOOlO\
l\
ll\

==
llO\
OOO\
llOO\
O
)
;
ll\
O\
OOOO\
OOOl
*
lOOl\
ll\
OOOO\

=
(
llOOO\
OOO\
OO\
l
*
)
llOO\
OO\
llO\
OO
->
Ge\
tSpac\
e\
D\
ivisi\
o\
nNo\
deMemo\
ry
(
)
;
TA_ASS\
ER\
T
(
lOOlll\
O\
O\
OO
)
;
if\

(
*
(
u32
*
)
(
(
uSize
)
llOOOOllOOO\

->
llOO\
OOl\
Olll
+
siz\
e\
of\

(
uSize\

)
)
==
0
)
{
uS\
iz\
e\

lOO\
lllOl\
lO
=
(
uSi\
ze\

)
&
llO\
OO\
Oll\
OOO
->
llO\
OO\
lOOOOl
-
(
uS\
iz\
e
)
ll\
OO\
O\
Oll\
O\
O\
O\

;
SpaceD\
iv\
i\
sionObject
*
llOOOO\
O\
l\
lO\
l\

=
(
Spac\
eDivi\
sionO\
b\
j\
ect
*
)
(
(
uSiz\
e
)
llO\
OOO\
llO\
O\
O
->
llOO\
OOl\
O\
lll
-
(
uSi\
ze
)
lOOlllO\
l\
l\
O
)
;
TA_\
ASSER\
T\

(
*
llO\
OO\
OOllOl
->
llO\
OO\
Ol\
O\
lll
==
llOOO\
OO\
llO\
l
)
;
TA_\
ASSERT\

(
ll\
OOOOOl\
lOl
->
llO\
OO\
lOOOOl
==
ll\
O\
OOO\
l\
lOOO
)
;
TA_ASSERT
(
&
llOO\
OOOllOl
->
llO\
O\
Ol\
OO\
O\
Ol
==
llOOOOll\
O\
OO\

->
ll\
O\
O\
OO\
lO\
l\
l\
l\

)
;
ll\
OO\
O\
O\
OllO\
l
->
llOOO\
lOOOOl
=
llOOOOllOOO
->
ll\
OOOlO\
OOO\
l
;
if\

(
llOO\
OOOllOl
->
llOOO\
lOOOOl
)
llOO\
OO\
OllOl
->
ll\
OOOlO\
OOOl
->
llOO\
O\
O\
lO\
lll
=
&
llO\
OOOOllOl
->
ll\
O\
OOlOOOOl
;
llOOO\
Ol\
lOOO
->
ll\
OOO\
lOOOOl
=
0
;
llO\
OO\
OllO\
OO
->
llOOOO\
lOlll
=
0
;
#ifdef _DEBUG
lOllllllOOl
--
;
#endif //
lO\
l\
lll\
OllO\
O
(
)
llOO\
OOO\
OO\
Ol
*
lO\
Ol\
ll\
OOOO
=
(
llO\
OOOOOOOl
*
)
llOOOOllOOO
->
Ge\
tSp\
ac\
e\
D\
iv\
isionNodeM\
emor\
y
(
)
;
TA_A\
SS\
ERT
(
lOOlllO\
O\
OO\

)
;
if
(
(
lOOll\
l\
OOOO\

->
llOOOOOOlOl\

.
lOlOllOOll
&
ll\
OOOOO\
l\
OlO
)
==
0
)
{
llOO\
OOOO\
OOl
*
llOOOlOOOl\
O
=
(
llO\
OO\
O\
OO\
OOl
*
)
llOOO\
OOll\
Ol\

->
GetSp\
ace\
Divis\
io\
nNodeMem\
o\
ry\

(
)
;
TA\
_A\
S\
SERT
(
llOOO\
lO\
OOlO
)
;
TA_ASSER\
T
(
llOO\
OlOOOlO
->
ll\
OOO\
OOO\
lO\
l\

.
lOlOllO\
Ol\
l
&
llOOOOO\
lOlO
)
;
me\
mcpy\

(
&
llOOOlOOO\
l\
O
->
llOOOOO\
OlO\
l
,
&
lOO\
lll\
OO\
O\
O\

->
ll\
OO\
OOO\
OlOl
,
sizeo\
f\

(
lOOlllOOOO\

->
ll\
OOOOOOl\
Ol\

)
)
;
ll\
OOOOO\
lOOO
*
ll\
O\
O\
OlO\
OOll
=
(
llOOOOOlOO\
O\

*
)
&
lOOlllOO\
OO
->
llOO\
O\
O\
OOlOl
;
llOOOOOl\
O\
OO
*
llOOOOOlOO\
l\

=
(
llO\
OOOO\
lOOO
*
)
&
llO\
O\
OlO\
OO\
lO
->
llOOOOOOlOl\

;
if
(
llO\
OOO\
OlOO\
l
->
llOOO\
OOllOl
)
{
TA_ASS\
ERT
(
ll\
OOOOOl\
O\
O\
l
->
ll\
OO\
O\
OOllO\
l
->
llO\
O\
O\
OlO\
Oll\

[
ll\
OOOOOlOOl
->
llOOO\
Ol\
O\
l\
OO
]
==
llOOOlOOO\
ll
)
;
llOO\
OOOl\
OOl
->
llO\
OOOOll\
Ol\

->
llO\
OOOl\
OOll
[
llOO\
OOOlOO\
l
->
llOOOOlOlOO
]
=
llOOOOO\
lOOl
;
}
else\

{
TA_ASSERT
(
lOl\
lllOl\
llO
==
llOOOlOOOll
)
;
lOlll\
lOlllO
=
llOOOOOl\
OOl
;
}
TA\
_ASSERT
(
llOOO\
OOlOOl
->
ll\
OOOOl\
OllO
)
;
llOO\
OOOlOO\
l\

->
llO\
OOO\
lOllO
->
llOOOO\
lOlll\

=
&
llOO\
OOOlOOl\

->
ll\
OOOO\
lO\
llO
;
}
}
el\
se
{
lOll\
llOllOO
(
)
ll\
O\
OO\
OOl\
OOO
*
ll\
O\
OOOOl\
OO\
l
=
(
ll\
OOOOOlO\
OO
*
)
(
(
uSi\
ze
)
llOO\
OOll\
OO\
O
->
ll\
OO\
OO\
lOll\
l
-
20
)
;
TA_\
A\
S\
SERT
(
ll\
OOOOOlOOl
->
llO\
OOO\
l\
OllO
==
llOOOOllOOO
)
;
TA_AS\
SERT
(
(
llOOOOO\
lOOl
->
ll\
OOOO\
llOlO
&
(
llOOOOOlOOl
->
ll\
OOOOllOl\
O
-
1
)
)
==
0
)
;
lOl\
llllO\
OO\
O\

(
lO\
llllO\
lll\
O
,
llOOO\
OllOOO\

)
lO\
l\
ll\
llO\
OOO
(
lOll\
llOlllO
,
ll\
OOOOOlOO\
l
)
llOOOOO\
lOOl
->
ll\
OO\
OO\
lOll\
O
=
llOOOOllO\
O\
O
->
llOOO\
lOOOOl
;
if
(
llOOOO\
OlOO\
l
->
llO\
OOOlOllO\

)
{
llOOOOOO\
O\
Ol
*
lO\
Olll\
OOOO\

=
(
llOO\
OO\
OOOOl
*
)
llOOOOllO\
OO
->
Get\
SpaceDivisionN\
od\
eM\
em\
or\
y
(
)
;
TA_ASS\
ERT
(
lOOll\
lO\
O\
O\
O\

)
;
if
(
(
lOOlllOO\
OO
->
llO\
OOOOOlO\
l
.
lOlO\
l\
lOOll
&
llO\
OO\
OO\
lOl\
O\

)
==
0
)
{
TA_A\
SSERT\

(
(
llOOOOOlOOO
*
)
&
lO\
OlllOOOO
->
ll\
OOOO\
OOlOl\

==
llOOO\
OOlOOl
)
;
ll\
O\
OO\
OO\
OOO\
l
*
llOO\
O\
lOOOlO
=
(
llO\
OOOO\
OOOl
*
)
llOOOOOlOOl\

->
llOOOOlOll\
O
->
Get\
S\
paceDivisionNodeMem\
ory\

(
)
;
TA_ASSERT
(
ll\
O\
OOlOOO\
lO
)
;
TA_\
AS\
SER\
T
(
llOOOlO\
OOl\
O
->
ll\
O\
OOO\
O\
OlOl
.
lOlOllO\
O\
ll\

&
llOOOOOlOl\
O
)
;
memcpy
(
&
llOO\
Ol\
OOOlO
->
llOOOOO\
O\
lOl
,
&
lOOlllOOO\
O
->
llO\
OOO\
O\
OlOl\

,
siz\
eof
(
lO\
Ol\
llO\
OOO
->
llO\
OOOOO\
l\
Ol
)
)
;
ll\
OO\
OO\
O\
lOO\
O
*
llO\
OOlO\
OOl\
l
=
llO\
OOOOlO\
Ol\

;
ll\
OOOOOlOOl
=
(
llOO\
O\
OOlOOO
*
)
&
ll\
OOOlOO\
Ol\
O
->
llOOOO\
O\
O\
l\
Ol
;
if
(
llOOOO\
OlOO\
l\

->
ll\
OO\
O\
O\
OllOl\

)
{
TA_ASS\
ERT
(
llO\
OOOOlOOl
->
llOOOOOll\
Ol
->
llOOOOlOOll\

[
llOO\
OOOlOO\
l
->
llOOOO\
lOlO\
O
]
==
llOO\
O\
lOOOll
)
;
llOO\
OO\
OlO\
Ol
->
llOOOOOllOl\

->
ll\
OOOOlOOll\

[
llOOOOOl\
OOl
->
ll\
OOOOlO\
lOO
]
=
ll\
OOOOO\
lOOl\

;
}
el\
se
{
TA_ASSERT
(
lOlll\
lOl\
llO
==
llO\
O\
OlOOOl\
l
)
;
lOllllO\
lllO
=
llO\
OO\
OOlO\
Ol
;
}
TA_ASSE\
RT
(
ll\
OOOOOl\
O\
O\
l
->
ll\
OOOOlOllO
)
;
llOOO\
OO\
lOOl
->
llOOOOl\
O\
ll\
O
->
ll\
OOO\
O\
lO\
l\
l\
l\

=
&
llO\
OOOOl\
OOl
->
llOOO\
OlOllO
;
}
else\

{
TA_AS\
SERT\

(
(
llOOOOOlOOO
*
)
&
lO\
O\
lllOOOO
->
llO\
OOOOOl\
O\
l
!=
llOOOO\
OlO\
Ol\

)
;
}
ll\
OOO\
OOl\
OOl
->
ll\
OOOOlOll\
O
->
ll\
OOO\
O\
lOlll
=
&
llO\
OOOOlOOl\

->
llO\
OOOlOl\
lO\

;
#ifdef _DEBUG
lOlll\
lllOOl
--
;
#endif //
lOlll\
l\
O\
ll\
OO
(
)
lOll\
l\
ll\
O\
lOO
(
TA_ASSERT
(
!
lOlllll\
OO\
Ol
(
(
ll\
OOO\
OOlOOO
*
)
&
lO\
Oll\
lOOOO
->
ll\
OOOO\
O\
OlOl\

)
)
;
)
}
else
{
if
(
ll\
OOOOOlOOl\

->
llO\
l\
l\
OOl\
ll\

==
0
)
ll\
OOOl\
OOlO\
O
(
ll\
OOOOOlOOl
)
;
el\
s\
e
if
(
llOOOO\
OlOOl
->
llOllO\
Oll\
l\

==
1
)
llO\
O\
Ol\
O\
O\
l\
Ol
(
llOOOOO\
lOOl
)
;
#ifdef _DEBUG
lOll\
l\
lllOOl
--
;
#endif //
lOllll\
O\
llOO
(
)
lOlllllOlOO
(
TA_ASSERT
(
!
lOl\
ll\
ll\
OO\
Ol
(
(
llO\
OOOO\
l\
OOO
*
)
&
lOOl\
llOOOO
->
llOOOOOOlOl
)
)
;
)
}
ll\
OOO\
O\
ll\
OO\
O
->
llOOOlO\
O\
OOl
=
0
;
ll\
OO\
OO\
l\
lOOO
->
llO\
O\
O\
O\
lO\
l\
ll
=
0
;
}
}
vo\
id
lO\
lllll\
O\
lOl
::
llOOOlOOll\
O
(
const
AABB
&
lOOOOOO\
lll
,
void
(
TAC\
_CA\
LL
*
llOO\
OlOOlll
)
(
Spac\
eD\
ivis\
ionObjec\
t
&
llOOO\
OO\
OOOO
,
voi\
d
*
lO\
OO\
O\
lll\
lO
)
,
void
*
lOOOO\
llllO
)
{
if
(
!
lOl\
ll\
lO\
l\
llO
)
return
;
llOO\
OlOlOO\
O
llOOOlO\
l\
O\
Ol
;
llOOO\
lOlOOl\

.
lOO\
OOOOlll
=
lO\
OOOOO\
ll\
l
;
cons\
t\

fl\
o\
at\

ll\
OOOOll\
OO\
l
=
1
<<
30
;
Ve\
c3\

v3Exte\
nt
=
lO\
OOO\
OOlll\

.
v3Ex\
tent\

*
lO\
lllllOlll\

;
if
(
v3E\
xten\
t
.
x
>
llO\
OOOllOOl
*
0.5f
)
v3E\
x\
tent
.
x
=
llOO\
O\
Oll\
OOl
*
0.5f
;
if
(
v3Ex\
tent
.
y
>
llOOOOl\
lO\
Ol
*
0.5f
)
v3Ext\
ent
.
y
=
llO\
O\
OOllOOl
*
0.5f
;
if
(
v3Exten\
t
.
z
>
llO\
OOOl\
lOOl
*
0.5f
)
v3\
E\
xten\
t
.
z
=
ll\
O\
OOOl\
lO\
O\
l
*
0.5f
;
Ve\
c3
ll\
O\
Ol\
llllO
=
(
lOO\
OOOO\
l\
ll
.
v3Center
+
lOlllllOllO
)
*
lOlllllO\
l\
l\
l
;
Cl\
amp
(
llOOlllllO\

.
x
,
0.0f
,
ll\
O\
OOOllOOl
)
;
Cl\
a\
m\
p
(
llO\
O\
lllllO
.
y
,
0.0f
,
llOO\
OOll\
O\
Ol
)
;
Clamp
(
llO\
Ol\
ll\
ll\
O
.
z
,
0.0f
,
llOOO\
OllOOl
)
;
llOO\
OlOlOOl
.
llO\
OO\
OlllOO
=
FastFloa\
tToI\
nt
(
llOO\
lllllO
.
x
)
;
ll\
OOOl\
OlOOl\

.
llOOOOlllOl
=
Fas\
t\
F\
l\
oat\
ToIn\
t
(
llOOlllllO
.
y
)
;
llOOOl\
OlOOl
.
llOOOO\
lll\
lO\

=
FastFloatToIn\
t
(
llOO\
l\
l\
lllO
.
z
)
;
llOO\
OlOlOOl
.
llOO\
O\
lOlOlO
=
Fa\
s\
tF\
loatToInt\

(
lOOO\
OOO\
lll
.
v3\
Ex\
tent\

.
x
*
lOlllllOlll\

)
;
llOOOlO\
l\
OOl\

.
llOO\
OlOlO\
ll
=
FastFl\
o\
a\
tT\
oIn\
t
(
lOOO\
OOOlll\

.
v3E\
x\
tent
.
y
*
lO\
lll\
llOl\
ll
)
;
llOOOlOlOOl\

.
ll\
OOOlOllOO
=
Fas\
tF\
l\
o\
atToInt
(
lOO\
OOOOl\
ll
.
v3Extent
.
z
*
lOlllllOl\
ll
)
;
llOOOlOlOOl
.
llOOOlOO\
ll\
l
=
llOOOlO\
Ol\
ll
;
llOOO\
lOlOOl
.
lOOOOllllO
=
lO\
OOOll\
l\
lO\

;
llO\
OOlO\
l\
lOl
(
lO\
llllO\
lllO
,
llO\
OOlOlOOl
)
;
}
void\

lOlllllOlO\
l
::
llOO\
O\
lOlllO\

(
co\
nst
Vec3
&
llO\
OOlOl\
ll\
l\

,
cons\
t
Vec3\

&
llOO\
Ol\
lOOO\
O
,
voi\
d
(
TAC_CALL\

*
llOOOl\
OOl\
ll
)
(
SpaceD\
i\
visio\
nOb\
jec\
t
&
llOOOOOOO\
OO\

,
void
*
lOO\
lllOO\
OO
)
,
void
*
lOOOOl\
lllO
)
{
if
(
!
lOllll\
OlllO
)
ret\
u\
r\
n\

;
Vec3\

lOOl\
O\
lO\
lll
=
(
ll\
OOOl\
O\
l\
lll
+
lO\
lll\
ll\
O\
llO
)
*
lO\
l\
llllOl\
l\
l
;
Vec3
lO\
Ol\
Oll\
OOl
=
(
llOOOl\
lOOOO
+
lOlllllOll\
O
)
*
lOl\
llll\
Ol\
ll\

;
llOOO\
llO\
OOl
llOOOlOlO\
O\
l\

;
llOOOlO\
l\
OOl
.
llOO\
O\
l\
OOll\
l
=
ll\
OOO\
lOOlll
;
llOOO\
lOlO\
Ol
.
lOOOO\
l\
ll\
lO
=
lOO\
OOlll\
l\
O
;
Vec3
lO\
OO\
lOO\
OOO\

=
lOOlO\
llOOl
-
lOO\
lOlO\
lll
;
llO\
OOlOlO\
Ol
.
lO\
OlOll\
OOO
=
lOO\
O\
lO\
OOOO
.
GetMagnitude
(
)
;
llOOOlOl\
OOl\

.
lOOO\
OOllOl\

[
0
]
.
llOOO\
llOOlO
=
lOO\
lOl\
Olll
.
x
;
ll\
O\
OO\
lOlOOl
.
lOOOOOll\
Ol\

[
1
]
.
llO\
O\
Oll\
OOlO
=
lOOl\
OlOlll
.
y
;
ll\
OOOlOl\
OOl
.
lO\
OOOOl\
l\
Ol
[
2
]
.
llOOOllOOlO
=
lOO\
lOl\
Oll\
l
.
z
;
ll\
OO\
OlO\
lOOl
.
lOOOOOllO\
l
[
0
]
.
llOOOll\
OOll\

=
lOOOlOO\
O\
OO
.
x
;
llO\
O\
O\
lO\
lO\
Ol
.
lOO\
O\
O\
OllOl
[
1
]
.
llOOOll\
OOll
=
lOOOl\
O\
OO\
O\
O
.
y
;
llOOOl\
Ol\
OO\
l
.
lO\
OOO\
OllO\
l
[
2
]
.
llOOOllOOl\
l
=
lOOOlO\
OOOO\

.
z
;
if
(
Fa\
bs
(
lOOO\
lO\
OO\
O\
O\

.
x
)
>
lOOOl\
OOOll\

)
{
ll\
OOO\
lO\
lOOl\

.
lOOOO\
Oll\
Ol
[
0
]
.
llOOOllOlO\
O\

=
1.0f
/
lOOO\
lOOOOO
.
x
;
ll\
OOOlOlOOl\

.
lOO\
OOOllOl\

[
0
]
.
llOOOllOlOl
=
1
;
}
els\
e
{
llOOOlOlOOl
.
lOOOO\
O\
llOl\

[
0
]
.
llOOOl\
l\
OlO\
l
=
0
;
ll\
OOOlOlOOl
.
lOOO\
OO\
llOl
[
0
]
.
llO\
OOllOl\
l\
O
=
(
lOOlOlO\
lll\

.
x
+
lOOl\
O\
llOOl
.
x
)
*
0.5f
;
llOOO\
lOlOOl
.
lOO\
O\
OOllOl\

[
0
]
.
llO\
O\
OllOlll
=
Fabs
(
lOOlO\
lOlll
.
x
-
lO\
OlOllO\
Ol
.
x
)
*
0.5f
;
}
if
(
Fab\
s\

(
lO\
O\
OlO\
OOOO
.
y
)
>
lOOO\
lOO\
O\
ll\

)
{
llOOOlOl\
OOl
.
lOOOOOl\
lO\
l
[
1
]
.
ll\
OO\
OllOlOO
=
1.0f
/
lOOOlO\
OOOO
.
y
;
llOOOlOlOOl\

.
lO\
OO\
OO\
llO\
l
[
1
]
.
ll\
OOOl\
lOlOl
=
1
;
}
els\
e
{
llOOO\
lOlO\
Ol
.
lOOOOO\
l\
lOl
[
1
]
.
llO\
OOl\
lOlOl
=
0
;
ll\
O\
OO\
lOlOO\
l
.
lO\
OOO\
O\
llOl
[
1
]
.
llO\
OOllOllO\

=
(
lOO\
lOlO\
l\
ll\

.
y
+
lOOlOl\
l\
O\
O\
l
.
y
)
*
0.5f
;
llO\
OOlOl\
OO\
l\

.
lOOO\
O\
OllOl
[
1
]
.
llOOOllOlll
=
Fabs
(
lO\
O\
lO\
l\
Oll\
l
.
y
-
lOOl\
Oll\
OOl
.
y
)
*
0.5f
;
}
if
(
Fabs
(
lOOOlOOOOO
.
z
)
>
lOOOlO\
OO\
l\
l
)
{
llO\
OOl\
OlO\
O\
l
.
lO\
OO\
O\
O\
ll\
Ol
[
2
]
.
ll\
OO\
O\
ll\
Ol\
OO
=
1.0f
/
lOOOlOOO\
OO
.
z
;
llOOOlOl\
OO\
l\

.
lOOOO\
Ol\
lO\
l\

[
2
]
.
ll\
O\
OOll\
OlOl\

=
1
;
}
el\
se
{
llOOOlO\
lOOl
.
lO\
OO\
OOllOl
[
2
]
.
llO\
OOllO\
lO\
l\

=
0
;
llOO\
OlOlOOl
.
lO\
OOOOllO\
l
[
2
]
.
llOOO\
llOllO
=
(
lOOlOlOlll
.
z
+
lOOl\
O\
llOOl
.
z
)
*
0.5f
;
llO\
OO\
l\
OlOO\
l
.
lOOOOO\
llOl\

[
2
]
.
llOO\
OllO\
lll
=
Fabs
(
lOO\
lO\
l\
O\
l\
ll
.
z
-
lOOl\
OllOOl
.
z
)
*
0.5f
;
}
ll\
O\
OOl\
l\
lO\
OO
(
lOlll\
lO\
ll\
lO
,
llOOOlO\
lOO\
l
)
;
}
bo\
ol
lO\
llll\
lOl\
O\
l
::
lOlll\
l\
lOOO\
l
(
SpaceD\
ivi\
sion\
Obj\
ec\
t
*
llOOOOllOOO
)
{
re\
turn
lOlllllOOOl\

(
lOllllOll\
lO
,
ll\
O\
OOOll\
OOO
)
;
}
boo\
l\

lOl\
llllO\
l\
Ol
::
lOl\
llll\
OOO\
l\

(
con\
s\
t
ll\
O\
OOOO\
lO\
OO
*
llOO\
OlllOOl\

)
{
ret\
ur\
n
lOl\
ll\
l\
lOOO\
l
(
lOllllOlll\
O
,
ll\
OO\
OlllOOl
)
;
}
bool\

lO\
lll\
l\
lOlOl
::
lO\
l\
llll\
OOll
(
ll\
OOOOOlOOO
*
ll\
OO\
OlllOlO\

)
{
llO\
OOOOlOll
*
ll\
O\
OOOOlO\
O\
l
=
lO\
ll\
llllOOO\

;
for
(
llOOO\
OO\
l\
O\
ll
*
ll\
OOOOOl\
OOl
=
lOllllll\
O\
O\
O
;
llOOO\
OOlOO\
l
;
llOOOOOlOOl
=
llOOOOOlOO\
l\

->
llOOOOOlll\
O
)
{
if
(
(
llOOOOOl\
OOO
*
)
ll\
O\
OOO\
OlOOl\

==
llOOOlll\
OlO
)
retu\
rn
tru\
e
;
}
return\

false
;
}
void
lOlllllO\
l\
Ol
::
llOOO\
l\
OllOl
(
llOOOOO\
l\
OOO
*
llOOO\
OOl\
OOl\

,
llO\
OO\
l\
O\
lO\
OO\

&
ll\
OOOlOlOOl
)
{
co\
nst\

u32
llOO\
OOl\
l\
Ol\
O
=
llOOOOOlO\
O\
l
->
llOOOOllOl\
O
<<
1
;
int\

llOOOOOOll
=
(
int
)
(
llOOOlOlOO\
l
.
llOOOlOl\
OlO
+
llO\
OOOll\
OlO
)
-
Ab\
s
(
llOOOO\
O\
l\
OOl
->
llOOOOll\
lOO
-
llOO\
Ol\
Ol\
OOl
.
llOOOOlllOO
)
;
in\
t
llOOOOOlO\
O
=
(
int
)
(
llOO\
Ol\
OlOOl
.
llOOO\
lO\
lOll
+
ll\
OOO\
OllOlO\

)
-
Abs
(
llOO\
OOOlOOl\

->
llOOOOlllOl
-
llOOOlOl\
OOl\

.
ll\
O\
OOOlllO\
l
)
;
int\

llOOO\
O\
O\
lOl
=
(
in\
t
)
(
ll\
OO\
OlOlOOl
.
llOOOl\
O\
llO\
O
+
llOO\
OOllOlO
)
-
Abs
(
llO\
O\
O\
OOlOOl
->
llOOOO\
ll\
ll\
O
-
llOO\
O\
l\
OlOOl
.
llOO\
OOllllO
)
;
if
(
(
(
u32
)
(
ll\
O\
OO\
OOOll
|
ll\
OOOOO\
lOO
|
ll\
OO\
O\
OOlOl
)
>>
31
)
)
retur\
n
;
for\

(
Spac\
e\
Di\
v\
is\
ionObject
*
llOOOOllOOO\

=
ll\
OOOO\
OlOOl
->
llOO\
OOlOllO
;
llOOOOll\
OOO\

;
llOO\
OOllOOO
=
llOOO\
OllOOO\

->
llOO\
OlO\
O\
O\
Ol
)
{
TA\
_AS\
S\
ERT
(
llO\
OOlOlO\
Ol\

.
ll\
OOO\
lOO\
ll\
l
)
;
llOOOlOlOOl\

.
llOOO\
lOOlll
(
*
llOOOOllOO\
O
,
llOOOlOl\
OOl
.
lO\
OOO\
lll\
lO
)
;
}
#ifdef lOllllOlOlO
const
int
llOOO\
lllO\
l\
l
=
(
int\

)
lOlll\
lO\
lOll\

[
llO\
O\
OOOl\
OOl
->
llOOO\
O\
lOOlO
]
;
co\
ns\
t
in\
t
llOOO\
llllOO\

=
(
ll\
OOO\
lll\
Oll
&
15
)
;
TA_AS\
SERT
(
(
ll\
OOOlllOll
&
15
)
==
llOOOO\
OlOOl
->
llOllOOlll\

)
;
for
(
int
lOO\
Ol\
l\
O\
OOl
=
0
;
lO\
OOllOOOl
<
llOOOllll\
OO\

;
lO\
OOll\
OO\
Ol\

++
)
{
int
llOOOOl\
Ol\
Ol
=
(
llOOO\
lllO\
ll\

>>
(
lOOOllOOO\
l\

*
3
+
4
)
)
&
7
;
if
(
llOO\
OOOlOOl
->
llOOOOlO\
O\
lO\

&
(
1
<<
ll\
OOOO\
l\
OlOl
)
)
{
TA_A\
SS\
ERT
(
ll\
OO\
O\
O\
O\
lOOl
->
ll\
OOO\
O\
lOO\
ll
[
llOO\
OOlOlOl
]
)
;
ll\
OOOlOll\
O\
l
(
llOOOOOl\
O\
O\
l\

->
ll\
OOOOlO\
O\
ll
[
llOOOO\
l\
O\
l\
Ol
]
,
llO\
OOlO\
lOOl
)
;
}
}
#else
if
(
ll\
OOOOOl\
OOl\

->
llOll\
OOl\
ll
)
for
(
int
llOOOOl\
Ol\
Ol
=
0
;
ll\
OO\
O\
O\
lOl\
Ol\

<
8
;
llOOOOl\
OlOl
++
)
{
if
(
llOOOOO\
lOOl
->
llOOOOlO\
Ol\
O\

&
(
1
<<
llOO\
OOl\
Ol\
O\
l
)
)
{
TA_A\
SSERT
(
llO\
OOOO\
l\
OOl
->
llOO\
OOlO\
O\
ll
[
llOOOOl\
OlOl\

]
)
;
llOOO\
lOl\
lOl
(
llOOOOO\
lOOl
->
ll\
O\
OOOlOOll
[
llOOOOlOl\
Ol
]
,
llOO\
OlOlOOl\

)
;
}
}
#endif
}
void\

lO\
lllllOl\
Ol
::
llO\
O\
Ol\
l\
lOOO
(
llO\
OOOOl\
OOO
*
llOOOOOl\
O\
O\
l
,
llO\
OOllO\
OOl\

&
llOOOlOlOOl
)
{
fl\
oat\

lOOO\
O\
Olll\
l
;
cons\
t
fl\
oat
ll\
O\
lllOO\
Ol
=
(
float\

)
llOOOO\
OlO\
Ol
->
ll\
O\
OOOllOlO
;
fl\
o\
a\
t
lOOllOO\
O\
O\
l\

=
0.0f
;
floa\
t
lOOll\
OOOl\
O
=
llOO\
Ol\
O\
lOOl
.
lOO\
lOllO\
O\
O\

;
for
(
int
lO\
OOl\
lllO\
l\

=
0
;
lO\
O\
Ol\
l\
llOl\

<
3
;
lO\
OOllllO\
l
++
)
{
flo\
a\
t
ll\
OOOllOlll
=
llOl\
llO\
O\
Ol
*
3.0f
;
ll\
O\
OOllOOOl
::
Axis
&
lO\
OOO\
OllOl
=
ll\
OOO\
l\
OlO\
Ol
.
lO\
O\
OOO\
l\
lO\
l
[
lOO\
Ol\
ll\
lOl
]
;
float
ll\
OOO\
l\
l\
OllO\

=
(
fl\
o\
at\

)
(
&
ll\
OOO\
OOlOOl
->
ll\
OOO\
Ol\
ll\
OO
)
[
lOO\
Ol\
ll\
lOl
]
;
lO\
OOOOlll\
l
=
Sign
(
lO\
OO\
OO\
llOl\

.
ll\
OOOllOlO\
O
)
;
if
(
lOOO\
OOl\
lOl
.
llOOOllO\
lOl
)
{
llOOOll\
Ol\
l\
l
*=
lOOOOOlll\
l
;
fl\
oat
lOl\
OlllO\
Ol
=
llOOOllO\
ll\
O
-
lOOO\
OOll\
Ol\

.
llO\
O\
Oll\
OOlO
;
float\

lOOllOOl\
lO
=
(
lOlOl\
llOOl
-
llO\
O\
Ol\
lOlll
)
*
lOOOOOl\
lOl
.
ll\
O\
O\
OllOlO\
O\

;
if
(
lO\
OllOOOl\
O
<
lOOl\
l\
OOll\
O\

)
re\
turn
;
float
lOOllOOlll
=
(
lOlOlllO\
Ol\

+
ll\
OOO\
ll\
Ol\
l\
l
)
*
lOO\
OOO\
llOl
.
llOOOllO\
lOO
;
if\

(
lOOll\
OO\
O\
O\
l
>
lOO\
l\
l\
O\
Ol\
l\
l
)
ret\
ur\
n
;
Cl\
a\
mp\
IfL\
e\
s\
sTh\
e\
n\

(
lO\
Ol\
lOOO\
Ol
,
lOOllOO\
l\
lO
)
;
Cla\
mpIfGreate\
rT\
hen
(
lOOllOOO\
lO
,
lOOllO\
Olll
)
;
}
else\

{
if
(
Fab\
s
(
lO\
OOOOllOl
.
llOOOllOllO
-
llOOOll\
OllO\

)
>
lOO\
OO\
OllOl
.
llOO\
OllOl\
l\
l
+
ll\
OOOllOlll
)
retu\
rn
;
}
}
TA_ASSE\
R\
T
(
llOOOO\
OlOOl
)
;
fo\
r
(
SpaceDiv\
is\
ionObj\
ect
*
ll\
O\
OOO\
l\
l\
O\
OO
=
llOOOO\
O\
lOO\
l
->
ll\
OOOO\
l\
OllO
;
ll\
O\
OO\
OllOO\
O
;
llOOOOll\
OOO\

=
ll\
OOOOll\
O\
O\
O
->
llO\
OO\
lOO\
OOl
)
{
llOOOlOlO\
Ol
.
llOO\
Ol\
OO\
lll
(
*
llOOO\
Ol\
lO\
OO\

,
llOO\
O\
l\
OlOO\
l
.
lOO\
O\
Ol\
lllO\

)
;
}
for
(
Sp\
a\
ce\
Di\
v\
i\
sionObject
*
ll\
OOOOll\
OO\
O
=
llO\
O\
OOOl\
OOl
->
llO\
O\
OOlOl\
lO
;
llOOOOl\
lOO\
O\

;
ll\
OO\
O\
OllO\
OO
=
llO\
OOO\
l\
lOO\
O\

->
llO\
OOlOO\
OOl
)
{
TA\
_\
AS\
SE\
RT
(
llOOOlOlOOl
.
llOOOlOO\
lll\

)
;
llOOOl\
OlOO\
l
.
llOOO\
lOO\
lll\

(
*
llO\
OO\
OllO\
OO\

,
llOO\
O\
lOlOO\
l
.
lO\
OOOllllO\

)
;
}
if
(
ll\
OO\
OOOlOOl\

->
llOll\
O\
O\
lll
)
for\

(
int
llOOOOlO\
lOl
=
0
;
llOOOOlOlOl
<
8
;
ll\
OOOOlOl\
Ol
++
)
{
if\

(
ll\
OOOOOlOOl
->
llOO\
O\
OlO\
O\
lO\

&
(
1
<<
llOO\
O\
OlO\
lOl\

)
)
{
TA_AS\
SE\
RT
(
ll\
O\
O\
OOOlOOl
->
llOO\
OOlOOl\
l
[
llOOOO\
lOlO\
l
]
)
;
llOO\
Oll\
lOOO\

(
ll\
O\
O\
OOO\
lOO\
l
->
llO\
OOOlOOll
[
llOO\
OOlO\
l\
Ol
]
,
llO\
OOlOlOOl
)
;
}
}
}
vo\
id
lO\
llll\
lOlOl
::
ll\
OOOl\
O\
OOOO\

(
llOOOOlll\
ll\

&
lOOlOOllllO
)
{
lOllllOll\
OO
(
)
if\

(
!
lO\
llllOl\
llO
)
{
llOOOllllO\
l
(
0
,
&
lOllllOl\
llO
,
lOOl\
O\
Oll\
l\
lO\

)
;
lOllllOllO\
O
(
)
ret\
ur\
n
;
}
llOOOOOl\
OOO
*
llOOOO\
OlOO\
l
=
lOllllO\
ll\
lO
;
for
(
;
;
)
{
u3\
2
llOO\
Ol\
llllO
=
(
llOOO\
OO\
lOOl
->
ll\
OOOOll\
lOO
^
lOOl\
OO\
lll\
l\
O
.
llOOOOlllO\
O
)
;
u32
llO\
OOl\
llll\
l
=
(
llO\
OOO\
OlOOl
->
llOO\
OOlllOl\

^
lOOl\
OOll\
llO\

.
llOOOOll\
lO\
l
)
;
u3\
2\

llOOlO\
OOOOO
=
(
ll\
O\
OOO\
OlOO\
l
->
llOO\
OO\
lll\
lO
^
lO\
OlO\
O\
llll\
O
.
llOO\
O\
Olll\
lO
)
;
u3\
2
llOOlO\
OOOO\
l
=
llOOOlllllO
|
llOOOll\
ll\
l\
l
|
llOOlOO\
OOOO\

;
if
(
(
llOOlO\
O\
OOOl
>>
1
)
>=
llOO\
OOOlOO\
l
->
llOO\
OO\
l\
l\
Ol\
O
&&
(
llOOlOOOO\
Ol
>>
1
)
>=
lO\
OlO\
OllllO
.
ll\
O\
O\
O\
Ol\
lO\
lO\

)
{
llOOlOO\
O\
O\
lO\

(
llOO\
OOOlOOl
,
lOO\
lOOllllO
,
llO\
Ol\
O\
OOOO\
l
)
;
lO\
l\
l\
llOllOO
(
)
ret\
ur\
n\

;
}
if\

(
lOO\
lOOllll\
O\

.
llOO\
OOllOlO
>
llOO\
O\
O\
Ol\
OOl
->
llOOOOllO\
lO
)
{
llOOlO\
OO\
Ol\
l\

(
llOO\
OOOlOOl\

,
lOOlOOllllO\

)
;
lOll\
llOll\
OO
(
)
ret\
urn
;
}
if
(
lOOlOO\
ll\
l\
lO
.
llOOOOllOl\
O
==
llOO\
OOOlOO\
l
->
llOOOOllOlO
)
{
llO\
OlOOO\
l\
O\
O
(
ll\
OOOOO\
lO\
O\
l
,
lOOlOO\
llll\
O
)
;
lOll\
l\
lO\
llOO\

(
)
return
;
}
if
(
llOOOOOlO\
Ol
->
lOlO\
llOO\
ll
&
llO\
O\
OOOOllO
)
{
lO\
ll\
llOllO\
O
(
)
;
TA_A\
SS\
ERT
(
ll\
OOlO\
OOlOl
(
llOOOO\
OlOOl
)
)
;
llOO\
lO\
OOllO
(
&
llOOOOOlOOl\

)
;
TA_AS\
SERT
(
llO\
OOOl\
O\
OOl
(
llOO\
OOO\
l\
OO\
l
)
)
;
}
in\
t
llO\
O\
O\
Ol\
OlOO
=
(
(
(
llOOOOOlOO\
l\

->
ll\
OO\
O\
Ol\
l\
lOO
-
lOO\
lO\
O\
l\
ll\
lO
.
llOOOOll\
lOO
-
1
)
>>
31
)
<<
2
)
+
(
(
(
llOO\
OOOl\
O\
Ol\

->
ll\
OO\
OOlllOl
-
lO\
OlO\
O\
ll\
llO
.
llOOOOlll\
Ol\

-
1
)
>>
31
)
<<
1
)
+
(
(
llOOOOOlOOl
->
llOO\
OOlll\
lO
-
lOOlOOl\
l\
llO\

.
ll\
OOO\
OllllO
-
1
)
>>
31
)
;
if
(
!
ll\
OOOOOlOOl
->
llOOOOlOOll
[
llOO\
OO\
lOlOO
]
)
{
llOOO\
OOl\
O\
O\
O
*
llOOOOOl\
lll
=
llOOOllllOl
(
ll\
O\
O\
OO\
OlOOl
,
&
llOOOOO\
lO\
Ol
->
llO\
OOOlO\
O\
l\
l
[
llO\
O\
O\
OlOlO\
O
]
,
lOOlOO\
l\
lllO\

)
;
llOOO\
OOllll
->
llOOOOlO\
lOO
=
llOOOO\
lOlOO
;
TA\
_AS\
SER\
T
(
llO\
O\
OO\
lOOO\
l
(
llO\
OO\
O\
Ol\
OOl
)
)
;
llOOOO\
OlOO\
l
->
ll\
O\
OOO\
lOOlO
|=
1
<<
ll\
O\
OOOl\
OlOO
;
llOOOOO\
lOOl
->
llOll\
OOlll
++
;
TA_\
ASSERT\

(
ll\
OOO\
OO\
l\
lll\

->
llOll\
O\
O\
lll
<
8
)
;
lOllllOl\
l\
OO
(
)
re\
t\
urn
;
}
el\
s\
e
{
llO\
OOOO\
lOOl
=
llOOOO\
OlOOl
->
llOOOOlOO\
ll\

[
llOOOOl\
Ol\
O\
O
]
;
}
TA_\
ASSE\
RT
(
ll\
OOOOO\
lOOl\

)
;
}
}
voi\
d
lOl\
ll\
llO\
lO\
l
::
llOO\
O\
l\
OOl\
OO
(
ll\
OOOOOlOOO
*
llOO\
OOO\
lO\
Ol
)
{
TA_ASS\
ER\
T
(
ll\
OOOO\
Ol\
OOl
)
;
TA\
_A\
SSERT
(
llO\
OOO\
Ol\
OO\
l
->
llOllO\
O\
lll
==
0
)
;
TA_ASSE\
RT\

(
llOO\
OOOlO\
Ol
->
llO\
OOOl\
OOlO\

==
0
)
;
lOl\
lllOl\
l\
OO\

(
)
lO\
lllllO\
OOO
(
lO\
lll\
l\
OlllO
,
ll\
O\
OOOO\
lOOl
)
if
(
llOOOOO\
lOOl
->
llOOOOO\
ll\
Ol
==
0
)
{
TA_A\
SSERT
(
lOll\
llOlllO\

==
ll\
O\
OOOOlOOl
)
;
lOlll\
lOll\
lO\

=
0
;
ll\
OO\
lOOOll\
l
(
llOO\
OO\
OlOO\
l
)
;
lOllllO\
llOO
(
)
}
else\

{
lOlll\
lOl\
lO\
O
(
)
lOll\
l\
llOOO\
O
(
lOllll\
Ol\
llO
,
llOO\
O\
OOlOO\
l
)
TA\
_\
ASSE\
RT\

(
llO\
O\
OO\
OlOO\
l
->
ll\
OOOO\
Ol\
lOl
->
llOO\
OOlOO\
ll
[
llO\
OOO\
OlOOl\

->
llO\
OOOlOlO\
O\

]
==
llOOOOOlOOl
)
;
TA\
_\
A\
SSERT
(
ll\
O\
OOOOlOOl
->
llOOOOOllOl
->
llOOOOlOOlO
&
(
1
<<
llO\
OOOO\
lOOl
->
llOOOOlO\
lOO
)
)
;
TA_\
AS\
SERT
(
llO\
OOO\
OlO\
Ol
->
llO\
OO\
OOllO\
l
->
llOllO\
Oll\
l\

>
0
)
;
llOOOOOlOOl\

->
llOOOO\
O\
llOl
->
llOOO\
OlO\
OlO\

&=
~
(
1
<<
llO\
OOO\
OlOO\
l\

->
llOO\
O\
OlO\
lOO\

)
;
ll\
O\
OOOOlOOl
->
llOO\
OOO\
l\
lO\
l
->
llOOOOl\
O\
Oll\

[
llOOOO\
OlOOl
->
ll\
OO\
OOlO\
lO\
O
]
=
0
;
llOOOOOl\
OOl
->
llO\
OO\
OOl\
lOl
->
llOllOOl\
ll
--
;
if\

(
ll\
OOOOOl\
OO\
l
->
llOO\
OOOl\
l\
Ol
->
ll\
O\
ll\
OO\
lll\

==
0
)
{
if
(
ll\
OOO\
OOlOOl\

->
llO\
OOOO\
llOl
->
llOOO\
OlOl\
lO
==
0
)
{
llOOOOOl\
OOl
->
llOOOOOllO\
l
->
lO\
lOllOOl\
l
|=
llOOlO\
O\
lOOO
;
#ifdef _DEBUG
lOlllll\
ll\
O\
O
++
;
#endif //
llOO\
OlOOlOO
(
llOOO\
OOlOOl\

->
llO\
O\
OOOllOl
)
;
#ifdef _DEBUG
lO\
llll\
lll\
O\
O
--
;
#endif //
}
else
{
llO\
Ol\
OOlOOl
(
&
ll\
O\
OO\
OOlOOl
->
ll\
OOOO\
OllOl
)
;
}
llOOl\
O\
OOl\
ll
(
llOOO\
O\
OlO\
Ol
)
;
lOll\
llO\
llOO\

(
)
}
el\
se
if\

(
llO\
O\
OO\
Ol\
OOl
->
ll\
OOO\
O\
OllOl
->
llOO\
OOlOll\
O
==
0
&&
llO\
O\
OOO\
l\
OOl
->
llOO\
O\
OOllOl
->
ll\
OllOO\
lll
==
1
)
{
llO\
OOlOO\
lOl
(
llOOO\
OOlOOl
->
llOOOO\
Oll\
O\
l
)
;
llOO\
l\
OO\
Oll\
l\

(
llOOOOO\
l\
OO\
l\

)
;
lOl\
l\
llOll\
OO\

(
)
;
}
else
{
TA_\
ASS\
E\
RT
(
ll\
OOOO\
OlO\
Ol
->
llOO\
OO\
OllOl\

->
llO\
l\
lOO\
lll
>
0
)
;
llOOlOO\
Olll
(
ll\
OOOOOlOOl\

)
;
lOl\
lllOl\
lOO\

(
)
}
}
lOl\
lllOllO\
O\

(
)
}
vo\
i\
d
lOl\
llllOlO\
l
::
llO\
OO\
lO\
O\
lOl
(
ll\
OO\
OOO\
lOOO
*
ll\
OO\
OOOlO\
Ol\

)
{
int
llOO\
OOlO\
l\
OO
=
llOOl\
OOlO\
lO\

(
llO\
O\
OO\
OlOOl
->
ll\
OOO\
OlOO\
l\
O\

)
;
TA_A\
S\
SERT
(
llOOO\
OOlOOl
->
llOO\
OOlO\
Oll
[
llO\
OOOlOlO\
O
]
)
;
llOOOOOlOOO
*
ll\
OOlOOlOl\
l\

=
llOOOOOl\
OOl
->
llOOOOlOO\
ll
[
ll\
OOOOlOlO\
O
]
;
if
(
llO\
OOOO\
lOOl
->
llO\
OOOOll\
O\
l\

)
{
TA_\
ASSERT
(
ll\
OOO\
OO\
lOOl
->
llO\
OOOO\
llOl
->
llO\
OOO\
l\
OOll
[
llO\
OO\
OOlOOl
->
llOO\
OOlOlOO\

]
==
llOOOOOl\
OOl
)
;
llOOO\
OOlOO\
l\

->
llOOOOO\
llOl
->
llO\
O\
O\
Ol\
O\
O\
l\
l
[
llOOOOO\
lO\
Ol
->
llOO\
OO\
l\
O\
l\
O\
O
]
=
llOOlOOl\
O\
ll
;
llO\
Ol\
OOl\
Oll
->
llOOOOOll\
O\
l
=
llOOOO\
Ol\
OOl
->
ll\
OOOOOllO\
l\

;
llOO\
lOOlOll\

->
llOOOOlOlOO\

=
ll\
OOOOOlO\
Ol
->
llOOOOl\
OlO\
O
;
}
else
{
TA_ASSERT
(
lO\
llllOlll\
O
==
llOOOOOl\
O\
Ol
)
;
lO\
lll\
l\
OlllO
=
llOO\
lOO\
l\
Oll\

;
llO\
O\
lO\
OlOll\

->
llOOOO\
O\
ll\
Ol
=
0
;
ll\
OOl\
OO\
lOll
->
llOOOO\
lO\
lOO
=
0
;
}
llOOOOO\
O\
lOO\

(
ll\
O\
O\
OOOlOO\
l
)
;
}
lOl\
llllOlOl\

::
llOOOOOlOOO
*
lOll\
l\
llO\
lOl
::
llO\
O\
O\
llllO\
l
(
ll\
OOOOOlOOO
*
llOOOOOlOOl
,
ll\
O\
OOO\
OlOOO
*
*
llOO\
l\
OO\
llOO
,
llOOO\
Oll\
l\
ll\

&
lO\
OlOOlll\
l\
O
)
{
ll\
OOOOO\
lOOO
*
llO\
OOOOl\
lll
=
(
llOOOOOlOOO\

*
)
&
lO\
O\
lOO\
llllO
;
llO\
OOO\
Ol\
lll
->
lOlO\
llOOll
&=
~
llOOOOOlOlO
;
*
llOOlOOl\
l\
O\
O
=
ll\
OOOOOllll
;
llOOO\
OOllll\

->
llOOOO\
lO\
lO\
O
=
0
;
llOOOO\
Oll\
ll\

->
llOllOOlll
=
0
;
llOO\
OOOll\
ll
->
ll\
OO\
OOl\
O\
OlO
=
0
;
TA\
_\
AS\
S\
ERT\

(
lO\
Ol\
OO\
llll\
O
.
llOOOOlO\
llO
)
;
TA_ASSERT
(
lOO\
lOOlll\
lO\

.
llOOOOl\
Oll\
O
->
llO\
OOlOO\
OO\
l
==
0
)
;
TA_ASSERT
(
lOOl\
OOlll\
l\
O
.
llOOOOlO\
llO\

->
ll\
OO\
O\
OlOl\
l\
l\

==
0
)
;
ll\
OOOOO\
llll\

->
llOOOOlOllO
->
ll\
O\
OO\
Ol\
O\
l\
ll\

=
&
ll\
O\
OO\
OOll\
l\
l\

->
llO\
OOOlOllO
;
llOOO\
OOllll
->
llOOOOO\
llO\
l
=
ll\
O\
OOOOl\
OOl
;
ret\
urn
llOOOO\
Oll\
l\
l
;
}
void
lOlllllOlO\
l
::
ll\
OO\
lOOOOlO
(
llO\
OOO\
OlOOO
*
llOOOOOlOOl
,
llOO\
OO\
lllll
&
lOOlOOlll\
lO
,
u32
llOOlOOO\
O\
Ol
)
{
TA_ASSER\
T
(
ll\
O\
OlOOOOO\
l\

!=
0
)
;
ll\
O\
OlOOOOO\
l\

=
llOOOO\
ll\
Ol\
l
(
llOOl\
OOO\
OO\
l\

)
;
TA\
_\
A\
SSERT
(
llOOlOOOOOl\

!=
0
)
;
u3\
2
llOOlOOl\
lO\
l
=
~
(
(
ll\
O\
Ol\
OOO\
OOl
)
+
0xFFFFFFFF
)
;
#ifdef _DEBUG		
TA_ASSE\
RT\

(
(
lO\
OlOOl\
lllO
.
llOOOOlllOO
&
llOOlOO\
llOl
)
==
(
llO\
OOOOlO\
Ol\

->
ll\
OOOOl\
llOO
&
ll\
O\
O\
lOOll\
Ol
)
)
;
TA_ASS\
ERT
(
(
lOOlOO\
llllO
.
ll\
OO\
O\
OlllOl\

&
llO\
O\
lOOllOl
)
==
(
llOOOOOlOO\
l
->
llOO\
OOll\
l\
Ol
&
llOOl\
O\
Ol\
l\
Ol
)
)
;
TA_AS\
SERT
(
(
lOOlOOlll\
lO
.
llOOOOllllO
&
ll\
OOlOOllOl
)
==
(
llO\
OO\
OOlOO\
l
->
llO\
OOOll\
llO
&
llOOl\
OOl\
lO\
l
)
)
;
u32
lOl\
lOlOll\
l\
O
=
~
(
(
ll\
O\
O\
lOOOOOl\

>>
1
)
+
0xFFFFFFFF
)
;
TA\
_ASS\
ERT
(
(
lOO\
lO\
O\
lll\
l\
O
.
llO\
OO\
Olll\
OO
&
lOllO\
lOll\
lO
)
!=
(
ll\
OOOOOl\
O\
Ol\

->
llOO\
OOlllOO\

&
lOll\
OlOl\
llO
)
||
(
lO\
OlO\
OllllO
.
llO\
OOO\
lll\
Ol
&
lOllO\
lOl\
ll\
O
)
!=
(
llOOO\
O\
OlOOl
->
ll\
O\
OOOl\
l\
lOl
&
lOll\
OlOl\
llO
)
||
(
lOOlOOllllO
.
ll\
OOO\
Ol\
ll\
lO
&
lOllO\
l\
Olll\
O\

)
!=
(
llOOOOO\
lO\
Ol
->
llOOOOllllO\

&
lOllOlOlllO
)
)
;
#endif
llOO\
O\
OOlOOO
*
llOOlO\
Ol\
llO\

=
llOOOO\
lOOOO
(
)
;
ll\
OO\
l\
OOll\
l\
O
->
ll\
OOOOlO\
lOO
=
llO\
O\
OO\
Ol\
O\
Ol
->
ll\
OOO\
O\
lOlOO
;
llOO\
lOOlllO\

->
llOll\
OOl\
l\
l
=
0
;
llOOl\
OOlll\
O
->
llOOOO\
lOOlO
=
0
;
llOOlOOlllO\

->
llOOOOl\
lO\
l\
O
=
llOOl\
OOOO\
Ol
>>
1
;
TA_ASSERT
(
llOOO\
OOl\
O\
Ol
->
llOOO\
OllOlO
<
llOOlOO\
lllO
->
ll\
OO\
OOllOlO\

)
;
TA_ASSE\
RT
(
lOOlO\
OllllO
.
llOO\
OOllOl\
O\

<
llOO\
lO\
Oll\
lO
->
ll\
OOOOllOlO
)
;
llOO\
lOOll\
l\
O\

->
llOOOOl\
l\
lO\
O
=
(
lOOlOOlll\
lO\

.
llOOOO\
ll\
lOO\

&
llO\
OlOOl\
lOl
)
+
llOO\
l\
OOlllO\

->
llOOO\
Oll\
O\
l\
O
;
ll\
OOlO\
O\
lllO
->
ll\
O\
O\
O\
O\
lllOl
=
(
lOOlOOllllO
.
llOO\
OOlllOl
&
llO\
Ol\
OOll\
Ol\

)
+
llOOlOO\
lllO
->
ll\
O\
O\
OOl\
lO\
lO
;
llOOlOOlllO
->
llOOOOllll\
O
=
(
lOOlOOllll\
O
.
llO\
OOOl\
l\
llO
&
llOOlOOll\
O\
l
)
+
llOOlOOl\
l\
lO
->
llOOO\
OllOl\
O
;
llOOl\
OOlllO\

->
llOOOO\
lOl\
l\
O
=
0
;
int
llO\
OOOlOl\
OO\

=
(
(
(
ll\
OOl\
OOl\
ll\
O
->
llOOOOlll\
OO
-
ll\
OOO\
OO\
l\
O\
Ol
->
ll\
OOOO\
ll\
lOO
-
1
)
>>
31
)
<<
2
)
+
(
(
(
llOO\
l\
OO\
ll\
lO
->
ll\
OO\
OOll\
lOl
-
llOOOOOl\
OOl\

->
llOOOO\
lll\
Ol
-
1
)
>>
31
)
<<
1
)
+
(
(
llOOlOO\
lllO
->
llOOOOlll\
lO
-
ll\
O\
OOOOl\
OO\
l
->
llOO\
OOl\
lllO
-
1
)
>>
31
)
;
TA_\
ASSERT
(
llO\
Ol\
OOll\
l\
O\

->
ll\
Ol\
lOOlll
==
0
)
;
TA\
_A\
SSE\
R\
T
(
llOOlOOlllO
->
ll\
OO\
OOlOOl\
O
==
0
)
;
llOOlOOll\
lO\

->
llO\
OOOlOOl\
O
|=
1
<<
llOOOOlOlOO
;
llO\
O\
lO\
OlllO
->
llO\
l\
l\
OO\
lll
=
2
;
llOO\
lOOll\
lO
->
llOOOOOll\
O\
l
=
llOOOOOlOO\
l
->
llOO\
OOO\
ll\
Ol\

;
llOOOOOlOOl
->
llO\
O\
OOOl\
lOl\

=
llOOlOOlllO
;
llOOOOO\
l\
OOl
->
ll\
O\
O\
OOlOlOO
=
llOO\
OOlOlO\
O
;
ll\
OOl\
OO\
ll\
lO
->
llO\
O\
OO\
lOO\
ll\

[
llOOOO\
OlOOl
->
ll\
OOO\
OlO\
l\
OO
]
=
llO\
OOOO\
lOOl\

;
if
(
!
ll\
OO\
lOOlll\
O
->
ll\
O\
OOOOllOl
)
{
TA_AS\
SER\
T
(
lOllll\
Ol\
llO
==
llOO\
OOO\
lO\
O\
l\

)
;
lOlll\
lOlll\
O
=
llO\
O\
l\
OOlllO
;
}
els\
e
{
TA_ASSERT
(
llOOlOO\
lllO\

->
llOO\
OOOllOl
->
ll\
OOO\
Ol\
OO\
l\
l\

[
llOOlOOlllO\

->
llOOO\
OlOl\
OO
]
==
llO\
OOOOl\
OOl
)
;
ll\
OOlOOll\
l\
O
->
ll\
OOOOOl\
lOl\

->
llOO\
OOl\
O\
Oll
[
llO\
OlOO\
lllO
->
llOOOOlOl\
OO
]
=
ll\
OO\
lOO\
lllO
;
}
ll\
OO\
OOlOl\
OO
=
(
(
(
ll\
O\
O\
lOO\
lllO\

->
llOOOOlllOO
-
lOO\
l\
OOllllO
.
llO\
OOOl\
llOO
-
1
)
>>
31
)
<<
2
)
+
(
(
(
ll\
O\
Ol\
OOl\
llO\

->
ll\
OOOOl\
llO\
l
-
lO\
Ol\
OO\
ll\
llO
.
ll\
O\
OOO\
l\
ll\
Ol\

-
1
)
>>
31
)
<<
1
)
+
(
(
ll\
O\
OlOOll\
lO
->
llOOOOll\
llO
-
lO\
OlOOlll\
l\
O
.
llOOO\
OllllO
-
1
)
>>
31
)
;
llOOOOl\
l\
lll
*
ll\
OOl\
OOllll
=
&
lOOlOOllll\
O
;
llOO\
lOO\
llll
->
lOl\
OllOOl\
l\

&=
~
llO\
OOOO\
lO\
lO
;
llO\
OlOOllll
->
llOOOOlOl\
OO
=
llOOOOl\
OlOO\

;
llOOlOOl\
ll\
l\

->
llOllO\
Olll
=
0
;
ll\
OOlOO\
llll\

->
ll\
OOO\
Ol\
O\
Ol\
O
=
0
;
TA\
_A\
SSERT\

(
llOO\
lOOllll
->
llOOOO\
lOlO\
O
!=
llOO\
OOOl\
OOl
->
llOOOOl\
OlOO
)
;
TA_AS\
SER\
T
(
llOOl\
OO\
l\
l\
lO\

->
llOOOOlOOll
[
llOOlOOlll\
l\

->
ll\
OOOOlOlOO
]
==
0
)
;
ll\
OOlOOlllO
->
llOOOOlOOlO\

|=
1
<<
llOO\
OO\
l\
OlO\
O
;
llOO\
l\
OO\
l\
llO
->
llOOOOlOOll
[
llOOlOOllll\

->
ll\
O\
OO\
OlOlO\
O
]
=
(
llOOOOOlOOO\

*
)
llOOl\
O\
Ol\
lll\

;
llOOlOO\
l\
l\
ll
->
llOOO\
OOllOl
=
llO\
Ol\
OOlll\
O\

;
TA_ASSER\
T
(
lOOlOOllllO
.
llO\
OOO\
l\
OllO
)
;
TA_ASSE\
RT
(
lO\
Ol\
OOlll\
l\
O
.
llO\
OO\
O\
lOllO
->
llOOOlOOOOl
==
0
)
;
TA_\
ASS\
ERT
(
lOOlOOllll\
O
.
llOO\
OOlOllO
->
llOOOO\
lOll\
l\

==
0
)
;
lO\
OlO\
OllllO
.
ll\
OOO\
OlOllO\

->
llO\
OO\
OlOl\
ll
=
&
ll\
O\
OlOOllll
->
ll\
OOOOlOllO
;
}
void
lO\
llll\
lO\
lOl
::
llOO\
lO\
OOO\
ll\

(
ll\
OOOOOlO\
OO
*
llOO\
OOO\
lOOl
,
ll\
OOOO\
llll\
l\

&
lO\
OlOOlll\
lO
)
{
llOO\
O\
OOlOOO
*
ll\
O\
OOOO\
llll\

=
llOOOOl\
OOOO\

(
)
;
llOOOOO\
ll\
ll
->
llOOO\
O\
lOlOO\

=
llO\
O\
O\
O\
O\
lOOl
->
llOOOO\
l\
OlOO\

;
llOOOOOlll\
l
->
ll\
O\
ll\
OO\
l\
ll
=
0
;
llO\
O\
OOOlll\
l
->
ll\
OOOOlOO\
lO
=
0
;
ll\
O\
O\
OO\
Ol\
lll\

->
llOOOOl\
lOlO\

=
lOOlOOll\
l\
lO
.
llOOOOl\
lOlO\

;
llOO\
O\
OOllll
->
llOOOOl\
llO\
O
=
lO\
Ol\
OOllllO
.
llOOOOll\
lOO
;
llOOOOOlll\
l
->
ll\
OOOOll\
lOl
=
lOOlO\
O\
l\
l\
llO
.
llO\
OOOlllO\
l\

;
llO\
O\
O\
OO\
llll\

->
llOOO\
Olll\
lO
=
lOOlOOl\
lllO
.
llOOO\
O\
lll\
l\
O
;
TA\
_ASS\
ERT
(
lOOl\
OOll\
llO
.
llOOOOlO\
llO
)
;
TA\
_AS\
SE\
RT
(
lOOlOOll\
ll\
O
.
llOO\
OOlO\
llO
->
llOOOlO\
OO\
O\
l
==
0
)
;
TA\
_ASSERT
(
lO\
Ol\
OOllll\
O
.
llOOO\
OlOll\
O
->
llOOOOlOlll
==
0
)
;
llOO\
OOO\
l\
l\
ll
->
llOOOOlOl\
lO
=
lOO\
lOOl\
lllO
.
llO\
OO\
Ol\
Ol\
lO
;
lOOlOOll\
llO\

.
llOOOOlOllO\

->
ll\
O\
OOOl\
Olll
=
&
llOO\
OOOl\
lll
->
ll\
OO\
OOl\
OllO\

;
in\
t
ll\
OOOO\
lOl\
O\
O\

=
(
(
(
llOO\
OOOllll
->
llO\
OOOlllOO
-
llOOOOOlOO\
l
->
ll\
OOOOl\
llOO
-
1
)
>>
31
)
<<
2
)
+
(
(
(
llOO\
OOOlll\
l
->
llOO\
OOlllOl
-
llOOOOOl\
O\
O\
l\

->
ll\
OO\
O\
OlllOl
-
1
)
>>
31
)
<<
1
)
+
(
(
ll\
OOOO\
Ol\
lll
->
ll\
OO\
O\
Oll\
l\
lO
-
ll\
OO\
OO\
OlOOl
->
llO\
O\
OOllll\
O
-
1
)
>>
31
)
;
TA_ASSER\
T
(
llO\
O\
O\
OOllll
->
llOll\
OOlll
==
0
)
;
TA_ASS\
ER\
T
(
llOOO\
OO\
llll\

->
ll\
OOO\
OlO\
OlO
==
0
)
;
TA\
_\
A\
SSERT
(
llOOOOl\
O\
O\
Ol
(
llOOOOOl\
lll
)
)
;
llOOOOOll\
ll
->
llO\
O\
O\
OlOOlO
|=
1
<<
ll\
OOOOlO\
lOO
;
llOOO\
OOl\
lll
->
ll\
O\
l\
lOOlll
++
;
ll\
OOOOO\
llll
->
llO\
OO\
OOl\
l\
Ol
=
llO\
OOO\
Ol\
OOl
->
llOOOOOllOl
;
llO\
OOOOl\
O\
O\
l
->
ll\
OO\
OOOllOl\

=
llOOOOOllll\

;
llO\
OOOOlO\
Ol
->
ll\
OOOO\
lOl\
OO
=
ll\
OOOOlOlO\
O
;
llOOO\
O\
Ollll\

->
llOOOOlOOl\
l
[
llOOO\
OOlO\
Ol\

->
ll\
OO\
O\
O\
l\
OlOO
]
=
ll\
OOOOOlOOl\

;
if
(
!
llOOOOO\
ll\
ll\

->
llO\
OOOO\
l\
lOl\

)
{
TA_A\
S\
SERT
(
lOllll\
OlllO
==
llO\
OOOOlOOl
)
;
lOll\
llOlll\
O
=
llOOOOOl\
lll
;
}
else\

{
TA_AS\
SERT
(
llOOO\
OOlll\
l
->
llO\
OOOO\
l\
l\
Ol
->
llO\
OO\
OlOOll
[
llOOO\
O\
Ol\
l\
ll
->
llOOOO\
lOlOO
]
==
llOOOO\
Ol\
OO\
l
)
;
llOOOOOl\
lll
->
ll\
OOOOO\
l\
lOl
->
llOOOOlOOl\
l
[
llO\
O\
OO\
O\
lll\
l
->
ll\
OO\
OO\
lOlO\
O
]
=
llOOOOO\
l\
ll\
l
;
}
}
vo\
id
lOlll\
ll\
OlOl
::
ll\
OO\
lO\
OO\
lOO
(
ll\
OOOOOl\
OOO\

*
llO\
OOOOlO\
O\
l\

,
llO\
OO\
Ollll\
l
&
lOO\
l\
O\
OllllO\

)
{
TA_AS\
SERT
(
lOO\
l\
O\
Ollll\
O\

.
llOOOO\
l\
OllO
)
;
TA\
_A\
SS\
ERT\

(
lOOlO\
Ollll\
O
.
llOO\
OOlOllO
->
ll\
O\
OO\
lOOOOl
==
0
)
;
TA_ASS\
E\
RT
(
lOOlO\
OllllO
.
ll\
OOOO\
lO\
llO
->
llOOOOl\
O\
lll
==
0
)
;
lO\
OlOOll\
llO\

.
llOOO\
OlOll\
O
->
llOOO\
OlOlll
=
&
llOOOOOlO\
O\
l\

->
llO\
O\
O\
OlOll\
O
;
if
(
llOO\
OOOlO\
O\
l
->
ll\
OOO\
Ol\
Ol\
lO
)
llO\
OOOOlOOl
->
ll\
OOOOlOllO
->
llO\
OOO\
lOl\
ll
=
&
lOOlOOl\
lll\
O
.
ll\
O\
OOOlOl\
lO
->
llO\
OOlOOOOl
;
lOOlOO\
llll\
O
.
llOOO\
O\
lOl\
lO\

->
llOO\
Ol\
OOO\
Ol\

=
llOOOO\
OlO\
Ol
->
ll\
OOOOlOllO
;
llOO\
OOOlOOl
->
ll\
OOOOlOllO
=
lOOlOOlll\
l\
O
.
llOOOOl\
OllO
;
}
lOlll\
l\
lO\
lOl
::
ll\
O\
OOOOlOOO
*
lOlll\
llOlOl
::
llOOOOl\
O\
OO\
O
(
)
{
ll\
OOOOOlOOO
*
llO\
OOOO\
llll
=
(
llOO\
OOOlOO\
O
*
)
lOllllll\
OOO
;
TA_AS\
SER\
T
(
llOOOO\
Ollll
)
;
lO\
l\
llll\
lOOO\

=
lO\
ll\
llll\
OOO\

->
llO\
OOOOll\
l\
O
;
if
(
lOlll\
lll\
OOO
)
lO\
l\
ll\
l\
l\
lOO\
O\

->
llOOOOOllOl
=
0
;
mem\
s\
et
(
llOOO\
O\
Ollll
->
llO\
OOOlO\
Oll\

,
0
,
sizeof\

(
ll\
OOO\
OOl\
OO\
O
*
)
*
8
)
;
TA_A\
SS\
E\
R\
T
(
llOOOOlOOOl
(
llOOO\
OO\
ll\
ll
)
)
;
TA_A\
SSER\
T
(
(
llOOOOO\
l\
ll\
l\

->
lOlOllOOll
&
ll\
OOOOOl\
O\
lO\

)
!=
0
)
;
llOOOOOl\
ll\
l
->
lOlO\
l\
lOOll
=
llO\
O\
O\
OOO\
Ol\
l\

;
#ifdef _DEBUG
lO\
lll\
lllOll
++
;
lO\
ll\
l\
l\
l\
l\
OlO
--
;
#endif //
retu\
rn\

llOOOOO\
llll\

;
}
void\

lOl\
llll\
O\
lOl
::
llO\
OO\
OOO\
lOO
(
llOOOOOlOOO
*
llOOOOOl\
O\
O\
l
)
{
TA\
_ASSERT\

(
ll\
O\
OO\
OOlOO\
l
)
;
TA_\
ASS\
E\
RT\

(
llOOO\
OlOOOl\

(
ll\
O\
O\
OOOlOOl
)
)
;
TA\
_ASSERT\

(
(
llOOOOO\
l\
OOl
->
lOlOllOO\
ll\

&
ll\
O\
OOOOlOl\
O
)
==
0
)
;
llO\
OOOOlOOl
->
lOlOl\
lO\
Oll\

|=
ll\
O\
OOOO\
l\
O\
lO
;
ll\
O\
O\
OOOlOO\
l
->
lOl\
OllOOll
&=
~
ll\
OOl\
OOl\
OOO
;
ll\
O\
OO\
OOl\
Oll\

*
llOO\
lOlOO\
OO
=
(
ll\
OOOOO\
lOl\
l
*
)
llOOO\
OOlOO\
l
;
if\

(
lO\
llllll\
OO\
O\

)
lOlllll\
lO\
OO
->
llOOOOOllOl
=
llOOlOl\
OOO\
O
;
ll\
OOlOl\
OOOO
->
llOO\
OO\
OllOl
=
0
;
ll\
OOlO\
lOO\
OO
->
llO\
O\
O\
O\
O\
lll\
O
=
lOllllllOO\
O
;
lOllll\
llOO\
O
=
ll\
OO\
lOlOOOO
;
#ifdef _DEBUG
lOllllllOll
--
;
lOl\
ll\
lllOlO
++
;
#endif //
}
void
lOlll\
llOlOl
::
llO\
OlOOO\
ll\
l
(
llOOOO\
OlOOO
*
llOO\
OO\
Ol\
OO\
l
)
{
if\

(
llOO\
OOOl\
OOl
->
lOlOl\
l\
OOl\
l
&
llOOO\
O\
OOOll\

)
llOOO\
O\
O\
O\
l\
O\
O\

(
ll\
OOOO\
OlOOl
)
;
else
llOO\
lO\
lO\
OOl
(
ll\
OOOO\
OlOOl
)
;
}
voi\
d
lOll\
ll\
lOl\
O\
l
::
ll\
OOlOlOOOl\

(
ll\
OOOO\
OlOOO
*
llOOl\
O\
lOOlO\

)
{
TA_ASSERT\

(
llOOlOlOO\
lO
)
;
TA_\
A\
SSE\
RT
(
llOO\
lOOOlO\
l
(
llOOlOl\
OOl\
O
)
)
;
ll\
OO\
l\
OlOO\
lO
->
lO\
lOl\
lOO\
ll
|=
llOOOO\
OlOlO\

;
TA_ASSERT
(
(
llOOlOlOOlO
->
lO\
lOll\
OOll
&
llOO\
l\
OO\
l\
OOO
)
==
0
)
;
}
void
lOllll\
l\
OlOl\

::
llOOlOO\
OllO
(
llOOOOO\
l\
O\
OO
*
*
llOO\
lOlOO\
ll\

)
{
TA\
_\
ASS\
ER\
T
(
llOOlO\
l\
O\
Oll
)
;
TA\
_\
ASSE\
RT
(
*
ll\
OOlOl\
O\
O\
ll\

)
;
TA_AS\
SERT\

(
ll\
OOlOOOlOl
(
*
llOOl\
OlOO\
ll
)
)
;
TA\
_ASSERT
(
(
(
(
*
ll\
O\
OlOlOOll
)
->
lOlO\
llOOll
)
&
ll\
OOOO\
O\
lOl\
O\

)
==
0
)
;
ll\
O\
O\
O\
OOlOO\
O\

*
llOOOOOlOO\
l\

=
llOOO\
OlOOOO
(
)
;
TA_ASSERT
(
llOOO\
OlOO\
Ol\

(
llOOO\
O\
Ol\
OOl
)
)
;
ll\
OOO\
OO\
lOOl
->
llOO\
OOll\
Ol\
O
=
(
*
llOOlOl\
O\
Oll
)
->
llOO\
O\
OllOlO\

;
llOO\
O\
O\
OlOOl
->
llOOOOlllOO
=
(
*
llOOlO\
lOOll
)
->
llOOOOlllO\
O
;
ll\
OO\
OOO\
lOOl
->
llOO\
O\
O\
ll\
lO\
l
=
(
*
llO\
OlOl\
OOll
)
->
llOO\
OO\
l\
ll\
Ol\

;
llO\
OOOOl\
O\
Ol\

->
llO\
OOOllllO\

=
(
*
ll\
OOlOlOOll
)
->
llOOOOl\
lll\
O
;
ll\
OOOO\
Ol\
OOl
->
ll\
OllOO\
lll
=
0
;
llOOO\
O\
OlOOl
->
llO\
OO\
OlOOlO
=
0
;
llOO\
OOOl\
OO\
l\

->
lOlO\
llOOll\

|=
(
(
*
llOOlOl\
OOll
)
->
lO\
lOl\
lOOll\

)
&
~
(
ll\
O\
O\
OOOOOll
|
ll\
OO\
OOOO\
llO
)
;
(
(
*
llOOlOlOOll
)
->
lO\
lO\
llOOll
)
|=
llO\
OO\
O\
OlOl\
O
;
llOOO\
OOlOOl\

->
llO\
O\
OOlOlOO\

=
(
*
llOOlO\
lOOl\
l
)
->
llO\
O\
O\
Ol\
OlOO
;
llOO\
OOO\
lOOl
->
ll\
OO\
OOOll\
Ol\

=
(
*
llOO\
l\
O\
lOOl\
l
)
->
llOOO\
O\
OllO\
l
;
if\

(
llO\
OOOOlOOl
->
ll\
O\
O\
OOOllO\
l
)
{
TA_AS\
SER\
T\

(
llO\
OOO\
lOOOl\

(
llOO\
OOOlOOl
->
llOOO\
OO\
llOl
)
)
;
TA\
_ASSERT
(
ll\
O\
OOOOlOOl\

->
ll\
OOO\
O\
O\
llOl\

->
llOOOOlO\
Ol\
l
[
ll\
OOO\
OO\
lO\
O\
l
->
llOOOOlOl\
OO\

]
==
*
ll\
OOlOl\
OOll
)
;
llOOO\
OO\
lO\
Ol
->
llOOOOOllO\
l
->
ll\
OOOOlOOl\
l
[
llOOO\
OOlO\
Ol
->
ll\
OOOOlOlOO\

]
=
llOOOOOl\
OO\
l
;
}
else
{
TA\
_A\
SSERT
(
lOl\
lllOll\
l\
O
==
*
llOOlO\
lOO\
ll\

)
;
lOlll\
lOlllO\

=
llO\
OOO\
OlOOl\

;
}
llOOOOOlOOl\

->
ll\
OOOOl\
O\
llO
=
(
*
llOOl\
OlO\
Oll
)
->
llOOOOl\
OllO
;
if
(
llOOOOO\
lOOl
->
llOOOOlOll\
O
)
ll\
OOOO\
OlO\
O\
l
->
llOOOO\
lO\
l\
lO
->
llOO\
OO\
lOlll
=
&
llOOOOOlOOl
->
llOO\
OOl\
OllO\

;
TA_\
ASS\
ERT\

(
llOOO\
Ol\
OOOl
(
llOO\
OO\
O\
lOOl
)
)
;
TA\
_\
A\
S\
S\
ERT
(
(
llOO\
OO\
O\
lOOl
->
lO\
lO\
llOOll
&
ll\
OOO\
OOl\
OlO
)
==
0
)
;
*
llO\
OlOlOOll
=
ll\
OOO\
OO\
lO\
Ol
;
}
vo\
id
lOl\
ll\
l\
lOl\
Ol
::
llOOlO\
Ol\
OOl
(
llOOOOOlOO\
O
*
*
llOO\
lOO\
llOO\

)
{
TA\
_ASSE\
RT
(
llOOl\
O\
OllOO
)
;
TA_ASS\
ERT
(
*
llO\
OlOOllOO
)
;
TA_ASSERT
(
llOOOOlOOOl
(
*
llOOlOOl\
lOO\

)
)
;
TA_AS\
SE\
RT
(
(
*
llOO\
l\
OOll\
OO
)
->
llOOOOlO\
llO
)
;
ll\
OOO\
O\
OOOOl
*
lOOll\
lOOOO\

=
(
llOOOOOOO\
Ol
*
)
(
*
llOO\
lOO\
l\
l\
OO
)
->
llOOOOl\
OllO
->
Ge\
t\
Spac\
e\
Di\
v\
isio\
nNod\
e\
Mem\
ory
(
)
;
TA\
_\
AS\
SE\
RT
(
lOO\
ll\
l\
OOO\
O
)
;
llOOOOlllll
*
llOOl\
OlOOlO
=
&
lOOlllO\
OOO
->
ll\
OOO\
OOOlO\
l\

;
TA_\
AS\
SERT
(
llOOl\
O\
l\
OOlO
->
lO\
lOllOOll
&
llO\
OOOOlOl\
O
)
;
TA_ASSER\
T\

(
llOO\
l\
OO\
OlOl
(
(
llOOOOO\
lOOO
*
)
llO\
OlOlOOlO\

)
)
;
ll\
OOlO\
lOO\
lO
->
ll\
OOOOl\
lOlO\

=
(
*
llO\
OlOOl\
l\
OO
)
->
llOO\
OOll\
Ol\
O
;
ll\
OO\
lOl\
OOlO
->
llOOOOl\
llOO
=
(
*
llO\
OlOOllOO
)
->
llOOOO\
l\
llOO\

;
ll\
O\
O\
l\
OlOOl\
O
->
llOOOOll\
lOl
=
(
*
llOOlO\
OllO\
O
)
->
llOOOOll\
lO\
l\

;
ll\
OOlO\
lOOlO
->
llO\
O\
OOlll\
lO\

=
(
*
llOOl\
O\
O\
llOO\

)
->
llOO\
OOl\
l\
llO\

;
TA_AS\
S\
E\
R\
T\

(
(
*
ll\
OOlOOllOO\

)
->
ll\
Ol\
lOOlll\

==
0
)
;
TA\
_\
AS\
SERT
(
(
*
ll\
OOl\
OOl\
lOO\

)
->
llOOOOlO\
OlO
==
0
)
;
llOO\
lOlOOlO
->
llO\
l\
lOOll\
l
=
0
;
llO\
Ol\
OlOOlO
->
llOOO\
O\
lOOlO
=
0
;
llOOl\
OlOOlO\

->
lO\
lOllOOll
|=
(
(
*
llOOl\
OOll\
OO\

)
->
lO\
lO\
llO\
Oll
)
&
~
(
llO\
OOO\
OO\
Oll\

|
llOOOOO\
Ol\
lO
)
;
llOOlO\
lOO\
lO
->
lOlOl\
lOOll
&=
~
llOOO\
OO\
l\
Ol\
O
;
llO\
O\
lOlO\
Ol\
O\

->
ll\
OOOOlOl\
OO
=
(
*
llOOlOOl\
lO\
O
)
->
llOOOOlOlOO\

;
llO\
O\
l\
OlOOlO
->
llOOOOO\
l\
lOl
=
(
*
ll\
OOl\
O\
O\
llOO
)
->
llOOOOOllOl\

;
if
(
llO\
OlOlOOl\
O
->
llOOOOOllO\
l
)
{
TA_ASS\
ERT
(
llOOO\
Ol\
OO\
Ol
(
llOO\
l\
OlO\
OlO
->
llO\
OOOOllOl\

)
)
;
TA_\
A\
SSERT
(
llOOlOl\
O\
O\
lO
->
llOOOO\
O\
llOl
->
llOOOOl\
OO\
l\
l
[
llOOlO\
lOOlO
->
ll\
O\
OOO\
lO\
l\
OO\

]
==
*
ll\
OO\
l\
OO\
ll\
O\
O
)
;
llOOlOlO\
OlO\

->
ll\
OOOOOllOl\

->
llOOOOl\
OOll
[
llOOlOlOOl\
O
->
ll\
O\
OO\
OlOlOO
]
=
(
llOO\
OOOlOOO
*
)
llO\
OlOlO\
Ol\
O
;
}
else\

{
TA_ASS\
ERT
(
lO\
llllOll\
lO
==
*
llOO\
lOO\
llOO
)
;
lOllllOl\
ll\
O\

=
(
llOO\
O\
OO\
lO\
O\
O
*
)
llOO\
lO\
lOO\
lO\

;
}
llOOlOl\
OOlO\

->
ll\
OO\
OOlO\
llO\

=
(
*
llOOl\
OOllOO
)
->
llOOOOlO\
llO
;
if
(
llOO\
lOlOOlO\

->
llOOOO\
lOl\
lO
)
ll\
OOl\
OlOOlO
->
llOOO\
OlOl\
lO
->
llOOOOlO\
l\
ll\

=
&
llOOlOlOOl\
O\

->
ll\
O\
O\
OOl\
OllO\

;
TA\
_\
A\
SS\
ERT\

(
llOO\
lOO\
OlO\
l
(
(
llOOO\
OOlO\
O\
O
*
)
ll\
OOlOl\
OOlO
)
)
;
llOO\
OOOOlOO
(
*
llOO\
lOOllOO
)
;
*
llOOlO\
OllOO
=
(
llO\
OOOOlO\
O\
O
*
)
ll\
O\
OlOlOOlO\

;
}
void
lOl\
ll\
l\
lOl\
Ol
::
lOllllO\
llll
(
)
{
#ifdef _DEBUG
in\
t\

ll\
OllOOlll
=
0
;
ll\
OOOOOlOll\

*
llOOOOOlO\
Ol\

=
lOllllllOOO
;
ll\
OOOO\
O\
l\
Oll
*
ll\
OO\
l\
OlOlOO
=
0
;
for\

(
llO\
OOOOlO\
ll
*
ll\
OOOO\
O\
lO\
Ol
=
lOll\
llllOOO
;
llOOO\
OOl\
OO\
l
;
llO\
OOOO\
l\
OO\
l
=
llOOO\
OOlOOl
->
llOO\
O\
OOl\
llO
)
{
TA_A\
SSERT
(
llO\
O\
OO\
O\
l\
OOl
->
llOOOOOll\
Ol
==
ll\
O\
OlO\
lO\
lOO
)
;
TA_ASS\
ERT
(
llOO\
OO\
OlO\
O\
l
->
lO\
lO\
l\
lOOl\
l
&
llOOOO\
O\
l\
OlO\

)
;
llOOlO\
l\
O\
l\
OO\

=
llOOO\
OOl\
O\
O\
l
;
llOl\
lO\
Olll\

++
;
}
if
(
!
lO\
lllllll\
O\
O\

)
{
TA_A\
SSE\
R\
T
(
lOll\
llll\
OlO
==
llOllOO\
lll\

)
;
TA_ASSERT
(
lOlll\
lllOl\
O\

+
lOllllllOl\
l\

==
lO\
l\
llll\
l\
l\
Ol
)
;
TA_ASSERT
(
lOllllllOll
<
lOll\
llll\
OOl
||
(
lOllllllOOl
==
0
&&
lO\
llllllOll
==
0
)
)
;
}
#endif //
}
vo\
id\

lOl\
llllOlO\
l
::
lOlll\
lO\
llOl
(
llO\
OOOOlO\
O\
O
*
llOOO\
OO\
lO\
O\
l
)
{
#ifdef _DEBUG
int\

llO\
llOOlll
=
0
;
lO\
l\
lllOllO\
l
(
llOOO\
OOlO\
Ol
,
llO\
l\
lOO\
ll\
l
)
;
if\

(
llOOO\
OOlOOl
==
lOllll\
OlllO
&&
!
lO\
l\
llllll\
OO
)
{
TA_AS\
SERT\

(
llO\
l\
lO\
Oll\
l
==
lOlllll\
lOll
)
;
}
#endif //
}
void
lOlllllOl\
Ol
::
lO\
ll\
llOll\
Ol
(
llOO\
O\
OOlOOO
*
llO\
OOOOlO\
O\
l
,
int
&
llO\
l\
lOOll\
l\

)
{
#ifdef _DEBUG
if
(
!
llOOO\
OO\
l\
OOl\

)
return
;
TA_ASSE\
RT
(
(
llOO\
O\
OOlO\
Ol
->
lOlO\
ll\
OOll
&
ll\
OOOOO\
l\
OlO
)
==
0
)
;
if\

(
llOO\
O\
OlOOO\
l
(
ll\
OOOOOlO\
O\
l
)
)
llOllOO\
lll
++
;
Spac\
eD\
ivisionO\
b\
jec\
t\

*
*
ll\
OOlO\
lO\
lOl
=
&
llOO\
OOOlOOl
->
llOOOOlOllO
;
for
(
Sp\
a\
ce\
Divi\
sionObject\

*
llO\
OOO\
llOOO
=
llO\
OOO\
OlO\
O\
l
->
llO\
OOOl\
Oll\
O
;
llOOOO\
llOO\
O
;
llO\
O\
OOl\
lOOO\

=
llOO\
OO\
l\
l\
O\
OO
->
llO\
OOlOOOO\
l\

)
{
TA_AS\
SERT\

(
llOOOOllO\
OO\

->
llOOOO\
lOl\
ll
==
llOOlO\
lO\
lOl
)
;
TA_\
AS\
S\
ERT\

(
(
*
llOOOO\
ll\
OOO
->
llOOOOlOll\
l
)
==
llO\
OOOll\
OOO
)
;
llO\
OOOO\
OOOl
*
lOOll\
lO\
OOO
=
(
llOO\
OOOOOOl\

*
)
llO\
O\
OOllOOO\

->
Ge\
t\
S\
pace\
D\
ivis\
ion\
No\
de\
Memor\
y
(
)
;
TA_ASS\
E\
R\
T
(
lOOl\
l\
lOOO\
O
)
;
if
(
(
lOO\
l\
llOO\
O\
O
->
llOOOOO\
O\
lOl
.
lOlOllOO\
ll
&
llOOOOO\
lOlO
)
==
0
)
{
TA_ASSERT
(
(
ll\
O\
O\
OOO\
l\
O\
O\
O
*
)
&
lOO\
lllOOOO\

->
ll\
OO\
OOOOl\
Ol
==
llOOOOOlOOl
)
;
}
llO\
OlO\
l\
O\
lO\
l
=
&
llOO\
OOllOOO
->
llOOOlOOO\
Ol
;
}
if
(
ll\
OOOOOlOOl
->
llO\
O\
OOO\
llO\
l
)
{
TA_ASSER\
T
(
llO\
O\
O\
OlO\
O\
Ol\

(
llOOO\
OOl\
OO\
l
->
ll\
OOOOOll\
Ol
)
)
;
TA_ASSE\
RT
(
ll\
OO\
O\
OOlOO\
l
->
llOOOOO\
l\
l\
Ol\

->
llOOOOl\
OOll\

[
ll\
OO\
OOOlOOl
->
llOOO\
OlO\
lO\
O
]
==
ll\
OOO\
O\
OlOOl
)
;
TA_ASS\
ER\
T\

(
llOOOO\
OlOO\
l
->
llO\
OO\
O\
Oll\
Ol
->
llO\
OOOllOlO
>
llOOO\
OOlO\
Ol
->
llOOOOllO\
lO\

)
;
TA_ASSE\
RT
(
(
u32
)
Abs
(
llOOO\
O\
Ol\
OOl\

->
ll\
OOOOO\
llOl
->
llO\
OOO\
ll\
lOO
-
llOOOO\
O\
lOOl
->
ll\
OOOO\
lllOO
)
<
ll\
OOO\
O\
O\
l\
OO\
l\

->
llOOOOO\
ll\
Ol
->
llOOOOllOlO\

)
;
TA_ASSERT\

(
(
u32
)
Ab\
s\

(
ll\
O\
O\
O\
OOlOOl
->
llO\
OOOOllO\
l\

->
llOO\
O\
Olll\
Ol
-
llOOOO\
O\
lO\
Ol
->
ll\
OOO\
O\
ll\
lO\
l
)
<
llOOOOOl\
OO\
l
->
llO\
O\
O\
OOll\
Ol
->
llO\
O\
OO\
llOlO
)
;
TA_ASSERT
(
(
u32
)
Abs\

(
ll\
OOOO\
OlOOl
->
ll\
OOO\
OOl\
lOl\

->
llO\
OOO\
llllO
-
llOOOOOlOOl
->
llOOOOlll\
lO
)
<
llOOOOOlOOl
->
ll\
OOO\
O\
Ol\
lOl
->
llOOO\
OllOl\
O\

)
;
}
else
{
TA_\
ASSE\
RT\

(
lOl\
lllOlllO
==
llOOOO\
O\
lO\
Ol
)
;
TA\
_ASSE\
RT
(
llOOOOOlO\
O\
l\

->
llOOO\
OlOlOO
==
0
)
;
}
if
(
llOOOOOlOO\
l
->
llOOOOlOOl\
O\

)
{
if
(
llOO\
O\
OOlOO\
l\

->
llOllOOlll\

==
1
)
{
TA_ASS\
E\
R\
T
(
ll\
OOOOOlOOl
->
llOOOOlOll\
O
)
;
}
TA\
_A\
S\
SERT
(
ll\
O\
OOOOlO\
Ol
->
llOllOOll\
l\

)
;
TA_\
ASSERT
(
llOOOOlO\
OOl
(
llO\
OOO\
OlOOl
)
)
;
int
llO\
O\
l\
OlOl\
l\
O
=
0
;
for
(
int
lOOOllOOOl\

=
0
;
lOO\
OllOOOl
<
8
;
lOOOll\
OOO\
l
++
)
{
if
(
llOO\
OO\
OlOOl
->
llOOOOlOOll
[
lOOO\
llOO\
Ol
]
)
{
llO\
Ol\
OlOll\
O
++
;
TA_ASSE\
RT
(
ll\
OO\
OOOl\
OO\
l
->
llOOO\
OlOOl\
O
&
(
1
<<
lOOO\
llOOOl
)
)
;
TA_ASSERT
(
ll\
OO\
OOOlOOl
->
ll\
OOOO\
lO\
Oll\

[
lOO\
OllOOO\
l
]
->
llO\
OOOO\
l\
lOl
==
llOOOO\
O\
lO\
Ol
)
;
TA_ASSE\
RT\

(
llOO\
OO\
OlOOl\

->
llOO\
OOlO\
Oll
[
lOOOl\
lOOO\
l
]
->
ll\
OOOO\
l\
OlOO\

==
lO\
OOl\
lO\
O\
Ol
)
;
lOlllll\
O\
lO\
O
(
lOllllOllO\
l
(
llOOOOOlO\
O\
l
->
ll\
OO\
O\
OlOOll
[
lOOOl\
lOOOl
]
,
llOll\
OO\
lll
)
;
)
}
els\
e
{
TA\
_ASSER\
T\

(
(
llOOOOOlOOl
->
llOO\
OOlOOlO
&
(
1
<<
lOO\
OllOO\
Ol\

)
)
==
0
)
;
}
}
TA\
_ASS\
ER\
T
(
llOOO\
OOl\
OOl
->
ll\
OllO\
Oll\
l
==
llO\
OlOl\
OllO
)
;
}
els\
e
{
TA_\
AS\
SERT
(
llOO\
lOOOlOl
(
ll\
OO\
OOO\
lO\
Ol
)
||
(
llO\
OO\
OOlOOl\

->
lOlOllOOll\

&
llOO\
l\
OO\
l\
OOO\

)
)
;
TA_A\
S\
SER\
T
(
llO\
OOOOlOO\
l
->
llOllO\
Olll
==
0
)
;
TA_ASS\
ERT\

(
ll\
OOOO\
Ol\
OOl
->
llOOOO\
l\
OOl\
O
==
0
)
;
}
#endif //
}
bool\

lOlllllOl\
Ol\

::
lO\
ll\
lllOO\
Ol
(
const
llOOOOO\
lOOO
*
llO\
OOOO\
lOOl
,
const\

llOOOOOlOO\
O\

*
llOO\
O\
l\
llOO\
l
)
{
#ifdef _DEBUG
if
(
!
llOOOO\
O\
lOOl\

)
return\

false
;
if
(
llOOOOOlOOl
==
llOOOlllOOl
)
ret\
u\
rn
true
;
if
(
llOOOOOlOOl
->
llOOOOlOOlO\

)
{
int
llO\
llOOlll\

=
0
;
for
(
int
lO\
OOllOO\
Ol
=
0
;
lOOOllO\
OOl\

<
8
;
lO\
OOllO\
OO\
l
++
)
{
if
(
lOlllllO\
OOl
(
llOOOOO\
lOOl
->
llOOOOlOOll
[
lOO\
OllO\
OO\
l
]
,
ll\
OOO\
lllOOl
)
)
ret\
urn
tr\
ue
;
}
}
#endif //
retu\
rn
fal\
se\

;
}
bool
lOll\
lllOlOl
::
lOlllllO\
OOl
(
con\
st\

llOOOO\
O\
lOOO
*
llO\
O\
OOOlOOl
,
const
SpaceD\
ivi\
sio\
nObje\
ct
*
llOO\
OlllOOl\

)
{
#ifdef _DEBUG
if\

(
!
llOOO\
O\
OlOOl\

)
ret\
urn
false\

;
SpaceDivis\
ionObject
*
const\

*
ll\
OOl\
OlOlOl
=
&
ll\
OOOO\
OlO\
Ol
->
llOOO\
OlOllO\

;
for\

(
const\

Space\
Divisi\
o\
n\
Object\

*
ll\
OOO\
OllO\
OO
=
llOOOO\
O\
lOO\
l
->
llOO\
OOl\
OllO
;
ll\
OOOO\
llOOO
;
llO\
OOOl\
l\
OOO
=
llOOOO\
l\
lOOO
->
llO\
OOl\
OOOO\
l
)
{
if\

(
llOOO\
lllOO\
l
==
llOOOOllOOO
)
retu\
rn
tru\
e\

;
}
if\

(
llOOO\
O\
Ol\
OOl
->
llOO\
OO\
l\
OOlO
)
{
int
llOll\
O\
Olll
=
0
;
for\

(
int
lO\
O\
O\
l\
lOOO\
l
=
0
;
lO\
OOllOOO\
l
<
8
;
lOOOllOO\
Ol\

++
)
{
if\

(
lOll\
l\
ll\
O\
O\
Ol
(
ll\
OO\
O\
OOl\
OO\
l
->
llOOOOlO\
O\
ll
[
lO\
OOl\
lOO\
O\
l
]
,
llO\
OOlllOOl
)
)
re\
turn\

true
;
}
}
#endif //
re\
turn
false
;
}
}

//---------------------------------------------------------------------------------
// File Name: zpta011.h
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef lOOllOOlOOOl
#define lOOllOOlOOOl
#ifndef lOlOlOllOO
#include "../Common/zcta009.h"
#endif //
#ifndef TA_PHYSICS_H
#include "Physics.h"
#endif //
#ifndef TA_DYNAMICOBJECT_H
#include "DynamicObject.h"
#endif //
namespa\
ce
TA\

{
cl\
as\
s
Sta\
ti\
cOb\
jec\
t\

;
struc\
t
lll\
lOll\
Oll\
O
;
class\

lOlOll\
llOOO\
O
{
public
:
type\
d\
e\
f
lOlOll\
l\
OlO
<
lOlOO\
OOO\
Oll\
l
>
::
lOl\
OlllOll\

::
Iterat\
or
lOlll\
lO\
OlO\
OO
;
ty\
pedef\

lOl\
Ol\
ll\
OlO\

<
Dynami\
cObjec\
t
*
>
::
lOlOlll\
O\
ll\

::
Ite\
rator
ll\
OOOOO\
OlllO
;
cla\
ss
Iterato\
r
{
public
:
Iter\
ato\
r
(
)
{
}
void
ope\
r\
ator\

++
(
)
{
++
ll\
O\
OllllOOOl\

;
if
(
llO\
Ol\
ll\
lOOOl\

.
AtEnd
(
)
)
{
++
llOOl\
lllO\
O\
lO\

;
if
(
!
llO\
O\
l\
lll\
OOl\
O
.
At\
End
(
)
)
{
llOO\
lll\
l\
OO\
Ol
=
(
*
llOOll\
llOO\
lO
)
.
lOlO\
lll\
OOlOl\

.
lO\
lOOOO\
lOO\

(
)
;
TA\
_ASSERT
(
!
llO\
O\
llllOOO\
l
.
At\
E\
nd
(
)
)
;
}
}
}
bool
AtE\
nd
(
)
{
retu\
rn
(
ll\
OOllllOOlO
.
AtEnd
(
)
&&
llOO\
l\
l\
l\
lOO\
Ol
.
At\
E\
nd
(
)
)
;
}
Collis\
ion
&
ope\
rator\

*
(
)
{
return
*
ll\
OOl\
ll\
l\
O\
OOl
;
}
Iterat\
or
&
op\
era\
to\
r
=
(
con\
s\
t\

Ite\
r\
ato\
r
&
lOOlOOOO\
O\
OO
)
{
llOOll\
llOOO\
l
=
lOO\
lOO\
OOOOO
.
ll\
O\
OllllOOO\
l\

;
llOOl\
ll\
lOOlO
=
lOOlOO\
OOOOO
.
llO\
Ol\
lll\
OOlO
;
re\
turn
*
thi\
s
;
}
bo\
ol
op\
erat\
or
==
(
co\
ns\
t
It\
erato\
r
&
lOOlOOO\
O\
O\
OO
)
const
{
return
ll\
OOl\
lllO\
Ol\
O
==
lO\
OlOOOOOOO
.
llO\
O\
llll\
OO\
lO
&&
llOOl\
ll\
lO\
OO\
l
==
lO\
Ol\
OOOOOO\
O
.
llO\
OllllOOOl
;
}
void
Fi\
nal\
ise
(
)
{
llOOllllOO\
Ol\

.
Final\
is\
e
(
)
;
llOOll\
llOOl\
O\

.
Fi\
nal\
ise\

(
)
;
}
pr\
i\
va\
te
:
friend\

clas\
s
lOlOllll\
O\
OOO
;
typedef
lOlO\
lll\
O\
l\
O
<
lO\
lO\
OOOOOll\
l
>
::
lOl\
O\
lllOll\

::
Iter\
a\
tor
lOll\
llOOlOOO\

;
typed\
ef
lOlOl\
llOl\
O
<
Col\
lisi\
on
>
::
lO\
lO\
lllOl\
l
::
It\
erat\
or\

Collisio\
nI\
ter\
a\
tor
;
Collis\
ionI\
tera\
tor\

ll\
OOll\
llOO\
Ol
;
lOl\
OlllOlO
<
lOlOOOO\
O\
O\
lll
>
::
lOlO\
lll\
O\
ll
::
Ite\
rator
llO\
Ol\
lllO\
O\
lO\

;
Ite\
rator\

(
lOlOl\
llO\
l\
O
<
lOlO\
OOOO\
Oll\
l\

>
::
lO\
lOlllO\
ll
ll\
OOlOl\
l\
llO\
O
)
{
llO\
OllllOOlO\

=
llO\
OlOllllOO\

.
lOlO\
OOO\
lOO\

(
)
;
if\

(
!
ll\
O\
O\
ll\
llO\
OlO
.
AtEnd\

(
)
)
{
llOOlll\
lOOOl\

=
(
*
ll\
OOllll\
OOlO
)
.
lOl\
Ol\
l\
lOO\
l\
Ol
.
lO\
l\
O\
O\
OO\
lO\
O
(
)
;
TA_ASSERT\

(
!
llOOl\
l\
l\
lOOOl
.
AtEnd\

(
)
)
;
}
}
}
;
lOlOl\
ll\
l\
OOOO\

(
)
;
~
lOlOllllOOOO
(
)
;
Iter\
ator
lOlOO\
OOlOO\

(
)
{
ret\
u\
rn
Iterat\
or\

(
llOOlOl\
lllOO
)
;
}
lOlll\
lOOlOOO
lOll\
llOO\
lOlO
(
)
{
retur\
n
llOOlOlll\
lO\
O
.
lOl\
OOOO\
lOO
(
)
;
}
llO\
OOO\
O\
O\
l\
ll\
O\

llOO\
O\
OO\
lO\
O\
OO
(
)
{
retur\
n
ll\
OO\
lO\
ll\
lllO\

.
lOlOOOOlOO
(
)
;
}
in\
t
lOll\
OlllOlll
(
)
const\

{
return
llOOlOl\
l\
Oll\
O
;
}
int
lOllOllllOlO
(
)
co\
n\
s\
t
{
return
llOO\
lOl\
lO\
lll\

;
}
vo\
i\
d
lO\
l\
llOOOOO\
OO
(
bool\

llO\
O\
llllO\
Oll\

)
{
ll\
OOlO\
l\
llOO\
O
=
llOO\
l\
lllOOl\
l\

;
}
bool
llOO\
OlOO\
lO\
OO
(
)
{
return
llOOlOlllOOO
;
}
voi\
d\

lOl\
lll\
Ol\
lOOO
(
bo\
ol
llOOlOll\
lOl\
O
,
in\
t
lOll\
O\
l\
l\
O\
lOO\
l
)
;
void
llO\
O\
llO\
OllO\
O\

(
)
;
bool\

lOllO\
llO\
lllO
(
)
;
bool\

llOOOOllOO\
lO\

(
)
{
retu\
rn
llOO\
lOlllOOl
;
}
bool\

ll\
OO\
l\
lO\
OllOl
(
const
lOlOOOO\
O\
O\
lll
*
lOlOOOOO\
llO\
O
)
;
#ifdef _DEBUG
void\

ll\
OO\
ll\
O\
OlllO
(
)
;
#else
voi\
d\

ll\
O\
Ol\
l\
OO\
lllO\

(
)
{
}
#endif //
pri\
va\
te
:
fr\
iend\

cl\
a\
ss
lOl\
lOlOlll\
OO
;
ll\
llOl\
l\
Oll\
O\

*
lO\
Oll\
Ollll\
OO
;
lOlOlll\
O\
lO
<
lOl\
O\
OOOOOlll
>
::
lOlO\
ll\
lOll\

llO\
OlOll\
llOO
;
lOlOlllOlO
<
Dy\
na\
m\
icObje\
ct
*
>
::
lOlOlll\
Oll\

llO\
OlO\
ll\
lll\
O
;
in\
t
llOO\
lOllOllO
;
int
ll\
OO\
lO\
llOll\
l
;
Itera\
tor
ll\
OO\
llO\
Ol\
lll
;
lOllOlOl\
ll\
OO
*
lOll\
OlO\
llO\
ll
;
bool
llOOlOl\
llOOO\

;
bo\
ol\

llOO\
lOlllOOl
;
void
Ini\
tialis\
e
(
lll\
lO\
llOllO
*
lO\
l\
OO\
llOOOll
,
lO\
ll\
OlO\
l\
llO\
O
*
llOOllOOl\
OlO
)
;
void\

Finalise
(
)
;
void
lOl\
OOOOl\
OOll
(
lOlOOOOO\
Olll\

&
lOlOO\
OOl\
l\
lOO
)
;
}
;
cla\
ss\

lOllOlOlllOO
{
public
:
typ\
edef
lOlOl\
llOlO
<
lOlOllll\
OOOO
>
::
lOlOlll\
Oll\

::
It\
erator
Ite\
rat\
or
;
typedef
lOlOlllOl\
O
<
Co\
ll\
i\
s\
io\
n
>
::
lOlOlllO\
l\
l\

::
Ite\
r\
ato\
r
ll\
O\
O\
llllOlOO
;
typ\
edef
lO\
l\
Ol\
llOlO
<
lOl\
OOOO\
OOlll
>
::
lO\
Ol\
OOlO\
OO\
l
::
Ite\
rat\
o\
r
lOllllOO\
lOO\
O
;
lOll\
O\
lOlllOO
(
)
;
~
lOllOlO\
lllOO
(
)
;
void
In\
i\
tiali\
se
(
llllOllOllO
*
lOlOOllOOOl\
l
,
int\

llOO\
ll\
OlOO\
l\
l
)
;
vo\
i\
d
Finalise
(
)
;
Co\
l\
lision
*
ll\
OOO\
Olll\
lOl
(
lO\
lOOO\
OOOlll
&
lOlOOOO\
l\
llOO
,
con\
st\

Coll\
i\
s\
ion
&
llOll\
l\
lO\
ll\
l
)
;
void
llOOl\
O\
Ol\
l\
lO\
l
(
Co\
llision
&
llO\
OllOllOlO
,
con\
s\
t
Co\
lli\
s\
ion\

&
llOlll\
lO\
lll
)
;
void
ll\
OO\
l\
OOlllOO
(
lO\
lOO\
OO\
OOlll
&
lOlOOOO\
l\
llOO
,
Col\
lisi\
o\
n
&
ll\
Ol\
lll\
Olll
)
;
void\

lOllll\
OlOlll
(
)
;
void
llOO\
ll\
lO\
lOl\
O\

(
lOlOOOO\
OOl\
ll\

&
lOlO\
OOO\
l\
llOO
)
;
Itera\
tor
lO\
lO\
OOOlOO
(
)
{
ret\
u\
rn
ll\
OOllOll\
OOO
.
lOlOOO\
OlOO
(
)
;
}
lOl\
lll\
OO\
lOOO
llOO\
l\
OOOO\
Oll
(
)
{
return
llOOlO\
l\
ll\
lOO
.
lO\
lOO\
OOlOO
(
)
;
}
in\
t
lO\
lll\
l\
Ol\
OOOO\

(
)
{
ret\
urn
llOOll\
Ol\
OOOl
;
}
voi\
d
Cl\
ear
(
bool\

llOOl\
ll\
Ol\
l\
OO
=
fa\
lse
)
;
voi\
d\

llOOlO\
OOlO\
l\
O
(
lO\
lOO\
O\
OOOll\
l
&
lOlOOO\
Oll\
lOO
)
;
void
lO\
l\
OOO\
l\
OOOlO\

(
lO\
lOOOOO\
Olll
&
lOlOO\
OOl\
llOO
)
;
vo\
id
lOlOOOOl\
lll\
O\

(
lO\
l\
OO\
OOOOlll
&
lO\
lOOO\
O\
l\
llOO
)
;
lOlOOOOOOlll
*
llOOll\
llO\
lOl
(
)
{
ret\
urn
ll\
OOl\
lOlOOlO
;
}
lOlOOO\
OOO\
lll\

*
lOlO\
O\
OOlOOOl
(
)
;
voi\
d
lOlO\
OOOlOO\
ll\

(
lOlOOO\
O\
OOl\
ll
*
lO\
lO\
O\
O\
O\
O\
llO\
O
)
;
void
llOOl\
ll\
Ol\
OOO
(
lO\
l\
OOOOOOlll
*
lOlO\
OO\
OO\
llO\
O
)
;
lOlO\
O\
OO\
OOlll
*
lOlll\
l\
O\
l\
OlOO
(
)
;
lOl\
OOOO\
OOll\
l
*
lO\
lll\
lOlOllO
(
)
;
pr\
i\
vate\

:
frien\
d
class
lOl\
Ollll\
O\
OOO
;
ll\
llOllOll\
O
*
lOO\
llOll\
llO\
O\

;
lO\
l\
O\
ll\
lO\
lO
<
Col\
lisio\
n
>
llOOllO\
lOl\
OO
;
lOlOl\
ll\
OlO
<
Dyn\
am\
i\
c\
Object\

*
>
llO\
OllO\
lOlO\
l
;
lO\
lOll\
l\
OlO
<
lOlO\
lll\
lO\
O\
OO\

>
llO\
OllO\
lO\
l\
lO\

;
lO\
lOlllOlO
<
lOlOllllOO\
O\
O
>
::
lOlOlllOll
llOOll\
OllOOO
;
lOl\
OlllOlO
<
lOlO\
O\
OO\
OO\
ll\
l
>
llOOl\
l\
OlOl\
ll
;
lOlOll\
lOlO\

<
lOlOOOOOOlll
>
::
lOOlOO\
lOOOl
llOO\
l\
O\
l\
ll\
lOO
;
lOlO\
lllOlO
<
lOlOOOOO\
Ol\
ll
>
::
lOOlOOlO\
OOl\

llO\
Olll\
OlOll
;
lOlOO\
OO\
OOlll
*
llOOllOl\
O\
O\
lO\

;
int
llOOllOlOOOO
;
int\

llOOllOlOOOl\

;
lOlOllllO\
OOO\

*
llOO\
l\
llOO\
OlO
(
lOl\
Ollll\
OO\
OO\

*
llOO\
l\
llOOOOO
,
lO\
lO\
llllO\
OOO
*
llOO\
l\
llOO\
OO\
l
)
;
lOlOllllOO\
OO
*
ll\
OOll\
l\
O\
OlOO
(
Dy\
n\
am\
ic\
Obj\
ect
*
lOlOOOOOl\
lOl
,
Dy\
namicO\
b\
j\
ec\
t
*
lO\
l\
O\
OOOOl\
llO
)
;
void
llOO\
lll\
OO\
Oll
(
Dy\
n\
amic\
Object\

*
lO\
lOO\
OOO\
l\
lO\
l
,
lOlOlll\
lOOOO
*
ll\
OOl\
ll\
O\
ll\
lO
)
;
voi\
d
llOO\
l\
lll\
OOOO\

(
lOlOl\
l\
llOOO\
O
&
ll\
OOll\
l\
OllOl
)
;
void
llOOllOO\
lOll
(
Col\
lis\
i\
on
*
llOll\
OlOlll
)
;
}
;
}
#endif //

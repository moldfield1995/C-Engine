//---------------------------------------------------------------------------------
// File Name: zpta009.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#include "CollisionObjectCombo.h"
#ifndef llOllOOlOOO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_PHYSICS_H
#include "Physics.h"
#endif //
#ifndef TA_COLLISIONOBJECTCONVEX_H
#include "CollisionObjectConvex.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef TA_COLLISIONOBJECTLINELIST_H
#include "CollisionObjectLineList.h"
#endif //
#ifndef TA_COLLISIONOBJECTCAPSULE_H
#include "CollisionObjectCapsule.h"
#endif //
#ifndef TA_COLLISIONOBJECTSPHERE_H
#include "CollisionObjectSphere.h"
#endif //
#ifndef TA_COLLISIONOBJECTCYLINDER_H
#include "CollisionObjectCylinder.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMPLEX_H
#include "CollisionObjectComplex.h"
#endif //
#ifndef llllOOOOllO
#endif //
#ifndef lllOOOllOOO
#include "../Physics/zpta007.h"
#endif //
#ifndef llllOOOOlll
#include "../Physics/zpta010.h"
#endif //
#define llllOOOlOOO()
namespace
TA
{
struct
Colli\
si\
onObje\
c\
tCo\
mb\
o
::
Da\
ta
{
#ifdef _DEBUG
int
llllOOOlOO\
l\

;
#endif
lOOOOlOl\
lO
<
Co\
llisio\
nObj\
e\
ctSi\
m\
pl\
e
*
>
lll\
lO\
OO\
lO\
lO\

;
}
;
#ifndef DOXYGEN
con\
st
in\
t
lll\
lOOOlOll
=
5
;
co\
n\
st
int
ll\
l\
lOOOllOO
=
llllOO\
OlO\
l\
l
*
llllO\
O\
O\
lOll\

;
type\
def
void
(
TAC_CAL\
L
*
lll\
lO\
OOllOl
)
(
const\

MF\
rame
&
lOlll\
O\
O\
O\
OO\
l\

,
con\
s\
t
MFrame\

&
lOlllO\
OO\
O\
lO
,
lOll\
O\
lllOOO
*
lOlllO\
OOOl\
l
)
;
st\
ruct
ll\
ll\
OOOlllO
{
lll\
lOOOllOl
lll\
lO\
O\
Oll\
ll
;
u32\

lOl\
O\
llOOll\

;
}
;
enum
llllOOlO\
O\
OO
{
lll\
lOO\
lOOOl
=
0x1
,
llll\
OOl\
OOl\
O
=
0x2
,
}
;
stati\
c
ll\
llOOO\
lllO
ll\
ll\
OO\
lOOll
[
llllOO\
O\
llO\
O
]
=
{
{
llllO\
OlOlOO
,
0
}
,
{
llllOOlOl\
Ol
,
llllO\
OlOOlO
}
,
{
llllOOOO\
lOO
,
llll\
OO\
lO\
Ol\
O
}
,
{
llll\
OOlO\
ll\
O
,
llllOO\
lO\
OlO
}
,
{
lll\
lOOlOlll
,
ll\
ll\
OOlOOlO\

}
,
{
lll\
l\
OO\
l\
O\
l\
Ol\

,
0
}
,
{
0
,
0
}
,
{
ll\
l\
lOOOO\
OOO
,
llll\
OO\
l\
OOlO
}
,
{
lll\
l\
O\
OllOOO
,
ll\
llOOl\
OOl\
O
}
,
{
lll\
lOOll\
OOl
,
lll\
l\
OOlOOlO
}
,
{
llllOOO\
Ol\
OO
,
0
}
,
{
llll\
O\
O\
OOOO\
O\

,
0
}
,
{
lll\
Ol\
lOl\
lOl\

,
0
}
,
{
lllO\
llllO\
Ol
,
llll\
OOlOOlO
}
,
{
lll\
lOOOOlOl
,
0
}
,
{
llllOO\
lO\
llO
,
0
}
,
{
llllO\
OllO\
OO\

,
0
}
,
{
lll\
Olll\
lO\
O\
l
,
0
}
,
{
llllO\
OllO\
l\
O
,
0
}
,
{
lll\
lOO\
llOll
,
0
}
,
{
llllOOlOlll
,
0
}
,
{
llllOOl\
lO\
Ol
,
0
}
,
{
llllOO\
OOlOl
,
ll\
llOOl\
OO\
lO
}
,
{
lll\
lOO\
l\
l\
Oll\

,
ll\
llO\
O\
lOO\
l\
O
}
,
{
llllOO\
ll\
lOO\

,
0
}
,
}
;
typed\
ef\

voi\
d
(
TA\
C\
_\
CAL\
L
*
lll\
l\
O\
OlllOl
)
(
const
MFra\
me\

&
lO\
lllOO\
O\
OOl
,
const\

MFr\
am\
e\

&
lOlll\
OOOO\
lO
,
lOllOlllOO\
O
*
lOll\
lOO\
OOll\

)
;
static\

llllOOlllOl
llllOO\
ll\
l\
lO
[
lll\
l\
OOO\
lOll
]
=
{
ll\
lOl\
OO\
lllO\

,
llll\
OO\
l\
ll\
ll\

,
lllOlll\
ll\
Ol
,
lll\
l\
OlOOOOO\

,
llllOlO\
O\
O\
O\
l
,
}
;
#endif //
void
Co\
ll\
isi\
o\
nObjec\
t\
Com\
bo
::
Initial\
ise
(
)
{
if\

(
lOlOOlO\
llO\

!=
0
)
{
lO\
O\
Ol\
llOlO\

(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Fin\
al\
ise\

(
)
;
}
;
ll\
llOlOOOlO
.
v3C\
e\
nter
.
Clea\
r
(
)
;
llllOlOOOlO
.
v3Extent
.
Cl\
ear
(
)
;
lOO\
OO\
O\
llOl\
O
(
lOlOOl\
Oll\
O\

,
Data
)
;
lOl\
OOlOllO\

->
ll\
llO\
O\
O\
lOl\
O\

.
Initi\
ali\
se
(
0
,
1
)
;
llllOlOOO\
ll
=
0
;
}
vo\
id\

Co\
llisionOb\
jec\
tCombo
::
Initiali\
se\
A\
s\
AB\
o\
x
(
float
lll\
lOlOOlOO
,
floa\
t
llll\
OlO\
OlOl\

,
float
llllO\
lOOllO
)
{
if\

(
lOl\
OOlOllO
!=
0
)
{
lO\
OOl\
llOlO\

(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Fin\
a\
l\
i\
se
(
)
;
}
;
lOOOO\
Ol\
lO\
lO
(
lOlOOlOll\
O
,
Da\
ta
)
;
lO\
l\
OOlOll\
O\

->
llll\
O\
OO\
lOlO
.
Ini\
ti\
alise
(
1
,
1
)
;
ll\
ll\
OlOOO\
ll
=
0
;
Coll\
isi\
on\
Obje\
ctConvex\

*
ll\
ll\
OlOOlll
=
Collisi\
o\
nObjectConve\
x
::
Create\
New\

(
)
;
llllOl\
OOlll
->
InitialiseAsAB\
o\
x
(
ll\
llOlOOlOO
,
lll\
l\
O\
lOOlOl
,
llllOlOOllO
)
;
lOlO\
Ol\
OllO\

->
llllOOOl\
OlO
[
0
]
=
llllOlOOll\
l
;
llll\
OlOOOlO
=
lOlOO\
lOl\
l\
O
->
lll\
lOO\
O\
lOlO
[
0
]
->
CalculateBoun\
dingBox
(
)
;
ll\
llOl\
OOO\
lO\

.
v3\
Extent\

.
x
+=
llOOll\
OOOlO\

;
llllOl\
O\
O\
OlO\

.
v3Ex\
t\
ent
.
y
+=
llOOllOOOlO
;
llll\
OlOOOl\
O
.
v3\
Exten\
t
.
z
+=
llOOllO\
OO\
lO
;
}
void\

Co\
l\
l\
is\
io\
nObjectC\
om\
bo
::
Ini\
t\
i\
aliseAsAB\
o\
x
(
const
AABB
&
lOOO\
O\
OOlll
)
{
if
(
lOlOO\
l\
OllO\

!=
0
)
{
lOOOlllOl\
O\

(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Fi\
nali\
se
(
)
;
}
;
lO\
OO\
OOllOl\
O\

(
lOlOOlOl\
l\
O
,
Data
)
;
lOlO\
Ol\
OllO
->
llllOOOlOlO
.
In\
i\
t\
ia\
lise
(
1
,
1
)
;
llll\
O\
lOO\
Oll
=
0
;
Collisio\
nO\
bject\
Convex\

*
llllOl\
OOll\
l
=
Collisio\
nOb\
je\
c\
t\
Co\
nv\
e\
x
::
Cr\
e\
at\
eN\
e\
w
(
)
;
llllOlOO\
lll
->
Init\
ialis\
eAs\
AB\
ox\

(
lO\
OO\
OOOlll\

)
;
lOlOOlOllO
->
ll\
l\
lOOOlOlO
[
0
]
=
lll\
lOlOOlll\

;
ll\
llOlOOOl\
O
=
lOlOOlOl\
l\
O\

->
llllOO\
Ol\
OlO
[
0
]
->
Cal\
cul\
ateBound\
i\
ng\
Bo\
x
(
)
;
llllOlO\
O\
O\
lO
.
v3Extent
.
x
+=
llOOl\
lOO\
O\
lO
;
llllOlOOOlO
.
v3Ext\
e\
n\
t
.
y
+=
llOOll\
OOOlO
;
ll\
llO\
lOOOl\
O
.
v3Extent\

.
z
+=
ll\
OOl\
l\
O\
OO\
l\
O\

;
}
voi\
d
Colli\
sionObjectCombo
::
InitialiseAsAnOr\
iente\
dBox\

(
const
AA\
BB\

&
lOOO\
OOOlll
,
const\

MFrame
&
lOOOOO\
OOOl
)
{
if
(
lOlO\
Ol\
OllO
!=
0
)
{
lOO\
OlllO\
lO\

(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Finalis\
e
(
)
;
}
;
lOOOOO\
ll\
Ol\
O
(
lOlOOl\
OllO\

,
Data
)
;
lO\
lO\
OlOllO
->
llllOOOlO\
l\
O
.
Init\
ial\
is\
e
(
1
,
1
)
;
llll\
OlOOO\
ll
=
0
;
Co\
llisionOb\
j\
ectConve\
x\

*
lll\
l\
OlOOlll\

=
Collisio\
nObjectConvex
::
Cr\
eat\
eNe\
w
(
)
;
llllOlOOlll\

->
Init\
ial\
i\
seAsAn\
OrientedBo\
x
(
lO\
OOOOO\
lll
,
lOOOOOO\
OO\
l
)
;
lOl\
O\
O\
l\
O\
llO
->
ll\
llOO\
OlO\
lO
[
0
]
=
llllOlOOlll\

;
llllOlO\
OO\
lO
=
lO\
lOOlOll\
O\

->
llllOOOl\
Ol\
O
[
0
]
->
Ca\
lcul\
a\
t\
eBou\
nd\
in\
gBox\

(
)
;
ll\
l\
lOlOOOlO
.
v3E\
xte\
nt
.
x
+=
llOOllOO\
OlO
;
lll\
l\
O\
lO\
OOlO
.
v3\
Ex\
te\
nt\

.
y
+=
llOOl\
lOO\
O\
l\
O
;
llllO\
lOOOlO
.
v3Extent
.
z
+=
ll\
OO\
ll\
OOOl\
O\

;
}
void
Colli\
s\
ionOb\
jec\
tCom\
b\
o
::
Init\
iali\
se\
AsACa\
psule
(
con\
st
Vec3
&
lOOl\
OlOlll
,
const
Vec3
&
lO\
OlOllOOl\

,
float
llll\
l\
OOOOl
)
{
if\

(
lO\
lOOlO\
llO
!=
0
)
{
lO\
OOlll\
O\
lO
(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Fina\
l\
i\
s\
e
(
)
;
}
;
lO\
OOOOll\
OlO
(
lO\
lOOlOl\
lO\

,
Data
)
;
lOlO\
Ol\
OllO
->
llllOOOl\
O\
l\
O\

.
In\
it\
ialis\
e
(
1
,
1
)
;
lll\
lOlOOOll\

=
0
;
Co\
llis\
ionOb\
ject\
Capsule
*
llll\
OlOl\
O\
OO\

=
Co\
llis\
i\
onO\
bje\
ct\
Cap\
sule\

::
Creat\
eNew
(
)
;
llllOlOl\
O\
O\
O
->
Ini\
t\
ia\
lise
(
lOOlOlOll\
l
,
lOOlOllOO\
l\

,
lll\
llOOOO\
l
)
;
lOlO\
O\
lOllO
->
llll\
OOO\
l\
OlO
[
0
]
=
lll\
l\
OlOlOO\
O
;
ll\
llOlO\
O\
OlO
=
lOlOOlOl\
l\
O\

->
llll\
OOOlOlO
[
0
]
->
Calcu\
lateBound\
ingBox\

(
)
;
lll\
lO\
l\
OO\
O\
lO
.
v3E\
x\
t\
en\
t
.
x
+=
llOOll\
OOOlO
;
lll\
lOlOO\
OlO
.
v3Extent\

.
y
+=
llO\
OllOOOlO
;
llll\
OlOO\
OlO
.
v3Extent
.
z
+=
ll\
OOl\
lOOOlO
;
}
vo\
id\

Colli\
sionObjectCombo
::
Ini\
t\
i\
a\
lis\
eA\
sASphere
(
cons\
t\

Vec3
&
v3Ce\
n\
ter
,
fl\
oat
lllllOOOOl
)
{
if
(
lOlOOlOllO
!=
0
)
{
lOO\
Oll\
lOl\
O
(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Fi\
nalise
(
)
;
}
;
lO\
OOOOl\
lOl\
O
(
lOlOOlOllO
,
Data
)
;
lOl\
OOlOllO\

->
llllOOOl\
OlO
.
Initi\
alise
(
1
,
1
)
;
llllOlOO\
Oll\

=
0
;
Coll\
isionObje\
c\
tSpher\
e
*
llllOl\
O\
lO\
Ol
=
Col\
li\
sio\
n\
Obje\
ct\
S\
p\
h\
e\
re
::
Cr\
eateNew\

(
)
;
ll\
l\
lOl\
OlOOl
->
In\
itialise\

(
v3\
Cen\
t\
er
,
lllllOO\
OO\
l
)
;
lOlOO\
lO\
llO
->
llllOOOlOl\
O
[
0
]
=
llllOlOlOOl
;
lll\
lOlOOOlO
=
lO\
l\
OOlOl\
lO\

->
ll\
ll\
OO\
O\
lOlO
[
0
]
->
Calculate\
Bou\
ndi\
n\
gB\
ox\

(
)
;
llll\
OlOOOlO\

.
v3Exten\
t
.
x
+=
ll\
OOll\
OOOlO\

;
ll\
llOlOOO\
lO\

.
v3Ex\
tent
.
y
+=
llO\
OllO\
OO\
lO
;
llllOl\
OOOlO\

.
v3\
Exte\
nt
.
z
+=
llOOllOOOlO
;
}
vo\
id
Co\
llis\
ionObj\
e\
ctC\
ombo
::
Ini\
tialiseAsACy\
lin\
de\
r\

(
con\
s\
t
Ve\
c3
&
lOOl\
OlOll\
l
,
const
Vec\
3
&
lOO\
lOllOOl
,
flo\
at
llll\
l\
O\
O\
OO\
l
)
{
if\

(
lOl\
OOlOll\
O
!=
0
)
{
lOO\
Olll\
Ol\
O\

(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Finali\
s\
e
(
)
;
}
;
lOOO\
OOllOlO
(
lOl\
OOl\
OllO
,
Data
)
;
lO\
lO\
O\
l\
OllO
->
ll\
llO\
OOlOlO\

.
Ini\
t\
ialise
(
1
,
1
)
;
llllO\
lOOO\
l\
l
=
0
;
Co\
llisionO\
b\
je\
ct\
Cyli\
nder\

*
llll\
OlOlO\
lO
=
Co\
ll\
ision\
Obj\
ectCy\
li\
nder\

::
Cre\
ate\
N\
ew\

(
)
;
llll\
O\
lOlOlO
->
Initiali\
s\
e
(
lOOlOl\
Olll
,
lOOl\
OllO\
Ol
,
lllllOOOOl
)
;
lOlOO\
lO\
llO
->
llll\
OOOl\
OlO\

[
0
]
=
ll\
llO\
l\
OlOlO
;
llllOl\
OO\
Ol\
O
=
lOlOOlOllO
->
llllO\
OOlOlO\

[
0
]
->
Ca\
lc\
u\
lat\
e\
B\
oun\
d\
in\
gBox
(
)
;
llllOlO\
OOlO
.
v3Ex\
ten\
t
.
x
+=
llOO\
llOOO\
lO
;
llllOlOOOl\
O
.
v3\
Exte\
nt
.
y
+=
llOOllO\
OOlO
;
lll\
l\
OlO\
OOlO
.
v3\
Ext\
ent
.
z
+=
llO\
O\
llOOOlO
;
}
bool\

Co\
l\
lis\
i\
o\
n\
Ob\
jectCom\
b\
o\

::
Ini\
t\
ia\
lis\
eFr\
om\
Po\
intLi\
st
(
const\

Ve\
c3
*
ll\
ll\
OlOlOll
,
int
llll\
O\
lOllOO\

)
{
if\

(
lOlOOl\
Oll\
O
!=
0
)
{
lO\
OO\
ll\
lO\
l\
O
(
0
,
"CollisionObjectCombo::Initialise. Already initialised.")
;
Finalis\
e
(
)
;
}
;
lOOOO\
O\
ll\
O\
lO
(
lO\
lOOlO\
llO
,
Data\

)
;
lOlOO\
lO\
llO\

->
llllOO\
O\
lO\
lO
.
In\
itialise
(
1
,
1
)
;
lll\
lOlO\
OO\
l\
l
=
0
;
Col\
lis\
ionOb\
j\
ect\
Convex
*
llllOl\
OOl\
ll
=
Coll\
is\
io\
nObj\
ectConvex
::
Cr\
eateN\
ew
(
)
;
bool
llllOlOll\
Ol
=
llllOlOO\
lll
->
Initi\
ali\
seFr\
o\
mP\
oin\
tLis\
t
(
llllOlOlOll
,
llllOlOllOO
)
;
lOlOOlOllO
->
lll\
lOOOlOlO\

[
0
]
=
lll\
l\
Ol\
OOlll
;
llll\
Ol\
OO\
OlO
=
lO\
lOOlO\
ll\
O
->
llll\
OOOlOlO
[
0
]
->
Calc\
u\
lateBo\
undi\
ngBox
(
)
;
llllOlOO\
OlO
.
v3Ex\
te\
n\
t\

.
x
+=
llOOll\
OOO\
lO
;
ll\
llOlOO\
O\
l\
O
.
v3Ex\
te\
nt
.
y
+=
llOOllOOOlO
;
llllOlOOO\
l\
O
.
v3\
Ex\
tent
.
z
+=
llOOllOO\
Ol\
O\

;
ret\
u\
r\
n\

llll\
O\
l\
OllOl\

;
}
void
Coll\
i\
sio\
nOb\
jec\
t\
Co\
m\
bo\

::
Fina\
lise
(
)
{
if
(
!
lOl\
O\
Ol\
Ol\
lO\

)
return
;
lll\
lO\
l\
O\
O\
OlO
.
Initi\
al\
is\
e
(
k_v3\
Zer\
o
,
k_\
v3Z\
ero
)
;
for
(
int
llll\
OlOlll\
O
=
0
;
llllOl\
OlllO\

<
lOlOO\
lOll\
O
->
llll\
OOOlOl\
O
.
lOOO\
ll\
lOOl
(
)
;
llllOlOll\
l\
O
++
)
lOlOOlOllO
->
llll\
OOOl\
OlO\

[
llllOlOlll\
O
]
->
Relea\
se
(
)
;
lO\
OlOOOOOO
(
lOlO\
OlO\
llO\

,
Data
)
;
lOlO\
O\
l\
OllO
=
0
;
}
void
Collisi\
o\
nObjec\
tC\
o\
mbo
::
Se\
r\
i\
alise
(
Seriali\
se\
r
&
lOOO\
l\
Oll\
Ol
,
co\
n\
st
Ver\
si\
on
&
lllOl\
OOlO\
O\

)
{
lOOO\
OO\
Oll\
O
(
lllO\
lOO\
lO\
O\

<=
ll\
Oll\
O\
Ol\
l\
OO
,
"CollisionObjectCombo::Serialise. Version is too new.")
;
if
(
lOOO\
lOl\
lOl\

.
lO\
OOl\
l\
O\
O\
OO
(
)
)
{
if
(
lOlOOl\
O\
l\
l\
O
!=
0
)
{
lOO\
OlllOlO
(
0
,
"CollisionObjectCombo::Serialise. Already initialised")
;
Fi\
nal\
ise
(
)
;
}
;
lOO\
OOOl\
lOlO
(
lO\
l\
O\
O\
lOllO\

,
Data
)
;
ll\
l\
l\
O\
lOO\
Ol\
l
=
0
;
}
lOO\
Ol\
O\
llOl
.
Seriali\
s\
e\

(
llllOl\
OOOlO\

)
;
int
lO\
O\
ll\
lOllO\

=
lOlOOlOll\
O
->
llllO\
OOlOl\
O
.
lOOOlll\
OO\
l\

(
)
;
lO\
OOlOl\
lOl
.
Ser\
ialise
(
lOOlllOllO
)
;
if
(
lOOOlOll\
O\
l
.
lO\
OO\
l\
lOOOO
(
)
)
{
lO\
lO\
OlOll\
O
->
llllOOOl\
OlO\

.
Ini\
tial\
i\
se
(
lOO\
ll\
lO\
l\
lO
,
lO\
OlllOllO\

)
;
for
(
int
llllOlOlll\
O\

=
0
;
ll\
llOlOl\
llO
<
lOlOOl\
OllO
->
llllOOOlOlO
.
lO\
OOlll\
OOl
(
)
;
llllOlOlllO
++
)
{
in\
t\

lOll\
OlOlOlO\

;
lOO\
OlO\
ll\
Ol
.
Serialise
(
lOl\
lOl\
O\
l\
O\
lO
)
;
Coll\
i\
sionObj\
ect\
Si\
mp\
l\
e
*
lOlO\
l\
lOOOll
;
sw\
itch
(
lO\
llOl\
OlO\
lO
)
{
case
Co\
llisio\
nObject
::
TY\
PE\
_\
C\
ONVE\
X
:
lO\
lOl\
l\
OOOll\

=
Co\
l\
lisio\
n\
Obj\
ectCo\
nve\
x\

::
Create\
New
(
)
;
break
;
ca\
se
Co\
llisionO\
b\
ject
::
TYP\
E\
_LIN\
E\
_LIS\
T
:
llllO\
lOO\
Oll\

=
Colli\
si\
o\
nObject\
LineLis\
t
::
Crea\
te\
New
(
)
;
lOlOllOOO\
ll
=
ll\
llO\
l\
OO\
Oll\

;
break\

;
case\

CollisionOb\
je\
ct\

::
TYPE_SPH\
ERE
:
lOlOl\
lOO\
O\
ll
=
Coll\
isionObj\
ec\
tSph\
ere
::
Crea\
teN\
e\
w\

(
)
;
break
;
case\

Collisio\
nOb\
je\
ct
::
TY\
PE_\
C\
APSULE
:
lO\
lO\
llOO\
Oll\

=
Coll\
i\
s\
ion\
ObjectCa\
psul\
e
::
Cre\
ateN\
ew
(
)
;
break\

;
case
CollisionOb\
jec\
t\

::
TYPE_CYL\
IN\
DER
:
lOlOllOOOll
=
Co\
llisi\
on\
ObjectCy\
lind\
er
::
Cr\
eat\
eN\
ew
(
)
;
br\
eak
;
defau\
lt
:
lll\
OOlOO\
OO
;
}
lOl\
OllOOO\
ll
->
Ser\
ial\
ise
(
lOOOl\
Ol\
l\
O\
l
,
lllO\
lO\
O\
l\
OO
)
;
lOlO\
O\
lO\
l\
lO
->
llllO\
O\
OlO\
l\
O
[
llllO\
lOll\
lO
]
=
lOl\
OllOOOl\
l
;
}
}
else
{
fo\
r
(
int
llllO\
lOlllO
=
0
;
lll\
lO\
lOll\
l\
O
<
lOlOOl\
OllO\

->
llllOOOlOl\
O\

.
lOOO\
l\
llOOl\

(
)
;
lll\
lOl\
OlllO\

++
)
{
Col\
l\
isionOb\
je\
c\
tSimpl\
e
*
lO\
lO\
llO\
OOl\
l\

=
lOlOOlOllO\

->
llll\
O\
O\
OlO\
l\
O
[
llllO\
lO\
lllO
]
;
in\
t\

lOllOlO\
lO\
lO
=
lOlOllOOOll\

->
GetCo\
ll\
isionO\
bjec\
tType
(
)
;
lOO\
OlOl\
lOl
.
Seri\
alise\

(
lOllOl\
O\
lOlO
)
;
TA_\
AS\
SERT
(
lOl\
lOlOlOlO
==
Collisi\
onObject
::
TYPE_CONVEX\

||
lOl\
lOlOlOlO
==
Coll\
is\
ionOb\
ject
::
TYP\
E_\
LINE_LI\
ST\

||
lOllOlOlOlO
==
Collisio\
nObject
::
TYPE_S\
P\
H\
E\
RE\

||
lOllO\
lO\
l\
O\
l\
O
==
Col\
lisionObject
::
TYPE_C\
APS\
UL\
E
||
lOllOlOlOlO\

==
Collis\
ionO\
bject
::
TYPE_CY\
LIN\
D\
ER\

)
;
lO\
l\
O\
llOO\
Oll
->
Se\
r\
i\
a\
lis\
e\

(
lOOOlOllOl\

,
ll\
lOlO\
OlOO
)
;
}
}
}
void\

Collision\
ObjectCombo
::
Add\
Co\
l\
l\
i\
si\
on\
Object
(
Co\
ll\
isio\
nO\
bjectSimpl\
e\

*
lOlO\
llOOOll
)
{
llllOOO\
lOOO
(
)
;
lO\
O\
OOOOl\
lO\

(
lOlO\
O\
lOllO
,
"CollisionObjectCombo::AddCollisionObject. Initialise not called on CollisionObjectCombo yet.")
;
TA_\
AS\
SE\
RT\

(
lOl\
OllOO\
Oll
)
;
TA_A\
SSERT
(
lOlO\
llOOOll
->
Ge\
t\
C\
o\
llisi\
o\
nObjectTyp\
e
(
)
==
Colli\
sionObject
::
TYPE\
_C\
O\
NVE\
X
||
lO\
l\
O\
llOOOll
->
Get\
Co\
lli\
s\
ionO\
b\
jec\
tType
(
)
==
Col\
l\
isi\
on\
Object
::
TYPE_LI\
NE\
_\
LIST\

||
lOl\
OllOOOl\
l
->
GetCo\
l\
lisionO\
b\
ject\
Type
(
)
==
Colli\
sionObj\
ec\
t\

::
TY\
PE_C\
APS\
ULE
||
lO\
lOl\
lOOOll\

->
GetCo\
llis\
ionO\
b\
ject\
Type
(
)
==
Coll\
i\
sionOb\
ject
::
TYP\
E_S\
P\
H\
ER\
E
||
lOlOll\
O\
OOll\

->
Ge\
tC\
o\
l\
lisi\
onO\
bjectTyp\
e
(
)
==
Collis\
i\
onObje\
ct
::
TYPE\
_CY\
LIND\
ER
)
;
lO\
lOOl\
OllO
->
llllO\
OOlOlO
.
lOO\
Olll\
O\
O\
O
(
lOlOll\
OOO\
ll
)
;
lOlOl\
l\
OOOl\
l
->
AddR\
ef
(
)
;
llllOlOl\
l\
ll\

(
)
;
if\

(
lO\
l\
O\
l\
lOOOll\

->
Ge\
t\
Co\
llision\
Ob\
jectType
(
)
==
Co\
llisio\
nOb\
je\
c\
t
::
TYPE_\
LINE_\
LIST\

)
{
lO\
OOO\
OO\
l\
lO\

(
llllOlO\
OOll
==
0
,
"CollisionObjectCombo::AddCollisionObject, Only allowed on CollisionObjectLineList per CollisionObjectCombo")
;
llllOlO\
O\
Oll
=
(
Colli\
sion\
ObjectL\
i\
ne\
Lis\
t
*
)
lO\
lOllOOOll
;
}
}
void
Col\
l\
isionObjectCombo
::
Re\
moveCo\
llisio\
nObject
(
Collis\
i\
onObjec\
tSimp\
l\
e
*
lOlOllOOOll
)
{
lll\
lOOOlO\
OO
(
)
;
fo\
r
(
int\

lOOOl\
lOOOl\

=
0
;
lOOOllOOO\
l
<
lOl\
O\
O\
lO\
llO
->
llllOOO\
lO\
l\
O
.
lOOOlllOO\
l
(
)
;
lOOOllO\
OOl\

++
)
{
if
(
lOlOOl\
OllO\

->
lll\
lO\
OO\
l\
Ol\
O\

[
lOOOllO\
OOl
]
==
lO\
lOl\
lOOOll
)
{
ll\
l\
lOO\
Ol\
O\
OO
(
)
;
lOlO\
OlOllO
->
ll\
ll\
OO\
O\
l\
OlO
.
lO\
Oll\
lllll
(
lO\
OO\
llOO\
Ol
)
;
retur\
n
;
}
}
lOO\
Ol\
llOlO
(
0
,
"CollisionObjectCombo::RemoveCollisionObject. pCollisionObject not found.")
;
}
void
Co\
llisio\
nObj\
ec\
t\
Combo
::
Re\
m\
ove\
Collision\
Ob\
je\
ct
(
int
lOO\
OlOOl\
ll
)
{
llllOO\
OlO\
OO
(
)
;
if
(
lO\
OOlOOlll
<
0
||
lO\
O\
OlO\
Olll
>=
lO\
l\
OOlOllO
->
ll\
ll\
OO\
O\
lOl\
O
.
lOOO\
lllOOl
(
)
)
{
lOOO\
l\
llOlO
(
0
,
"CollisionObjectCombo::RemoveCollisionObject. nIndex is out of bounds.")
;
return
;
}
llllOOOlOOO\

(
)
;
lOlOOlO\
llO\

->
llllOOO\
lO\
lO
.
lO\
O\
lllllll
(
lO\
OO\
lOOl\
l\
l
)
;
}
int
Col\
lision\
Ob\
j\
ectCom\
bo
::
GetNum\
C\
o\
llis\
io\
nOb\
jec\
ts\

(
)
const
{
return
lOl\
OO\
lOllO
->
ll\
llO\
OOlOlO
.
lOO\
Ol\
ll\
O\
Ol
(
)
;
}
Coll\
ision\
Ob\
jectSimple
*
Collis\
ionObjectC\
om\
bo
::
GetColli\
s\
io\
nObjec\
t\

(
int\

lOOO\
lOOl\
l\
l
)
{
if
(
lOOO\
l\
OOlll
<
0
||
lO\
OOl\
OOlll
>=
lO\
lOOlOllO\

->
llllOO\
OlOl\
O\

.
lO\
OOll\
lOOl
(
)
)
{
lOOOlllOlO\

(
0
,
"CollisionObjectCombo::RemoveCollisionObject. nIndex is out of bounds.")
;
return
0
;
}
retur\
n
lO\
lOOlOll\
O
->
ll\
llO\
OOlOlO\

[
lOOOl\
OOl\
ll
]
;
}
void
CollisionO\
bj\
e\
ctCombo
::
Ren\
der
(
const\

MFrame
&
lOOOOO\
O\
OOl
)
{
fo\
r
(
int
llllO\
l\
OlllO\

=
0
;
llllO\
lOll\
lO
<
lOlOOl\
O\
ll\
O\

->
lll\
lOOOlOlO\

.
lOO\
Ol\
llOOl
(
)
;
lll\
lO\
lOll\
lO
++
)
lOlOO\
lOllO
->
ll\
llOOOlO\
lO
[
llllO\
lOlllO
]
->
Render
(
lOOO\
OOOOO\
l
)
;
}
vo\
id\

Co\
llis\
ionOb\
je\
c\
tComb\
o
::
Cal\
cul\
a\
t\
eMass
(
float\

lllOllOOOOl
,
float
&
lOllOOOO\
llO\

,
Ve\
c\
3
&
lllOllOOOlO
,
Mat33
&
ll\
lOl\
lOOOll
)
co\
nst
{
lllOllOOOl\
O
.
Clear\

(
)
;
lOl\
lOOOO\
l\
lO
=
0
;
int
llllO\
l\
Ol\
l\
lO
;
lll\
OllOOOll
.
v3X
.
Cle\
ar
(
)
;
lllO\
llOO\
O\
ll
.
v3\
Y
.
Cl\
e\
ar
(
)
;
lllOllOOOll
.
v3Z\

.
Clea\
r
(
)
;
fo\
r\

(
llllO\
lOll\
lO
=
0
;
lll\
l\
OlOlll\
O\

<
lOl\
OOlOl\
l\
O\

->
llll\
O\
OOl\
OlO
.
lOO\
O\
lllOOl
(
)
;
llllOl\
OlllO
++
)
{
float
ll\
l\
lOl\
l\
OO\
OO
;
Vec3
ll\
llOllOOOl
;
Mat33
llllO\
ll\
O\
O\
l\
O\

;
lOlOOl\
O\
llO
->
llllO\
OOl\
O\
lO
[
llllO\
l\
O\
lllO
]
->
Cal\
cu\
l\
ateM\
as\
s\

(
lllO\
llOOO\
Ol\

,
llllOllOO\
OO
,
llllO\
llO\
OOl
,
llllOllOOl\
O
)
;
lOll\
OOOOllO
+=
llllO\
l\
lOOOO
;
lllO\
ll\
OO\
Ol\
O
+=
llllOllOOO\
l
*
ll\
ll\
OllOOO\
O\

;
}
if
(
lO\
llO\
OOOllO\

>
0.0f
)
lllOl\
l\
OO\
O\
l\
O
/=
lOllOOOOllO
;
fo\
r
(
lll\
lOlO\
ll\
lO
=
0
;
llll\
O\
lOl\
llO
<
lOlO\
OlOllO
->
llllO\
OOlOlO
.
lOOOll\
lOOl
(
)
;
llllO\
lO\
l\
llO
++
)
{
fl\
o\
at
llllOllOOOO
;
Ve\
c\
3
lll\
lOllOOO\
l
;
Mat33
llllOllOO\
l\
O
;
lOlO\
OlOllO
->
llll\
OOOlOlO
[
ll\
llOlO\
lllO\

]
->
CalculateM\
a\
ss\

(
ll\
l\
Ol\
lOOOOl
,
ll\
ll\
OllOO\
OO\

,
llllOllOOOl\

,
lll\
lO\
llOOlO\

)
;
Vec\
3
lllOlOllOOO
=
llllOllO\
O\
Ol\

-
ll\
lOll\
OO\
OlO
;
lll\
l\
OllOOl\
O\

.
M11
(
)
+=
llllOl\
l\
OOOO
*
(
lllO\
lO\
l\
l\
OO\
O
.
y
*
ll\
l\
O\
l\
OllOO\
O\

.
y
+
lll\
OlOl\
lOOO
.
z
*
ll\
l\
O\
lOllOOO
.
z
)
;
llllO\
ll\
OOlO\

.
M22
(
)
+=
llll\
Oll\
OO\
OO\

*
(
lllOlOllO\
O\
O\

.
z
*
lllOlOllOOO
.
z
+
lll\
OlOllOOO
.
x
*
ll\
lOl\
Oll\
OOO
.
x
)
;
llll\
OllOOlO
.
M33\

(
)
+=
llllO\
llOO\
OO\

*
(
lllOl\
OllOOO
.
x
*
lll\
Ol\
OllOOO
.
x
+
lllOl\
Ol\
lOO\
O
.
y
*
lllOlO\
llO\
OO\

.
y
)
;
lll\
lOl\
l\
OO\
lO
.
M12
(
)
=
ll\
l\
lOl\
l\
OO\
lO
.
M21
(
)
-=
llllOllOOOO\

*
lll\
OlOl\
lOOO
.
x
*
lllOlOl\
lO\
OO\

.
y
;
llllOll\
O\
O\
l\
O
.
M2\
3
(
)
=
lll\
lOllO\
OlO
.
M32\

(
)
-=
llllOllO\
OOO
*
ll\
lOlO\
llO\
OO
.
y
*
ll\
lOlOllOO\
O
.
z
;
llllOllOOlO
.
M13
(
)
=
llllOl\
lOO\
lO\

.
M31
(
)
-=
llllOl\
lOOO\
O
*
lllO\
lOl\
lO\
OO
.
z
*
ll\
l\
OlOllOOO
.
x
;
lll\
OllO\
O\
Oll
+=
llllOl\
lOOlO
;
}
}
bo\
ol
Co\
llisi\
onO\
b\
jectCo\
mbo
::
Tes\
tLi\
n\
eFo\
rC\
ollis\
ion
(
co\
n\
st\

Vec3
&
lOO\
l\
OlOlll
,
cons\
t\

Vec3
&
lOOOlOOO\
OO
,
floa\
t
lOO\
lOll\
O\
OO
,
Collisi\
on
&
llOl\
lllOlll
)
const
{
bool
lll\
lOl\
Oll\
Ol
=
fal\
se
;
for
(
int
llllOlO\
lllO
=
0
;
lll\
lO\
lOlllO
<
lOl\
OOlOll\
O\

->
llll\
OOO\
lO\
l\
O\

.
lO\
OOlllOO\
l\

(
)
;
llll\
O\
l\
O\
l\
l\
l\
O
++
)
{
Vec3\

lll\
l\
OllOOl\
l
;
Vec3
llllOllOlO\
O
;
if
(
lO\
lOO\
lOll\
O\

->
lll\
lOOOlOl\
O\

[
llll\
OlO\
lllO
]
->
TestLi\
neForCollision
(
lOOl\
OlOlll
,
lO\
OO\
lOOO\
OO
,
lOO\
lOllO\
O\
O
,
ll\
Ol\
lllOl\
ll
)
)
{
lll\
lOl\
Ol\
lO\
l
=
tru\
e
;
TA\
_\
AS\
SERT\

(
llOllllOl\
ll
.
Ge\
tCo\
l\
l\
isi\
onObjectA\

(
)
)
;
}
}
re\
t\
urn
llllO\
lOl\
l\
O\
l
;
}
CollisionObje\
ctCom\
bo\

*
TAC\
_CAL\
L
CollisionObjectCo\
mbo
::
Cre\
ate\
New\

(
)
{
Co\
ll\
ision\
ObjectCo\
m\
bo\

*
lOl\
Oll\
Ol\
OOl
;
lOOO\
OO\
llOlO\

(
lOlOllO\
l\
OOl
,
CollisionObje\
c\
t\
C\
ombo\

)
;
retur\
n
lOlOll\
OlO\
Ol
;
}
CollisionObj\
ectC\
ombo
::
Col\
lisionO\
bjec\
tCo\
mbo
(
)
:
CollisionO\
b\
jec\
t\

(
TYP\
E_CO\
MBO\

)
{
llllOlOOOlO
.
In\
i\
ti\
al\
is\
e
(
k_\
v3\
Zero
,
k_v3Zer\
o
)
;
lO\
lOO\
lOl\
lO
=
0
;
}
Collisi\
o\
nO\
b\
jectCombo
::
~
Co\
llision\
O\
b\
je\
c\
tCombo
(
)
{
Finalise
(
)
;
}
void\

Co\
l\
l\
is\
ion\
ObjectCombo
::
llllOl\
Ollll\

(
)
{
if\

(
lOlOOlOllO
->
llllO\
OO\
l\
Ol\
O
.
lOOOll\
lO\
Ol
(
)
>
0
)
{
ll\
ll\
OlO\
OOlO
=
lO\
lOOlOllO
->
llllOOOlOlO
[
0
]
->
Ca\
lcul\
ateBoun\
di\
ngBo\
x
(
)
;
for
(
int\

llllO\
lOll\
l\
O\

=
1
;
llllOlO\
lllO
<
lOlOO\
lOllO
->
ll\
l\
l\
OOO\
lOl\
O\

.
lO\
OOlllOO\
l
(
)
;
llllO\
lOlllO
++
)
{
lll\
l\
OlOO\
O\
l\
O
+=
lOlOO\
lOl\
lO\

->
llllOOO\
lOlO
[
llllO\
lOlllO
]
->
CalculateB\
oun\
d\
ingBox
(
)
;
}
llllOlOOOlO
.
v3E\
x\
tent
.
x
+=
llOOllOOOlO
;
llllO\
lOOO\
lO
.
v3E\
xt\
ent
.
y
+=
ll\
OOl\
lOOO\
lO\

;
llllOlO\
OOlO
.
v3Exten\
t
.
z
+=
llOOll\
OO\
OlO
;
}
else\

{
llllO\
l\
OOOlO\

.
v3\
Cent\
er
.
Clear
(
)
;
llllOlO\
OO\
l\
O
.
v3Ext\
en\
t
.
Clear\

(
)
;
}
}
#ifndef DOXYGEN
void
TAC_C\
ALL
ll\
ll\
OllO\
lO\
l
(
llllOllOl\
lO
&
lll\
l\
OllOlll
,
Coll\
i\
sio\
nObj\
ect
&
lllOl\
lOl\
ll\
O
,
const
MF\
r\
ame
&
lOlllOOOOOl
,
cons\
t
MFra\
m\
e\

&
lOlllOOOO\
lO\

,
Collisi\
onOb\
j\
ect
&
ll\
lO\
llOll\
l\
l
,
llllOlll\
OOO
*
llllOlllOOl
,
lOl\
l\
Ol\
lOllO
lllOOOOl\
OOl
,
void
*
lllOllOllO\
O
)
{
if
(
lllOllO\
lllO
.
Ge\
tCo\
ll\
i\
sionOb\
jectT\
y\
pe
(
)
==
Col\
lisionOb\
j\
ect
::
TY\
PE\
_COMBO
)
{
if\

(
lll\
OllOl\
ll\
l
.
Ge\
tC\
o\
llisi\
onO\
bjectType\

(
)
==
Co\
llisio\
nObject\

::
TYPE_\
CO\
MB\
O
)
{
llllOllOlOl\

(
llllOllOl\
ll
,
*
(
Coll\
isi\
onObjectC\
ombo\

*
)
&
ll\
l\
OllOl\
ll\
O\

,
lOl\
llOOOOO\
l\

,
lO\
lllOOOOlO
,
*
(
Coll\
i\
sionObje\
c\
tCombo
*
)
&
lll\
OllOllll\

,
llllOl\
ll\
OO\
l
,
ll\
l\
OOO\
OlOOl
,
lll\
Ol\
lOl\
l\
OO
)
;
}
else\

if
(
lllOllOlll\
l
.
Ge\
tC\
ollisionObj\
ectTy\
pe
(
)
==
Col\
lisionObj\
ect
::
TY\
P\
E_COM\
PLE\
X
)
{
llllOl\
lOl\
Ol
(
llllO\
llOll\
l
,
*
(
Collision\
Ob\
je\
ctC\
om\
b\
o
*
)
&
lllOllOl\
llO\

,
lO\
lll\
OOOO\
Ol
,
lOlll\
OOOOlO
,
*
(
Co\
ll\
i\
sionOb\
jectCom\
p\
lex\

*
)
&
lllOl\
lOllll
,
lll\
O\
OOO\
lO\
Ol
,
lll\
O\
llOl\
lOO
,
0
,
fa\
l\
se\

)
;
}
el\
se
{
lllOOlOOO\
l
(
0
)
;
}
}
else\

{
if
(
lllOll\
Olll\
l
.
Get\
Coll\
is\
ionO\
bj\
e\
ctType
(
)
==
Coll\
i\
sionOb\
j\
ec\
t\

::
TY\
PE_COM\
B\
O\

)
{
llllO\
llO\
lO\
l
(
llllOllOlll\

,
*
(
Co\
l\
l\
isi\
onOb\
je\
ct\
Comb\
o
*
)
&
lll\
OllOll\
ll
,
lO\
ll\
lO\
OO\
OO\
l
.
GetInverse
(
)
,
lOlllOOOOlO
.
Ge\
tIn\
ve\
rse\

(
)
,
*
(
Colli\
s\
i\
on\
Obj\
ec\
t\
C\
omp\
lex\

*
)
&
lll\
O\
llOlll\
O\

,
lll\
OOOOlOOl
,
ll\
lOllO\
l\
lOO
,
0
,
true
)
;
}
els\
e
{
lllOOl\
OOOl
(
0
)
;
}
}
}
void
TAC_\
CAL\
L
llllOllOlOl
(
ll\
l\
lOll\
OllO\

&
llllOllOl\
ll
,
Co\
ll\
isionObjectC\
ombo
&
lllOl\
lOl\
llO
,
co\
n\
st
MFra\
m\
e\

&
lOlllO\
OOOOl\

,
const\

MF\
r\
ame
&
lO\
lllOOOOlO
,
Colli\
s\
ionObjectComb\
o\

&
ll\
l\
O\
llOllll
,
llll\
OlllOOO
*
llllOlll\
O\
Ol
,
lO\
llOll\
Oll\
O\

lllOOO\
O\
lO\
Ol
,
voi\
d
*
lll\
OllOll\
O\
O
)
{
TA_A\
SSERT\

(
ll\
lOl\
lOlllO
.
lOl\
O\
Ol\
OllO\

)
;
TA\
_\
A\
S\
SE\
RT
(
ll\
lOll\
Ollll
.
lOl\
O\
OlO\
ll\
O
)
;
in\
t
llllOll\
lOlO
;
int
lll\
lOl\
llO\
ll
;
bo\
ol
lOllOl\
llOl\
l
=
false
;
co\
nst
flo\
at
ll\
l\
lOlll\
l\
O\
O
=
0.02f
;
const
flo\
at
llllOllll\
Ol
=
0.95f
;
co\
nst\

float
llllOlllllO
=
ll\
llOl\
lllOO
*
ll\
llOll\
ll\
OO
;
if\

(
(
lOlllO\
O\
OOOl
.
v3T\
r\
anslat\
ion
-
lOl\
llOOO\
OlO
.
v3T\
ranslation
)
.
GetMagnitudeSqr\
d
(
)
>
llllOll\
lllO
*
ll\
O\
OllOOOll\

*
llOO\
llO\
O\
Oll\

||
lOl\
llO\
OOOO\
l\

.
m33Ro\
tation
.
v3X
.
Dot
(
lOlllOO\
OOl\
O\

.
m33R\
otation\

.
v3X
)
<
llllO\
lll\
lO\
l\

||
lOlllOOOOOl
.
m33R\
otati\
on
.
v3\
Y\

.
Dot
(
lOlll\
OOOOlO
.
m33Ro\
tati\
on
.
v3Y
)
<
ll\
llOllll\
O\
l\

||
lOlllOOO\
OO\
l
.
m3\
3Rotat\
i\
on
.
v3Z
.
Dot
(
lO\
lllO\
OO\
O\
lO
.
m33\
Ro\
t\
a\
t\
ion
.
v3Z\

)
<
ll\
llOll\
llO\
l
)
{
lOllO\
ll\
lOll
=
tru\
e
;
}
#ifdef llllOllllll
llll\
l\
OO\
OOOO
lllll\
OOO\
OO\
l\

;
if
(
llll\
Oll\
lOOl
)
lll\
l\
l\
OOOO\
Ol
=
llll\
Olll\
OOl
->
lllll\
OOOOlO
.
lOl\
OOOOlO\
O
(
)
;
#endif //
lO\
llOll\
lOO\
O\

ll\
ll\
lO\
OOOll
;
ll\
l\
llOOOO\
ll
.
lOllOllllO\
l
=
0
;
lllllOOO\
Ol\
l
.
lO\
llOlllOOl
=
lllOO\
OO\
lO\
O\
l\

;
lll\
l\
l\
OOO\
Oll
.
lOll\
OlllOlO
=
lllOllOllOO\

;
ll\
l\
llOO\
O\
Ol\
l\

.
lOl\
lOlll\
O\
ll
=
lO\
llOlll\
Ol\
l
;
lllll\
OOOO\
ll
.
lOllOl\
l\
llOO\

=
fa\
l\
se
;
for
(
llllO\
lll\
OlO
=
0
;
llll\
O\
lllOlO
<
lll\
O\
llOlll\
O
.
lOlOOlOll\
O
->
llllOOOl\
O\
lO
.
lO\
OOl\
llO\
O\
l
(
)
;
ll\
llO\
ll\
lOlO
++
)
{
lllll\
OOO\
Oll
.
lOllO\
O\
O\
ll\
ll
=
lllO\
llOll\
lO
.
lO\
l\
OOlOllO
->
llllOOOl\
OlO
[
llllO\
ll\
lOlO
]
;
TA_A\
S\
SER\
T
(
lll\
ll\
OOO\
Oll\

.
lO\
ll\
OOO\
llll
)
;
fo\
r
(
llll\
Olll\
Oll
=
0
;
llllOlllOll
<
lllOllOllll
.
lO\
lOO\
lOl\
l\
O
->
llllOO\
OlOlO
.
lOOOll\
lOO\
l\

(
)
;
ll\
llOlllOll
++
)
{
ll\
lllO\
O\
OO\
ll
.
lOl\
lOO\
lOO\
OO
=
lllOllOll\
ll\

.
lO\
lOOlO\
llO
->
llllOOO\
lO\
lO\

[
llllOll\
l\
O\
ll
]
;
TA_ASSE\
R\
T\

(
llll\
lOOOO\
l\
l
.
lOllO\
Ol\
OOO\
O\

)
;
in\
t\

lllll\
OOO\
lOO
=
(
llll\
lOOO\
Oll
.
lOl\
lO\
O\
Olll\
l
->
GetCo\
llisio\
n\
Ob\
jec\
t\
Type\

(
)
*
ll\
llO\
O\
O\
l\
O\
l\
l
)
+
lllll\
OO\
OOll\

.
lO\
ll\
OOl\
OOOO
->
GetColli\
s\
ionObjectTy\
pe
(
)
;
lll\
OOlOOOl
(
lllllO\
OO\
l\
OO
>=
0
)
;
lll\
OOlOO\
Ol
(
ll\
lllOOOlO\
O\

<
llllOO\
O\
llOO
)
;
if
(
llllO\
OlOOll\

[
lllllOOO\
lOO\

]
.
llllOOO\
llll\

)
{
ll\
l\
l\
lOO\
O\
O\
ll\

.
lOllOllllOl\

=
0
;
if
(
llllOO\
lOOll
[
ll\
lllO\
OOlOO
]
.
lOlOllOOll
&
ll\
ll\
O\
OlOOlO\

)
{
lllllO\
OOOll
.
lOl\
l\
Ollll\
lO
=
lOlllOO\
O\
OOl
;
lllll\
O\
O\
OOll
.
lOll\
Ol\
lllO\
O
=
tru\
e
;
Sw\
ap
(
lll\
ll\
O\
OOOll
.
lO\
l\
lO\
OOlll\
l\

,
lllllOOOO\
ll
.
lOl\
l\
OOl\
O\
OOO
)
;
lll\
lOOl\
OOl\
l\

[
llll\
lO\
OOl\
OO
]
.
llllO\
OOll\
ll
(
lO\
lllO\
OOO\
Ol
.
Ge\
tInv\
ers\
e
(
)
,
lOlllOOO\
OlO
.
Get\
Inverse
(
)
,
&
ll\
lllOOO\
Ol\
l\

)
;
Swa\
p
(
lll\
l\
lO\
OO\
Oll
.
lOl\
lOOOlll\
l\

,
lllll\
OOOOl\
l
.
lOllOO\
lOOO\
O\

)
;
lllllO\
O\
O\
Oll
.
lOllOllll\
OO
=
fal\
se\

;
}
el\
se\

{
TA_ASSERT
(
!
lllllOOO\
Oll
.
lO\
l\
lO\
l\
l\
llO\
O
)
;
ll\
llOOlO\
Oll
[
lll\
llOOOlOO
]
.
llllO\
OOllll
(
lOll\
lO\
OOOOl
,
lOll\
lO\
OOOlO
,
&
lllllOOOOll\

)
;
}
}
}
}
}
void
TAC\
_CALL
llllOl\
lOlOl
(
ll\
llOllOllO
&
lll\
lO\
llOlll
,
Co\
llisi\
onObj\
ectCo\
mbo
&
llll\
l\
OOOlOl
,
const
MFr\
ame
&
lOl\
l\
l\
OOO\
OOl
,
cons\
t
MFrame
&
lOl\
llO\
OO\
O\
lO
,
Coll\
is\
i\
onObjectComplex
&
lll\
llOOOllO
,
lOl\
lOll\
OllO\

ll\
lOOOOlOO\
l
,
voi\
d
*
lll\
OllO\
llOO
,
voi\
d\

*
llOlll\
l\
lll\
O
,
bo\
ol\

lOllOll\
llOO
)
{
TA_ASS\
E\
RT
(
ll\
lllOOOlOl
.
lO\
lO\
Ol\
Oll\
O\

)
;
Col\
lisionObjectCache\
d\
P\
olyDat\
a
&
llO\
ll\
l\
llOOl
=
lll\
lOllOl\
ll\

.
GetPh\
ysic\
s
(
)
.
lll\
l\
lOOO\
lll\

(
)
;
AABB
lO\
OOOO\
Olll
;
bo\
ol
lOllO\
ll\
l\
O\
l\
l\

=
false
;
const
floa\
t
ll\
llOllllOO\

=
0.02f
;
co\
n\
s\
t
fl\
o\
a\
t
llllOllllOl
=
0.95f
;
co\
ns\
t
fl\
oat
llllOlll\
ll\
O
=
llllO\
l\
lllOO
*
llllO\
llllOO
;
if
(
(
lOl\
ll\
OOO\
O\
Ol
.
v3Tra\
ns\
latio\
n\

-
lOl\
l\
l\
OO\
O\
OlO
.
v3Tran\
slation\

)
.
GetM\
agnitudeS\
q\
rd
(
)
>
llllO\
lllllO
*
llO\
OllO\
OOll
*
llOOllOOOl\
l
||
lO\
lllOOO\
OO\
l
.
m33Rotat\
ion\

.
v3\
X
.
Do\
t\

(
lOl\
llOOOO\
l\
O
.
m33\
R\
o\
t\
a\
tion\

.
v3X
)
<
lll\
lOllll\
Ol\

||
lOl\
llOOOO\
O\
l
.
m33Ro\
ta\
t\
io\
n
.
v3Y
.
Dot
(
lO\
lllO\
OOOlO
.
m3\
3R\
otat\
i\
o\
n
.
v3Y
)
<
llllO\
llllOl
||
lOlllOO\
OOOl
.
m33Ro\
t\
ati\
on
.
v3Z\

.
Dot\

(
lOl\
l\
lOO\
O\
Ol\
O
.
m33Ro\
tation
.
v3\
Z
)
<
lll\
lOll\
l\
lO\
l
)
{
lOll\
Olll\
Oll
=
tr\
u\
e
;
lOOOOO\
O\
lll
=
lllllOOOlOl\

.
lll\
lOl\
OOOlO
*
lO\
lllOOOO\
Ol
+
lllllOO\
OlO\
l
.
ll\
llOlOOOlO
*
lO\
l\
llOOO\
OlO
;
}
else\

{
lO\
OOOOO\
lll
=
lll\
l\
lOOOlO\
l
.
llllO\
l\
OOOlO\

*
lOl\
llOO\
OO\
Ol
;
}
lll\
l\
lO\
O\
O\
l\
lO
.
Cac\
hedL\
ocalP\
olygons
(
llOll\
lllOOl
,
lOO\
OOOOll\
l\

,
ll\
Oll\
ll\
l\
ll\
O\

)
;
if
(
ll\
Oll\
l\
llOOl
.
ll\
lO\
lO\
Ol\
Ol\
O
(
)
==
0
)
return\

;
lOl\
lOlll\
OOO
ll\
l\
l\
l\
OOO\
Oll
;
lll\
ll\
OO\
OOll
.
lOll\
Ol\
ll\
lO\
l
=
0
;
lll\
l\
lOOOOll
.
lOllOlllOOl
=
lllOO\
O\
OlOOl
;
lllllOOOOll
.
lOll\
Ol\
llOl\
O
=
ll\
lO\
llOll\
OO
;
ll\
ll\
l\
O\
O\
O\
O\
ll
.
lOllO\
l\
llO\
ll
=
lOllOlll\
Ol\
l\

;
lll\
llOO\
OOll
.
lOllO\
Ol\
O\
OOO
=
&
llOlllll\
OOl
;
llO\
lllllO\
Ol
.
lllO\
lOOllO\
O
(
&
lllll\
OOOl\
lO\

)
;
lll\
ll\
O\
OO\
Oll
.
lOl\
lO\
ll\
l\
lO\
O\

=
lOllO\
l\
lllO\
O
;
if
(
lOllOll\
llO\
O
)
lllllOOO\
Oll
.
lOllOlllllO
=
lO\
lllOOOOOl
.
GetInver\
s\
e
(
)
;
fo\
r
(
int\

lll\
lOlOlllO\

=
0
;
llllO\
l\
Oll\
l\
O
<
lllllOO\
O\
lOl
.
lOlOOl\
Oll\
O
->
llll\
O\
OOlOlO\

.
lO\
O\
O\
lllO\
Ol
(
)
;
ll\
llOlOlllO
++
)
{
llll\
lOOO\
O\
ll
.
lO\
ll\
OO\
Oll\
ll
=
lll\
llOOOlOl\

.
lOl\
OOlO\
l\
l\
O
->
llllO\
OOlOlO\

[
llll\
OlOlllO\

]
;
int
ll\
lllOOOl\
OO
=
ll\
lll\
OOOOll
.
lOllOO\
Ollll
->
Get\
C\
oll\
i\
sio\
n\
Objec\
t\
T\
yp\
e
(
)
;
lll\
OOlOO\
O\
l\

(
lllllO\
OOlOO
>=
0
)
;
lllOOlOOOl
(
lll\
llO\
OOl\
O\
O
<
ll\
ll\
O\
OO\
l\
lOO\

)
;
if
(
llllOOll\
ll\
O\

[
lll\
llOOO\
lOO
]
)
ll\
llOOllll\
O
[
ll\
ll\
l\
O\
O\
Ol\
OO\

]
(
lOlll\
OOOOO\
l
,
lOlllOOOOl\
O
,
&
lllllO\
OOOll
)
;
}
llllOllO\
lll
.
GetPhy\
sics
(
)
.
llll\
lOOOlll\

(
)
.
Cl\
e\
ar\

(
)
;
}
#endif //
}

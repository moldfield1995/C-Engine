//---------------------------------------------------------------------------------
// File Name: zpta018.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#define lOllOllOOlO
#include "DynamicObject.h"
#ifndef TA_RANDFUNC_H
#include "../Common/RandFunc.h"
#endif //
#ifndef TA_PHYSICS_H
#include "Physics.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMBO_H
#include "CollisionObjectCombo.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMPLEX_H
#include "CollisionObjectComplex.h"
#endif //
#ifndef llOOllOOOOl
#include "../Physics/zpta001.h"
#endif //
#ifndef llllOOOOllO
#endif //
#ifndef lOOllOOlOOOl
#include "../Physics/zpta011.h"
#endif //
#ifndef llllOOOOlll
#include "../Physics/zpta010.h"
#endif //
nam\
espace
TA
{
float
lOOlOll\
llllO
=
1.0f
;
floa\
t\

lOOl\
l\
OOO\
OOO\
l
=
0.001f
;
con\
st
fl\
oat
lOO\
llOOlOOlO
=
1.0e-9f
;
const
float
lOOllO\
Ol\
OOll
=
1.0e9f
;
st\
at\
ic
u32
lOOllO\
Ol\
O\
lOO
=
1
;
void\

DynamicObject
::
Initia\
lis\
eFromFile
(
const
Char
*
ll\
lO\
OO\
lOll\

)
{
Co\
llisio\
nObjectC\
om\
bo
*
lO\
O\
ll\
O\
OlOlOl
=
Co\
llis\
ionObjectCo\
m\
bo\

::
Crea\
t\
eNe\
w\

(
)
;
lOOllO\
OlO\
l\
Ol
->
InitialiseFro\
m\
File
(
lllOOOl\
O\
ll
)
;
Initiali\
se
(
lOOl\
lO\
Ol\
OlO\
l
)
;
lOO\
l\
lOOlOlO\
l
->
Re\
lea\
se
(
)
;
}
vo\
id
Dynam\
icOb\
ject
::
Init\
ial\
i\
seA\
sA\
Box\

(
const
AA\
BB\

&
lO\
OOOOOlll
)
{
CollisionObjectCombo\

*
lOOl\
lOOl\
OlO\
l
=
Co\
l\
lisionObj\
ect\
Combo\

::
CreateNew
(
)
;
lO\
O\
llO\
O\
lO\
lO\
l
->
Init\
ial\
is\
eA\
sABox
(
lOOOOOOl\
ll
)
;
In\
i\
tial\
is\
e
(
lO\
OllOOlOlOl
)
;
lOOllOOlOl\
O\
l\

->
Relea\
se
(
)
;
}
void
Dynamic\
Obj\
ect
::
Init\
i\
alis\
eAsA\
nOr\
ie\
n\
ted\
Box
(
const
AA\
BB
&
lOOOOOO\
ll\
l
,
co\
nst
MFr\
a\
m\
e
&
lO\
O\
OOOOOO\
l
)
{
Colli\
sio\
nOb\
j\
ec\
tCom\
bo
*
lOOllO\
OlOlOl
=
Co\
l\
lis\
io\
nOb\
j\
ectC\
ombo\

::
Cr\
eateNe\
w
(
)
;
lO\
OllO\
OlOl\
Ol
->
Initia\
l\
i\
seAsAn\
Or\
ientedB\
ox
(
lOOOOOOlll
,
lOO\
OOOOOOl
)
;
In\
itiali\
se
(
lOOllOOlOlOl\

)
;
lOOllOOlOl\
Ol
->
Relea\
se
(
)
;
}
void
Dy\
namicOb\
ject
::
Initial\
is\
eAs\
ACaps\
ule
(
co\
nst\

Ve\
c3\

&
lOOlOlOl\
ll\

,
const\

Ve\
c\
3\

&
lOO\
lO\
llOOl
,
flo\
a\
t\

llll\
lO\
OO\
Ol
)
{
Collisio\
n\
Ob\
jectC\
o\
mb\
o
*
lOOllOOlOl\
Ol
=
Co\
ll\
isionO\
b\
je\
c\
t\
Co\
mb\
o
::
Create\
New
(
)
;
lOO\
llOO\
lOlOl
->
Initia\
li\
s\
eAsA\
Caps\
ule
(
lO\
O\
l\
O\
lO\
l\
ll
,
lOOlOll\
OOl\

,
lllllO\
O\
O\
O\
l
)
;
Ini\
tialise\

(
lO\
OllO\
O\
lOlOl
)
;
lO\
Ol\
l\
OOlOl\
Ol
->
Release
(
)
;
}
void
Dy\
n\
ami\
cObjec\
t
::
In\
itia\
liseAsASphe\
r\
e
(
const\

Vec\
3
&
v3Center
,
float
ll\
l\
l\
lO\
OOOl
)
{
Col\
lis\
ionObjectC\
omb\
o\

*
lO\
Oll\
OOlO\
lOl\

=
CollisionOb\
jec\
tCombo
::
Crea\
teNew
(
)
;
lO\
O\
ll\
OO\
lOlOl\

->
Init\
i\
al\
iseA\
sASphere
(
v3\
Cente\
r
,
lll\
llOOOOl\

)
;
Initialise
(
lOOllOOlO\
l\
O\
l\

)
;
lO\
O\
ll\
OOlO\
lOl
->
Re\
le\
a\
se
(
)
;
}
vo\
id
Dy\
na\
micOb\
ject\

::
Initialise\
A\
s\
ACylinder
(
con\
st
Ve\
c3\

&
lOO\
lO\
l\
Olll
,
con\
st\

Ve\
c3
&
lO\
O\
l\
Oll\
OO\
l
,
float
llll\
lO\
OO\
Ol\

)
{
Co\
llisionO\
bjectComb\
o\

*
lO\
OllOO\
lOlOl
=
Collisi\
onObj\
ectCombo
::
Cr\
e\
at\
e\
N\
e\
w
(
)
;
lOOl\
lO\
OlOlOl\

->
Initia\
lis\
eA\
sACylind\
er
(
lO\
O\
l\
OlOll\
l\

,
lOO\
l\
OllOOl
,
lllllOO\
OO\
l\

)
;
Ini\
ti\
alise
(
lO\
OllOOlOl\
Ol\

)
;
lOOl\
lO\
OlOlO\
l\

->
Rel\
ease
(
)
;
}
void\

Dyn\
a\
m\
i\
cObje\
ct
::
Initial\
is\
eFrom\
P\
oint\
Li\
st\

(
con\
st
Vec3
*
ll\
llOlO\
lOl\
l
,
in\
t\

lll\
lOlO\
l\
l\
OO
)
{
Co\
llisionO\
bje\
ctCo\
mbo\

*
lOOllOOlO\
lOl
=
Collisio\
nO\
b\
je\
c\
tCo\
mbo\

::
Create\
Ne\
w
(
)
;
lOOllOO\
l\
OlOl
->
Initial\
is\
eFromPoi\
ntLi\
st
(
lll\
l\
OlOlOll
,
llllOlOllOO
)
;
Ini\
t\
ialise
(
lOOllOO\
lOlO\
l
)
;
lO\
Ol\
lOOlO\
l\
Ol
->
Release\

(
)
;
}
vo\
i\
d
DynamicObj\
ect\

::
Ini\
t\
i\
al\
ise\

(
Co\
llisionO\
bj\
ect\
Combo\

*
lOOll\
OOl\
Ol\
O\
l
)
{
TA_ASS\
ERT
(
lO\
Oll\
OOlOl\
Ol\

)
;
Ini\
ti\
a\
lis\
eC\
om\
mon
(
)
;
lOOl\
l\
OOlOllO
=
lOOllO\
OlO\
lOl\

;
lOO\
llOOlOllO\

->
Add\
Ref
(
)
;
SetCol\
li\
si\
onOb\
j\
ectChanged
(
)
;
Cl\
ear
(
)
;
}
voi\
d
Dy\
n\
am\
icObject
::
In\
i\
tial\
ise
(
Col\
li\
sionOb\
je\
ctComple\
x
*
lOOllOOl\
Ol\
ll\

)
{
TA_ASSERT
(
lOOllOO\
lOl\
ll
)
;
Init\
i\
ali\
seComm\
o\
n\

(
)
;
lOOllOOlOll\
O
=
lOO\
llOOlOlll
;
lO\
OllOO\
l\
O\
llO\

->
Ad\
dRef\

(
)
;
Se\
tCo\
l\
li\
sio\
nObje\
ctChanged
(
)
;
lOOllOOll\
OOO
.
Set\
ToId\
entity
(
)
;
lOO\
llO\
O\
llOOl
.
Se\
t\
ToIdentit\
y
(
)
;
lOlOl\
OlOlOO
=
1.0e9f
;
lOOlOl\
ll\
ll\
OO\

=
1.0f
/
lO\
l\
OlO\
lOl\
OO\

;
SetI\
nfini\
teMas\
s
(
true
)
;
Se\
tMovementDisabled
(
true
)
;
lOOll\
OOll\
OlO\

=
1.0e6f
;
lO\
OllO\
OllOll\

=
0.0f
;
Clear
(
)
;
}
void
Dy\
n\
amicO\
bj\
ec\
t
::
InitialiseAsWo\
rldO\
bject\

(
)
{
Initialis\
e\
Comm\
o\
n\

(
)
;
lO\
OllO\
OlO\
llO
=
0
;
SetMo\
vem\
entD\
is\
abled
(
tr\
u\
e\

)
;
lO\
Ol\
lOO\
l\
llOO\

(
true
)
;
SetC\
ollisi\
onDisab\
l\
ed
(
true
)
;
Set\
Inf\
i\
ni\
t\
eMass\

(
true
)
;
lOO\
ll\
OOllO\
OO
.
Set\
ToI\
dentity
(
)
;
lOO\
llOOll\
OOl\

.
Se\
tT\
oIdentity
(
)
;
lOlOlOlO\
lOO\

=
1.0e9f
;
lOOlO\
ll\
ll\
lOO\

=
1.0f
/
lOlO\
l\
OlOlOO
;
lOOl\
lOOllOl\
O\

=
1.0e6f
;
lOOllOOllOll\

=
0.0f
;
Cl\
e\
a\
r
(
)
;
}
void
DynamicObject
::
Fina\
lis\
e
(
)
{
TA\
_A\
SSERT
(
!
Adde\
dToPh\
ys\
ics
(
)
)
;
lO\
lOlOl\
OlOO
=
0.0f
;
lOOlO\
ll\
lll\
OO\

=
0.0f
;
lOO\
ll\
OOllOO\
O
.
Set\
T\
oI\
d\
entity
(
)
;
lO\
O\
llO\
OllOOl
.
Set\
ToIdentit\
y
(
)
;
lO\
OllOOl\
ll\
Ol\

.
Set\
ToI\
de\
ntit\
y\

(
)
;
lOO\
l\
lOO\
llllO
.
Set\
To\
Ide\
ntity
(
)
;
lO\
OllOO\
l\
llll\

=
1.0f
;
lOO\
llOl\
OOOOO\

=
-
1.0f
;
lOOllOl\
OOOOl
=
0.0f
;
lOOl\
l\
OlO\
OO\
lO\

=
1.0f
;
lOO\
llO\
lOOO\
ll\

=
0
;
lllOllOOOO
=
0
;
lOOll\
O\
lOOlO\
O\

=
0
;
lOO\
l\
lOlO\
O\
lOl
.
Cl\
e\
ar\

(
)
;
lOO\
l\
OlllOlO\
l
.
Clea\
r
(
)
;
lOO\
llOlOOll\
O
.
Cl\
e\
a\
r
(
)
;
lOOllO\
lO\
Olll
.
Cle\
ar
(
)
;
lOOl\
lOlO\
lOOO
.
Clear
(
)
;
lO\
O\
lOllllOll
.
Cle\
ar
(
)
;
lOO\
lOl\
l\
ll\
lOl
.
Cle\
ar\

(
)
;
lO\
O\
l\
lOl\
OlOO\
l
.
Clear
(
)
;
lOOl\
lOlOlO\
lO
.
Clear\

(
)
;
lOOll\
OlO\
lOll\

=
0
;
lOO\
llOlO\
llO\
O
=
0
;
lOOl\
lO\
l\
O\
ll\
Ol
.
Initialise
(
k_\
v3Zero
,
k_v3Zero
)
;
lO\
OllOlOlllO\

=
-
1
;
lOOllOlOlll\
l
=
0
;
lO\
OllOl\
lO\
OO\
O\

=
0
;
if
(
lOOl\
lOOlOllO
)
{
lOOllOO\
l\
Oll\
O
->
Release
(
)
;
lOOllO\
OlO\
llO\

=
0
;
}
lOOl\
lOl\
lOOOl
=
0
;
lOO\
llOl\
lOOlO
=
0
;
lOOllOllOOl\
l\

=
0
;
TA_ASS\
ERT
(
lOOllOl\
lOlOO\

==
0
)
;
TA_\
ASSERT\

(
lOOllOllOlO\
l\

==
0
)
;
lOO\
ll\
OllOl\
OO
=
0
;
lOO\
l\
l\
O\
ll\
OlOl
=
0
;
lOOllO\
ll\
Oll\
O
=
0
;
lO\
Ol\
lOl\
lO\
lll\

=
-
1
;
Clea\
r\
L\
i\
neI\
nt\
ersectio\
n\
s
(
)
;
lOO\
l\
lOlll\
OOO\

.
Fin\
al\
i\
s\
e\

(
)
;
Rem\
o\
veAl\
l\
Joints
(
)
;
lO\
Oll\
Oll\
lO\
O\
l\

.
Finalis\
e
(
)
;
lOO\
l\
l\
OlllOlO
.
Fina\
li\
s\
e\

(
)
;
lO\
OllOlllOll
(
)
;
TA\
_\
ASSE\
R\
T
(
lOOllOll\
llOO\

==
0
)
;
TA_ASSER\
T
(
lOOll\
OllllOl
==
0
)
;
}
void\

Dyn\
ami\
c\
Obj\
ect
::
Set\
Fra\
m\
e
(
co\
nst\

MFrame\

&
lOllOllll\
lO
)
{
lO\
Oll\
O\
l\
OOlll\

=
lOllOlllll\
O
;
lOO\
lOlllOlOl\

=
lOOl\
lOlOO\
lOl
*
lO\
Ol\
lOlOO\
lll
;
lO\
OllOl\
OOllO
=
lOOl\
O\
lllO\
lOl
;
lOOll\
Ol\
Ol\
OOO
=
lO\
llOll\
l\
llO\

;
lOO\
l\
lO\
l\
lll\
lO
=
lOllOlll\
llO
;
lOOllOll\
l\
lll\

=
lOl\
l\
Ol\
llllO
;
lOOlllOOOOOO
=
lOllO\
l\
llllO
;
UpdateWor\
ld\
SpaceI\
ner\
tialTensor
(
)
;
Ca\
lcu\
la\
te\
W\
o\
rld\
A\
ABB
(
)
;
lO\
Ol\
l\
lOO\
OOOl\

(
)
;
if
(
AddedTo\
Ph\
ysic\
s
(
)
)
{
TA_\
ASSERT
(
lOOllO\
lll\
lOO\

)
;
lOOllOl\
lllO\
O\

->
Get\
Physi\
cs
(
)
.
lO\
Ol\
llO\
OO\
OlO\

(
thi\
s\

)
;
}
{
for\

(
Joint\
Iterator
lO\
l\
OO\
lOOlO
=
lO\
OllOlllOOl
.
lOlOOOO\
l\
OO
(
)
;
!
lOlOO\
lOOl\
O
.
At\
En\
d\

(
)
;
++
lOl\
OOlO\
Ol\
O
)
{
Phy\
sicsJ\
oi\
nt
&
lOOlllOOOOll
=
*
lOl\
OO\
lOO\
l\
O\

;
lOO\
lll\
OOOOl\
l
.
lOOll\
l\
O\
OOlOO
(
Eu\
l\
erA\
ngles\

(
0.0f
,
0.0f
,
0.0f
)
)
;
}
}
{
for
(
List
<
Phy\
s\
icsJ\
oin\
t\

*
>
::
It\
erator
lOlO\
OlOO\
lO
=
lOO\
ll\
Ol\
l\
lO\
lO\

.
lO\
lOOO\
OlOO
(
)
;
!
lO\
l\
OOl\
OOlO
.
AtEnd\

(
)
;
++
lOlOOlOOlO
)
{
Ph\
ysicsJo\
int
*
lOl\
llOO\
lOlO
=
*
lOl\
O\
O\
l\
OO\
lO
;
lO\
lll\
O\
OlOlO
->
lOOll\
lOOOlOO
(
Eule\
rAng\
les
(
0.0f
,
0.0f
,
0.0f
)
)
;
}
}
}
void\

Dyn\
am\
icOb\
ject\

::
SetPo\
s\
ition
(
const
Ve\
c3
&
lOOOOlllll\

)
{
SetFrame\

(
MFrame
(
lO\
OOOlllll
,
lOO\
llOlOOl\
l\
l
.
m33Rotation
)
)
;
}
void
Dy\
na\
m\
icObje\
ct
::
Set\
Center\
O\
ff\
set\

(
co\
nst
Vec3
&
lOOll\
l\
O\
OOl\
Ol
)
{
lOOllOlOOlO\
l
=
lOOlllOOOl\
O\
l
;
lOOlOlll\
OlOl
=
lOOllOlOOlOl\

*
lOOllOl\
OOll\
l
;
lOOllOlO\
OllO
=
lOOllOlO\
O\
lOl\

*
lOOll\
OlOlOO\
O
;
}
voi\
d
Dyna\
mic\
Ob\
j\
e\
c\
t\

::
Se\
tM\
ass
(
flo\
a\
t\

lOl\
l\
OOOOll\
O
)
{
lOOO\
lllO\
lO
(
lOl\
lOOOOllO
>=
lOOl\
lOOlOOlO
,
"Mass is less than 1.0e-9f, automatically increasing to 1.0e-9f.")
;
lOO\
OlllO\
lO
(
lO\
l\
lO\
OOOllO
<=
lOOllO\
Ol\
O\
Ol\
l
,
"Mass is greater than 1.0e9f, automatically decreasing to 1.0e9f.")
;
if\

(
lOllOOO\
OllO
<
lOO\
llOOlOO\
lO
)
lOl\
lOOOOllO
=
lOO\
llOO\
l\
OOl\
O\

;
if
(
lOllO\
OOOl\
lO
>
lO\
Oll\
OOlOOll
)
lOll\
OOOOllO
=
lOOl\
l\
O\
OlOO\
ll
;
flo\
at\

lO\
O\
lll\
OOOl\
l\
O
=
lOllOOO\
O\
l\
l\
O
/
lOlOlOl\
Ol\
OO
;
lO\
lO\
lOl\
OlO\
O
=
lOll\
OO\
OO\
ll\
O
;
lOOlOl\
ll\
llOO
=
1.0f
/
lO\
lOl\
OlOlOO
;
lO\
O\
llO\
OllO\
OO
*=
lO\
OlllOO\
O\
l\
l\
O
;
lO\
O\
ll\
OO\
llO\
Ol
=
lOO\
l\
lOOl\
lOOO
.
Ge\
tInve\
rse\

(
)
;
Update\
W\
orld\
Spa\
c\
eInertia\
lTens\
or
(
)
;
}
void\

Dynami\
cOb\
jec\
t
::
SetInertiaF\
ro\
m\
B\
ox\

(
const
AA\
BB
&
lOOOOO\
O\
lll
)
{
lOO\
llOOllO\
OO
.
SetT\
oIdentity
(
)
;
float\

lO\
l\
O\
OOl\
OOl\
l
=
lO\
OOO\
O\
O\
ll\
l\

.
v3E\
xten\
t
.
x
*
2.0f
;
flo\
at
lOl\
OO\
OlOlO\
l
=
lOOOOO\
Olll\

.
v3E\
xtent
.
y
*
2.0f
;
float
lOlOOOlOl\
lO
=
lO\
OOOO\
Oll\
l\

.
v3E\
xten\
t
.
z
*
2.0f
;
lOO\
l\
l\
OOl\
lOOO
.
M11
(
)
=
lOlOlO\
l\
OlOO
/
12.0f
*
(
lOlOOOlO\
lOl\

*
lOl\
OOOl\
Ol\
Ol
+
lOlOOOl\
O\
l\
lO
*
lOlOOOlOl\
l\
O\

)
;
lOOll\
OOl\
l\
OOO\

.
M22\

(
)
=
lOlOl\
O\
l\
OlOO
/
12.0f
*
(
lOlOOO\
lOOll
*
lOl\
OOO\
lOO\
ll
+
lOlOOOlOl\
lO
*
lO\
lO\
OOlOll\
O
)
;
lOOllOOllOOO
.
M33
(
)
=
lOlOlOlO\
lOO\

/
12.0f
*
(
lOl\
OOOlOOll
*
lOlOOOlOO\
ll\

+
lOlOOOl\
OlOl
*
lO\
l\
OOOlOlOl
)
;
lOOl\
lOO\
llOOl\

=
lOOll\
OOl\
lOOO
.
GetInver\
se
(
)
;
lOOll\
OlOOlO\
l
=
lOO\
O\
O\
O\
Olll\

.
v3Cente\
r
;
UpdateWor\
ldS\
paceIne\
rtialT\
en\
sor
(
)
;
}
void
Dyna\
mi\
cOb\
je\
ct\

::
Se\
tIne\
r\
tiaFrom\
Box\

(
float
lO\
lO\
OOl\
OOll
,
floa\
t
lOlO\
OOl\
OlOl
,
floa\
t
lO\
lO\
OOlO\
l\
l\
O\

)
{
lOOllO\
O\
llOOO
.
SetTo\
Identit\
y
(
)
;
lO\
OllOO\
llOO\
O\

.
M11
(
)
=
lO\
l\
Ol\
OlOlOO
/
12.0f
*
(
lOlOOOl\
Ol\
Ol
*
lO\
l\
OOOlOlOl\

+
lOlOOOl\
Oll\
O
*
lOlO\
OO\
lOllO\

)
;
lOOllOO\
l\
l\
OOO\

.
M22\

(
)
=
lOlOlOlO\
lO\
O
/
12.0f
*
(
lOlOOOlOO\
ll
*
lOl\
OOOlOOll
+
lOl\
OOO\
lO\
llO
*
lO\
lOOOlOllO
)
;
lOOll\
OO\
l\
l\
OOO
.
M33
(
)
=
lOl\
Ol\
OlOlOO
/
12.0f
*
(
lO\
lOOOlOOll
*
lOlO\
OOlOO\
ll
+
lOlOO\
Ol\
OlOl
*
lOl\
OO\
OlOlOl
)
;
lOOllO\
O\
llOOl
=
lOO\
llOO\
llOOO\

.
Get\
Inverse
(
)
;
UpdateW\
orldSp\
ace\
Iner\
tialTenso\
r
(
)
;
}
voi\
d
Dyna\
micObject
::
SetRot\
a\
tionDisable\
d\

(
bool
lllOl\
lO\
Ol\
O
)
{
cons\
t
float
lOO\
ll\
lOOO\
lll
=
10000.0f
;
if
(
ll\
lO\
ll\
O\
OlO\

)
{
if
(
lllOllOOOO
&
lO\
Ol\
l\
lO\
OlOO\
O
)
re\
tur\
n
;
lll\
Ol\
lOOOO
|=
lOOlllOOlOOO
;
lOOl\
lOO\
llOOO
*=
lOO\
l\
l\
lOO\
Oll\
l\

;
lOOllOOllOOl
=
lOOllOOllO\
OO
.
GetInv\
e\
rse
(
)
;
lOOlOl\
llllOl
.
Clea\
r
(
)
;
}
else
{
if
(
!
(
ll\
l\
Ol\
lOO\
O\
O\

&
lOOlllOOlOOO
)
)
return\

;
lllOl\
lOOOO\

&=
~
lOOl\
llOOlOOO\

;
lOOllO\
OllOOO
/=
lO\
O\
lll\
OO\
Ol\
ll
;
lOOl\
l\
O\
Ol\
lOO\
l
=
lOOll\
OOl\
lOOO
.
GetIn\
ve\
rse
(
)
;
}
Upd\
at\
e\
Wo\
rldSpac\
e\
Iner\
t\
i\
a\
lTensor\

(
)
;
}
void
Dyn\
amic\
Objec\
t
::
Se\
tMo\
vemen\
tDi\
s\
abled
(
boo\
l
lllO\
llOOlO
)
{
if
(
ll\
lOllO\
Ol\
O\

)
{
if
(
ll\
l\
OllOOO\
O\

&
lOOll\
l\
OOlOOl
)
ret\
u\
rn\

;
lllOllOOOO
|=
lOOl\
llOOlOOl
;
lOO\
lOlllllOl\

.
Cle\
ar
(
)
;
lOOlOllllO\
ll
.
Clear
(
)
;
SetT\
oResti\
ng
(
)
;
lOOlllO\
O\
OOO\
l
(
)
;
}
els\
e\

{
if
(
!
(
lllO\
llOOOO
&
lO\
Oll\
l\
OOlOOl
)
)
ret\
u\
r\
n\

;
lll\
OllO\
OO\
O
&=
~
lOOll\
lOOlOOl
;
lOOlll\
O\
OOOO\
l
(
)
;
lOOl\
l\
lOOlOlO
(
false\

)
;
}
}
void
Dyna\
mi\
c\
O\
bje\
ct
::
Se\
tInfini\
t\
eM\
ass
(
bool
lllOllO\
O\
lO\

)
{
if
(
lllOl\
l\
OO\
lO
)
{
if
(
(
lllOl\
lO\
OO\
O
&
lOOl\
llOO\
lOll
)
==
0
)
{
ll\
lO\
l\
l\
OOO\
O\

|=
lOOlllOOlOl\
l\

;
lOO\
lll\
OOOOOl
(
)
;
}
}
else
{
if
(
(
ll\
lO\
llOOOO
&
lOOlllOOlOll
)
)
{
lllO\
llOOO\
O\

&=
~
lO\
Ol\
llO\
O\
lOll
;
lOOlll\
OO\
OO\
Ol
(
)
;
lOOll\
lO\
OlOlO\

(
fal\
se
)
;
}
}
}
Physic\
s\

*
Dynamic\
Object
::
GetPhys\
ics
(
)
{
if
(
!
lOOl\
l\
O\
l\
lllOO
)
re\
t\
urn
0
;
else\

retu\
rn
&
lOOl\
lOlll\
lO\
O
->
GetPh\
ys\
ic\
s
(
)
;
}
void
Dyn\
amicObject
::
Set\
ToMo\
ving\

(
int
lOOlllO\
OllOO
)
{
if
(
MovementDisab\
led
(
)
)
return
;
if
(
!
Ad\
de\
dToP\
hysi\
cs\

(
)
)
ret\
urn\

;
TA_AS\
SER\
T
(
lO\
O\
llOllllOO
)
;
if
(
!
IsI\
nMov\
ingList\

(
)
)
lO\
Ol\
lOllllO\
O
->
GetPhysics
(
)
.
lOO\
l\
llOO\
llOl\

(
this
,
lOOl\
llOOllOO\

)
;
if\

(
IsInMo\
ving\
List
(
)
)
lOOlllOOlllO
(
)
;
}
void
Dyn\
am\
icOb\
ject
::
SetTo\
Res\
ti\
ng
(
)
{
if
(
!
Add\
e\
dToPhysics
(
)
)
re\
t\
urn
;
TA_ASSERT
(
lOOllOllllOO
)
;
lO\
OllOll\
ll\
O\
O
->
GetP\
h\
ys\
ics
(
)
.
SetDyn\
a\
m\
icO\
bjectA\
t\
R\
e\
s\
t
(
th\
is
)
;
}
void
TA
::
Dy\
nam\
icObjec\
t
::
Se\
tVe\
l\
ocitiesToMoveToFr\
ame
(
const\

MF\
ram\
e
&
lOOOOOOO\
Ol\

,
fl\
oa\
t\

lO\
Oll\
lOOllll
)
{
if
(
lOOlllO\
Ollll\

>
0.0f
)
{
Se\
tNextFra\
me
(
lOOOO\
OO\
O\
Ol
)
;
Set\
Li\
ne\
ar\
V\
e\
locity\

(
(
Ge\
tNex\
t\
Ce\
n\
ter\
OfMass
(
)
-
GetC\
e\
nte\
rOfM\
a\
ss\

(
)
)
/
lOOll\
lOOll\
ll
)
;
Mat\
33
lOOll\
lOlO\
OOO
=
GetFram\
e
(
)
.
m33R\
o\
t\
a\
ti\
o\
n
.
Ge\
t\
Trans\
pos\
eAsInver\
se
(
)
*
Ge\
tNe\
xt\
Frame
(
)
.
m33Rot\
ation
;
Ve\
c3
lOOO\
OOl\
l\
lll\

;
float
lOOOO\
lOOOOO
;
lO\
OlllOlOOOO\

.
GetRota\
t\
ionAxis\
A\
nd\
Magn\
i\
tud\
e
(
lOOOOOlllll
,
lOOO\
OlOOOOO\

)
;
SetAng\
ul\
arVe\
l\
ocity
(
lOOOOO\
ll\
lll
*
lO\
OO\
O\
lOOOOO\

/
lOOlll\
OOllll
)
;
}
}
Vec3
Dynam\
ic\
O\
bject
::
GetVelo\
c\
ityA\
tWorl\
d\
Posi\
tio\
n
(
con\
st\

Vec3
&
lOOOOl\
lll\
l\

)
co\
nst
{
re\
tur\
n
lO\
OlO\
ll\
llOll
+
lO\
OlOllll\
l\
Ol
.
Cro\
s\
s
(
lOOOOlll\
ll
-
lO\
Ol\
Oll\
lOlOl
)
;
}
void
Dynami\
c\
O\
bj\
ec\
t\

::
ApplyImpu\
l\
s\
e
(
const\

Ve\
c\
3
&
lO\
Oll\
l\
O\
l\
OOOl
,
cons\
t
Vec3
&
lOOlllO\
lOOl\
O
)
{
if
(
!
lO\
O\
l\
l\
lO\
lOOl\
l
(
)
)
ret\
u\
r\
n
;
lOOlO\
ll\
ll\
Ol\
l
+=
lOO\
lllO\
lOOOl
*
lOOl\
Oll\
l\
l\
l\
OO
;
lOOlOlllllOl
+=
(
lO\
O\
lllOlO\
O\
Ol
.
Cr\
o\
ss
(
lOO\
lOlll\
OlOl
-
lOOl\
llOl\
OOlO
)
*
lO\
OllOOllllO
)
*
lO\
OlOll\
lll\
lO
;
}
void
Dyna\
micO\
bj\
ect
::
Ac\
cumulateGrav\
ity\

(
)
{
if
(
lOOllO\
lll\
lOO
)
lOOll\
lO\
lO\
lOO
+=
lOO\
l\
lOlll\
l\
O\
O
->
GetPhysics
(
)
.
Ge\
tGravit\
y\

(
)
*
(
lOlO\
lOlO\
lOO\

*
lO\
OlllOl\
OlOl\

)
;
}
vo\
i\
d
Dynam\
ic\
Object
::
Acc\
umu\
l\
ateF\
o\
rce\
AndTorq\
u\
e
(
cons\
t
Ve\
c3\

&
lO\
OlllOlOll\
O\

,
const
Vec\
3
&
lO\
OlllOlOOl\
O
)
{
lO\
Olll\
OlOl\
OO
+=
lOOlllOlO\
ll\
O
;
lOOl\
llO\
lOl\
ll\

+=
lOOlllOl\
O\
llO
.
Cro\
ss
(
lOOlOl\
llOl\
Ol
-
lO\
Ol\
l\
lOlOOl\
O
)
;
}
void
DynamicO\
b\
jec\
t
::
AccumulateL\
ine\
ar\
Force\

(
con\
s\
t
Vec3\

&
lOOl\
l\
lOlOllO\

)
{
lOOl\
l\
l\
O\
lOl\
OO
+=
lO\
OlllOlOllO
;
}
void
Dynami\
cObj\
ect
::
Ap\
p\
lyForceAndTorqueToVeloci\
tie\
s\

(
float
lOOlllOOllll\

)
{
if
(
!
IsIn\
Mov\
in\
g\
List\

(
)
)
retu\
r\
n
;
lO\
O\
lOllllOll
+=
lOOlllOl\
O\
l\
O\
O\

*
(
lO\
OlOl\
llllOO
*
lOOlllOOlll\
l\

)
;
lOOlOll\
lllOl
+=
(
lO\
O\
l\
llO\
lOlll
*
lO\
OllOOlll\
lO
)
*
lOOlllO\
Ollll
;
}
vo\
id
Dy\
n\
amic\
O\
bject
::
Cl\
e\
a\
r\
For\
ceA\
ndTorque
(
)
{
lOOlllOlOlOO
.
Clear\

(
)
;
lOOlllOlOll\
l
.
Cle\
ar\

(
)
;
}
void
DynamicObj\
ect
::
Clear
(
)
{
lOOlO\
lllOlOl
.
Clea\
r\

(
)
;
lOOllOlOOllO\

.
Cle\
ar
(
)
;
lOO\
llO\
lOO\
lll\

.
Clea\
r
(
)
;
lOOll\
O\
lO\
lOOO\

.
Clea\
r\

(
)
;
lOOllO\
ll\
lllO
.
Clear
(
)
;
lOOllOl\
ll\
lll\

.
Clear\

(
)
;
lOOl\
llOOOOOO
.
Cl\
ear
(
)
;
lO\
OlO\
l\
l\
llOll\

.
Clear
(
)
;
lO\
Ol\
Olllll\
Ol\

.
Cl\
ear
(
)
;
lOOll\
lOlOlOO
.
Cl\
ear
(
)
;
lOO\
lll\
OlOlll
.
Cl\
ear\

(
)
;
lOOl\
l\
lOl\
lO\
OO
.
Cl\
ear
(
)
;
lOO\
ll\
l\
Ol\
lO\
Ol
.
Clear
(
)
;
Upd\
a\
t\
eW\
orld\
Spa\
c\
eIne\
rt\
i\
alTensor
(
)
;
}
vo\
id
Dy\
namic\
Obj\
ect\

::
Upd\
ate\
Worl\
dSp\
aceI\
nertialT\
enso\
r
(
)
{
lOO\
l\
l\
OOlllO\
l
=
lOOl\
lO\
lOOl\
ll
.
m33\
R\
ota\
tion
.
Ge\
tTransposeAsInverse
(
)
*
lOOllO\
Oll\
OOO
*
lOOllO\
l\
OOlll
.
m3\
3Rotation\

;
lOOllO\
O\
l\
lll\
O\

=
lOOl\
l\
O\
OlllO\
l
.
Ge\
tI\
n\
v\
ers\
e
(
)
;
}
vo\
id\

Dynam\
icOb\
j\
ect
::
Up\
dat\
e
(
fl\
oat\

lOO\
lllO\
Ollll\

)
{
lO\
OOOOOl\
l\
O\

(
lOOl\
lOll\
l\
lOO
,
"DynamicObject::Update: Error, not added to physics")
;
if\

(
Ge\
tFin\
dVe\
locityFromNextFra\
me\

(
)
)
{
TA_ASSERT\

(
lO\
Ol\
l\
lOOlll\
l
>
0.0f
)
;
lO\
OlOllllOll
=
(
GetNextCenterOfMass
(
)
-
Get\
Cen\
te\
rOfMass
(
)
)
/
lO\
OlllO\
Ollll
;
Mat33
lO\
Ol\
llO\
lOOOO
=
lOOllOlOOlll
.
m33\
R\
otat\
ion
.
GetT\
r\
anspose\
As\
Inverse
(
)
*
lOO\
ll\
O\
l\
Ol\
OOO
.
m33Ro\
t\
atio\
n\

;
Vec3
lOOOOOlll\
ll
;
fl\
o\
at
lOOOOlOOOOO
;
lOOlllO\
lOOOO
.
GetRo\
tat\
io\
n\
A\
xi\
sAnd\
Magnitu\
de\

(
lOOOOO\
lllll
,
lOO\
OO\
l\
OOO\
OO
)
;
lOOlOlllll\
Ol
=
(
lOOOO\
Olllll
*
(
lOO\
O\
OlOOOOO
/
lOO\
lllO\
Ol\
lll
)
)
;
}
else
{
TA\
_A\
SS\
ERT\

(
lOOllOllllOO
)
;
lOOlOllllOll
+=
lOOll\
Oll\
l\
lOO\

->
GetPh\
ysic\
s
(
)
.
GetGravit\
y
(
)
*
(
lO\
OlllO\
lOlOl
*
lO\
O\
l\
ll\
OO\
llll
)
;
Apply\
VelocityToNe\
xtFrame
(
lOOlllOOll\
ll
)
;
}
}
void
Dynam\
icO\
bj\
ec\
t
::
Upd\
ateGraphics\

(
float
lOOlllOOlll\
l
,
float
lOOl\
llO\
l\
lOl\
O\

)
{
lOOlll\
O\
OOOO\
O\

=
lOOll\
O\
lO\
O\
l\
ll
;
}
static
Vec3\

lOO\
lll\
Oll\
O\
l\
l
(
cons\
t\

Ve\
c3
&
llllO\
OOOll
,
const\

Ve\
c3
&
ll\
l\
lO\
OOlOO
,
co\
n\
st
Ve\
c3\

&
llll\
OOOlOl
,
const
Vec3\

&
ll\
llOOOl\
lO
,
fl\
oat
lllOlll\
llO\

)
{
ll\
lOl\
llllO
+=
1.0f
;
Vec\
3\

lll\
lOO\
lOOO
=
llllOOOOll
;
Vec3\

lll\
l\
lll\
ll\

=
llllOO\
Oll\
O
+
llllOOOOll
-
lll\
l\
OOO\
lO\
O
;
Vec3
lOO\
O\
OOO\
OOO\

=
ll\
llOOOlO\
O
-
lll\
lO\
OOOll
-
llllll\
l\
l\
l
;
Vec\
3
ll\
llO\
Ol\
O\
O\
l
=
llllOOlO\
OO
+
lO\
O\
OOO\
OO\
O\
O
*
lllOlll\
llO
+
llllll\
lll
*
(
lll\
Ol\
llllO
*
ll\
lOlll\
llO
)
;
ret\
u\
rn
lll\
lOOlOOl
;
}
void
Dy\
namicOb\
ject\

::
Extr\
apol\
ate\

(
const
MFra\
me
&
lOOl\
l\
lO\
l\
llOO
,
const
MFr\
a\
me
&
lOOl\
llOll\
l\
Ol\

,
const
Vec3
&
lOO\
l\
ll\
Ol\
lll\
O
,
const
Vec3
&
lOOlllOlllll\

,
fl\
oat
lOO\
lllO\
Ollll
,
fl\
o\
a\
t
lOO\
ll\
ll\
OO\
OOO
)
{
Vec3
lOOll\
llO\
OOOl\

=
lOO\
ll\
l\
OllOll
(
lO\
Oll\
Ol\
OO\
l\
Ol
*
lOOlllOlll\
OO
,
lOOllO\
l\
OOlOl\

*
lO\
OlllOll\
lOl\

,
lOOlll\
Olll\
l\
l
*
lOOlllO\
O\
l\
lll
,
(
lOOll\
lOlllll\

+
(
lOOlllO\
lllll
-
lOOlllOllll\
O
)
)
*
lO\
OlllOOllll
,
lOOl\
lllOOOOO
/
lOOlllOOllll
)
;
Vec3
lOO\
llllOO\
OlO
=
(
lOOllll\
OOOOl
-
Get\
CenterOfM\
ass
(
)
)
/
lOOlll\
OOllll
;
fl\
oa\
t
lOOllllOOOll
=
lOOlll\
lO\
O\
OlO
.
Get\
Ma\
gnit\
u\
de
(
)
;
float
lOOllllOOl\
OO
=
lOOll\
l\
Ollll\
l
.
Get\
M\
ag\
nitu\
de\

(
)
+
5.0f
;
if\

(
lO\
Oll\
ll\
OOO\
ll
>
lOO\
l\
lllOOlO\
O
+
5.0f
/
lOOl\
llOOl\
lll\

)
{
SetFrame
(
MFrame
(
lO\
Ol\
l\
l\
lOO\
OOl\

-
lO\
Oll\
OlO\
OlOl
*
lOOl\
ll\
Ol\
llOl
.
m3\
3R\
otation
,
lOOlllOl\
llO\
l
.
m3\
3Ro\
t\
atio\
n
)
)
;
SetL\
inea\
rV\
elocity
(
lO\
Ol\
llOll\
lll
)
;
SetAng\
ula\
rVe\
locity
(
k_\
v\
3\
Ze\
ro\

)
;
}
else\

{
Mat\
33
lOOlllOlOOO\
O
=
lOO\
lllOl\
llOO
.
m33Ro\
ta\
tion\

.
GetTrans\
po\
seAs\
In\
ve\
r\
se
(
)
*
lOO\
ll\
lOlllOl
.
m33Rotation
;
Vec3\

lOOOOOllll\
l
;
floa\
t
lOOOOlO\
O\
OOO\

;
lOOl\
l\
l\
O\
lO\
OOO
.
GetRot\
atio\
n\
AxisAn\
dMagnitude
(
lOOOO\
Olllll\

,
lOO\
OO\
lOOOOO\

)
;
flo\
at
lO\
Oll\
llO\
OlO\
l
=
lO\
OOOl\
OOOOO
;
lOOOOl\
OOO\
OO
*=
(
lO\
OllllOOOOO
/
lOO\
ll\
l\
OOl\
ll\
l
+
1.0f
)
;
lOOlllOlOOOO\

.
Init\
ial\
ise
(
lO\
OOOO\
lllll
,
lOO\
OOlOOOOO
)
;
Mat3\
3
lOOl\
ll\
lOOllO\

=
lOOl\
llOlllOO\

.
m3\
3Rotation
*
lOO\
ll\
lOlO\
O\
OO
;
lOOlllOlOOO\
O
=
Ge\
tFr\
ame
(
)
.
m3\
3\
Ro\
t\
a\
ti\
on
.
GetTransp\
oseA\
sInverse
(
)
*
lO\
Ol\
lllOOllO\

;
lOOlllOlO\
OOO
.
Get\
Rotati\
onA\
xis\
AndM\
agnitu\
d\
e
(
lO\
OOOOll\
lll
,
lOOO\
OlOOO\
OO
)
;
const
float
lOOll\
llO\
Olll
=
1.0f
;
if
(
Fa\
bs
(
lOO\
OOlO\
OOOO\

)
>
Fabs
(
lOO\
l\
lll\
OOlOl
)
+
lOOl\
lllO\
Olll
)
lOOOOlOO\
OOO
=
Sign\

(
lO\
O\
OO\
l\
O\
OOOO
)
*
(
Fab\
s
(
lO\
OllllOOlOl
)
+
lOOl\
lll\
OO\
ll\
l
)
;
Set\
L\
inearV\
elocity
(
lOOllllOOO\
lO
)
;
SetAn\
gul\
arVeloci\
ty
(
lOOOOOlll\
ll
*
lOOOOlOOOOO
/
lOO\
lll\
O\
Ollll\

)
;
ApplyVel\
o\
city\
T\
oNe\
xtFr\
am\
e
(
lO\
OlllOOlll\
l
)
;
}
}
void\

Dynami\
cO\
bj\
ect\

::
Ap\
ply\
Ve\
lo\
c\
i\
tyT\
oN\
ext\
Frame
(
float\

lOOlllO\
Ol\
lll
)
{
if
(
Get\
Fi\
nd\
Vel\
oci\
ty\
F\
romNextFra\
me
(
)
)
return
;
lOO\
llOlO\
lOO\
O
=
lO\
O\
ll\
OlO\
O\
l\
ll
;
co\
n\
st
float
lOO\
ll\
l\
l\
OlOOO\

=
TA_MA\
X\
_AN\
GU\
L\
AR\
_VELO\
CITY
;
if
(
lO\
O\
lO\
llll\
l\
O\
l
.
GetMagni\
t\
ude\
Sq\
rd
(
)
>
lOOlll\
l\
OlOOO\

*
lOOllllO\
lOO\
O\

)
{
lOOl\
O\
l\
ll\
llO\
l
=
lO\
Ol\
Ol\
llll\
O\
l
.
GetNormal
(
)
*
lOOllllO\
lOOO\

;
}
const
floa\
t
lOO\
lll\
lO\
l\
OOl
=
TA\
_M\
AX_LINEAR_\
VEL\
O\
CITY
;
if
(
lO\
OlO\
llllO\
l\
l
.
Ge\
tMag\
nit\
udeSqrd\

(
)
>
lOOllllOl\
O\
O\
l\

*
lOOllllOlOOl
)
{
lOO\
lOll\
l\
l\
Oll
=
lOOlOllllO\
ll
.
Get\
Normal
(
)
*
lOO\
llllOl\
OO\
l
;
}
if\

(
lllOllOOOO
&
lOOlllOOl\
O\
OO
)
{
lO\
OlOl\
llll\
O\
l
.
Cl\
ear
(
)
;
}
else
{
if
(
!
IsAllDampingDisa\
bl\
ed
(
)
)
lO\
Ol\
O\
lllllOl\

*=
0.998f
;
fl\
oa\
t
lOllllOlOl
=
lO\
OlOlllll\
Ol\

.
GetMagn\
itu\
de\

(
)
;
if
(
lO\
l\
lll\
Ol\
Ol\

>
0.00001f
)
{
Vec3
lO\
Ol\
lllO\
lOlO
=
lOOlOlllllOl
/
lO\
lll\
lOlOl
;
Ma\
t3\
3
m33Rotation
(
lOOllllOl\
O\
lO
,
lOllllOlOl\

*
lOO\
lll\
OOll\
ll
)
;
lO\
OllOlOlOOO
.
m33Ro\
t\
at\
i\
o\
n
*=
m33Rotation\

;
}
}
lOOll\
O\
lO\
Ol\
lO\

=
lOOlOlllOl\
Ol
+
lOOlOll\
llOll
*
lOO\
lllOO\
llll
;
lO\
O\
llOlOlOO\
O\

.
v3Tran\
s\
lation
=
lOO\
llO\
l\
OOl\
l\
O
+
(
-
lO\
Oll\
OlOOlOl
)
*
lO\
Oll\
OlOlOOO
.
m33\
Rot\
ation
;
Ve\
c3\

lOOll\
llO\
lOll
=
(
lOOlO\
ll\
lllOl
*
lO\
O\
llOlO\
l\
OOO
.
m3\
3\
Ro\
tati\
o\
n
.
GetT\
ranspose\
A\
sInvers\
e
(
)
)
*
lOO\
l\
l\
OOllOOO
-
(
lO\
O\
lOll\
l\
llOl
*
lOO\
ll\
OlOO\
lll
.
m33\
R\
otati\
on
.
Get\
Tr\
a\
nspo\
s\
e\
As\
Invers\
e
(
)
)
*
lOOll\
OOllOOO\

;
lOOlOl\
llllOl
-=
(
lO\
OllllOlOll
*
lOOll\
OOllOOl\

)
*
lOOl\
l\
OlOlOOO\

.
m33R\
o\
t\
ati\
o\
n
;
}
void
DynamicObject
::
Ap\
pl\
y\
NextFra\
me
(
)
{
lOOllO\
lll\
lll\

=
lOOl\
lO\
l\
OOlll
;
lOOllOl\
OOlll
=
lOOllO\
l\
OlOO\
O
;
lOOll\
OlO\
Ol\
ll
.
m33R\
o\
ta\
tion
.
Ort\
ho\
gonalise
(
)
;
lOOlOlllO\
lO\
l
=
lOOllO\
l\
OOllO\

;
Upd\
ate\
WorldSpaceIn\
er\
ti\
alTen\
so\
r
(
)
;
}
voi\
d
Dynam\
i\
cObje\
c\
t
::
Render
(
)
{
TA\
_\
AS\
SERT
(
lO\
OllOOlOllO
)
;
lOO\
llOOlOll\
O
->
Rend\
e\
r\

(
lO\
Oll\
Ol\
OOll\
l
)
;
}
vo\
id
Dy\
namic\
O\
b\
ject\

::
Calcula\
te\
Wo\
rldAA\
B\
B\

(
)
{
TA_ASS\
ER\
T
(
lO\
Ol\
lO\
O\
lO\
llO
)
;
lOOll\
Ol\
O\
ll\
Ol
=
lOOllOOlOllO
->
GetAABB
(
)
*
lOOllO\
lOO\
lll
+
lO\
OllOOlOllO\

->
GetAABB
(
)
*
lO\
Ol\
l\
OlOlO\
OO
;
}
voi\
d
TA
::
Dyna\
micObj\
e\
ct
::
SetCol\
lis\
ion\
Object\

(
Coll\
is\
ion\
Objec\
tCombo\

*
lOOllOOlOl\
Ol
,
int
lOl\
OllOOl\
l
)
{
lOO\
ll\
O\
OlOllO\

->
Rel\
e\
a\
se
(
)
;
lOOll\
O\
OlOll\
O
=
lO\
OllO\
OlOl\
O\
l\

;
lOOllO\
OlO\
l\
l\
O
->
Add\
R\
ef
(
)
;
SetCo\
ll\
isi\
onObjec\
t\
Cha\
nged
(
lOl\
Oll\
OO\
ll\

)
;
}
vo\
id
TA\

::
Dy\
namicOb\
ject\

::
SetC\
o\
l\
lisi\
onObj\
ectChange\
d\

(
in\
t\

lOlOllO\
Oll
)
{
TA_A\
S\
SE\
RT
(
lOOll\
OOl\
O\
l\
lO\

)
;
Co\
lli\
sio\
nObjectCo\
m\
bo
*
lOOl\
lOOlO\
l\
Ol\

=
GetCo\
l\
li\
sio\
nObj\
ec\
tC\
ombo
(
)
;
if
(
!
lOOllOOlO\
lO\
l\

)
{
lOOllOlll\
OOO
.
In\
it\
ialis\
e
(
0
,
0
)
;
Cl\
e\
a\
rL\
ineInte\
rs\
e\
ctions\

(
)
;
retu\
rn\

;
}
if
(
lOl\
Ol\
lOO\
ll\

&
(
REINIT_\
FLA\
G_U\
P\
DA\
TE_MA\
S\
S
|
REINIT_\
FL\
AG\
_UPD\
A\
TE_I\
NERTIA_TENSO\
R
|
RE\
INIT_\
FL\
AG_UPDATE\
_\
CENTE\
R_OFFS\
E\
T
)
)
{
const
fl\
oat
lO\
Ol\
ll\
lOl\
lOO
=
10.0f
;
fl\
oat
lOl\
lO\
OOOl\
lO
=
0.0f
;
Mat33\

lllOl\
l\
OOO\
ll
;
Vec3
lOO\
lllOOOlOl
;
lllO\
llO\
OO\
l\
l
.
SetToId\
entity
(
)
;
lOOlll\
O\
OO\
lOl
.
Cle\
ar
(
)
;
lOO\
l\
lOOlOlOl
->
Cal\
c\
ula\
te\
Mass
(
lOOllllOl\
lOO\

,
lOll\
O\
OOOll\
O
,
lOOlllO\
OOlOl\

,
lll\
O\
llOOOll\

)
;
lOOllOOll\
Ol\
O\

=
lOO\
llO\
O\
lOlO\
l
->
Ge\
tA\
ABB
(
)
.
v3Ex\
t\
e\
nt\

.
Ge\
tMagnitud\
e
(
)
;
if
(
lOl\
OllO\
Oll\

&
REI\
N\
IT_FLAG_U\
PDATE_C\
E\
N\
TER_OFFSET
)
{
lO\
OllO\
lOO\
l\
Ol
=
lOOll\
lO\
OO\
lOl
;
}
if
(
lOlOl\
l\
OOl\
l
&
REINI\
T_\
FLAG_UPD\
ATE\
_IN\
ERTIA_T\
E\
NSOR
)
{
lOOll\
O\
Oll\
OOO\

=
lllOllOOOll
;
if
(
(
lO\
lOllOOll
&
RE\
INIT\
_F\
LAG_UPDAT\
E_MASS
)
==
0
)
lOOll\
OOllOO\
O
*=
lOlO\
lO\
l\
O\
lOO
/
lOll\
OO\
OO\
llO
;
lO\
O\
llO\
OllOOl\

=
lO\
OllOO\
llOOO\

.
Ge\
tInv\
erse
(
)
;
}
if\

(
lOlOll\
OO\
ll\

&
RE\
IN\
IT_FLAG_UPDATE\
_\
MA\
S\
S\

)
{
lOl\
OlOl\
O\
lOO
=
lOllOOOOll\
O\

;
Se\
t\
M\
a\
ss\

(
lOllOO\
O\
Oll\
O
)
;
}
}
int
lOO\
l\
lll\
OllOl\

=
lOOllOO\
l\
Ol\
Ol
->
GetMax\
N\
umLineCollisio\
n\
s
(
)
;
if
(
lOOllOl\
ll\
O\
OO
.
lOOOlllOOl
(
)
!=
lO\
O\
l\
l\
llOllOl
)
{
lOOll\
OlllOO\
O\

.
Init\
ial\
is\
e
(
lOOll\
llO\
ll\
O\
l
,
lOO\
llllOl\
lOl
)
;
lOOllOl\
llOOO
.
lOO\
ll\
llO\
l\
O\

(
)
;
ClearLi\
ne\
Intersec\
tion\
s\

(
)
;
}
lOO\
ll\
lOOOOOl
(
)
;
}
void
TA
::
Dynam\
icObj\
ect
::
Rei\
nitCol\
lisio\
n\
A\
sA\
B\
o\
x
(
const\

AAB\
B
&
lO\
OOO\
OO\
ll\
l\

,
int
lOlOl\
l\
OOl\
l\

)
{
lOO\
l\
lO\
OlO\
l\
lO\

->
Re\
lease\

(
)
;
Colli\
si\
o\
nObjectCombo\

*
lOOllOO\
lOl\
Ol
=
Collisi\
on\
ObjectComb\
o
::
Create\
Ne\
w
(
)
;
lOOl\
lOOlOlOl
->
Initiali\
seAsA\
Box
(
lO\
OO\
O\
OOlll
)
;
lOOllOOl\
OllO\

=
lOOll\
OOlOlOl
;
Se\
tC\
ollisi\
o\
nObj\
ect\
Cha\
ng\
ed\

(
lOlOllO\
Oll
)
;
}
vo\
id
TA
::
DynamicObje\
c\
t
::
Rei\
n\
itColl\
isionAsAnOri\
en\
te\
dBox\

(
co\
ns\
t
AA\
BB
&
lOOOOOOl\
ll\

,
const
MFra\
me\

&
lOO\
O\
O\
O\
OOOl\

,
int
lOlOllOOl\
l\

)
{
lOOl\
l\
OO\
lO\
llO
->
Release
(
)
;
Col\
lis\
ion\
Ob\
j\
ectC\
o\
mbo\

*
lOOl\
lOOlO\
lOl
=
Co\
lli\
sionObjectComb\
o
::
CreateN\
ew
(
)
;
lOOllOO\
lO\
lOl
->
InitialiseAsAnO\
rien\
tedBox
(
lOO\
O\
OOOl\
ll\

,
lOOOOOOOOl\

)
;
lOO\
l\
lOO\
l\
Ol\
lO
=
lOO\
ll\
OO\
l\
OlOl\

;
SetC\
ol\
li\
sionObjec\
tChan\
ged
(
lOl\
OllOOl\
l
)
;
}
void
TA
::
Dynamic\
O\
bject
::
Rei\
nitCo\
llisionAsA\
Capsu\
le\

(
const\

Ve\
c3\

&
lOOlO\
lO\
lll
,
const
Vec3\

&
lOOl\
OllO\
O\
l
,
float
llll\
lOOOOl
,
int
lO\
l\
O\
ll\
OOll
)
{
lO\
Oll\
OOlOllO
->
Rel\
e\
ase
(
)
;
CollisionOb\
j\
e\
ctC\
omb\
o
*
lOOll\
OOlOlOl
=
Co\
llis\
io\
nO\
bje\
ctCom\
bo
::
Cr\
eate\
N\
ew
(
)
;
lOOllOOlO\
l\
O\
l
->
Initialis\
eAsAC\
apsule
(
lOOl\
Ol\
Olll
,
lOO\
l\
O\
l\
lOOl
,
ll\
ll\
lOOOOl\

)
;
lOOl\
l\
OOlOllO\

=
lOOllOO\
l\
OlOl
;
Se\
tC\
ollisionOb\
jectCh\
anged
(
lOlOllOOll
)
;
}
voi\
d\

TA
::
DynamicObj\
e\
c\
t
::
Reinit\
Col\
lision\
A\
sA\
Sph\
e\
r\
e
(
const
Ve\
c3
&
v3Ce\
nter
,
float\

lllllOO\
OOl\

,
int\

lOlOll\
OOll
)
{
lO\
OllOO\
l\
O\
ll\
O
->
Releas\
e\

(
)
;
Co\
ll\
is\
i\
onObjectC\
omb\
o
*
lOOllOOlOlOl
=
CollisionObje\
ct\
C\
o\
mbo
::
Cr\
ea\
teNew
(
)
;
lO\
O\
l\
lO\
Ol\
O\
lOl\

->
In\
itial\
ise\
AsASphe\
re
(
v3Cen\
t\
er
,
lllllO\
OOO\
l
)
;
lOOl\
lOOlOl\
lO\

=
lOOl\
lOOlOlO\
l
;
SetCol\
lisionObje\
ctCh\
a\
nged
(
lOlO\
llOOll
)
;
}
voi\
d
TA
::
Dyn\
ami\
cO\
bje\
c\
t
::
Re\
initCo\
l\
lis\
io\
nAsACyli\
nd\
er
(
co\
n\
st\

Vec\
3\

&
lOOlO\
lO\
l\
ll\

,
con\
st
Vec\
3
&
lOOlO\
llOOl
,
flo\
at
lll\
l\
lO\
OOOl
,
int
lOlOllO\
Oll\

)
{
lOOllOOlO\
ll\
O\

->
Rele\
ase\

(
)
;
Coll\
is\
ionOb\
je\
ctCombo
*
lOOllOOlOlOl
=
CollisionObjectCom\
bo
::
Cr\
eateN\
ew
(
)
;
lOOllOOl\
O\
lOl
->
Init\
ialiseAsAC\
ylinder\

(
lO\
OlOlO\
lll
,
lOOlO\
llOOl
,
lll\
ll\
OOOOl
)
;
lOOllOOlOllO
=
lOOllO\
Ol\
O\
lOl
;
SetCo\
llisio\
nObject\
Change\
d
(
lOlOllOOll
)
;
}
bo\
o\
l\

Dyn\
am\
icObje\
ct
::
Test\
LineForCo\
llision\

(
con\
st
Vec3
&
lOOl\
OlOll\
l
,
con\
st
Vec3
&
lOOOlOOOOO
,
fl\
oat
lO\
OlOl\
lO\
OO
,
Coll\
isi\
on
&
ll\
Ollll\
Ol\
ll\

)
const\

{
if
(
lOOl\
lOOl\
OllO\

->
TestLin\
e\
Fo\
r\
Collis\
ion\

(
lO\
OlOlOlll
/
lOOllO\
lO\
Olll\

,
lO\
O\
O\
lOOOOO
/
lOO\
l\
lO\
lO\
Oll\
l
.
m33Ro\
t\
a\
ti\
on
,
lO\
O\
lOllOOO\

,
ll\
Ollll\
Ol\
ll
)
)
{
llO\
ll\
ll\
O\
lll\

.
lO\
llO\
OO\
llOl\

=
(
DynamicO\
bje\
ct\

*
)
this
;
ll\
O\
l\
lllO\
lll\

.
Se\
tO\
bj\
ectB
(
0
)
;
llOll\
ll\
O\
ll\
l
.
lOOO\
O\
lllll
*=
lOO\
llOlOOlll
;
llOll\
ll\
Oll\
l
.
lOOOl\
O\
OOOO
*=
lOO\
llO\
l\
OOlll
.
m3\
3Rotatio\
n
;
ret\
urn
true
;
}
el\
s\
e
{
retur\
n
fa\
lse
;
}
}
void
Dy\
na\
micOb\
je\
ct
::
lOOll\
ll\
Oll\
lO\

(
in\
t\

lOOl\
ll\
lOl\
lll\

,
DynamicO\
bject
*
lOlllOOlOOO\

,
Co\
llisionOb\
jec\
t
*
lOlOllOOO\
ll\

,
u32
llOlllOlOOO
,
float\

lO\
l\
l\
OOlOOl\
l
,
con\
st
Ve\
c3
&
lOOOOlllll
,
const
Vec3
&
lOOOl\
OO\
OO\
O
)
{
Lin\
eInters\
ec\
ti\
on
&
lOOlllllOO\
O\
O\

=
lOOll\
OlllO\
OO
[
lOOl\
lllOllll
]
;
if\

(
lOO\
ll\
l\
l\
lO\
OO\
O\

.
lOllO\
OlOOll
==
-
1.0f
||
lOOlllllO\
OOO
.
lOllOOl\
OOll
>
lOllOOl\
O\
Oll
)
{
lOO\
llll\
lOOOO
.
lOllOO\
l\
O\
Ol\
l
=
lOllO\
O\
lOOll\

;
if
(
lOOll\
ll\
lOOOO
.
lOl\
llO\
OlOOO
)
lOOlll\
l\
lO\
O\
OO
.
lO\
l\
llOOl\
OOO
->
Rele\
a\
se
(
)
;
lOOl\
ll\
ll\
O\
OOO
.
lOlllOOlO\
OO
=
lO\
lllO\
O\
l\
OOO\

;
if
(
lO\
O\
lllllOOOO\

.
lOlllOOlO\
O\
O
)
lOOl\
llllOO\
OO
.
lOlll\
O\
Ol\
O\
OO\

->
AddR\
ef
(
)
;
if
(
lOOlllll\
OOOO
.
lOl\
O\
l\
l\
OOOll\

)
lOOlllllOOOO
.
lOl\
OllO\
O\
O\
ll
->
Release\

(
)
;
lOOlllll\
OOOO
.
lO\
l\
Oll\
OOOll
=
lO\
l\
O\
ll\
OOOll
;
lO\
O\
lll\
llOOOO\

.
lO\
lOl\
lOOOll
->
Ad\
dR\
e\
f\

(
)
;
lOOlllllOOOO
.
llOlllOlOOO
=
llOll\
lOlOOO\

;
lOOlll\
l\
lOOOO
.
lOOOOlllll
=
lOOOOlll\
ll
;
lOOll\
lllO\
OO\
O\

.
lOOOl\
OOO\
OO\

=
lO\
O\
O\
l\
OO\
OOO
;
}
}
PhysicsJoi\
nt
&
Dyn\
amic\
O\
b\
ject
::
AddJoint\

(
DynamicObj\
ec\
t\

*
lOOl\
llllOOOl
)
{
Ph\
y\
si\
c\
sJoint\

&
lOO\
lll\
ll\
OOlO\

=
lO\
OllOlllOOl
.
lO\
O\
OlllOOO
(
)
;
if
(
lOO\
lllllOO\
O\
l\

)
lO\
Ol\
llllOOOl
->
lOOllOlllOlO
.
lOOOll\
lOOO
(
&
lOOl\
lll\
lO\
OlO
)
;
lOOll\
l\
llOOlO
.
Initial\
is\
e
(
th\
i\
s
,
lOO\
l\
ll\
l\
lOO\
Ol
)
;
lOOlllOO\
OO\
Ol
(
)
;
retu\
r\
n
lO\
OlllllOOlO
;
}
#ifndef TA_REMOVE_DEPRECATED
Phys\
i\
c\
sJoint
&
Dy\
na\
mi\
cObje\
c\
t\

::
AddJ\
oint\

(
Dy\
nam\
icO\
b\
ject
*
lOOllll\
lO\
OO\
l
,
const\

Ve\
c\
3
&
lOOOl\
l\
l\
l\
OOOl\

,
cons\
t
Vec3
&
lOOlllllOOl\
l
,
cons\
t
Mat\
33
&
lO\
Ol\
lll\
l\
OlOO
,
con\
st\

EulerA\
n\
gl\
es
&
lOOl\
lll\
lOl\
Ol\

,
con\
st
EulerAn\
gle\
s
&
lOOllll\
l\
O\
ll\
O
)
{
Physics\
Joint
&
lO\
Ollll\
l\
OOlO\

=
lO\
OllO\
ll\
l\
OO\
l
.
lOOO\
lllOO\
O\

(
)
;
if
(
lOOlllllOOO\
l
)
lOOl\
llllO\
O\
O\
l
->
lOOllO\
l\
l\
lOlO
.
lO\
O\
O\
ll\
lOO\
O
(
&
lOOlllllOOlO
)
;
lOOlllllOOlO\

.
Ini\
tia\
l\
i\
se
(
th\
is\

,
lOOllll\
lOOOl
)
;
lOOl\
l\
lll\
O\
OlO
.
Reset\

(
lOO\
OllllOO\
Ol\

,
lOOl\
ll\
ll\
O\
Oll
,
lO\
Ol\
ll\
llO\
lO\
O
,
lO\
OlllllOl\
O\
l
,
lOOll\
l\
llOll\
O
)
;
lOOll\
lOOOOOl
(
)
;
re\
tur\
n
lOOll\
lll\
O\
OlO\

;
}
PhysicsJo\
int
&
Dy\
nam\
ic\
Objec\
t
::
AddJoi\
ntT\
y\
peHi\
nge
(
Dynam\
icO\
bject
*
lOOll\
l\
llOOO\
l
,
cons\
t
Vec3
&
lOO\
Ol\
lllOOOl
,
con\
st
Vec3
&
lO\
OlllllOO\
ll\

,
co\
n\
st
Ve\
c\
3
&
lOO\
lllllOlll\

,
co\
ns\
t\

Vec3
&
lOOl\
ll\
l\
ll\
OOO
,
float\

lO\
O\
llll\
llO\
O\
l
,
fl\
oat
lO\
Oll\
l\
lll\
Ol\
O
)
{
Phy\
s\
icsJoint\

&
lOOll\
l\
llO\
O\
l\
O
=
lOOllOlllOO\
l\

.
lOOOl\
llOO\
O
(
)
;
if
(
lOOl\
llllOOOl
)
lOOlllll\
OOOl\

->
lOOllOl\
ll\
OlO\

.
lO\
OOl\
llOO\
O
(
&
lO\
Ol\
l\
lllOOl\
O
)
;
lO\
Olll\
llOO\
l\
O
.
Initia\
lis\
e
(
th\
is
,
lOOlllll\
OOOl
)
;
lOOl\
llllOOlO\

.
Res\
e\
tAsT\
ypeHi\
nge
(
lOO\
Ol\
lll\
OO\
Ol\

,
lOO\
lllllOOll\

,
lO\
Oll\
ll\
lOlll
,
lOOl\
llll\
lO\
OO
,
lOO\
lll\
l\
l\
lOOl
,
lOOl\
llll\
lOlO
)
;
re\
tu\
rn
lOO\
l\
llllO\
OlO
;
}
Phy\
si\
csJo\
i\
nt
&
Dynami\
cO\
b\
je\
ct\

::
AddJoi\
nt\
T\
y\
p\
eSo\
c\
ket\

(
Dyna\
micObj\
e\
ct
*
lOO\
llll\
lOOO\
l
,
co\
nst
Vec3
&
lOO\
OllllOO\
Ol
,
con\
s\
t\

Vec3\

&
lO\
Olllll\
O\
Oll\

,
const
Ve\
c3
&
lOOlll\
l\
ll\
Oll
,
const\

Vec3
&
lO\
O\
l\
ll\
ll\
llO\
O\

,
float\

lOO\
lllll\
lO\
lO
)
{
PhysicsJoint
&
lOOl\
l\
lll\
OOlO
=
lOOllO\
ll\
lOOl
.
lOOOll\
lOOO
(
)
;
if
(
lOOlllllOOOl
)
lO\
Ol\
llllO\
OOl
->
lOO\
llOlllOl\
O
.
lOOO\
l\
llOOO
(
&
lO\
Oll\
l\
ll\
O\
O\
lO
)
;
lOOl\
lll\
lO\
OlO
.
Initialise
(
th\
i\
s
,
lOOlllllOOOl
)
;
lO\
Olll\
llOO\
lO
.
Rese\
tAsTy\
peSoc\
ket
(
lOO\
OllllO\
OOl
,
lOO\
l\
llllOOll
,
lOOll\
l\
lllOl\
l
,
lOOlll\
llllOO
,
lOOll\
llllOlO
)
;
re\
turn\

lOOl\
lll\
lOOlO
;
}
Physic\
sJoint
&
Dyna\
micObjec\
t
::
Add\
Joi\
ntTypeLim\
ited\
So\
cket
(
DynamicObjec\
t
*
lOO\
ll\
lllOO\
O\
l\

,
cons\
t
Vec\
3
&
lOOOllll\
OOOl
,
const
Vec3
&
lO\
O\
lll\
llO\
O\
ll
,
co\
nst
Mat\
33\

&
lOOlllllO\
lOO\

,
float
lOOll\
l\
l\
l\
llOl
,
float
lOOllllll\
llO\

)
{
Physics\
Jo\
i\
nt
&
lOOlllll\
OOlO
=
lOOllOl\
ll\
OOl\

.
lOOOlllOO\
O
(
)
;
if\

(
lO\
Olll\
llOO\
Ol
)
lO\
O\
lllll\
OOO\
l
->
lO\
O\
l\
lOll\
l\
Ol\
O
.
lOO\
Olll\
OOO\

(
&
lOOl\
l\
lllOOlO
)
;
lOOll\
lllOOlO\

.
Initia\
lise
(
this
,
lOOl\
l\
lllOO\
Ol
)
;
lOO\
l\
lll\
l\
OOlO
.
Re\
se\
tA\
sT\
yp\
eLimited\
S\
oc\
ke\
t
(
lOOOllllO\
OOl
,
lOO\
lllll\
OO\
ll
,
lOOlllllOlOO
,
lOOl\
l\
lllllOl\

,
lOOl\
l\
lllll\
l\
O\

)
;
return
lO\
Ol\
l\
l\
llO\
O\
lO
;
}
Physi\
csJoint
&
Dy\
na\
m\
icObject
::
AddJoint\
Ty\
peSqu\
a\
r\
eSoc\
k\
e\
t
(
Dy\
na\
mi\
cO\
bj\
e\
c\
t
*
lO\
OlllllOOOl
,
const
Ve\
c\
3
&
lOOOllllO\
O\
Ol
,
co\
nst
Ve\
c3
&
lOOll\
lllOOl\
l
,
con\
st
Mat\
33
&
lOOll\
ll\
lO\
lO\
O
,
float\

lOOlll\
llllll\

,
float
lOl\
OOOOOOOOO
,
float
lOl\
OOOOO\
OOOl
,
float
lOlOOOOOO\
Ol\
O\

,
float\

lO\
lOO\
OO\
O\
OOll\

,
float\

lOlOOO\
O\
O\
OlOO\

)
{
Ph\
ysicsJoint
&
lO\
Ol\
ll\
ll\
OOlO
=
lOOll\
Ol\
l\
l\
OO\
l
.
lO\
OOlllOOO
(
)
;
if\

(
lO\
Olll\
l\
lOOO\
l
)
lO\
O\
lllllO\
OOl
->
lO\
Oll\
O\
l\
llOlO\

.
lOOOl\
l\
lO\
OO\

(
&
lO\
Ol\
l\
lllOO\
lO
)
;
lOO\
lllllOOlO
.
Initiali\
se
(
this
,
lOOlll\
l\
lOOOl
)
;
lOOl\
l\
ll\
lOOlO
.
ResetAsTypeSq\
ua\
r\
eSoc\
ke\
t\

(
lOOO\
ll\
llOOOl
,
lO\
O\
ll\
lllO\
Ol\
l
,
lOO\
lllllO\
lOO
,
lOOlll\
l\
l\
l\
lll
,
lOl\
OOOOOOO\
O\
O\

,
lOlOOO\
O\
OO\
OOl\

,
lOlO\
O\
OOOO\
OlO\

,
lOlOOOOOOOll\

,
lOlOOOOOO\
lOO
)
;
ret\
urn
lO\
Ol\
llllOO\
lO
;
}
PhysicsJ\
oi\
n\
t
&
Dyn\
ami\
c\
O\
bj\
e\
ct
::
AddJ\
oi\
ntTy\
pe\
Sl\
ider
(
Dyna\
mi\
cObject
*
lOOll\
lllO\
OOl
,
const
Ve\
c3
&
lOOOl\
lllOO\
O\
l
,
const\

Vec3
&
lOlOOOO\
OO\
lOl
,
con\
st\

Vec3\

&
lOlOOOO\
O\
O\
ll\
O
)
{
Phy\
sicsJ\
oint\

&
lOOl\
llll\
OOlO
=
lOOllOlll\
OOl
.
lOOOl\
ll\
O\
O\
O\

(
)
;
if\

(
lOOl\
lll\
lOOO\
l
)
lOOlllllOOOl
->
lOOl\
lOlllOlO
.
lOOOl\
ll\
OOO
(
&
lOOlllll\
OOl\
O
)
;
lOOll\
lllO\
O\
lO
.
Initialis\
e
(
this
,
lO\
O\
ll\
l\
l\
lOOOl
)
;
lOOl\
l\
lllOOlO
.
Reset\
As\
Typ\
e\
Slider
(
lOOOllllO\
OOl
,
lOlOO\
OO\
OOlO\
l
,
lOlO\
OOO\
OOllO
)
;
return
lOOll\
ll\
lOO\
lO\

;
}
Ph\
ys\
icsJoint
&
Dynami\
cO\
bjec\
t
::
Ad\
dRota\
tionC\
onst\
r\
aint\

(
Dy\
na\
mic\
Object\

*
lO\
Oll\
ll\
lOO\
Ol
,
con\
st
Mat3\
3
&
lOOll\
lll\
O\
lOO
,
const
EulerA\
ngles
&
lOOlllllO\
lOl\

,
const\

Eul\
er\
Angles
&
lOOlllllOllO\

)
{
lO\
Oll\
l\
llOOOl\

=
0
;
Ph\
ysicsJoint\

&
lOO\
l\
llll\
OOlO
=
lO\
O\
llO\
l\
llO\
Ol
.
lOOOl\
l\
lOOO\

(
)
;
if
(
lOO\
lllllOOO\
l
)
lOOlllll\
O\
OOl
->
lOOll\
OlllO\
lO
.
lOOOl\
l\
l\
OO\
O\

(
&
lOOlllllO\
OlO
)
;
lOOll\
lll\
OOl\
O
.
Initia\
li\
se\

(
th\
i\
s
,
lOOlllllOOO\
l
)
;
lOOll\
lllOOlO
.
Res\
etA\
sT\
yp\
e\
R\
ot\
ation\
Const\
r\
ain\
t\

(
lOOlllll\
OlOO
,
lO\
Olll\
l\
lOlO\
l\

,
lOO\
lllllOl\
lO
)
;
ret\
urn
lOO\
lllllO\
O\
lO
;
}
Phy\
si\
cs\
Joint
&
Dyn\
a\
micObjec\
t
::
AddVec\
to\
r\
C\
o\
nst\
raint\

(
Dynami\
c\
Obj\
ect
*
lOOl\
llllOOOl
,
const
Vec3\

&
lOOlll\
lllOl\
l
,
const
Ve\
c3
&
lOOl\
llll\
llOO
,
float
lOOll\
llllOl\
O\

)
{
lOO\
lllllOOOl
=
0
;
Phys\
icsJoint\

&
lOOll\
ll\
l\
O\
Ol\
O
=
lOOllOll\
lOOl\

.
lOOOlll\
OOO
(
)
;
if
(
lO\
Ollll\
lOO\
Ol
)
lO\
OlllllOOOl
->
lO\
OllOlllOlO
.
lOOO\
l\
l\
l\
OOO
(
&
lO\
Ollll\
lO\
OlO\

)
;
lOOlllll\
OO\
lO
.
Initial\
ise
(
this
,
lOOl\
ll\
llOOO\
l
)
;
lOOlllllOOl\
O
.
Re\
s\
etA\
sTy\
pe\
VectorConst\
r\
aint
(
lOO\
ll\
ll\
ll\
Oll
,
lOOllll\
lllOO
,
lOOl\
lllllOlO
)
;
retur\
n
lOOll\
lll\
O\
OlO
;
}
#endif //
void
Dyna\
m\
icObject
::
RemoveAll\
Joints\

(
)
{
{
for\

(
Join\
tIte\
rator
lOlOOlOOlO
=
lOOll\
Olll\
OO\
l
.
lO\
lOO\
O\
OlOO
(
)
;
!
lO\
lOOlO\
OlO\

.
At\
End
(
)
;
)
{
Physics\
Joi\
nt
&
lOOl\
l\
lOOO\
Oll
=
*
lOlOOlOOlO
;
++
lOlOOl\
OOlO
;
TA_AS\
SERT
(
lOOlllOOO\
Oll\

.
GetOb\
jectA
(
)
==
th\
is
)
;
Remo\
v\
eJ\
oint
(
lOOll\
lOO\
OOll
)
;
}
}
{
fo\
r
(
Li\
st
<
Phys\
ic\
sJoint
*
>
::
It\
erator
lOlOOl\
OOlO
=
lO\
Oll\
Oll\
lOl\
O
.
lO\
l\
OOOOlOO
(
)
;
!
lO\
lOO\
lOO\
lO
.
At\
End
(
)
;
)
{
Physi\
cs\
Joi\
nt
*
lO\
lllOOlOlO
=
*
lOl\
OOlOOl\
O
;
++
lOl\
OO\
lOOlO
;
TA_A\
SS\
ERT
(
lOll\
lOOl\
O\
lO\

->
GetO\
b\
jectB
(
)
==
this\

)
;
lOl\
llOOlOlO
->
GetObjectA
(
)
->
Remove\
Joint\

(
*
lOl\
l\
lO\
O\
lOlO
)
;
}
}
lO\
Oll\
lO\
OO\
OOl
(
)
;
}
vo\
id
DynamicObj\
e\
ct\

::
RemoveJoint
(
Ph\
ysi\
csJoi\
nt\

&
lO\
OlllOO\
OOll
)
{
if
(
lO\
O\
lll\
OOO\
O\
ll
.
GetOb\
je\
ctA\

(
)
!=
this
)
{
lOOOO\
OO\
l\
l\
O\

(
0
,
"DynamicObject::RemoveJoint: Joint doesn't exist in this dynamic object.")
;
retu\
rn\

;
}
if
(
lO\
O\
l\
l\
lOOOOll
.
Get\
Objec\
tB
(
)
)
{
List
<
Ph\
ysicsJo\
i\
nt\

*
>
::
It\
era\
tor
lO\
l\
OOlO\
OlO\

=
lOOlllOOOOll
.
GetO\
bject\
B\

(
)
->
lOOllOl\
llOl\
O
.
lOlOOOO\
lOO
(
)
;
for
(
;
!
lOl\
OO\
l\
OOlO\

.
AtEn\
d
(
)
;
++
lOl\
OOlOO\
lO
)
{
PhysicsJo\
int
*
&
lO\
ll\
lO\
OlOl\
O\

=
*
lOlO\
OlOO\
l\
O
;
TA_AS\
SE\
RT
(
lOlllOO\
l\
OlO
->
GetO\
bje\
ctB
(
)
==
lO\
OlllOOOOll
.
GetO\
b\
je\
ctB
(
)
)
;
if
(
lOll\
lOO\
lOlO\

==
&
lO\
Olll\
OOOOl\
l
)
{
lO\
O\
lllOOOOl\
l\

.
GetObject\
B\

(
)
->
lO\
OllOll\
lOlO
.
lO\
Oll\
lllll
(
&
lO\
lllOOlOlO\

)
;
lOO\
lllOOOOll
.
GetObje\
ctB\

(
)
->
lO\
OlllOOOOO\
l
(
)
;
bre\
ak\

;
}
}
}
lO\
Ol\
l\
O\
l\
ll\
OO\
l
.
lOOlllllll\

(
&
lO\
O\
ll\
lOOO\
Oll
)
;
lO\
OlllOO\
OOOl
(
)
;
}
void\

Dyn\
am\
i\
cObject
::
Remove\
J\
ointsT\
oO\
bje\
c\
t\

(
Dy\
n\
amicOb\
jec\
t\

*
lOlllO\
O\
l\
OOO
)
{
for\

(
Joint\
Iterator
lO\
lO\
OlO\
Ol\
O
=
lOOll\
O\
lllOO\
l
.
lOl\
O\
OOOlOO
(
)
;
!
lO\
lO\
O\
l\
OO\
lO
.
At\
En\
d
(
)
;
)
{
Phys\
icsJoi\
nt
&
lOOlllOOOO\
ll\

=
*
lOlOOlOOlO
;
++
lOlOOlOOlO
;
TA_A\
S\
S\
E\
RT
(
lOOll\
lO\
O\
OOll\

.
Get\
O\
b\
ject\
A
(
)
==
th\
i\
s
)
;
if
(
lOOll\
lOOOOll
.
Get\
O\
b\
j\
ectB
(
)
==
lOlllOO\
l\
O\
O\
O
)
Rem\
oveJoint
(
lOOlllO\
OOOl\
l
)
;
}
if
(
lOlllOOl\
O\
O\
O\

)
{
for
(
Joi\
ntI\
te\
ra\
tor
lOlOOlOOlO
=
lOlllOOl\
OOO
->
lOOllOlllOOl\

.
lOlOOOOlOO
(
)
;
!
lOlOO\
lOOlO
.
At\
End\

(
)
;
)
{
Physic\
s\
J\
oi\
nt
&
lOOll\
lOOOOll
=
*
lOlOOlOOl\
O
;
++
lOlO\
O\
lOO\
lO
;
TA_\
A\
SSERT
(
lOO\
lll\
OOOOll
.
Ge\
tObj\
ectA\

(
)
==
lOl\
llOOl\
OOO\

)
;
if
(
lOOlllOOOOl\
l
.
Ge\
tObjectB\

(
)
==
th\
is
)
Rem\
oveJo\
in\
t\

(
lOOl\
ll\
O\
OOO\
l\
l
)
;
}
}
}
vo\
id
Dyn\
a\
m\
i\
c\
Obje\
ct
::
lOO\
llOll\
lOll\

(
)
{
ClearLine\
Inte\
rse\
c\
t\
io\
n\
s
(
)
;
if
(
lOOllOO\
lOll\
O
)
{
Collisi\
on\
Objec\
t\
Combo\

*
lOO\
llO\
Ol\
OlOl
=
Ge\
tCol\
lisionObje\
ct\
C\
o\
mbo
(
)
;
if\

(
lOOl\
l\
O\
O\
lOlOl
)
{
int
lOOl\
l\
ll\
OllOl
=
lO\
OllO\
Ol\
OlOl
->
GetMax\
N\
umLineC\
o\
llis\
io\
n\
s
(
)
;
if
(
lOOlll\
l\
OllO\
l
!=
lOOl\
lOll\
lOO\
O
.
lOOOl\
llOOl
(
)
)
{
lOOl\
lOl\
llOOO
.
Fin\
ali\
se
(
)
;
lOOl\
l\
OlllOO\
O
.
Initialis\
e
(
lOOll\
l\
l\
OllO\
l\

,
lOOlll\
lOllOl
)
;
lOOl\
lOlll\
OOO
.
lOOl\
lllOlO
(
)
;
Cl\
e\
arLineI\
nter\
sections\

(
)
;
}
}
}
}
lOl\
OOOOOO\
l\
ll
*
DynamicObjec\
t
::
lO\
lOOOO\
Ol\
O\
OO\

(
Dyn\
a\
mi\
c\
Objec\
t
*
llOO\
lO\
OlOll
,
bool
lO\
lOOOOOlOOl\

)
{
TA_ASS\
ERT
(
ll\
OOlOOlOll
)
;
#ifdef _DEBUG
if
(
lO\
Ol\
OOOll\
O
)
{
int
llOl\
l\
OOll\
l
=
0
;
lO\
lOOO\
OOlO\
lO
*
lOlOO\
OO\
OlOl\
l
=
lOO\
ll\
OllOlOO
;
for
(
;
lO\
l\
OOOO\
O\
lOll
;
lO\
lOOOO\
OlOll
=
lOlOOOO\
Ol\
O\
ll
->
llOOO\
l\
OO\
OOl\

)
ll\
O\
llOOlll
++
;
TA\
_ASS\
ERT\

(
llOllOOll\
l
==
lO\
O\
l\
l\
O\
l\
lOlOl\

)
;
llOl\
lOOll\
l
=
0
;
lO\
lO\
OO\
OO\
lOll
=
llOOl\
OOlOll
->
lO\
O\
ll\
Ol\
lO\
lOO
;
for
(
;
lOlOO\
O\
OOlOll
;
lOlOOOOO\
l\
O\
ll
=
lOlOOOOO\
lOl\
l
->
llO\
OOlOOOOl
)
llOll\
OOl\
ll
++
;
TA_\
A\
SSERT
(
ll\
Oll\
OOlll
==
llO\
OlOOlOl\
l
->
lOO\
l\
lOllOlOl
)
;
}
#endif 
lO\
l\
OOOOOlOlO
*
lOlOOOOO\
l\
Oll\

;
if
(
lOOl\
lOllOl\
Ol
<=
llOOl\
OOlOl\
l
->
lO\
Ol\
lOllOlOl
)
{
lOlOOOOO\
lOl\
l\

=
lOOllOll\
OlO\
O\

;
for
(
;
lOlOOOO\
OlOll
;
lOl\
OOO\
OO\
l\
O\
l\
l
=
lOlOOOO\
OlOll
->
ll\
O\
OO\
lOOOOl\

)
{
lOlOOOO\
O\
Olll
*
lOlOO\
OOOllO\
O
=
lO\
l\
O\
O\
OO\
OlOll\

->
lO\
l\
O\
OOOOllO\
O
;
if
(
lOlOO\
O\
OOllO\
O
->
lOlO\
OOOOllOl
==
thi\
s
)
{
if\

(
lOl\
OO\
OOOllOO
->
lOl\
O\
OOO\
O\
l\
llO
==
llOOlOOlO\
ll
)
return
lO\
lOOOOO\
ll\
O\
O
;
}
else
{
TA_ASS\
E\
R\
T
(
lO\
lO\
OOOOl\
lO\
O
->
lOl\
OOOOOlll\
O\

==
this
)
;
if
(
lO\
l\
OOOO\
Oll\
OO
->
lOl\
OOOOOllOl
==
llO\
Ol\
OOlO\
ll
)
return
lOl\
O\
OOO\
O\
llOO
;
}
}
}
els\
e
{
lOlOO\
OOOlOl\
l
=
llO\
OlO\
OlO\
ll
->
lO\
OllOllO\
lOO
;
for\

(
;
lO\
lOOOOO\
l\
Ol\
l
;
lO\
l\
OOOOO\
lOl\
l
=
lOl\
OOO\
OOl\
Oll
->
llO\
OOlOOOO\
l\

)
{
lOlOOOOOO\
l\
ll
*
lOlO\
O\
OO\
OllO\
O\

=
lOlOOO\
OOl\
Oll\

->
lOlOOOOOll\
OO\

;
if
(
lO\
lOOOOOllOO
->
lOlOOO\
O\
O\
l\
lOl\

==
llOOl\
OOlOll
)
{
if
(
lOlOOOOOll\
O\
O
->
lO\
lOOOOO\
lllO
==
th\
is\

)
re\
t\
ur\
n
lOlOOOOOllO\
O
;
}
else
{
TA\
_ASSERT\

(
lOlOOO\
O\
OllOO
->
lOlOO\
OOOl\
ll\
O
==
llO\
OlOOl\
Oll
)
;
if
(
lOlOOOOOllOO\

->
lOl\
OO\
O\
OOll\
Ol
==
thi\
s
)
re\
turn
lOlOOOO\
O\
llOO
;
}
}
}
if\

(
lOlOOOOO\
lOOl
)
return\

lOl\
OO\
OOOl\
lll
(
llO\
Ol\
OOlO\
l\
l
)
;
el\
se
re\
tu\
rn
0
;
}
lOlOOO\
OO\
Olll
*
Dyna\
mi\
cOb\
j\
ect
::
lOlO\
OOOOllll
(
Dy\
namicObject
*
llOOlOO\
lOl\
l
)
{
TA\
_\
A\
SSERT\

(
lOOllOlll\
lOO
)
;
lO\
lOOOO\
OO\
lll
*
lO\
lOO\
OOOl\
l\
OO
=
lOOl\
lO\
l\
ll\
l\
OO
->
Get\
Ph\
ysics
(
)
.
lOlOO\
OO\
lO\
OO\
O
(
)
.
lOlO\
OOOlOOOl
(
)
;
if
(
!
lOl\
OOO\
O\
Oll\
O\
O
)
re\
turn
0
;
lOlOOO\
O\
Ol\
lOO
->
lOlOOOOO\
ll\
Ol
=
this\

;
lO\
lO\
OOOOllOO
->
lO\
lOOOOOlllO
=
ll\
OO\
lOOlOll
;
lOlO\
OOOO\
llOO
->
lOlOOO\
Ol\
OOl\
O\

=
0
;
lOOl\
l\
O\
ll\
llOO
->
Ge\
tP\
hy\
sics
(
)
.
lOlOOOOl\
OOOO\

(
)
.
lO\
lOOOOlOOll
(
lOlO\
OOOOl\
lOO\

)
;
lOlOO\
O\
OOllOO\

->
lO\
l\
OOOOlOlOO
.
llOOOlO\
OO\
O\
l
=
lO\
OllO\
llOlO\
O\

;
if\

(
lOlOOOOOl\
lOO\

->
lOl\
OOOO\
l\
O\
lOO
.
llO\
OOlOOOOl
)
{
TA_A\
S\
S\
ERT
(
lO\
lO\
OOOOl\
lOO
->
lOlO\
OO\
OlOlOO
.
llOOOlOOO\
O\
l\

->
llOOOO\
lOlll
==
&
lOOllOllOlOO\

)
;
lOlOOOOOllOO
->
lO\
lO\
OOO\
l\
OlOO\

.
llO\
O\
OlOO\
OOl
->
llO\
O\
OOlOlll
=
&
lOlOOO\
OOl\
lOO\

->
lOlOOOOl\
OlOO
.
llO\
O\
O\
lOO\
O\
Ol
;
}
lOlOO\
OO\
O\
l\
lOO
->
lO\
lO\
O\
OOlOlO\
O
.
llOOOOl\
O\
l\
ll
=
&
lOOll\
Ol\
lO\
l\
OO\

;
lOO\
llOllOlO\
O
=
&
lOlO\
O\
OOOl\
lOO\

->
lO\
lOOOOlOl\
OO\

;
lOl\
OOO\
OOl\
lOO\

->
lO\
lOOOOl\
OlOO
.
lOlOOOOOllOO\

=
lOlOOOOO\
l\
lOO\

;
lOOl\
lO\
llO\
lO\
l\

++
;
TA_ASSERT\

(
ll\
OOlOOl\
Oll
)
;
lO\
l\
OOOO\
Ol\
lOO
->
lOlOO\
O\
O\
lOlO\
l\

.
llO\
OOlOOOOl\

=
llOO\
l\
O\
OlOll
->
lOOllO\
llO\
lO\
O
;
if\

(
lOlOOOOOl\
lOO
->
lOlO\
OOOlOlOl
.
llOOOl\
O\
OOOl
)
{
TA_ASSERT
(
lOlO\
OOOOl\
lOO
->
lO\
l\
OO\
OOlOlOl
.
ll\
O\
OO\
l\
OOO\
Ol\

->
llO\
OOO\
lOlll
==
&
llOOlOOlOl\
l
->
lO\
Ol\
l\
O\
ll\
Ol\
OO
)
;
lO\
lOOOOO\
l\
l\
OO
->
lOl\
O\
O\
OOl\
OlOl\

.
llOOOl\
O\
OOOl
->
ll\
OOOOlOlll
=
&
lOl\
OOOOOllOO
->
lOlO\
OOOlOlO\
l\

.
llOOO\
l\
OOOOl
;
}
lOlOOOOOll\
O\
O
->
lOlO\
OOOl\
O\
l\
Ol\

.
llOOOO\
lOl\
ll
=
&
llOOlOOlOll
->
lOOl\
lO\
llO\
lOO
;
llOOl\
OOlOll
->
lOOl\
l\
O\
ll\
Ol\
OO
=
&
lOlOOOO\
O\
llOO
->
lOl\
O\
OOOlOlOl
;
lOlOOOOO\
llOO
->
lOl\
O\
O\
O\
OlO\
l\
Ol
.
lO\
l\
OOO\
O\
Ol\
lOO\

=
lOlOOOOO\
ll\
OO
;
ll\
OOlOO\
lOll
->
lOOll\
Ol\
lO\
lOl
++
;
retur\
n\

lOlO\
O\
OO\
OllOO\

;
}
void\

Dyna\
m\
icObj\
ect
::
lOlOOOOlO\
l\
lO
(
in\
t
lOlOOOOlO\
ll\
l
)
{
for\

(
lO\
lO\
O\
O\
OOlOlO
*
lOlO\
OOOOlOll
=
lOOl\
lOl\
lOlO\
O
;
lO\
lOOO\
O\
Ol\
Oll
;
lOlOOOOOlOll
=
lOlO\
OOOOl\
Ol\
l
->
llOOOlOOOOl
)
{
lOl\
OOOOOO\
ll\
l
*
lO\
lOOOO\
OllOO
=
lOlO\
OOOOlOll
->
lOlOOOOOll\
O\
O
;
lOlO\
OOOO\
l\
lO\
O
->
lOl\
O\
OOO\
O\
l\
lO\
l
->
lO\
lO\
O\
OO\
llOO\
O
(
lOlOOOO\
lO\
lll
)
;
if
(
lOlOOOOOll\
O\
O
->
lOlOOO\
OOlllO
)
lOlOOO\
O\
Oll\
OO
->
lO\
l\
OOOOO\
ll\
lO
->
lOl\
OOO\
OllO\
O\
O
(
lO\
l\
O\
OOOl\
Ol\
ll
)
;
}
}
voi\
d\

Dyn\
a\
mic\
Ob\
ject
::
lO\
lOO\
O\
OllOOl
(
int
lOlOOOOl\
Ol\
ll
)
{
{
JointIt\
er\
ator
lOlOOlOO\
lO
=
lO\
OllOl\
llOOl
.
lOlOOOO\
lOO
(
)
;
for
(
;
!
lO\
lOOlO\
OlO
.
AtEnd\

(
)
;
++
lO\
lOOlOOlO
)
{
Phy\
si\
cs\
Joi\
nt
*
lOlll\
OOl\
OlO\

=
&
*
lOlO\
O\
lOO\
l\
O
;
if\

(
lOl\
llOOlOl\
O
->
IsCol\
lisio\
nD\
isabled\
BetweenObj\
e\
c\
ts
(
)
)
{
TA_ASSER\
T
(
lOl\
l\
lO\
O\
lO\
lO
->
Ge\
tObj\
ec\
tA\

(
)
==
this
)
;
if
(
lOll\
lOOlOl\
O
->
GetObj\
ectB
(
)
)
lOlll\
O\
Ol\
OlO
->
Ge\
tObject\
B
(
)
->
lOlO\
O\
OOllOOO
(
lO\
l\
O\
OOOlOl\
ll
)
;
}
}
}
{
List
<
Phys\
icsJoin\
t
*
>
::
Iterator
lO\
lO\
OlOOl\
O
=
lO\
OllOl\
l\
l\
OlO\

.
lO\
lO\
O\
O\
OlO\
O
(
)
;
for
(
;
!
lO\
l\
OOlOOlO\

.
At\
End\

(
)
;
++
lO\
lO\
OlOO\
l\
O
)
{
PhysicsJ\
o\
i\
nt
*
&
lOll\
lOO\
lO\
l\
O
=
*
lOl\
OOlO\
OlO
;
if\

(
lOlllOOlOl\
O\

->
IsCo\
llis\
ion\
D\
is\
ab\
led\
Bet\
weenObjects
(
)
)
{
TA_ASS\
ERT\

(
lOlllO\
OlOl\
O\

->
GetObjectB
(
)
==
this
)
;
TA_ASSE\
RT
(
lOlll\
OOlOlO\

->
GetObje\
ctA
(
)
)
;
lOll\
lO\
OlOlO
->
Ge\
tObje\
ct\
A
(
)
->
lOlO\
OOOllO\
OO\

(
lOlO\
O\
OO\
lO\
ll\
l
)
;
}
}
}
}
void
Dyn\
am\
icO\
b\
je\
ct
::
lOl\
OOOOll\
OlO
(
void\

(
TA\
C_CALL\

*
lOl\
O\
OOO\
ll\
Oll
)
(
lOlOOOOO\
Olll
&
lOl\
OOOOl\
llOO
,
voi\
d
*
lOOlll\
OOO\
O\

)
,
void
*
lO\
Oll\
lOOOO
)
{
TA\
_A\
S\
SERT\

(
lO\
l\
OOOO\
llOll
)
;
for
(
lO\
lOOOOOl\
OlO
*
lOlO\
OOOOlOl\
l\

=
lOO\
l\
l\
Ol\
lOlO\
O
;
lOlOO\
OOOlOll
;
lOlO\
O\
OOOlOl\
l\

=
lOlO\
OOO\
O\
lOll
->
llOO\
OlOOOOl
)
{
lOlOOOOOOlll
*
lOlOOO\
OO\
llOO
=
lOlO\
OOOO\
lOll
->
lO\
l\
OOOOOl\
lOO
;
TA_A\
SSERT
(
lOlOOO\
OOllOO
)
;
lO\
lOOOO\
llOll\

(
*
lOlO\
OOOO\
ll\
OO
,
lOOll\
lOOO\
O
)
;
}
}
void
Dy\
namicObj\
e\
ct
::
lO\
lO\
OOOlll\
Ol
(
)
{
lOlOO\
OO\
OlOl\
O\

*
lO\
lOO\
O\
OOl\
Oll
=
lOOll\
Oll\
OlOO
;
fo\
r
(
;
lO\
lO\
OOOO\
lOll
;
)
{
lOlOO\
OOOOl\
ll
*
lO\
lOO\
O\
OOll\
OO\

=
lOlOOO\
OOlOl\
l\

->
lO\
lOOO\
OO\
llOO
;
lOlO\
OO\
OOlOll
=
lO\
lOOO\
O\
O\
lOll
->
llOO\
OlOO\
OOl
;
TA_ASSERT\

(
lOOllOl\
lllOO
)
;
lOO\
llOl\
lll\
OO
->
GetPhys\
ic\
s
(
)
.
lOlOOOOlOOOO
(
)
.
lO\
l\
OOO\
Ol\
lll\
O
(
*
lOlOO\
OOOll\
OO
)
;
}
}
void\

DynamicObje\
ct
::
lOlO\
OO\
O\
l\
l\
lll
(
)
{
lO\
lOOOOOl\
OlO
*
lOlOOOO\
OlOl\
l
=
lOOllO\
llOlO\
O
;
for
(
;
lOlOOOOO\
lOll
;
)
{
lOlOOOOOO\
l\
ll
*
lOlOOOO\
OllO\
O\

=
lO\
lOO\
OO\
OlOll
->
lO\
l\
OO\
O\
O\
O\
ll\
O\
O
;
lOl\
OO\
O\
O\
O\
lOll
=
lOlO\
OOOOlO\
ll
->
llOOOlOOOO\
l
;
TA_\
ASSE\
RT
(
lOOl\
lOllll\
OO
)
;
if\

(
(
lOlOOO\
O\
Oll\
O\
O
->
lOlO\
OOOOll\
Ol
->
lOlOOOlOOOOO
(
)
||
lOl\
OOOOO\
llOO
->
lOlOOO\
OO\
llOl
->
lOlO\
OOl\
OOO\
O\
l\

(
)
)
&&
(
lOlO\
OOOOllO\
O\

->
lOlOO\
OOOlll\
O
->
lO\
lOOO\
lO\
OOO\
O
(
)
||
lOlO\
OOOOl\
lOO
->
lOlOOOOOlll\
O
->
lOlOOOlO\
O\
O\
Ol\

(
)
)
)
{
lOO\
llO\
ll\
l\
lOO\

->
GetPh\
ysics
(
)
.
lOl\
OOOOl\
OOOO
(
)
.
lOlOOOlOOOlO
(
*
lOlOO\
O\
OO\
l\
lOO
)
;
}
}
}
void
Dy\
nami\
c\
Object
::
lO\
lOOO\
lO\
OOll
(
)
{
lOlO\
OOO\
OlO\
lO\

*
lOlOO\
OOOlO\
l\
l
=
lOOl\
lOllO\
lOO
;
for
(
;
lO\
lOO\
OOOlO\
ll\

;
)
{
lOlOOO\
O\
OO\
l\
l\
l
*
lO\
lO\
OO\
OO\
ll\
OO
=
lO\
lOOO\
OOl\
Oll\

->
lOlO\
OOOO\
llOO
;
lOlOOOOOlOl\
l\

=
lOlOO\
OO\
O\
lOll
->
llOOOl\
OOOOl\

;
if
(
!
lOlOOOOOllOO
->
lOl\
O\
OOOOllOl\

->
IsInMovin\
gLi\
st
(
)
&&
!
lOlO\
OOO\
OllOO
->
lOlOOO\
OOll\
lO\

->
Is\
InM\
ovin\
g\
Li\
st
(
)
)
{
TA_ASSER\
T
(
lOOllOllllOO
)
;
lO\
Oll\
OllllO\
O\

->
GetPhysics\

(
)
.
lOl\
OO\
OOl\
O\
OO\
O
(
)
.
lOlOO\
O\
OllllO
(
*
lOlOOOOOllOO\

)
;
}
}
}
void\

Dynam\
icO\
bject
::
lOlOOO\
lO\
OlO\
O
(
lOl\
OO\
OO\
OOlll
&
lOlOOO\
O\
lllOO\

)
{
lOOl\
l\
OllO\
lOl\

--
;
TA_ASS\
E\
RT\

(
lOlO\
OO\
OlllOO
.
lOlO\
OOO\
O\
llO\
l
==
th\
i\
s
||
lOl\
OOOOlllOO\

.
lOlO\
OOOO\
lllO\

==
this
)
;
TA_\
ASSERT
(
lO\
Oll\
O\
llOlOl
>=
0
)
;
}
vo\
i\
d
DynamicO\
bject\

::
lOlOOO\
l\
OOlOl
(
)
{
lOOllOlOlOOl
=
lO\
O\
lOllll\
O\
ll
;
lOOllOlOl\
OlO
=
lOOlO\
l\
l\
lll\
Ol
;
}
void
Dy\
namicOb\
je\
ct
::
lOlOOO\
lOOllO
(
)
{
lO\
O\
lO\
ll\
llOll
=
lOOl\
l\
OlOl\
O\
Ol
;
lOOl\
Olll\
llOl
=
lOOllOl\
OlO\
lO
;
}
void
Dynami\
cOb\
j\
ect
::
lOlO\
OO\
lOOl\
ll
(
flo\
a\
t
lOOl\
llOOllll
,
float
lOlOOOlOlOOO
)
{
lOOlllOllOO\
O
+=
(
lOO\
lOllll\
Oll\

*
lOOlllOO\
llll\

-
lOOlllOllOOO
)
*
lOlOOOlO\
lOOO
;
}
void\

Dynami\
cO\
bje\
ct
::
lOl\
O\
OOlOlOO\
l
(
)
{
TA_ASSERT\

(
lOOl\
lOllllOO
)
;
{
Joi\
ntI\
te\
rato\
r\

lO\
lOO\
lOOl\
O
=
lOOl\
lOll\
l\
OOl
.
lO\
lOOOOlO\
O
(
)
;
for
(
;
!
lOlOOlO\
O\
lO\

.
AtE\
nd
(
)
;
++
lO\
lOOlOO\
lO
)
{
Phy\
s\
icsJoin\
t
*
lOl\
l\
lO\
OlOlO
=
&
*
lOlO\
OlOOl\
O
;
TA_ASSERT\

(
lOlllOO\
lOlO
->
Ge\
tOb\
ject\
A\

(
)
==
this
)
;
if
(
lOl\
l\
lOOlO\
lO
->
GetO\
bjectB
(
)
)
{
if
(
!
lO\
lllO\
OlOlO
->
Ge\
tObj\
ectB
(
)
->
IsInMovin\
gL\
is\
t\

(
)
&&
lO\
lllOOlO\
lO
->
GetOb\
je\
ctB
(
)
->
Ad\
ded\
T\
oPh\
y\
sics
(
)
)
{
lOOllOll\
ll\
O\
O
->
Ge\
tPhys\
ic\
s\

(
)
.
SetD\
ynami\
c\
Obje\
ctIs\
Mov\
ing\

(
lOlll\
OOlOlO
->
Ge\
tO\
bje\
ctB\

(
)
)
;
}
}
}
}
{
Li\
s\
t
<
Phys\
i\
csJoint
*
>
::
It\
e\
rat\
or\

lOl\
O\
O\
lO\
Ol\
O
=
lO\
Ol\
lO\
l\
llO\
lO\

.
lOlO\
O\
O\
O\
lOO\

(
)
;
for\

(
;
!
lOlOOl\
OO\
lO
.
AtEnd
(
)
;
++
lO\
lOOl\
OOlO\

)
{
Ph\
y\
si\
csJo\
int
*
&
lOll\
lOOl\
OlO\

=
*
lOl\
O\
OlO\
Ol\
O
;
TA_\
ASSERT
(
lOl\
l\
lOO\
l\
OlO
->
Ge\
tOb\
jectB
(
)
==
this
)
;
if
(
!
lOlllOOlO\
lO
->
GetObjectA
(
)
->
IsInMo\
ving\
L\
is\
t
(
)
&&
lOll\
lOOlOlO
->
GetObjec\
t\
A
(
)
->
Ad\
dedT\
oP\
h\
y\
sics
(
)
)
{
lOO\
llOllllOO
->
GetPh\
y\
sics\

(
)
.
Set\
D\
y\
n\
amicOb\
jectIsMo\
ving
(
lOl\
l\
lOOl\
O\
lO
->
Get\
ObjectA
(
)
)
;
}
}
}
}
vo\
id
Dy\
na\
micObj\
ec\
t
::
lOlOOO\
l\
OlOlO
(
)
{
}
voi\
d
Dyn\
ami\
cObject
::
lOl\
OOO\
lOlO\
ll\

(
DynamicObject
*
llOOlOO\
lOll\

)
{
flo\
at
lOl\
OO\
Ol\
OlO\
O
=
(
GetC\
e\
nterO\
f\
Mass\

(
)
-
ll\
O\
OlO\
Ol\
O\
ll
->
GetCenterO\
fMa\
ss\

(
)
)
.
Dot
(
lOOllOll\
llO\
O
->
GetPhysics\

(
)
.
GetGravi\
ty
(
)
)
;
flo\
at
llOlOll\
O\
OOO
;
llOlO\
ll\
OOOO\

=
0.05f
;
fl\
oa\
t\

lOlOO\
OlOll\
OO
=
lO\
Oll\
OOl\
lO\
ll\

*
llO\
lOllOOOO\

;
ll\
O\
OlOOlO\
l\
l\

->
lO\
O\
l\
lOOll\
Oll
=
Max
(
llOOlOOlOll
->
lOOllO\
OllOl\
l
,
lOlOOO\
l\
O\
llOO\

)
;
}
void
Dynam\
icOb\
j\
ect
::
lO\
lO\
OOlOllOl
(
float
lOlO\
OOlOlllO
,
float
lO\
lOOOl\
Oll\
ll
)
{
float
lO\
OOOOlll\
O\

=
GetLinear\
V\
el\
oc\
ity
(
)
.
GetMagnitu\
de
(
)
+
Get\
A\
ngular\
Veloc\
it\
y
(
)
.
Get\
Magnitude
(
)
;
lO\
O\
OOOlllO
*=
50.0f
*
GetMass\

(
)
;
if
(
lOOOOO\
lllO
>
lOOllOO\
llOl\
l
)
lOOll\
OOl\
lOll\

+=
(
lOOOOOll\
l\
O
-
lOO\
l\
l\
OO\
ll\
O\
ll
)
*
lOlOO\
O\
lOlllO\

;
els\
e
lOOl\
l\
O\
OllOll\

+=
(
lOOOOOlllO\

-
lOOllO\
OllOll
)
*
lO\
lOOOlOl\
lll
;
}
void
Dy\
nami\
cObj\
e\
ct
::
lO\
lO\
OOl\
lOOO\
O
(
)
{
TA\
_AS\
SER\
T\

(
lOOl\
l\
O\
llllOl\

==
0
)
;
if
(
!
lOOllOllll\
Ol
)
{
lOO\
OllllOO
(
lO\
Ol\
l\
OllllO\
l
,
u8
,
lO\
lOOOll\
O\
OOl
)
;
}
}
void\

Dyna\
micObject
::
lOlOOOllO\
OlO\

(
)
{
TA_AS\
SE\
RT\

(
lO\
O\
llO\
llll\
Ol
)
;
if
(
lOOllO\
l\
lllOl
)
{
lO\
lO\
O\
Olll\
O\

(
lOOllO\
ll\
llO\
l
,
u8
)
;
lOO\
llO\
l\
lll\
Ol
=
0
;
}
}
void
Dyna\
m\
icO\
bj\
e\
ct
::
lO\
Ol\
l\
lO\
O\
O\
OOl
(
)
{
fo\
r
(
lOlOOOO\
OlO\
lO
*
lOl\
OO\
O\
OOlOll
=
lOOllO\
ll\
OlOO\

;
lO\
lOO\
O\
OOl\
Ol\
l
;
lO\
lO\
OOO\
OlO\
ll
=
lO\
lOOO\
OOlOll
->
ll\
O\
OOlO\
OO\
Ol
)
{
lO\
lOOOO\
OOlll
*
lOl\
OOOOOll\
O\
O
=
lOlOOOO\
OlOll
->
lOlOOO\
OOllOO\

;
lOlO\
O\
OOOll\
OO
->
lO\
lOl\
lOOll
|=
lOl\
O\
O\
OO\
OO\
l\
ll
::
lOlOOO\
ll\
O\
Oll
;
}
}
bool
Dyna\
micObj\
ect
::
IsAllow\
e\
dToC\
ollideWi\
t\
h
(
con\
st\

Dyn\
a\
mi\
c\
Obj\
e\
c\
t
&
lOlOOOllOl\
OO\

)
con\
s\
t
{
if
(
lOOllO\
lOlll\
O
!=
lO\
l\
OO\
Ol\
lOlOO
.
lOOllOlOl\
llO
)
ret\
ur\
n
tr\
ue
;
if
(
lO\
O\
llOl\
lO\
OOO
&
lOlOO\
OllO\
lO\
O
.
lOOllOl\
Ollll
)
retu\
rn
fals\
e\

;
el\
se
retu\
rn\

tr\
ue
;
}
vo\
i\
d
Dyna\
mic\
Object\

::
Set\
U\
se\
rGrou\
pIt\
emId
(
int
lOlOOOllOlOl
)
{
lO\
OOOOO\
llO
(
lOlOOOllOl\
O\
l
>=
0
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lO\
OO\
OO\
O\
ll\
O
(
lOlOO\
O\
l\
lOlOl
<
32
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOO\
llOlOll\
ll\

=
1
<<
lO\
l\
OO\
Oll\
OlOl
;
}
void\

Dy\
n\
ami\
c\
Ob\
ject\

::
Di\
sa\
llowC\
olli\
s\
i\
o\
n\
WithU\
ser\
Gr\
oupI\
temId\

(
int
lOlO\
OOl\
lOlOl
)
{
lOOOOO\
OllO
(
lOl\
OO\
Oll\
OlOl
>=
0
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOOOO\
OOllO
(
lO\
lOOOl\
lOlOl\

<
32
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOOl\
l\
O\
llOO\
O\
O\

|=
1
<<
lOl\
OO\
Ol\
lOlO\
l
;
}
vo\
id
Dyn\
a\
mi\
cO\
bject
::
Al\
low\
Coll\
isio\
nWit\
h\
U\
ser\
G\
r\
oupI\
t\
emI\
d\

(
int
lO\
lOOOllOlOl
)
{
lOO\
OOOOl\
l\
O
(
lOlOO\
O\
ll\
Ol\
O\
l
>=
0
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOOO\
OOOllO\

(
lOlO\
OOllOlOl
<
32
,
"DynamicObject::SetUserGroupItemId. Invalid value for nUserGroupItemId.")
;
lOOllOllOOOO\

&=
~
(
1
<<
lOl\
OOOllO\
lOl\

)
;
}
int
Dy\
namicO\
bject
::
Cre\
ate\
Use\
rGrou\
p\

(
)
{
static
in\
t
lOlOOOllOll\
O
=
0
;
return\

++
lOlOOOllOl\
lO
;
}
Dyn\
amicObje\
ct
*
TA\
C\
_C\
ALL
Dynam\
icO\
bjec\
t
::
Cr\
eateNew
(
)
{
DynamicOb\
ject\

*
lOl\
OllOlOOl
;
lOOOOOl\
lOlO
(
lOlOllO\
l\
OO\
l
,
DynamicObject
)
;
retu\
rn\

lOlO\
l\
lOl\
OO\
l
;
}
Dynam\
icObject\

::
Dyna\
micObjec\
t
(
)
:
Phys\
icsObje\
ct
(
)
,
Spa\
ceD\
iv\
isi\
onObject
(
)
{
lOOllOllllOO\

=
0
;
lOl\
OlOlO\
lOO\

=
0.0f
;
lO\
OlO\
llll\
lOO
=
0.0f
;
lO\
O\
ll\
OO\
l\
lO\
OO\

.
SetT\
oId\
ent\
it\
y
(
)
;
lOOllOO\
ll\
OOl\

.
SetToIdent\
it\
y
(
)
;
lOO\
l\
l\
OOl\
ll\
Ol
.
Se\
tToI\
dentity
(
)
;
lOOllOOllllO\

.
SetToId\
ent\
ity
(
)
;
lOOl\
l\
OO\
lll\
ll
=
1.0f
;
lO\
O\
l\
lOlOOO\
OO
=
-
1.0f
;
lOO\
l\
llO\
lOlOl
=
1.0f
;
lOOllOl\
OOOOl\

=
0.0f
;
lOO\
l\
l\
OlO\
OOlO
=
1.0f
;
lO\
OllOlOOO\
l\
l
=
0
;
ll\
lO\
llOOOO
=
0
;
lOOllOlOO\
lOO
=
0
;
lOOl\
l\
Ol\
OOlOl
.
Cl\
e\
ar
(
)
;
lO\
OlO\
lllOlOl
.
Clear
(
)
;
lOOllOlOOllO
.
Clear
(
)
;
lO\
O\
ll\
Ol\
O\
O\
l\
ll\

.
Cle\
ar
(
)
;
lOOl\
lOl\
Ol\
O\
OO
.
Cle\
ar\

(
)
;
lOOll\
Ol\
llllO
.
Cl\
ear
(
)
;
lOO\
llOlllll\
l\

.
Cle\
ar\

(
)
;
lOO\
l\
llOOOO\
OO
.
Cl\
ear\

(
)
;
lOOlOllllOll
.
Cle\
ar
(
)
;
lO\
OlOllll\
lO\
l
.
Cle\
a\
r\

(
)
;
lO\
OllOlOl\
O\
O\
l
.
Clear
(
)
;
lOO\
llO\
lOl\
O\
l\
O
.
Clear\

(
)
;
lOOl\
lO\
l\
OllOO
=
0
;
lOOllO\
lO\
llO\
l
.
In\
itialis\
e\

(
k_\
v3Z\
ero\

,
k_v\
3Zer\
o
)
;
lOO\
l\
lOl\
O\
lllO
=
-
1
;
lOOllOlOlll\
l
=
0
;
lOO\
llOl\
lO\
OO\
O
=
0
;
lO\
OllOO\
lOl\
lO
=
0
;
lO\
O\
llO\
llO\
OOl
=
0
;
lOOllO\
l\
lOOlO\

=
0
;
lO\
Oll\
O\
llOOll
=
0
;
lO\
O\
llO\
ll\
Ol\
O\
O
=
0
;
lOOllOllOlOl\

=
0
;
lOOl\
lOllOl\
lO\

=
0
;
lOOllOl\
lOll\
l
=
-
1
;
lOOl\
lOll\
llO\
l\

=
0
;
}
Dy\
nam\
i\
c\
O\
bjec\
t
::
~
Dynamic\
Object
(
)
{
Fin\
alise
(
)
;
}
voi\
d
Dynam\
ic\
Object
::
Initia\
l\
iseCommon\

(
)
{
TA\
_ASSE\
RT
(
lOOl\
lOl\
lllOO
==
0
)
;
lOlOOOll\
Olll\

=
lOOll\
OOlO\
l\
OO
++
;
TA_\
ASS\
ER\
T
(
(
s32
)
lOlO\
OOllOlll
>
0
)
;
TA_A\
SSE\
R\
T
(
lO\
Oll\
OlO\
OOOl
==
0.0f
)
;
TA_\
A\
SSE\
RT\

(
lO\
OllO\
lO\
O\
OlO\

=
1.0f
)
;
TA_ASSERT
(
lOOl\
lO\
lO\
OOll\

==
0
)
;
TA_A\
S\
SE\
RT\

(
ll\
lO\
llOO\
OO
==
0
)
;
lllOll\
OOOO
|=
lOlOOOlllOO\
O
;
lOOllO\
lOll\
l\
O\

=
-
1
;
lO\
OllOlOllll
=
0
;
lOO\
l\
lOllOOOO
=
0
;
lOOl\
lOOllll\
l\

=
1.0f
;
lO\
O\
ll\
OlOO\
OOO
=
-
1.0f
;
lO\
OlllOlOlOl
=
1.0f
;
lO\
O\
llOlOlOll\

=
0
;
lOOllOll\
OlOO
=
0
;
lOOllOl\
l\
OlOl
=
0
;
lOOl\
lOl\
lOllO
=
0
;
lO\
Oll\
O\
llO\
ll\
l
=
-
1
;
lOOllOOllOlO
=
1.0f
;
lOOllOO\
ll\
Oll
=
0.0f
;
TA\
_AS\
S\
E\
R\
T
(
lO\
O\
llO\
llllOl
==
0
)
;
}
voi\
d
Dyn\
amicO\
bj\
ect
::
Cl\
e\
a\
rL\
ineIntersec\
t\
ions
(
)
{
fo\
r\

(
int
lll\
OO\
OOl\
O\
O\

=
0
;
lll\
OOO\
OlOO
<
lOOllOlllOO\
O
.
lOO\
Oll\
lOOl
(
)
;
lllOOOO\
lOO
++
)
{
Li\
neIn\
t\
ers\
ec\
tion
&
lOOl\
l\
l\
llOO\
OO
=
lOOl\
lOlllOOO\

[
lllOOOOlOO
]
;
lO\
Ollll\
l\
OOOO
.
lOl\
l\
OO\
lOOll\

=
-
1.0f
;
if
(
lOOl\
llll\
OOO\
O
.
lOlll\
O\
O\
lO\
OO
)
{
lOOlllllOO\
OO\

.
lOlllOOl\
OO\
O
->
Re\
l\
ease
(
)
;
lOOlllll\
OOO\
O\

.
lOl\
l\
l\
OOlOOO
=
0
;
}
if
(
lOOlllllOOO\
O\

.
lO\
lO\
l\
lOO\
Oll
)
{
lOOlllllOOOO
.
lOlO\
llOOO\
ll
->
Releas\
e
(
)
;
lOOlllllO\
OOO
.
lO\
lOll\
O\
OOll\

=
0
;
}
}
}
}

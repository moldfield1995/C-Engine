//---------------------------------------------------------------------------------
// File Name: zpta024.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#define lOllOllOOlO
#include "../Physics/zpta011.h"
#ifndef TA_RANDFUNC_H
#include "../Common/RandFunc.h"
#endif //
#ifndef lOOOOlOlOl
#include "../Common/zcta006.h"
#endif //
#ifndef TA_STACKALLOC_H
#include "../Common/StackAlloc.h"
#endif //
#ifndef llllOOOOlll
#include "../Physics/zpta010.h"
#endif //
#ifndef llOOllOOOOl
#include "../Physics/zpta001.h"
#endif //
nam\
espace
TA
{
co\
ns\
t
fl\
o\
at
ll\
OOlOll\
O\
OOO
=
0.05f
;
const
flo\
at\

llOOlO\
l\
lOO\
Ol
=
llOOlOllO\
OOO
*
llOOlOl\
lOO\
O\
O
;
co\
nst\

float
llO\
OlO\
llOOlO
=
0.1f
;
typedef
float
llO\
OlOll\
OOll
;
type\
def
lOlO\
OOOOOlll
*
ll\
OOlOllO\
lOO
;
#ifdef TA_MSVC
#pragma pack(push, 4)
str\
u\
ct
llOOl\
Ol\
lO\
lOl
{
llO\
OlOllOO\
ll\

lOOOlOO\
ll\
O
;
llO\
OlO\
llOlOO\

lOOlllOOO\
l\

;
}
;
#pragma pack(pop)
#else
str\
uct\

llOO\
l\
O\
llOl\
Ol\

{
llOOl\
O\
llOOll
lOOOlOOl\
lO\

;
ll\
OOl\
OllO\
lOO\

lOO\
lllOOOl\

;
}
;
#endif
void\

lOl\
l\
OllO\
O\
OO
(
Coll\
isi\
on
*
lOllOllOOO\
l
,
Co\
llisio\
n
*
lOO\
O\
OOlO\
OOl\

)
{
TA\
_ASSERT
(
lO\
OO\
OOlOOO\
l
->
lOOO\
O\
O\
l\
OOO\
l
==
0
)
;
lOO\
OOO\
lOOOl
->
lOOOOOl\
OOOl
=
lOll\
Ol\
lOOOl\

->
lOOOO\
OlOOOl
;
lOllOllOOOl
->
lO\
OOOOlOO\
O\
l
=
lOOOOO\
lO\
O\
O\
l
;
}
lOlOl\
l\
llOOOO
::
lO\
lO\
llllO\
OOO\

(
)
{
lOOl\
l\
Oll\
llOO
=
0
;
ll\
O\
O\
l\
Ol\
lOllO
=
0
;
llOO\
lOl\
lO\
lll
=
0
;
lO\
llO\
lOllOll
=
0
;
llOOlOll\
lOOO\

=
fa\
l\
se\

;
ll\
OOlOlllOOl\

=
fals\
e\

;
}
lOlOllllOOOO
::
~
lOlO\
llllO\
OOO
(
)
{
Finalise\

(
)
;
}
voi\
d
lOlOlll\
l\
O\
OOO
::
lOl\
l\
l\
lOl\
lOOO
(
boo\
l
llOOlOlllOl\
O
,
in\
t
lOllOllOlOO\
l
)
{
TA_ASSE\
RT
(
lOOl\
l\
OllllO\
O\

)
;
Phys\
ics
&
lO\
lOlOlOOlll
=
lOOl\
lOllll\
O\
O
->
GetPh\
ysi\
c\
s\

(
)
;
co\
nst
in\
t
llOO\
lOl\
l\
lOll\

=
lOOll\
OllllOO
->
lOl\
OllllOl\
Ol
>
lOO\
ll\
Ol\
ll\
lOO
->
lO\
l\
Oll\
ll\
Ol\
OO\

?
lO\
OllOll\
l\
lOO
->
lOlOl\
lllOlOl
:
lOO\
llO\
ll\
l\
lOO
->
lOlOl\
lllOlOO\

;
lOOlll\
O\
O\
Oll\

(
llOO\
l\
OllOlOl
,
lOl\
llOOOOlO\
O
,
llOOlO\
lllOll
)
;
Vec3\

llO\
OO\
ll\
OOOlO
=
lOlOlO\
lOOlll
.
Ge\
t\
G\
ravit\
y
(
)
;
float
ll\
OOOllOOOll\

=
lOlOlOlOOl\
l\
l
.
GetG\
ravity\

(
)
.
GetM\
agnitud\
e
(
)
;
ll\
OO\
Oll\
OOOll\

*=
0.2f
;
llO\
OOll\
OOOlO
.
x
+=
Ran\
dF\
unc\

::
Ta\
Rand\
Betw\
eenPosNeg
(
ll\
OOO\
llOO\
Oll
)
;
llO\
OOllOOOlO
.
y
+=
Rand\
F\
u\
nc
::
TaRa\
nd\
Be\
t\
weenPosN\
eg
(
llOOOll\
OOO\
l\
l
)
;
llOO\
O\
l\
lOOOlO
.
z
+=
Ra\
ndFunc
::
TaRandB\
et\
w\
e\
enPo\
sNeg
(
llOOOl\
lOOOll
)
;
if\

(
!
lOllO\
llO\
ll\
l\
O
(
)
)
{
int\

lOl\
llOO\
OOOll\

=
0
;
lOlOll\
lOl\
O
<
lO\
lO\
OOOOOlll
>
::
lOlOl\
llOll
::
It\
erator
lO\
ll\
llOO\
lOOl
=
llOOlOllllOO
.
lOlOOOO\
lOO
(
)
;
whi\
le\

(
!
lOl\
lllOOlOOl
.
AtEnd\

(
)
)
{
lO\
lOO\
OOOOl\
l\
l
&
lOlO\
OO\
OlllOO
=
*
lO\
ll\
llO\
OlOOl
;
++
lOllll\
OO\
lOO\
l
;
TA_AS\
SER\
T
(
lOlllO\
OO\
OOll
<
lO\
OllOl\
l\
llOO
->
lOlOllllOl\
Ol
)
;
ll\
OOlOll\
OlOl
&
lOOlO\
OllllO
=
lOl\
llOOOOlO\
O
[
lOl\
llO\
O\
O\
O\
O\
ll
++
]
;
lOOlOOllllO
.
lO\
OlllOOO\
l
=
&
lOl\
O\
OOOlllOO\

;
lOO\
lO\
Oll\
llO
.
lOOOlOOllO
=
0.0f
;
int
ll\
OO\
l\
O\
Ol\
O\
O\
l\
O
=
0
;
lOlOlllOlO\

<
Col\
lisi\
on
>
::
lOlO\
l\
llOll\

::
Iterator\

lOlOlllO\
O\
OlO
=
lOlO\
OOOl\
llO\
O\

.
lOlO\
l\
llOOlO\
l\

.
lO\
lOOOOlOO
(
)
;
fo\
r
(
;
!
lOlOl\
llOOOl\
O
.
AtEnd
(
)
;
++
lO\
lOl\
llOOOlO
)
{
Co\
llis\
ion\

&
ll\
O\
llllOl\
l\
l
=
*
lOlO\
l\
ll\
OOO\
lO
;
lO\
OlOOllll\
O
.
lO\
OOlO\
OllO
-=
llO\
OO\
llOOOl\
O
.
Do\
t
(
llOl\
l\
l\
lOl\
ll
.
lOOO\
Ol\
llll
)
;
llOOlOOlO\
Ol\
O
++
;
}
if
(
llOO\
l\
OOlO\
O\
lO
)
lOOlOO\
ll\
ll\
O
.
lO\
OOlOO\
l\
lO\

/=
(
fl\
oa\
t\

)
llOOlOOlO\
OlO
;
ll\
OOl\
Ollll\
O\
O
.
lOOl\
ll\
llll
(
&
lOl\
OOOOl\
l\
lOO
)
;
}
lOOOlll\
llO
<
llOOlOllOl\
Ol
>
::
lO\
OO\
l\
l\
ll\
ll
(
lO\
lllO\
OOOlOO
,
lOl\
llOO\
O\
OOll
)
;
for\

(
int
lOOOllOOO\
l
=
lOl\
llOOOOOll\

-
1
;
lO\
O\
OllOO\
Ol
>=
0
;
lOOOllO\
OOl
--
)
{
llO\
O\
lOl\
l\
O\
lOl\

&
lO\
O\
lO\
O\
llllO
=
lOll\
lOO\
O\
Ol\
OO
[
lOOOllOOOl\

]
;
TA_\
A\
S\
SERT
(
(
lOOl\
OOllllO
.
lO\
OlllO\
OOl
->
lOlO\
llO\
Oll\

&
lOlOO\
OOOOl\
ll
::
lOlOllllOOOl
)
==
0
)
;
llOOlOllll\
OO\

.
lOlOlOO\
OOl
(
lO\
O\
lO\
Ol\
lllO
.
lOOlll\
O\
OOl
)
;
}
}
if\

(
!
lOl\
l\
Ol\
lOll\
lO
(
)
||
lOllO\
llOlOOl
!=
0
)
{
in\
t\

lOlllOO\
OOOll
=
0
;
ll\
O\
OOO\
OOlllO
ll\
OOl\
OllllOl
=
llOOlOlllllO
.
lO\
lOOOOlO\
O
(
)
;
wh\
ile\

(
!
llOO\
lOllll\
Ol
.
AtEnd
(
)
)
{
Dyn\
ami\
cObject
*
&
lO\
ll\
lOOl\
OOO\

=
*
llOOlOlll\
lOl
;
++
llOO\
lOl\
lllOl
;
if
(
lOllOllOlllO
(
)
&&
lO\
lllOOlO\
OO
->
GetJoin\
tI\
terator
(
)
.
AtE\
nd\

(
)
&&
lOlllO\
O\
lOO\
O\

->
lO\
lOOl\
l\
OlO\
OO
(
)
.
AtEnd\

(
)
)
contin\
ue
;
TA_ASS\
E\
R\
T\

(
lOll\
lOO\
OOOll\

<
lOO\
l\
l\
Ol\
lllOO
->
lOlOllllOlOl
)
;
llO\
O\
lOllO\
l\
Ol
&
lOOlOOl\
lllO
=
lOll\
lOOOO\
l\
OO
[
lOlllOO\
O\
OOll
++
]
;
lO\
OlOOl\
lllO
.
lOOl\
llOO\
Ol
=
(
lOlOO\
OOOOl\
l\
l\

*
)
&
lOlll\
OO\
lO\
OO
;
int
lOlOl\
O\
OOlOlO
=
lOlllOOlOOO\

->
GetID\

(
)
;
lOOl\
O\
Ol\
lllO
.
lOOOlOO\
llO
=
(
float\

)
lO\
lOlO\
OOlO\
lO
;
ll\
OOlOlllllO
.
lOOlll\
llll
(
&
lO\
lllOOlOOO
)
;
}
lOO\
O\
llll\
lO
<
llO\
OlOllO\
l\
Ol
>
::
lO\
OOllllll
(
lOll\
lOO\
OOlOO
,
lOlllOOOOOl\
l\

)
;
for
(
int\

lO\
OOllOOOl
=
lOl\
ll\
OOOOOll
-
1
;
lOOOll\
OO\
Ol\

>=
0
;
lOOOl\
lOOOl
--
)
{
llOOlOll\
Ol\
Ol\

&
lO\
OlOOllllO
=
lOl\
llOOOOlOO\

[
lOOOllO\
OOl
]
;
llOOlOlll\
ll\
O
.
lOl\
OlO\
OOOl
(
(
Dyn\
amicObject
*
*
)
lOOlOOllllO
.
lOOll\
l\
O\
O\
Ol
)
;
}
}
#ifdef llOOlOllllll
llOOlOllO\
l\
Ol\

lOlllOOOOl\
OO
[
lOOl\
lOl\
lllOO\

->
lOl\
OllllOOll
]
;
int\

lOll\
lOOOO\
O\
ll
=
0
;
fo\
r
(
Itera\
t\
o\
r
lO\
lOOlOOlO
=
lOl\
O\
O\
OO\
lOO
(
)
;
!
lOl\
OOlO\
Ol\
O
.
AtEnd\

(
)
;
)
{
TA_A\
SSE\
RT
(
lO\
l\
llO\
OOOO\
l\
l
<
lO\
Ol\
lOll\
llOO
->
lOl\
Olll\
lOOll
)
;
llOOlOllOlO\
l
&
lOOlOOll\
l\
l\
O
=
lOlllO\
OOOlOO
[
lOlllO\
O\
OOOll
++
]
;
lOOlO\
Oll\
llO
.
llO\
llOlOlll
=
&
*
lOlOOl\
OOlO\

;
++
lOlOOlOOl\
O
;
lOO\
lOOllllO
.
lOOllOlOOOO\

=
(
u64
)
(
lOO\
lO\
Oll\
llO\

.
ll\
O\
llOlOl\
ll
->
GetO\
bj\
ectA
(
)
->
Get\
ID
(
)
)
<<
32
;
lOOl\
O\
Ollll\
O
.
lOO\
llOlOOOO
+=
(
u64
)
lOOlOOl\
l\
llO\

.
llOll\
O\
lOlll
->
GetO\
bje\
ct\
B
(
)
->
GetI\
D
(
)
;
lOlOl\
llOlO
<
Collisi\
on\

>
::
lO\
lO\
ll\
lO\
ll
::
lOO\
l\
OO\
OlllO
(
lOO\
lO\
Olll\
lO
.
ll\
Oll\
O\
lO\
ll\
l
)
;
}
if
(
llOOl\
Ol\
llOl\
O
)
{
Dynam\
ic\
O\
bje\
ct
*
llO\
Ol\
lOOOOOO
=
0
;
DynamicO\
bject
*
ll\
OOll\
OOOOOl
=
0
;
Iter\
at\
or
ll\
OOllOOOOlO
;
It\
e\
rator
ll\
O\
OllOOO\
Oll
;
ll\
OOll\
OOO\
lOO
::
lO\
OOll\
lll\
l
(
lOlllO\
O\
O\
OlOO
,
lOlllOOOOOll
)
;
Vec3
ll\
OOll\
OOO\
l\
Ol
=
k_v\
3\
U\
nit\
Y
;
for\

(
int
lO\
OO\
llOOOl\

=
lOlllOO\
OO\
Oll
-
1
;
lOOOl\
lOO\
Ol
>=
0
;
lO\
OO\
l\
lOO\
O\
l
--
)
{
llOOlOllOl\
Ol
&
lOOlOOl\
l\
llO
=
lOl\
llOOOOl\
OO
[
lO\
OOllO\
O\
Ol
]
;
if\

(
llOOllOOO\
OOO
!=
lOOlOOllllO\

.
llOl\
l\
OlOlll\

->
lO\
llO\
OOllOl
||
llOOllOO\
OOOl
!=
lOOl\
OOllllO\

.
llOllO\
l\
Olll\

->
GetObje\
ct\
B
(
)
)
{
ll\
OO\
llOOOO\
O\
O
=
lOOlO\
Ol\
l\
ll\
O
.
llOllOlOlll\

->
lO\
l\
lO\
OO\
ll\
Ol
;
llOO\
llOOOOO\
l\

=
lOOlO\
OllllO\

.
llO\
l\
lO\
lOll\
l
->
Ge\
tOb\
jec\
tB\

(
)
;
llOOllOO\
O\
ll\
O
.
lOlOlOOO\
Ol
(
lOO\
lOOl\
l\
ll\
O
.
ll\
Oll\
OlOlll
)
;
ll\
O\
O\
llOOOO\
ll
=
llOOll\
O\
OO\
OlO
=
llOO\
l\
lOOOll\
O
.
lOlO\
O\
OO\
l\
OO\

(
)
;
ll\
OOl\
l\
OO\
OlOl\

.
Cle\
ar
(
)
;
fo\
r\

(
int
lOO\
lOOl\
Ol\
O
=
lOOO\
ll\
OO\
O\
l
;
lOOl\
OOlOlO
>=
0
;
lOO\
lOOl\
O\
l\
O
--
)
{
llOOlOll\
OlOl
&
llOOl\
lOO\
Olll\

=
lOl\
llOOOOlOO\

[
lOOlOOlOlO
]
;
if
(
ll\
OOllOOOlll
.
llO\
ll\
Ol\
Olll
->
lOl\
lO\
O\
OllOl
!=
lOOlO\
O\
l\
lllO\

.
ll\
Oll\
OlOl\
ll
->
lOllOO\
Oll\
Ol
||
ll\
OO\
llOOO\
lll
.
llOllOlOlll
->
Ge\
tObj\
ect\
B
(
)
!=
lOO\
lOOlll\
lO
.
llOllOlOl\
l\
l
->
Ge\
tO\
bj\
ectB\

(
)
)
br\
e\
a\
k
;
llOOl\
l\
O\
OOlO\
l
+=
ll\
OOllOOOl\
ll
.
llOll\
O\
lO\
ll\
l
->
lOOOlOO\
OOO\

;
}
floa\
t
lO\
llllOlO\
l
=
llOOll\
O\
O\
O\
lOl
.
Ge\
tM\
agni\
tude
(
)
;
if
(
lOll\
llO\
l\
Ol\

>
0.0f
)
llOOllOOOlOl
/=
lOll\
l\
l\
OlOl
;
else
ll\
OOllOOOlOl
=
k_v3\
UnitY\

;
}
else
{
TA_ASSERT\

(
lO\
O\
lO\
O\
lll\
lO
.
llO\
llOlOl\
ll
)
;
Collisi\
o\
n
&
llOllllOl\
ll
=
*
lO\
Ol\
O\
Olll\
lO
.
llOllOl\
Oll\
l
;
bool\

llOO\
ll\
OOlOOO
=
tru\
e
;
if
(
(
llOl\
l\
ll\
O\
ll\
l
.
lO\
lOl\
lO\
Oll
&
(
Collis\
i\
on\

::
FLAG_JOI\
NT
||
Collis\
ion\

::
FL\
AG_JOI\
NT_LIMIT
)
)
==
0
)
{
if
(
llO\
OllOOOlO\
l\

.
Do\
t
(
llOlll\
lOlll
.
lOOOlOOOOO
)
<
-
0.01f
)
{
ll\
O\
OllOO\
lOOO
=
fa\
lse
;
}
else\

{
Iter\
at\
or\

lOl\
OO\
lOOlO
=
llOOllOO\
OOll
;
fo\
r
(
;
0
;
)
{
Collision
&
llO\
O\
l\
l\
OOlOOl
=
*
lO\
lOOlOOlO
;
if
(
(
llO\
OllOO\
lOOl
.
lOlO\
llOO\
ll\

&
(
Collision
::
FLAG_JOINT\

||
Co\
ll\
is\
i\
on
::
FL\
AG\
_JOINT_LIMIT\

)
)
==
0
&&
(
llOlll\
lO\
lll
.
lOO\
OOllll\
l
-
llOOllO\
OlOO\
l\

.
lOOO\
Olll\
l\
l
)
.
Get\
Magni\
tud\
eSq\
rd
(
)
<
llOOl\
OllOOO\
l
&&
llOllllOlll
.
lOOOl\
OOOO\
O
.
Dot
(
ll\
OOl\
lOO\
lOO\
l\

.
lOO\
OlOO\
O\
O\
O\

)
>
1.0f
-
llOOlOllOOlO
)
{
llO\
Ol\
lOOl\
OOO
=
false
;
if
(
llOOllOOlO\
Ol
.
ll\
lOl\
lll\
l\
O
>
llOl\
lllO\
lll
.
ll\
l\
OlllllO
)
llO\
OllOOl\
OOl
.
lllOlll\
llO
=
ll\
Ollll\
O\
lll\

.
lllOllll\
lO
;
if
(
ll\
OOl\
lOOlOOl
.
lO\
llO\
O\
lOOll\

<
llOl\
ll\
lO\
l\
ll\

.
lO\
llOOl\
OOll
)
ll\
OOllOO\
lOO\
l
.
lOll\
OOlOO\
ll\

=
llO\
l\
lllO\
l\
ll
.
lOll\
OOl\
OOll\

;
llOOl\
lOO\
lO\
Ol\

.
lO\
lOllOOll\

|=
llOll\
llOlll
.
lOlOllOOll\

&
Collis\
ion
::
FLAG_CO\
NSTRA\
I\
N_\
IN_\
B\
OT\
H_\
DIR\
ECT\
IONS
;
}
if\

(
lOlOOlO\
OlO
==
llOOllOOO\
OlO
)
br\
e\
ak
;
++
lOlOOlOOlO
;
}
}
}
if
(
ll\
OOllOOlO\
OO
)
{
ll\
OOllOOO\
ll\
O\

.
lOl\
O\
l\
O\
OOO\
l\

(
lO\
OlO\
Ol\
lllO\

.
llO\
l\
lOlOll\
l\

)
;
llOO\
l\
lOO\
OO\
ll\

=
llOOl\
l\
O\
O\
Ol\
lO
.
lO\
lO\
OOO\
lO\
O
(
)
;
}
else\

{
llO\
O\
lOllOllO
--
;
ll\
OOll\
OO\
lOlO
->
llOOllOO\
lO\
l\
l\

(
lOOl\
O\
O\
l\
l\
llO
.
llOllOlOlll\

)
;
lO\
OlOOl\
ll\
lO
.
ll\
OllO\
lOlll
=
0
;
}
}
}
}
els\
e
{
llO\
O\
l\
lOOOlO\
O
::
lOOOll\
ll\
ll\

(
lO\
lll\
OOO\
OlOO
,
lO\
l\
l\
lOOOOO\
ll
)
;
for
(
int
lOO\
OllOOO\
l
=
lOlllOOOOOll
-
1
;
lOO\
Ol\
lOOO\
l
>=
0
;
lOOO\
llOOO\
l\

--
)
{
llOOlO\
llOlOl\

&
lOOlO\
O\
llllO\

=
lOlllOOOOl\
OO
[
lO\
O\
OllOOOl\

]
;
llO\
OllOOOllO\

.
lOl\
OlO\
OOOl\

(
lO\
Ol\
OOllllO
.
ll\
OllOlOl\
ll
)
;
}
}
#endif
}
void
lO\
lOll\
l\
l\
O\
OOO
::
llOOll\
OOl\
l\
OO\

(
)
{
}
bool
lOlOllllO\
OO\
O
::
lOll\
OllO\
l\
l\
lO
(
)
{
if\

(
!
llOOO\
lO\
Ol\
OO\
O
(
)
)
{
if
(
lOll\
O\
lllOll\
l
(
)
>
lOOllO\
ll\
llOO
->
lOl\
Olll\
lO\
ll\
O
)
ret\
u\
rn
true
;
if\

(
lO\
ll\
Oll\
l\
lOlO\

(
)
>
lOO\
ll\
Oll\
l\
lOO
->
lO\
lOll\
llOlll\

)
return
true
;
return
fals\
e
;
}
ret\
u\
rn
true
;
}
bo\
ol
lOl\
OllllOOO\
O
::
llOOllOOllO\
l\

(
const\

lO\
l\
OO\
OO\
OO\
lll\

*
lOlOOOOOllOO
)
{
TA_\
ASSER\
T\

(
lOlO\
OOOO\
ll\
OO
)
;
return\

llOOlO\
llllO\
O\

.
lOOlO\
OOllOl
(
lOl\
OOOOO\
llOO
)
;
}
#ifdef _DEBUG
vo\
i\
d
lO\
lOl\
l\
llO\
OOO
::
llO\
O\
l\
l\
OOlll\
O
(
)
{
int
ll\
OOl\
OO\
lOOlO
=
0
;
Iterator
lOl\
OlllOOOlO
=
lO\
lO\
lllOOO\
lO\

=
lOlOOO\
O\
lOO
(
)
;
fo\
r\

(
;
!
lOlO\
lllOOOlO
.
AtEnd
(
)
;
++
lOlOlllOOOlO
)
{
Co\
llisi\
on\

*
llOllO\
lOlll
=
&
*
lOlOl\
l\
l\
OOOlO\

;
fo\
r
(
;
ll\
Ol\
lOlOll\
l
;
ll\
Ol\
l\
OlOlll
=
llO\
l\
lOlOlll\

->
GetNe\
x\
t
(
)
)
{
llOO\
lO\
OlOOl\
O
++
;
}
}
TA\
_ASS\
ERT
(
llOOlOOlOOlO
==
llOOl\
O\
llOllO
)
;
}
#endif //
void
lO\
lOllllOOOO
::
Initial\
i\
se
(
llllOl\
lOllO
*
lOlOO\
llO\
OO\
ll\

,
lOllOlOll\
lOO\

*
ll\
OOll\
OO\
lO\
lO
)
{
TA_A\
S\
SER\
T
(
lOlO\
OllOOO\
ll
)
;
lOOllOllllOO
=
lOlOOl\
lO\
OOl\
l
;
llOO\
lOllOllO
=
0
;
llOOl\
lOOll\
ll
.
Fin\
al\
i\
se\

(
)
;
lOl\
lOlO\
llOll
=
ll\
OO\
llOO\
lOlO
;
llOOl\
Oll\
l\
OOO\

=
fa\
l\
se
;
llOO\
l\
Ol\
l\
lOO\
l
=
fals\
e
;
}
void
lOlOl\
lll\
OOOO
::
Fin\
a\
lise
(
)
{
lOO\
ll\
OllllO\
O
=
0
;
TA_ASSE\
RT
(
llO\
OlO\
ll\
ll\
l\
O
.
lOO\
OlllOO\
l
(
)
==
0
)
;
llOOlOllOllO
=
0
;
ll\
OOlO\
lllllO\

.
Fin\
al\
ise\

(
)
;
ll\
OOllOOllll
.
Fina\
l\
i\
se
(
)
;
}
inline
voi\
d\

lOlOllllOOOO
::
lOlOOOOl\
OOl\
l
(
lOl\
OOOOOOl\
l\
l\

&
lO\
l\
OOOO\
lllOO
)
{
TA_ASSERT\

(
(
lO\
lO\
OOO\
l\
llO\
O
.
lOlOl\
lOOl\
l
&
lOl\
OOOOOOlll
::
lOlOll\
l\
l\
OOOl
)
==
0
)
;
llOOlOl\
l\
llO\
O
.
lOlO\
l\
OOOOl
(
&
lOlOO\
OOll\
lOO
)
;
TA_AS\
SERT
(
lO\
l\
OOOO\
ll\
lO\
O\

.
lO\
lO\
O\
OO\
lOOl\
O
==
0
)
;
lO\
lOOOOlllOO\

.
lOlOO\
OOlO\
OlO
=
th\
is\

;
}
lOll\
O\
lO\
l\
llOO
::
lOllOlOlllO\
O
(
)
{
lOOllOl\
l\
ll\
OO
=
0
;
llOO\
llOl\
OO\
OO
=
0
;
llOO\
llO\
l\
OOOl
=
0
;
llOOllO\
lOO\
lO
=
0
;
}
lOllOlO\
lllO\
O\

::
~
lOll\
Ol\
OlllO\
O
(
)
{
Fi\
na\
lis\
e
(
)
;
}
void\

lOl\
lO\
lOlll\
OO
::
In\
itialis\
e
(
lll\
lO\
l\
lOl\
l\
O
*
lOlO\
OllOO\
Oll
,
int
ll\
OOllOlO\
Ol\
l
)
{
TA_ASS\
E\
RT
(
lOl\
OO\
llOOO\
ll
)
;
lOOl\
lOl\
ll\
lOO
=
lO\
lOOl\
lOOOll
;
llOOllOlOlOO
.
In\
itiali\
se
(
lO\
Oll\
Oll\
llOO
->
lO\
lOllll\
OO\
ll
)
;
llOO\
l\
lOlOlOl\

.
Init\
ial\
ise
(
lOOllOllllOO\

->
lOlOllllO\
Oll
)
;
llO\
Oll\
OlOll\
O\

.
In\
iti\
alise\

(
lOOl\
lOll\
llO\
O\

->
lOl\
Ollll\
O\
Oll
)
;
ll\
OOllOlOO\
OO\

=
llO\
Ol\
l\
OlOOll
;
ll\
O\
Oll\
OlO\
l\
ll
.
In\
iti\
alis\
e
(
lOOllOllllOO\

->
lOlOl\
lllOlOl
)
;
llOO\
ll\
O\
lOO\
l\
O\

=
0
;
ll\
OOl\
lOl\
OOOl
=
0
;
}
voi\
d
lOllOl\
Ol\
llOO
::
Finali\
se\

(
)
{
Cl\
ear\

(
)
;
ll\
OOllO\
l\
Ol\
OO\

.
Fi\
na\
lise\

(
)
;
llOO\
ll\
O\
l\
Ol\
Ol\

.
Fi\
nal\
is\
e\

(
)
;
ll\
OOl\
lOl\
OllO\

.
Finalis\
e\

(
)
;
llOO\
l\
lO\
l\
lO\
OO\

.
Fin\
alis\
e\

(
)
;
llOOllOlOO\
OO
=
0
;
ll\
OOll\
O\
l\
OO\
Ol\

=
0
;
}
Co\
llision
*
lOllOl\
O\
ll\
lO\
O\

::
llOOOOllllOl
(
lOlOOO\
OO\
O\
lll
&
lOlO\
O\
OOlllOO
,
const
Colli\
sion
&
llO\
l\
lll\
Olll\

)
{
TA_AS\
SER\
T\

(
(
lOlO\
OOOl\
ll\
OO
.
lO\
lOO\
OOO\
llOl\

==
llOlll\
lOlll
.
Ge\
t\
Obje\
ct\
A
(
)
&&
lOl\
OOO\
Oll\
lOO
.
lO\
lOOO\
OOlll\
O
==
llOl\
l\
ll\
Ol\
l\
l\

.
Ge\
tOb\
jectB
(
)
)
||
(
lO\
l\
OOOO\
ll\
lO\
O
.
lOl\
OOOOOllO\
l
==
llOlll\
lOl\
ll
.
Ge\
tObjec\
tB\

(
)
&&
lOlOO\
OOll\
l\
OO
.
lOlOOO\
OOlllO
==
llOll\
llOll\
l\

.
GetOb\
jec\
tA
(
)
)
)
;
Co\
llision\

*
llOOllOl\
l\
OOl
=
llO\
Oll\
O\
l\
O\
lOO
.
Al\
lo\
c
(
)
;
if
(
!
llOOllOllOO\
l
)
re\
turn
0
;
llOO\
llO\
lOOOl
++
;
*
llOOllOllOO\
l
=
llOllllOl\
ll
;
llOOl\
lO\
llO\
O\
l
->
lO\
llOlOOlll
(
0
)
;
lOlOOO\
O\
lllO\
O
.
lOlOlll\
O\
OlOl\

.
lOlOlOOOOl
(
ll\
O\
OllOl\
lOO\
l
)
;
re\
tu\
rn
llO\
O\
llOl\
l\
OO\
l
;
}
void
lOllOlOlllOO
::
llOO\
lOOl\
llOl
(
Co\
lli\
si\
on\

&
llO\
Ol\
lO\
llOl\
O\

,
const
Co\
lli\
sio\
n
&
llOllllO\
ll\
l
)
{
Colli\
sion
*
ll\
OOllO\
llOOl
=
llOO\
llOl\
OlOO\

.
All\
oc\

(
)
;
if
(
!
llOOl\
lOl\
lOOl\

)
re\
tu\
r\
n
;
llO\
O\
ll\
OlOO\
Ol\

++
;
*
ll\
O\
OllOl\
lOOl\

=
llOll\
llOlll\

;
ll\
O\
Oll\
O\
ll\
OO\
l
->
lOllOlOOlll
(
0
)
;
lOllO\
llOOOO
(
&
llOOl\
lO\
ll\
Ol\
O
,
llO\
OllOl\
l\
OOl\

)
;
}
voi\
d
lOl\
lOl\
O\
lllOO
::
llO\
OlOOl\
llOO\

(
lOlOO\
O\
OOOl\
ll
&
lOlOOO\
O\
ll\
lOO\

,
Col\
li\
sion
&
llOllll\
O\
lll\

)
{
TA_\
A\
SSE\
RT
(
(
lOlOOOOlll\
O\
O
.
lOl\
O\
OOOOl\
lOl
==
llO\
lll\
lOlll\

.
GetObjectA
(
)
&&
lOl\
OOOOlll\
OO
.
lO\
lO\
OOOOll\
lO\

==
llOllll\
O\
lll
.
GetO\
bje\
c\
tB
(
)
)
||
(
lOlOOOOlllOO
.
lOl\
OOO\
O\
Oll\
Ol\

==
ll\
Ollll\
Olll
.
GetOb\
je\
ct\
B
(
)
&&
lOlO\
OO\
Ol\
llO\
O
.
lOlOO\
O\
OOlllO
==
llOllllOll\
l
.
Ge\
t\
O\
b\
j\
ectA\

(
)
)
)
;
Co\
lli\
si\
o\
n
*
llO\
O\
ll\
Ol\
l\
OOl\

=
llOOllO\
lOl\
OO
.
Alloc
(
)
;
if
(
!
ll\
OO\
l\
l\
OllOO\
l
)
return
;
llOOllO\
lOOOl
++
;
*
llOOllOllOOl
=
llOllllO\
lll
;
llO\
Ol\
lOllOO\
l
->
lOllOlOOlll\

(
0
)
;
lOl\
O\
OOOlllOO
.
lOlOll\
lOOlOl
.
lOlOlOOO\
Ol
(
llOOl\
lOl\
lO\
Ol
)
;
}
st\
at\
ic
void
llO\
OllOl\
lOll
(
Ve\
c3
ll\
OO\
llOlllO\
O
[
3
]
,
int
&
llOO\
llOlllOl
,
Vec3
&
lOllll\
lO\
O\
O
,
co\
ns\
t
Vec3
&
lOO\
OlOOOOO
)
{
switc\
h
(
llOOllOlllOl
)
{
case
0
:
llO\
OllOll\
lOO
[
0
]
=
lOOOlOO\
O\
OO
;
llOO\
llOl\
ll\
Ol
++
;
break
;
case
1
:
{
fl\
oat
lOlOOOl\
Ol\
OO
=
llOOllOlllOO
[
0
]
.
Do\
t
(
lOOOlOOOOO
)
;
if
(
lOlOOOlOlOO
<
0.99f
)
{
llOO\
llO\
l\
llO\
O
[
1
]
=
lOOO\
l\
OO\
OOO
;
ll\
OO\
ll\
OlllOl
++
;
if
(
lO\
lOOOlO\
lO\
O
<
-
0.98f
)
llOOllO\
l\
llOl\

=
4
;
}
}
break
;
ca\
s\
e
2
:
if\

(
llO\
OllOlllOO
[
0
]
.
Do\
t
(
lOOOlOOO\
OO\

)
<
0.99f
&&
llOOllOl\
ll\
OO
[
1
]
.
Dot
(
lOOOlOOO\
OO
)
<
0.99f
)
{
llOOllO\
ll\
lO\
l
++
;
llO\
O\
ll\
OlllOO\

[
2
]
=
lOO\
Ol\
OO\
OO\
O
;
lOlllllO\
OO
=
(
llOOllOll\
lO\
O\

[
2
]
-
llOOll\
Ol\
llOO
[
0
]
)
.
Cr\
oss
(
llOOll\
Oll\
lO\
O
[
1
]
-
llOOllOlllOO\

[
0
]
)
.
GetN\
ormal
(
)
;
flo\
at
lOlO\
lllO\
Ol
=
lOlllllOOO\

.
Dot
(
llOOllOll\
l\
OO
[
2
]
)
;
if
(
lOlO\
l\
l\
lOOl
<
0.0f
)
{
lOlllllOOO
=
-
lO\
llll\
lOOO\

;
lO\
lO\
lllO\
O\
l
=
-
lO\
lOlllO\
Ol
;
}
if
(
lOlO\
lllO\
Ol\

<
0.1f
)
llO\
Ol\
lO\
lll\
Ol
=
4
;
}
break
;
case\

3
:
if
(
lOll\
ll\
lOOO\

.
Do\
t
(
lOOO\
l\
OO\
OOO
-
ll\
O\
OllO\
lllOO
[
0
]
)
<
-
0.01f
)
{
Vec3
lOl\
lOO\
OOlllO\

=
(
llO\
O\
llOl\
llO\
O
[
0
]
-
lO\
OOlOO\
OOO
)
.
Cross\

(
llOO\
l\
lOl\
llOO
[
1
]
-
lOO\
OlOOOOO
)
.
GetNo\
rmal
(
)
;
Vec3\

lO\
ll\
O\
OOOllll
=
(
llOOllOlllOO\

[
1
]
-
lOOOlOO\
OO\
O
)
.
Cross
(
llO\
O\
llO\
lll\
OO\

[
2
]
-
lO\
OO\
lOOO\
O\
O
)
.
Ge\
t\
Normal\

(
)
;
Vec\
3
llOOllOllll\
O
=
(
llOO\
ll\
O\
l\
ll\
OO
[
2
]
-
lO\
OO\
l\
O\
OO\
OO
)
.
Cros\
s
(
llO\
Oll\
Olll\
OO
[
0
]
-
lOOOlOO\
OO\
O
)
.
GetNormal
(
)
;
if\

(
lOllOOOOlllO
.
Dot
(
lOlll\
ll\
OOO
)
<
0
)
lOl\
l\
O\
O\
OOlllO
=
-
lO\
llOOOOlll\
O
;
if\

(
lO\
llO\
OOOllll
.
Dot
(
lOl\
llllOO\
O
)
<
0
)
lOll\
OO\
O\
Ollll
=
-
lOllOOOOl\
lll\

;
if
(
llOOllO\
ll\
llO
.
Dot
(
lO\
l\
l\
ll\
lOOO
)
<
0
)
llOOllOllllO
=
-
llOOllOll\
llO
;
float
lOl\
lllO\
O\
OO
=
lOl\
l\
OOOOlll\
O
.
Dot
(
lOOOlOOO\
OO
-
ll\
OO\
l\
lOll\
l\
O\
O
[
2
]
)
;
fl\
oat
lOll\
l\
lO\
OlO
=
lOllOOOOll\
ll
.
Dot
(
lOO\
OlOOOOO
-
llOO\
llOl\
ll\
OO
[
0
]
)
;
flo\
a\
t
llOO\
ll\
Ol\
llll
=
llO\
OllO\
l\
lllO
.
Do\
t
(
lO\
OOl\
O\
O\
OO\
O\

-
llO\
Oll\
Olll\
OO
[
1
]
)
;
if
(
lOllllOO\
OO
<
lOllll\
OO\
lO
)
{
if
(
lO\
l\
lllOOOO
<
llO\
O\
llOlll\
ll\

)
{
lOlllllO\
OO
=
lOl\
lOOOO\
ll\
lO
;
llOO\
ll\
Ol\
l\
lOO\

[
2
]
=
lOOOlOOOOO
;
}
else
{
lOlllll\
O\
OO
=
llOOllOllllO\

;
llOOllO\
ll\
lO\
O
[
1
]
=
lOOOlO\
OOO\
O\

;
}
}
els\
e
{
if
(
lOl\
lll\
OOlO\

<
llO\
Oll\
Ol\
llll
)
{
lOllll\
l\
O\
O\
O
=
lOll\
OOOO\
llll
;
llOOll\
OlllOO
[
0
]
=
lOOOlO\
OO\
OO\

;
}
else
{
lOl\
llll\
O\
OO\

=
llOOl\
lOl\
lllO\

;
ll\
OOl\
l\
O\
l\
l\
lOO
[
1
]
=
lOOOlOO\
O\
O\
O
;
}
}
floa\
t\

lOlOlllOOl
=
lOll\
lllOOO
.
Dot
(
llOOllO\
lll\
OO\

[
2
]
)
;
if\

(
lOlO\
lllOOl
<
0.1f
)
llOOllOlllOl
=
4
;
}
break
;
case
4
:
bre\
ak\

;
}
}
voi\
d\

lO\
llO\
lOl\
llOO
::
lO\
llllOlOlll
(
)
{
fo\
r
(
lO\
lll\
l\
OOlOOO\

lO\
llllOOl\
OOl
=
llOOl\
OllllOO
.
lO\
lOO\
O\
OlOO
(
)
;
!
lOllllOOlO\
O\
l
.
AtE\
n\
d\

(
)
;
)
{
lOlO\
OOO\
OO\
ll\
l
&
lOlOO\
OOlll\
OO
=
*
lO\
llllOOlOOl\

;
++
lOllllO\
O\
lOO\
l
;
if
(
lO\
l\
O\
O\
O\
O\
lllO\
O\

.
lO\
lO\
lllOOlO\
l
.
lOOOOO\
lOlOO\

(
)
)
co\
ntin\
ue\

;
TA\
_A\
S\
SERT
(
lOl\
OOOOlllO\
O
.
lOlOOOOOllOl
)
;
TA\
_ASSE\
RT
(
lOlO\
OOO\
ll\
lOO
.
lOlO\
OOOOl\
llO
)
;
if\

(
lOlOOOOlllO\
O
.
lO\
lO\
OO\
OOll\
Ol
->
Ghost\

(
)
||
lOlOO\
O\
O\
l\
llOO
.
lOl\
OOO\
OOlllO
->
Ghost\

(
)
)
con\
tinue
;
Dynam\
ic\
Obje\
ct
*
lOllOOOll\
Ol
=
0
;
lOlOlll\
l\
OOOO
*
llO\
Oll\
lOO\
OOO
=
0
;
if
(
lO\
l\
OO\
OOll\
l\
O\
O
.
lOlOO\
OOOll\
O\
l
->
lO\
l\
OOlll\
lOl\
O
(
)
)
{
lO\
l\
lO\
OOl\
lOl
=
lOlOOO\
OlllOO
.
lOlOOOO\
O\
llOl\

;
llOOlll\
OOOOO
=
(
lOlOl\
ll\
lOOOO
*
)
lO\
llOOOllOl
->
lOl\
O\
OllO\
Olll
(
)
;
}
Dyn\
amic\
Ob\
j\
ect\

*
lOllOO\
O\
l\
llO\

=
0
;
lOlOll\
llOOO\
O
*
llOOlllOOOOl
=
0
;
if
(
lOlOOOOl\
l\
lO\
O
.
lOlOOOOOl\
llO\

->
lO\
lOOllll\
Ol\
O\

(
)
)
{
lO\
llOO\
O\
l\
llO
=
lOlOOOO\
l\
l\
lOO
.
lOl\
O\
OOOO\
lll\
O\

;
llOOl\
l\
lOOOO\
l
=
(
lO\
lOll\
l\
lOO\
O\
O
*
)
lOllOOOlllO
->
lOl\
OO\
llO\
Olll
(
)
;
}
TA\
_ASSERT
(
lOl\
l\
OOOllOl\

||
lOllOOOlll\
O\

)
;
if
(
ll\
OOl\
l\
lO\
OOOO\

)
{
if
(
llOOlllOOOOl
)
{
if
(
llOOl\
llOOO\
OO
!=
llO\
Ol\
l\
l\
OOOO\
l
)
llOOll\
l\
O\
OO\
Ol\

=
llO\
Ol\
llO\
OO\
OO
=
llO\
OlllOO\
Ol\
O
(
llO\
Ol\
llOOO\
OO
,
ll\
O\
O\
lllOO\
OOl
)
;
}
else\

{
llOOl\
llOOO\
Ol
=
ll\
OOll\
l\
OO\
OOO
;
if
(
lO\
llOO\
O\
lllO
)
llO\
Ol\
l\
lOO\
Ol\
l
(
lOl\
l\
O\
OOlllO
,
llOO\
lll\
OOOOl
)
;
}
}
else
if
(
ll\
O\
O\
ll\
lOOO\
O\
l\

)
{
llOOlllOOOOO
=
llO\
OlllOOOOl
;
if
(
lOllOOOll\
O\
l\

)
ll\
OO\
lllOOOl\
l
(
lO\
llOOO\
llOl
,
llOOll\
lOO\
OOO
)
;
}
els\
e
{
llO\
OlllO\
OO\
O\
l
=
llO\
Oll\
lOOOO\
O\

=
ll\
OOlllOOlO\
O
(
lO\
l\
l\
OOOllOl
,
lOl\
lOO\
Ol\
llO
)
;
}
TA_ASS\
ERT
(
llOOl\
ll\
O\
OOOO
==
llO\
O\
lllO\
OOO\
l
)
;
if
(
ll\
OO\
lllOOOOO
)
{
ll\
O\
OlO\
llllOO
.
lOO\
lll\
llll\

(
&
lOlO\
OOOl\
ll\
OO
)
;
ll\
OOlllOOOOO
->
lOl\
OOOOl\
O\
Ol\
l
(
lOlOOOOlll\
OO
)
;
}
}
Ite\
rat\
o\
r
llOO\
lllO\
O\
lOl
=
llOOl\
lO\
llO\
OO\

.
lOlOOOOlOO
(
)
;
for
(
;
!
llOOl\
ll\
OOlOl\

.
AtEnd
(
)
;
)
{
lO\
lOllll\
O\
OOO\

&
lOl\
lO\
ll\
Ol\
lO\
O
=
*
llOOlllOOlOl
;
++
ll\
O\
O\
lllOOlOl\

;
Vec3
llOOl\
lOlllOO
[
3
]
;
int
ll\
OOl\
lOlllOl\

=
0
;
Vec3
lOlll\
ll\
OOO
;
int
llOOlOOlOOlO
=
0
;
int
llOOl\
llOOll\
O\

=
0
;
int\

ll\
OOlllO\
O\
lll
=
0
;
lOlOl\
lllOOOO\

::
lOlll\
lO\
OlOOO
lOllllOO\
lOO\
l\

=
lOl\
lOl\
lO\
l\
lOO
.
ll\
O\
O\
lO\
llllOO\

.
lOlOO\
OOlOO
(
)
;
fo\
r
(
;
!
lOll\
ll\
OO\
lOO\
l\

.
AtE\
n\
d
(
)
;
)
{
lOlOOOOOOlll
&
lO\
lOOOOlll\
OO\

=
*
lOll\
l\
lO\
OlOOl
;
++
lOllllOOlOOl
;
lOlOOO\
OOOlll\

::
Co\
l\
l\
isionIte\
r\
ator
lOlOlllOOOl\
O
=
lOl\
OOOOlllOO
.
lOlOlllOO\
l\
Ol\

.
lOlO\
OOO\
lO\
O
(
)
;
if
(
lOl\
Ol\
ll\
OOOlO
.
AtEn\
d
(
)
)
{
TA_\
A\
SSERT
(
lOlOO\
OOl\
l\
lOO
.
lOlO\
O\
OOlOOlO
!=
0
)
;
TA\
_A\
SSERT
(
lOlOO\
OOll\
lOO
.
lOlOOOOlO\
OlO
==
&
lOllO\
ll\
Ol\
lOO
)
;
TA_\
A\
SSERT
(
(
lOlOOOOlllOO
.
lO\
lOllOOll
&
lOlOOO\
O\
OOl\
ll
::
lO\
lOll\
llOO\
O\
l\

)
==
0
)
;
lOlO\
O\
OOlll\
OO\

.
lO\
lOO\
OOlOO\
lO
->
llO\
OlOllllOO
.
lOOllll\
lll
(
&
lOlOOO\
O\
lllOO
)
;
lOl\
O\
OOOlllOO
.
lOl\
O\
OO\
Ol\
OOlO
=
0
;
llO\
OlllOlOOO
(
&
lOlOOOOlllOO
)
;
}
el\
se
{
for
(
;
!
lOlOlllOO\
OlO\

.
AtEn\
d
(
)
;
)
{
Collisi\
on
*
llOll\
OlOll\
l
=
&
*
lO\
l\
O\
ll\
lO\
OOlO
;
++
lOlOll\
lO\
OO\
lO
;
int
lOlOllOOll
=
0
;
if
(
!
llO\
llOlO\
l\
ll
->
Ge\
tObjectA
(
)
->
IsInMov\
i\
n\
gL\
i\
s\
t
(
)
||
(
ll\
OllO\
lOlll
->
lOlOll\
OO\
ll
&
Colli\
sion\

::
FL\
AG_OBJECTA_SOLID\

)
)
lOl\
OllO\
Oll
|=
Colli\
sio\
n
::
FLAG_\
OBJE\
CT\
A_\
SOL\
I\
D_INT\
ERN\
AL\

;
if
(
!
llO\
llO\
lOl\
ll
->
GetObje\
ctB
(
)
->
IsInMovin\
gLis\
t
(
)
||
(
llOl\
l\
O\
lO\
lll
->
lOlOll\
O\
Oll
&
Co\
ll\
ision\

::
FLAG_\
O\
BJECTB_S\
OL\
ID
)
)
lOlO\
ll\
OOll
|=
Collision
::
FL\
A\
G\
_OB\
JEC\
TB_SO\
LID_I\
N\
TERNAL
;
ll\
O\
l\
lOlOl\
ll
->
lO\
lOl\
lOO\
l\
l
&=
~
(
Co\
lli\
si\
on
::
FLA\
G_OBJECTA_SOLID_INTERNAL\

|
Collision
::
FLA\
G\
_\
OBJECTB_S\
O\
LI\
D\
_I\
NTERNA\
L\

)
;
ll\
OllOlO\
lll
->
lO\
lOl\
lOO\
ll
|=
lOl\
Ol\
lOOll
;
int
llOllOOlll\

=
0
;
fo\
r
(
Collis\
io\
n
*
lOOOO\
O\
lOOO\
l
=
llOllOlOlll
->
Ge\
tNe\
xt\

(
)
;
lOOO\
OOlOO\
Ol
;
lOOO\
OOlOOO\
l
=
lOO\
OOOl\
OOOl
->
Get\
Ne\
xt
(
)
)
{
lO\
OOO\
Ol\
O\
OOl
->
lOlOllOO\
ll
&=
~
(
Collisio\
n
::
FLAG_\
OBJEC\
TA_SOLID_I\
NTERN\
AL
|
Co\
l\
li\
s\
ion
::
FLAG_\
OBJ\
E\
C\
TB\
_SOLID_\
INT\
ERN\
AL
)
;
lOOOO\
OlOOOl
->
lOl\
OllOO\
l\
l
|=
lOlOllOOll\

;
ll\
OllOOl\
ll
++
;
}
if
(
llOl\
lOl\
O\
lll
->
lO\
lOl\
lOOl\
l\

&
Coll\
is\
io\
n\

::
FL\
AG_OBJECTB\
_SOLID\
_I\
NTERNAL
)
{
if
(
llOllO\
lO\
l\
ll
->
lOl\
O\
llOO\
ll
&
Co\
lli\
sion
::
FLAG_\
OB\
JEC\
TA_SO\
LID_INTERNAL
)
{
llOO\
lllO\
OllO
++
;
lOl\
OOO\
OlllOO\

.
lOl\
OlllOOlOl
.
lOOllll\
ll\
l\

(
llOl\
lOlOl\
ll
)
;
ll\
OOll\
OOl\
Oll
(
ll\
O\
llOlOlll
)
;
continue
;
}
}
else\

if
(
llO\
l\
l\
O\
lO\
ll\
l
->
lOl\
Ol\
lO\
O\
l\
l
&
Col\
l\
ision
::
FLAG_\
OB\
JEC\
TA_\
S\
OLID_INTERNAL\

)
{
TA\
_AS\
S\
ERT
(
(
ll\
O\
l\
lOlO\
l\
ll\

->
lOlOl\
l\
O\
Oll\

&
Colli\
sio\
n\

::
FLAG_O\
BJECT\
B\
_\
SOLID_\
I\
N\
TE\
RNAL
)
==
0
)
;
llOllOlO\
ll\
l\

->
lOll\
OlOll\
OO
(
)
;
for
(
Collision
*
lOOOO\
OlO\
OOl
=
ll\
O\
ll\
OlOl\
l\
l
->
GetNext
(
)
;
lOOOOOlOO\
Ol
;
lOOOOOl\
OOOl\

=
lOO\
OOOl\
OOO\
l
->
GetNe\
x\
t\

(
)
)
{
lOOOOOlOOO\
l\

->
lO\
llOl\
Ol\
l\
OO
(
)
;
}
}
el\
se
{
TA\
_ASS\
ERT
(
llOll\
OlO\
ll\
l\

->
Ge\
tObjectA
(
)
->
lOl\
O\
OllOO\
lll\

(
)
==
llO\
l\
lOlOlll\

->
GetOb\
je\
ct\
B\

(
)
->
lOlOOl\
lOOlll
(
)
)
;
}
if
(
(
!
ll\
O\
llOlOlll
->
GetObject\
A
(
)
->
IsI\
n\
Movin\
g\
List
(
)
&&
!
ll\
OllOl\
Ol\
ll
->
Ge\
tObject\
A
(
)
->
MovementDi\
sabled
(
)
)
||
(
!
ll\
OllOlOlll
->
GetOb\
jec\
tB\

(
)
->
IsInMovingL\
i\
s\
t
(
)
&&
!
llO\
llOl\
Olll
->
Get\
Obj\
e\
ctB\

(
)
->
Mo\
ve\
m\
e\
n\
tDis\
a\
bl\
e\
d\

(
)
)
)
{
llO\
OlllO\
O\
lll\

+=
llO\
l\
l\
OOlll
+
1
;
if
(
llOl\
lOl\
O\
ll\
l
->
lOlOllOOll\

&
Collis\
ion
::
FLA\
G_JOINT\

)
{
ll\
O\
Ol\
llOOl\
l\
l
+=
(
ll\
OllOO\
lll
+
1
)
*
4
;
llOOl\
lOl\
ll\
Ol\

=
4
;
}
els\
e
{
if
(
(
llO\
l\
lOlO\
lll
->
lO\
lOll\
O\
Ol\
l\

&
Col\
lis\
ion
::
FL\
A\
G_F\
R\
ICTION
)
==
0
)
{
if
(
llO\
llOl\
Ol\
ll\

->
Ge\
tObj\
e\
c\
tA
(
)
->
IsInMovi\
ng\
Lis\
t
(
)
)
llO\
OllOllOll
(
ll\
OOl\
lOlllO\
O
,
llOO\
llOlllOl\

,
lOllll\
lOO\
O
,
llOll\
OlOll\
l\

->
Ge\
tNo\
r\
ma\
l
(
)
)
;
els\
e
llOOllO\
llOll
(
ll\
OOllOlllOO
,
llOOllOlllO\
l
,
lO\
l\
l\
ll\
l\
OOO
,
-
llOllOl\
Olll
->
GetN\
ormal\

(
)
)
;
}
}
}
if
(
!
lOllOll\
Oll\
OO
.
llO\
Ol\
Olll\
OOO
&&
!
lOl\
lOllO\
l\
lOO
.
ll\
OOl\
OlllOO\
l
)
{
if
(
(
llOllOlOlll
->
Ge\
tOb\
jec\
tA
(
)
->
Inf\
init\
eMass\

(
)
||
(
llOll\
Ol\
Olll
->
lOlOllOO\
ll
&
Collis\
ion\

::
FLAG_\
OBJECTA_SOLI\
D
)
)
&&
llOl\
lOlOlll
->
GetOb\
j\
ectA
(
)
->
IsIn\
Movin\
gList
(
)
&&
(
llOllO\
lOlll
->
GetO\
bjec\
tA
(
)
->
Get\
L\
inea\
rVel\
oc\
i\
ty
(
)
.
GetMagnitude
(
)
>
0.0f
||
llOl\
lO\
lOll\
l
->
Get\
Ob\
je\
c\
t\
A
(
)
->
GetA\
ngu\
l\
a\
rV\
elocity
(
)
.
Ge\
tMagnit\
ude
(
)
>
0.0f
)
)
lOllOllOl\
lOO
.
llOOlOlll\
OOl
=
tru\
e
;
if
(
(
llOllOlOlll
->
GetObj\
ec\
tB
(
)
->
Infin\
ite\
Mass\

(
)
||
(
ll\
OllOl\
Olll\

->
lO\
lOll\
O\
Ol\
l
&
Co\
lli\
sion
::
FLAG_O\
BJECTB_S\
OL\
ID
)
)
&&
llOl\
lOl\
Olll
->
GetObject\
B
(
)
->
Is\
InM\
ovin\
g\
L\
ist
(
)
&&
(
llO\
ll\
Ol\
O\
ll\
l
->
GetObje\
c\
t\
B
(
)
->
Get\
Lin\
ea\
rV\
elo\
city
(
)
.
Ge\
t\
M\
agnit\
u\
d\
e
(
)
>
0.0f
||
llOllO\
lOlll
->
Ge\
tO\
bjectB
(
)
->
GetAngul\
arVelocity
(
)
.
Get\
Magn\
itu\
de
(
)
>
0.0f
)
)
lOl\
lOl\
lOl\
lOO
.
llO\
Ol\
OlllOOl\

=
tru\
e
;
}
llOO\
l\
OOlOO\
lO
+=
llOll\
OOlll
+
1
;
}
if
(
lO\
lO\
O\
O\
Ol\
llOO
.
lO\
l\
OOOOOl\
lO\
l
->
IsForc\
eFastSo\
l\
verEnab\
le\
d
(
)
||
lOlOOO\
O\
lllO\
O
.
lOlOO\
OOOlll\
O
->
IsForc\
e\
Fa\
s\
t\
Solver\
E\
na\
b\
led
(
)
)
lOll\
O\
llOl\
lOO\

.
lOlll\
OOOOO\
OO
(
tru\
e
)
;
}
}
lOllOll\
O\
ll\
OO\

.
llO\
OlOllO\
l\
lO
=
ll\
O\
O\
lO\
OlOOl\
O
;
if
(
ll\
OOllOlllOl
==
4
&&
ll\
O\
Olll\
OOl\
ll
*
3
>
llOOlOOlOOl\
O
)
lO\
llOllOl\
lO\
O
.
lO\
lllOO\
O\
OOOO
(
true
)
;
lOllO\
llO\
llOO
.
llOO\
l\
Ol\
l\
Olll
=
lOl\
lOllOllOO
.
ll\
OOlOlllllO
.
lO\
OOlllOOl
(
)
;
if
(
lOllO\
llOllOO\

.
ll\
O\
OlOl\
lO\
llO\

==
0
)
{
lO\
lOl\
ll\
lOOOO
::
llOOOO\
OO\
ll\
lO\

ll\
OOO\
OOO\
llll
=
lOllO\
l\
l\
Ol\
lOO
.
ll\
O\
Ol\
O\
lllllO
.
lO\
lOOOOlOO\

(
)
;
wh\
ile\

(
!
llOO\
OO\
OOllll
.
AtEnd
(
)
)
{
Dy\
na\
mi\
cO\
b\
ject
*
*
ll\
OOlllOlOO\
l
=
&
*
ll\
OOOOOOllll
;
++
llOOO\
OOOll\
ll
;
if
(
(
*
llOOlllO\
lOOl
)
->
lOlOOllOO\
ll\
l\

(
)
!=
0
)
{
(
*
llOO\
l\
llOlO\
O\
l\

)
->
lO\
lO\
Ol\
l\
O\
OlO\
l\

(
0
)
;
(
*
llOOl\
l\
lOlOOl
)
->
Rele\
as\
e
(
)
;
(
*
ll\
OOlll\
OlOO\
l
)
=
0
;
}
lO\
l\
lOllOll\
OO
.
llOOlOllll\
lO
.
lOOllll\
l\
ll\

(
llOOlllOlOO\
l
)
;
llOOllOlOlOl
.
Fr\
ee
(
llOO\
lll\
Ol\
OO\
l\

)
;
}
lOlOll\
l\
OlO
<
lO\
l\
OOOO\
OOll\
l\

>
::
lOl\
Ol\
l\
l\
Oll
::
Itera\
tor
lOllll\
OOlOOl\

=
lO\
l\
l\
O\
llOllOO
.
ll\
OOlO\
ll\
ll\
O\
O
.
lOlOO\
OOlOO
(
)
;
while\

(
!
lOll\
ll\
OOlOOl
.
AtE\
nd
(
)
)
{
lOlO\
O\
OOO\
O\
lll
&
lOlOOO\
OlllO\
O
=
*
lOlll\
lO\
O\
lOOl
;
++
lOl\
l\
llO\
O\
l\
OOl\

;
TA\
_AS\
S\
ER\
T
(
lOlO\
O\
O\
Ol\
llO\
O
.
lOlOOOOl\
OOlO
!=
0
)
;
TA\
_A\
S\
SER\
T
(
lOlOOOOll\
l\
OO
.
lOlOOO\
OlOO\
l\
O
==
&
lOl\
lOll\
O\
llOO\

)
;
TA_\
ASS\
ER\
T
(
(
lOl\
OOOO\
lllOO
.
lOlOll\
O\
Oll
&
lOlOOOOOOlll\

::
lO\
lO\
ll\
llOOOl\

)
==
0
)
;
lO\
lO\
OOOlllOO
.
lO\
lOOOO\
l\
OO\
l\
O
->
ll\
OOlO\
lll\
lO\
O\

.
lOOlllllll
(
&
lO\
lOOO\
OlllOO
)
;
lOlOOOOlllOO\

.
lOlOOOOl\
OO\
lO
=
0
;
llOOlllO\
l\
OO\
O
(
&
lOlOOO\
O\
l\
l\
lOO
)
;
}
lOll\
OllOl\
lOO
.
Final\
ise
(
)
;
llOOl\
lOl\
lO\
OO
.
lOO\
llll\
lll
(
&
lO\
ll\
OllO\
llOO\

)
;
llOOl\
lOlOl\
lO
.
Free\

(
&
lOl\
l\
O\
ll\
O\
llOO
)
;
}
}
}
void
lOl\
l\
Ol\
Oll\
l\
O\
O
::
ll\
OO\
lllOlOlO
(
lO\
lOOO\
OOOlll
&
lOlOOOOll\
lOO
)
{
in\
t
ll\
OO\
l\
OO\
lOOlO
=
0
;
for
(
lO\
l\
OlllO\
l\
O
<
Coll\
isi\
on
>
::
lOlOl\
llOll
::
Iterato\
r
lOl\
OOlOOlO
=
lO\
lOO\
OOl\
llOO
.
lO\
l\
O\
l\
llOO\
l\
Ol\

.
lOl\
OOOOlO\
O\

(
)
;
!
lO\
l\
OOlOO\
lO
.
At\
E\
nd\

(
)
;
)
{
Collision\

&
llO\
lll\
l\
Oll\
l\

=
*
lO\
lOOl\
OO\
l\
O
;
++
lOlOOlOO\
lO
;
if
(
llOllllOl\
ll
.
lOlOll\
O\
O\
ll
&
(
Collision\

::
FLAG_FRIC\
T\
IO\
N
)
)
{
lOlO\
OOOll\
lOO
.
lOl\
OlllOOlOl
.
lOOl\
lll\
lll
(
&
ll\
OllllO\
lll\

)
;
llOOl\
l\
O\
Ol\
Oll
(
&
llOll\
l\
lO\
l\
ll
)
;
continue
;
}
llOO\
lOOlOOlO
++
;
ll\
O\
ll\
llOll\
l
.
lO\
ll\
OOl\
OlOO\

=
0.0f
;
llOllllO\
lll
.
lOl\
lO\
O\
l\
lOOO
.
Cl\
ear\

(
)
;
llOll\
llOlll
.
lOllO\
O\
l\
l\
OOl
.
Clear
(
)
;
llOl\
lll\
O\
lll
.
lOlO\
llOOll
&=
~
(
Colli\
sion\

::
FLAG_FRI\
CTION\
_G\
ENE\
RATING_\
IMP\
ULSE\

|
Collision\

::
FL\
AG\
_MARKED
|
Collis\
io\
n
::
FLAG_\
R\
EST\
I\
TUTION_CALCUL\
ATED
)
;
}
if\

(
llO\
OlO\
O\
l\
OO\
lO
==
0
)
{
lO\
l\
OOO\
OllllO\

(
lOlOOO\
O\
lllOO\

)
;
return
;
}
TA_ASS\
ER\
T\

(
lOlOOOO\
ll\
l\
O\
O\

.
lOlOOOOlOO\
lO\

==
0
)
;
TA_ASSERT
(
lO\
lO\
OOOl\
ll\
OO
.
lOlOOOOO\
llOl
)
;
TA\
_ASS\
ERT
(
lO\
lOOOO\
lllOO
.
lOlOOOOO\
ll\
l\
O
)
;
Dynami\
cO\
b\
jec\
t
*
lOl\
lOOOl\
lOl
=
0
;
lOlOlll\
lOO\
OO
*
ll\
O\
O\
lllOOO\
OO
=
0
;
if
(
lOlOOOO\
lllO\
O
.
lOl\
O\
OOOOllO\
l
->
lOlOO\
ll\
llOlO
(
)
)
{
lOll\
OOOl\
l\
Ol
=
lOlOO\
OO\
l\
llO\
O
.
lOlOOOO\
OllOl\

;
llOO\
lllOO\
OO\
O
=
(
lOlOllllOOOO\

*
)
lOl\
l\
O\
OOllOl
->
lO\
lOO\
l\
lOO\
lll
(
)
;
}
DynamicObject
*
lOllO\
OOl\
ll\
O
=
0
;
lOlOl\
l\
l\
lOOOO
*
llOOll\
l\
O\
OOOl
=
0
;
if
(
lOlOOOOll\
lOO
.
lOl\
OO\
OOOlllO
->
lOlOOl\
ll\
lOlO
(
)
)
{
lO\
llOO\
Olll\
O\

=
lOl\
OOO\
Ol\
l\
lOO
.
lOlOO\
OOOl\
llO
;
ll\
OOlll\
OOO\
Ol
=
(
lO\
lOll\
l\
lO\
OOO
*
)
lOllOO\
OlllO
->
lOlOOllOOlll
(
)
;
}
TA_A\
SSERT
(
lOllO\
OOl\
lO\
l
||
lOll\
O\
OOlllO
)
;
if
(
llOO\
ll\
lOOOOO
)
{
if
(
llOOlllOOOOl
)
{
if
(
llOOlll\
OO\
O\
OO
!=
llOO\
ll\
lO\
O\
OOl
)
llOOlllOOOOl
=
llOOlllOOOOO
=
llO\
O\
lllOOOlO
(
llO\
Oll\
lOOOOO
,
llOOlll\
O\
OOOl
)
;
}
els\
e\

{
llOOlll\
OOOOl\

=
ll\
OOlllOOOO\
O
;
if
(
lO\
llOOOll\
l\
O
)
ll\
O\
Ol\
ll\
OO\
Oll
(
lOll\
OOOlllO
,
llOOlllOO\
OOl\

)
;
}
}
els\
e
if
(
llO\
Olll\
OOO\
O\
l\

)
{
ll\
OO\
l\
llOO\
OOO
=
llOOll\
lOOOOl
;
if
(
lOllOOOllOl
)
llOOlllOO\
Ol\
l
(
lOllOOOllO\
l
,
llOO\
l\
llOOOOO\

)
;
}
el\
s\
e
{
ll\
OOl\
llOOO\
Ol\

=
llOOlllO\
O\
OOO
=
ll\
OOll\
lOO\
l\
O\
O
(
lOllO\
OO\
llOl
,
lOl\
l\
OOOlllO
)
;
}
TA\
_AS\
SERT
(
ll\
OOlllO\
OOOO
==
llOOlllO\
OO\
Ol\

)
;
TA\
_A\
S\
SER\
T
(
llOOlllOO\
OOO
)
;
lOlOO\
OOlllO\
O
.
lOlOOOOlOOlO
=
llO\
O\
lllO\
OOOO
;
TA_AS\
S\
ER\
T
(
lOlOOOOlllOO
.
lO\
lO\
llO\
O\
ll\

&
lO\
lOOOOOOl\
l\
l\

::
lOlOl\
lllO\
OO\
l\

)
;
lO\
lOOO\
Ol\
llO\
O
.
lOlOllOOll
&=
~
lO\
l\
O\
O\
OO\
OOlll
::
lOl\
Ol\
l\
ll\
OOOl
;
ll\
O\
OlllO\
l\
Oll\

.
lOOl\
ll\
llll\

(
&
lOlOOO\
O\
l\
llO\
O
)
;
llO\
Ol\
llOO\
OO\
O
->
llOOl\
Ollll\
O\
O
.
lO\
lO\
l\
OOOOl
(
&
lOl\
O\
OOOlllOO
)
;
llOOlllOOO\
O\
O
->
llOOlOl\
lOll\
O\

+=
ll\
OO\
lOOlOOlO
;
}
vo\
id
lO\
llO\
lOlllOO
::
Clear\

(
bool
ll\
OO\
lll\
OllOO
)
{
TA_ASS\
ERT
(
lOll\
ll\
OlO\
llO\

(
)
==
0
)
;
TA_A\
S\
SERT
(
llOOl\
l\
lOl\
Ol\
l
.
lOOOOO\
lOlOO\

(
)
)
;
llO\
Oll\
lO\
lOll
.
llO\
llOll\
OO
(
llO\
OlO\
llllOO
)
;
Iterator\

ll\
OOll\
l\
OOlOl
=
llO\
OllOllOO\
O
.
lOlOOOO\
lO\
O\

(
)
;
while
(
!
llOOlllOOl\
Ol\

.
AtEn\
d
(
)
)
{
lOlOl\
ll\
lO\
OOO
&
llOOl\
ll\
Ol\
lO\
l
=
*
llOOll\
l\
OOlOl\

;
++
ll\
O\
OlllOO\
lOl
;
lO\
lOlll\
OlO\

<
lO\
l\
OOOOO\
Ol\
ll
>
::
lO\
lOl\
l\
lO\
l\
l\

::
Iterator\

lOllllOOlOOl
=
llOOl\
l\
lOllOl
.
llO\
Ol\
OllllO\
O\

.
lOl\
OOO\
O\
lOO
(
)
;
whil\
e
(
!
lO\
ll\
llOOl\
OO\
l
.
At\
End
(
)
)
{
lOl\
O\
OOOOOlll
&
lOlOOOOl\
llOO\

=
*
lO\
llllO\
OlOOl
;
++
lO\
l\
ll\
lOOlOOl\

;
TA_A\
SSERT
(
lOlOO\
OOl\
l\
lOO
.
lO\
lOOOOlOOlO\

!=
0
)
;
TA_\
ASSERT
(
lO\
lOOO\
O\
lllOO
.
lOlOOOOlOOl\
O
==
&
llOO\
lllOl\
lOl
)
;
TA_ASSE\
R\
T\

(
(
lOlOOOOl\
llOO
.
lOlOll\
OOll
&
lO\
lO\
OOO\
OO\
lll
::
lOlOllll\
OO\
Ol
)
==
0
)
;
lO\
lOO\
OOlllOO\

.
lOlOO\
O\
O\
l\
OOlO
->
llOOlOllllOO\

.
lOOll\
lllll\

(
&
lO\
lOOOOll\
lOO
)
;
lO\
l\
OO\
OOlllOO
.
lOl\
OO\
O\
OlOOlO
=
0
;
TA_\
A\
SSE\
RT\

(
lOl\
OOO\
O\
lllOO
.
lO\
lOOOOOllO\
l
)
;
TA_ASSERT\

(
lOl\
OOO\
OlllOO
.
lOlOOO\
OOlllO
)
;
if
(
!
lOlOOOOlllO\
O\

.
lO\
lOl\
l\
l\
OOlOl
.
lOOO\
OO\
lO\
lOO
(
)
&&
!
lOl\
OO\
OOlll\
OO
.
lOl\
OOOOO\
llOl
->
Ghost
(
)
&&
!
lO\
lO\
OOOlll\
OO
.
lO\
lOO\
O\
OOll\
lO
->
Gh\
os\
t
(
)
)
{
if
(
!
lOl\
OOOOll\
lOO
.
lOlOOOOO\
lllO
->
Infin\
ite\
Ma\
ss
(
)
&&
!
lOlOOOO\
lllOO
.
lOlOO\
OOOlllO\

->
MovementDisab\
led
(
)
)
lOlOOO\
Ol\
l\
lOO
.
lOlOOOOOllO\
l
->
lOlOOO\
lOlOll
(
lOlOOOOlllOO
.
lOlOOOOO\
l\
l\
lO\

)
;
if
(
!
lOlOO\
OO\
lllOO
.
lOlOOOOO\
llOl
->
InfiniteM\
ass
(
)
&&
!
lOlOOOOl\
llOO
.
lOlOOO\
OOllOl
->
Mo\
vementDi\
s\
abled
(
)
)
lOlOOOOl\
ll\
OO
.
lOl\
OOOOOl\
llO\

->
lOlOOOlOlOl\
l
(
lO\
l\
OOOOlll\
OO
.
lO\
lO\
O\
OOOllOl
)
;
}
lOlOOO\
O\
lO\
O\
ll
(
&
lOlOOOO\
ll\
l\
OO
)
;
}
lO\
lOlll\
lO\
OOO
::
llO\
OOOOOlllO\

llOOO\
O\
OO\
llll\

=
llO\
Ol\
llOllO\
l
.
ll\
O\
O\
l\
Ollll\
lO
.
lOlOOOOlOO\

(
)
;
wh\
il\
e
(
!
ll\
OOOO\
OOllll
.
AtEn\
d
(
)
)
{
Dy\
na\
micObject
*
*
llO\
OlllO\
lOOl\

=
&
*
llOO\
OOOOllll
;
++
llOOO\
OOOllll\

;
if
(
(
*
llOO\
ll\
lOl\
OOl
)
->
lOlOO\
l\
lOOll\
l
(
)
!=
0
)
{
(
*
llOOl\
llOlOOl
)
->
lO\
l\
O\
OllOOlOl\

(
0
)
;
(
*
llOOl\
l\
lOlOOl
)
->
Releas\
e
(
)
;
(
*
ll\
OOlllOlOO\
l\

)
=
0
;
}
llOOlllO\
l\
lO\
l\

.
ll\
OOlOllll\
lO
.
lOO\
lllllll
(
llOO\
l\
llOlOOl
)
;
ll\
OOl\
lOlOlOl
.
Fr\
ee\

(
llOOlllOlOOl
)
;
}
llO\
O\
lllOllOl
.
Fi\
nalis\
e\

(
)
;
llO\
Ol\
l\
Ol\
lOOO
.
lO\
Olllllll
(
&
llOO\
l\
llOll\
O\
l\

)
;
llOOllOlOllO
.
Free
(
&
llOO\
lll\
OllOl\

)
;
}
TA_\
ASS\
E\
RT
(
ll\
O\
O\
l\
lO\
llOOO
.
lOl\
O\
OOO\
lO\
O\

(
)
.
AtEnd
(
)
)
;
TA_ASS\
E\
RT
(
llOO\
lOll\
l\
lOO\

.
lOOO\
OOlOl\
OO
(
)
)
;
if\

(
llOOlllO\
llOO
)
{
TA_ASSE\
RT
(
llOOlO\
lll\
lO\
O
.
lO\
O\
OOO\
lO\
l\
O\
O
(
)
)
;
lO\
lOlll\
OlO\

<
lOl\
OOOOO\
O\
l\
ll
>
::
lOOlOOlOOOl\

::
Iterator
lOllll\
OOlOOl
=
llO\
OlllOlOl\
l
.
lO\
lOOO\
OlOO
(
)
;
whi\
le
(
!
lO\
llllOOlOOl
.
At\
E\
nd
(
)
)
{
lOl\
OOO\
OOO\
l\
ll
&
lOlOOOO\
lll\
OO\

=
*
lOl\
lll\
OOlO\
Ol
;
++
lO\
l\
lll\
O\
OlOOl
;
TA_ASSERT
(
lOl\
OOOOlllO\
O
.
lO\
lOOOOOllOl
)
;
TA\
_AS\
SER\
T
(
lO\
lOO\
OO\
ll\
lOO
.
lOlO\
OOO\
Ol\
llO\

)
;
lOlOOO\
Olll\
O\
O
.
lOlOllOOl\
l
|=
lOlOOOOOOll\
l
::
lO\
lOllllO\
OO\
l
;
if
(
(
lO\
lOOO\
Oll\
lOO
.
lOlO\
OOO\
OllO\
l
->
IsIn\
Mo\
ving\
L\
ist
(
)
||
lOlO\
O\
OOlllOO
.
lO\
lOOOOOlllO\

->
IsIn\
Mo\
vingLis\
t
(
)
)
&&
lOl\
OOOOlll\
OO\

.
lOlOO\
OOOllO\
l
->
lOlOOOlO\
OOOO
(
)
&&
lO\
l\
OOOOl\
llOO
.
lOl\
OOOOOl\
llO
->
lOlOOOlOOO\
O\
O
(
)
&&
(
lO\
lO\
OOOlllOO
.
lOlOllOO\
ll\

&
lOlOOO\
OOOlll\

::
lOl\
OOOllOOll
)
==
0
)
{
if
(
lOlOOOOlllOO\

.
lOlOOOOOllOl
->
lOlOOOlOOOOO
(
)
&&
lOl\
OOOOl\
llOO\

.
lOlOO\
O\
OOll\
lO
->
lOlOOO\
l\
OOOO\
O
(
)
)
{
if\

(
!
lOlOOOO\
l\
llOO
.
lOlOl\
ll\
OO\
lOl
.
lO\
lO\
OOOlOO
(
)
.
AtEnd
(
)
)
llOOlllO\
lOlO
(
lOlOOOOlllOO
)
;
}
}
else
{
lO\
lOOOOllllO\

(
lO\
lOOOO\
lll\
OO\

)
;
}
}
}
else
{
TA_\
A\
SSE\
RT
(
llOOlOllll\
OO
.
lOOOOOlOlOO
(
)
)
;
lOlO\
lll\
OlO
<
lOlO\
O\
O\
OOOl\
ll
>
::
lOOlO\
Ol\
OOOl
::
Iterator\

lOllllOO\
l\
OOl
=
ll\
OOlllOlOll
.
lOl\
OOO\
OlOO
(
)
;
whil\
e
(
!
lO\
l\
lllOOlOO\
l
.
At\
E\
nd
(
)
)
{
lOl\
OO\
O\
O\
O\
Olll
&
lO\
l\
OOO\
Ol\
llOO
=
*
lOllll\
OOlOO\
l
;
++
lOllllO\
O\
lOOl
;
lOl\
OOOOlllOO
.
lOlOllOOl\
l\

|=
lOl\
O\
OO\
O\
OOl\
ll
::
lOlO\
llllOOOl\

;
lO\
lO\
O\
OO\
llllO
(
lOlO\
O\
OOlllO\
O
)
;
}
TA_ASS\
ERT
(
llOOllOl\
Olll\

.
lOO\
lOO\
lOl\
OO
(
)
==
lOO\
llO\
l\
lll\
OO
->
lO\
lOl\
lll\
Ol\
Ol\

)
;
TA_\
ASSER\
T
(
llOO\
llO\
lOlOO
.
lOOlOOlO\
l\
OO\

(
)
==
lO\
OllOllllOO\

->
lOlOllllO\
Oll
)
;
}
}
void
lOl\
l\
OlOl\
llOO
::
llOOlOOOl\
O\
lO
(
lOlOO\
OOOO\
ll\
l
&
lOl\
OOO\
Oll\
lOO
)
{
TA_A\
SS\
ERT
(
lOlO\
OOOll\
lO\
O
.
lOl\
OOOOlOOlO\

!=
0
)
;
TA\
_ASSER\
T
(
(
lO\
lOO\
OOl\
l\
lOO
.
lOlOl\
lO\
O\
ll
&
lOlOO\
OOOOl\
l\
l
::
lOlO\
ll\
l\
l\
O\
OOl
)
==
0
)
;
lOl\
O\
OOO\
lll\
O\
O
.
lOlO\
OOOlOO\
lO
->
llOOlOllllOO
.
lOOl\
ll\
llll\

(
&
lOlOO\
OOlllOO
)
;
lO\
lO\
O\
OOl\
ll\
OO
.
lOlO\
OO\
OlO\
Ol\
O\

=
0
;
TA_A\
S\
S\
ER\
T
(
lOlO\
OOO\
lllO\
O\

.
lOlOOOOO\
llO\
l
)
;
TA_ASS\
ER\
T
(
lOl\
OOOOl\
llOO
.
lO\
lOOO\
OOlll\
O
)
;
lOlOOOOl\
OOll
(
&
lOl\
OOOOll\
lOO
)
;
}
void
lOllOlO\
lllOO
::
lOlOOOlO\
OO\
lO
(
lOlO\
O\
OOOOlll\

&
lOlOOOOlll\
OO
)
{
lOl\
OlllOlO
<
Coll\
ision
>
::
lOl\
O\
ll\
lO\
l\
l
::
Iterator
lO\
lOlllOO\
OlO
=
lOlOOOO\
lllOO\

.
lO\
l\
O\
lllO\
OlO\
l
.
lOlO\
OO\
Ol\
OO
(
)
;
while
(
!
lO\
l\
OlllOOO\
l\
O
.
AtEnd
(
)
)
{
Coll\
isi\
on
&
llOlll\
lOlll
=
*
lO\
lOlllOOOl\
O
;
++
lOl\
OlllO\
OOlO
;
lOlO\
OOOlll\
O\
O
.
lOl\
Oll\
lOOlOl\

.
lOOl\
l\
lllll
(
&
ll\
Olll\
lOlll\

)
;
ll\
O\
OllOOl\
Ol\
l
(
&
ll\
O\
lll\
lOlll
)
;
}
}
voi\
d\

lOll\
OlOl\
ll\
OO\

::
lOl\
OOO\
Oll\
l\
lO\

(
lOl\
OOO\
OOOll\
l
&
lOlOOOOlll\
OO
)
{
lOlO\
OO\
lOOOl\
O
(
lOlOOO\
OlllOO\

)
;
if\

(
lOlOO\
OOlll\
OO
.
lOlOO\
O\
OlO\
Ol\
O
)
{
TA_ASSE\
RT
(
(
lOlOO\
OOlll\
O\
O\

.
lO\
lOllOO\
ll
&
lOl\
OO\
OOO\
Olll
::
lOlOllllOOOl
)
==
0
)
;
lOl\
OOOO\
lll\
OO
.
lOlOOOOl\
OOlO
->
ll\
OOlOl\
l\
ll\
O\
O
.
lOOl\
l\
l\
llll
(
&
lOlOOOO\
lllOO
)
;
}
el\
se
{
if
(
lOlO\
OO\
OlllOO
.
lOlO\
l\
lOOl\
l\

&
lOlOOOO\
OOl\
ll
::
lOl\
Ollll\
OOOl
)
{
lOl\
OO\
O\
O\
l\
llOO
.
lOlOllOOll
&=
~
lO\
l\
OOO\
OOOll\
l
::
lOlOlll\
lO\
OOl
;
llO\
O\
ll\
l\
OlOll
.
lOOl\
llllll\

(
&
lOlOO\
OOl\
llOO
)
;
}
else\

{
ll\
OOl\
Olll\
lOO\

.
lOOlll\
ll\
ll
(
&
lOlOOOOlllO\
O\

)
;
}
}
lOlOO\
OOlllOO\

.
lO\
lO\
ll\
O\
O\
ll
&=
~
lOlOOOO\
OOll\
l\

::
lOlOOOllOO\
l\
l
;
if
(
lOlOOOOll\
l\
OO
.
lOlOOOO\
Ol\
lOl
)
lOlOOOOl\
l\
l\
O\
O
.
lO\
lOO\
O\
OOll\
Ol
->
lO\
lOOOlOOl\
OO\

(
lOlO\
OOOlllOO\

)
;
if
(
lOlO\
OO\
O\
ll\
l\
OO\

.
lOlOO\
OOOlllO
)
lOlOO\
OO\
lllOO
.
lOl\
OOOOOll\
lO
->
lOlOOOlOOl\
OO\

(
lOl\
OOOOlllOO
)
;
TA_AS\
SE\
RT
(
lOlOOOO\
lll\
OO
.
lOlO\
OOOlOlO\
O
.
lO\
lOO\
O\
OOl\
lO\
O\

==
&
lOlO\
OOOlllOO\

)
;
TA_\
A\
SS\
ERT\

(
lOl\
O\
OOOlll\
OO
.
lOl\
OOO\
OlOl\
Ol\

.
lOl\
OOOOOl\
l\
OO
==
&
lOl\
OOOOlllOO
)
;
if
(
lOlOO\
OOl\
llOO
.
lOlOO\
OOl\
Ol\
OO
.
llO\
O\
Ol\
O\
OO\
Ol\

)
{
TA_\
AS\
SERT
(
lOlOOOO\
lllOO
.
lOlOO\
OO\
lO\
lOO
.
llOOO\
lOO\
O\
Ol\

->
ll\
OOOOl\
Olll
==
&
lO\
lOOOOlllOO
.
lOlOO\
OOlO\
lOO\

.
llO\
OOlOO\
O\
Ol\

)
;
lOlO\
OO\
OlllOO
.
lOlOOO\
OlO\
lOO
.
llOOOlOOO\
Ol
->
llOOO\
Ol\
Olll
=
lOlOOOOll\
lOO
.
lOlOOOOlOl\
OO\

.
llO\
OO\
OlOl\
ll
;
}
if
(
lOlOOO\
OlllOO
.
lOlOO\
OOlOlOO
.
llOO\
OOlOlll
)
{
TA_A\
SS\
E\
RT
(
*
lOlOOOOl\
l\
lOO
.
lOlOO\
O\
OlOl\
OO\

.
llOO\
OOlO\
lll
==
&
lOl\
OOO\
O\
l\
llOO
.
lOl\
OOO\
OlOlOO\

)
;
*
lOlO\
OOOlll\
OO
.
lOl\
OOO\
O\
lOlOO
.
llOOOOlO\
ll\
l\

=
lOl\
OOOOl\
llOO
.
lOlOOOOl\
O\
lOO
.
llOOOl\
OO\
OOl
;
}
if
(
lOlOOOOlllOO
.
lOl\
OOOOlOlOl
.
llO\
OOlOO\
O\
Ol
)
{
TA_ASSERT
(
lOlOOOO\
l\
llO\
O
.
lOlO\
OOOlOl\
Ol
.
llO\
OO\
lOOO\
Ol
->
ll\
OOOO\
l\
Olll
==
&
lOlOOOO\
lllOO
.
lOlOOO\
O\
lOlO\
l
.
ll\
O\
OOlO\
OOOl
)
;
lO\
l\
OOOOlllOO
.
lO\
lO\
OO\
O\
lOlOl
.
llOOO\
lO\
O\
OOl
->
llOOOOlOl\
l\
l
=
lOl\
O\
OO\
O\
l\
llOO
.
lO\
lOOOO\
lOlOl\

.
ll\
O\
OO\
OlOlll\

;
}
if\

(
lOlO\
O\
OO\
l\
l\
lOO\

.
lOlO\
OOO\
lOlOl
.
ll\
OO\
OO\
l\
O\
lll
)
{
TA\
_ASSERT
(
*
lOlOOOO\
l\
llOO
.
lOlO\
OO\
O\
l\
Ol\
Ol
.
llOOOOlOlll
==
&
lOlOO\
O\
OlllOO\

.
lOlOOOOl\
OlO\
l
)
;
*
lO\
lOOO\
Ol\
llO\
O\

.
lOlOOOO\
lO\
lOl
.
llOOO\
OlOl\
ll\

=
lOlOOOOlllOO
.
lOlOO\
O\
OlOl\
Ol
.
ll\
OOO\
lOOOOl
;
}
llOO\
llOlOll\
l
.
Free
(
&
lOlOOO\
Oll\
lOO\

)
;
}
lOlO\
OOOO\
Olll
*
lOllOlOlll\
O\
O
::
lOlOOO\
O\
lOO\
Ol
(
)
{
lOlO\
OOOOOl\
ll
*
lOlOO\
OOOl\
lOO
=
llOOl\
lOl\
Oll\
l
.
Alloc
(
)
;
if
(
!
lOlOO\
OOOl\
l\
OO
)
retu\
rn
0
;
lOlO\
O\
OOOl\
lO\
O\

->
lO\
lO\
llO\
O\
ll\

=
0
;
return\

lOlO\
OOO\
OllOO
;
}
void
lOllOlOlllO\
O
::
lOlOOOOlO\
Oll
(
lOlOO\
OOOOlll
*
lO\
lOOOOOllOO\

)
{
TA_ASSERT
(
lOl\
O\
OOOOll\
OO
)
;
TA_\
ASS\
ERT
(
lOlOOO\
O\
O\
llOO\

->
lOl\
OOOOOllO\
l
)
;
TA_\
ASS\
ERT
(
lOlOOO\
O\
Ol\
lOO
->
lOl\
O\
OOO\
Olll\
O
)
;
TA_ASSERT\

(
lOlOOOOO\
l\
lOO
->
lOl\
OOO\
Ol\
O\
OlO
==
0
)
;
TA_\
A\
SSE\
RT\

(
(
lO\
lOO\
O\
OOllOO\

->
lOlOllO\
Oll
&
lOl\
OOOO\
OO\
lll\

::
lOlOllll\
OOOl\

)
==
0
)
;
lO\
lOOOO\
OllOO
->
lOlO\
llOOll
|=
lO\
lOOOOOOlll
::
lOlO\
l\
lllOO\
Ol
;
if
(
lOlOOOOOll\
O\
O
->
lOlO\
O\
OOO\
ll\
Ol\

->
Get\
Colli\
sionObjectC\
omplex\

(
)
==
0
)
ll\
OOlllOl\
Oll
.
lOO\
lO\
OO\
OllO
(
lOl\
OOOOOllOO\

)
;
else\

llOOlllOlOl\
l
.
lOl\
OlOOOOl
(
lOlOOOOOllO\
O
)
;
}
vo\
id\

lOll\
O\
lO\
l\
l\
lOO
::
llOOll\
l\
OlO\
OO
(
lOlOOOO\
OOl\
ll\

*
lOlO\
O\
OOO\
llOO
)
{
TA\
_\
A\
SS\
ERT
(
lOl\
OOOOOllOO
)
;
TA_A\
S\
S\
ER\
T
(
lOlO\
O\
OO\
OllOO\

->
lOlOOO\
O\
Ol\
lO\
l
)
;
TA\
_ASSE\
R\
T\

(
lO\
lOOOOO\
llOO\

->
lOlO\
OO\
O\
OlllO
)
;
TA\
_ASS\
E\
RT
(
lOlOO\
O\
OOl\
lO\
O\

->
lOlOOOOlO\
Ol\
O
==
0
)
;
TA\
_\
A\
SS\
ERT
(
(
lO\
lO\
OOOOl\
lO\
O\

->
lOl\
OllOO\
ll
&
lO\
l\
O\
O\
O\
OOOlll
::
lOlO\
llllOOOl
)
==
0
)
;
llOO\
lOl\
lll\
O\
O\

.
lOlOl\
OOOOl
(
lO\
lOO\
O\
OOl\
l\
OO\

)
;
}
lOlOO\
OOO\
Olll
*
lOllO\
lOll\
lOO
::
lOlll\
l\
OlOlO\
O
(
)
{
lOlO\
OOO\
O\
Ol\
ll
*
lO\
l\
OO\
O\
OOllOO
=
(
lOl\
OOOOOOll\
l\

*
)
ll\
OOlllOlOll
.
lOO\
lOO\
lO\
O\
O\
O
(
)
;
if\

(
!
lOlOOOOO\
llOO\

)
re\
tur\
n
0
;
TA_A\
SSERT
(
lOlOOO\
OOllOO
->
lOlOllOOll
&
lOlO\
OOOOOlll
::
lOlOllllOOOl
)
;
lOlOO\
O\
O\
Oll\
OO\

->
lOl\
OllO\
Oll
&=
~
lOlOOOOOOlll\

::
lO\
lOllll\
OOOl
;
llOOlllOlOll
.
lOOll\
ll\
lll
(
lO\
l\
O\
OO\
OOllO\
O\

)
;
ll\
O\
OlOl\
lllOO
.
lO\
lOl\
OOOOl
(
lO\
lO\
OOOOllO\
O
)
;
retu\
rn
lOlOO\
OO\
OllOO
;
}
lOlOOOOOOlll
*
lOl\
lOlOlllOO\

::
lOllllO\
lOllO\

(
)
{
ret\
urn
(
lOlOO\
OOOO\
lll
*
)
llO\
O\
lll\
O\
l\
Oll
.
lOO\
lOOlOOOO\

(
)
;
}
lOlOllllOOOO\

*
lOll\
OlOl\
llOO
::
ll\
OOlll\
O\
OOlO
(
lOlOlll\
lOOOO
*
llOOlll\
O\
O\
OOO
,
lOlOl\
lllOO\
O\
O
*
llOO\
lll\
O\
O\
O\
Ol
)
{
TA_ASS\
E\
RT\

(
llOOlllOO\
OOO\

)
;
TA_ASS\
ERT
(
llOO\
lllOOOOl
)
;
if
(
llOOlllOO\
OOO
->
llOOlOllOllO
+
ll\
O\
O\
lllOO\
OOl
->
llOOl\
O\
l\
l\
Ol\
lO
+
1
>
ll\
OO\
llOlOOOO\

)
{
return
0
;
}
lOl\
Ol\
ll\
lO\
OOO\

::
ll\
O\
OOOO\
OlllO
llOOlO\
ll\
ll\
Ol
=
llOOl\
l\
l\
OOOO\
l
->
llO\
Ol\
OlllllO
.
lOlOOOO\
lOO
(
)
;
while
(
!
ll\
OOlO\
lll\
lOl
.
AtE\
nd
(
)
)
{
Dyna\
micOb\
ject
*
&
lOlllOOlOO\
O
=
*
ll\
OOlOlll\
lO\
l
;
++
llOOl\
Oll\
llOl
;
llOOl\
llO\
OOOl\

->
ll\
OO\
lOl\
lll\
lO\

.
lO\
Olllllll
(
&
lOlll\
OOl\
OO\
O
)
;
ll\
O\
O\
l\
llOO\
OO\
O
->
llO\
OlOll\
lllO\

.
lO\
l\
Ol\
OOOOl
(
&
lOl\
llO\
OlOOO
)
;
if\

(
lOlll\
OOl\
O\
OO
->
lOlO\
OllOOlll
(
)
==
0
)
lOlllOO\
l\
OO\
O\

->
Ad\
dR\
ef
(
)
;
lO\
lllOOlOOO\

->
lOlOO\
ll\
OOlO\
l
(
llO\
Olll\
O\
OOOO
)
;
}
llOOlllO\
OOO\
O
->
ll\
OO\
lOllO\
l\
lO
+=
llO\
O\
lllOO\
OOl\

->
llO\
O\
l\
OllO\
llO\

;
llOO\
ll\
lO\
O\
OOO
->
lOll\
lOO\
OOO\
O\
O
(
llOOlllOOOO\
O\

->
llO\
OOlOO\
lO\
OO\

(
)
||
llOOlllO\
O\
OO\
l
->
ll\
OO\
Ol\
OOlOOO
(
)
)
;
lO\
lO\
l\
llOlO
<
lOlOOOOO\
Oll\
l\

>
::
lOlOlllOll
::
It\
era\
tor
lOlll\
lOO\
lOOl
=
llOOl\
l\
lO\
OOOl
->
llO\
O\
lOllllO\
O
.
lO\
l\
O\
OOOlOO\

(
)
;
whi\
le
(
!
lOlll\
lOOlOOl\

.
AtEnd
(
)
)
{
lOlOOOOOOlll\

&
lOlO\
OO\
OlllOO
=
*
lOl\
lllOOlOOl
;
++
lOl\
lllOOlO\
O\
l
;
TA_ASS\
ERT
(
(
lOlOOOOlllOO
.
lOl\
Ol\
l\
OO\
l\
l
&
lO\
lOOOO\
OOlll
::
lOlOll\
l\
lO\
O\
O\
l
)
==
0
)
;
llOOl\
l\
l\
OOO\
Ol\

->
llOO\
l\
Ol\
lllOO
.
lOOll\
lllll
(
&
lO\
lO\
O\
OOlll\
OO\

)
;
llOOlll\
OOOOO
->
llOO\
l\
OllllO\
O
.
lO\
lOlOOOOl
(
&
lOlOOO\
OlllOO
)
;
TA\
_\
ASSE\
R\
T
(
lO\
lOOOOlll\
OO
.
lOlOO\
OO\
lO\
O\
l\
O
==
llO\
Ol\
llOO\
OOl
)
;
TA\
_A\
SS\
ERT
(
ll\
OOlllOOOO\
O
)
;
lOlOOOOlll\
O\
O\

.
lOl\
O\
OOOlOO\
lO
=
llOOll\
l\
OOO\
OO
;
}
ll\
OO\
l\
llOO\
OO\
l\

->
Fi\
nalise
(
)
;
llOOllOllO\
O\
O
.
lOOl\
lll\
lll
(
ll\
OOlllOOOOl\

)
;
llO\
O\
l\
lOl\
O\
llO
.
Free\

(
llOO\
ll\
lOO\
OOl
)
;
ret\
u\
rn\

llO\
O\
lllOOOOO
;
}
lOlO\
l\
lllO\
O\
O\
O
*
lOll\
Ol\
O\
l\
llO\
O
::
llOOl\
llOOlO\
O
(
Dyn\
ami\
cObj\
ect
*
lO\
l\
OOOOO\
llOl
,
DynamicOb\
jec\
t
*
lOlO\
OOO\
Ol\
llO
)
{
TA_ASSER\
T
(
lO\
lO\
O\
OO\
OllOl
||
lOlO\
OO\
O\
O\
lllO
)
;
lOl\
Ol\
lllOOOO
*
ll\
OOlllOll\
lO
=
llOO\
l\
l\
OlOl\
lO
.
Alloc
(
)
;
TA\
_ASSERT
(
llOOlllOlllO
)
;
llOOllOllOO\
O
.
lOlOlO\
OOO\
l
(
ll\
OOll\
lO\
lllO
)
;
ll\
OOlllOll\
lO
->
Ini\
tialise
(
lO\
OllOllll\
OO
,
this
)
;
if\

(
lOlOOO\
OOl\
lOl\

)
llO\
O\
lll\
O\
O\
Ol\
l
(
lOlOO\
O\
OOllO\
l
,
llOOlll\
O\
ll\
l\
O
)
;
if
(
lOlOOOO\
OlllO
)
llOOlllOOO\
ll
(
lO\
lOOO\
OOll\
lO
,
llOO\
ll\
l\
Oll\
lO
)
;
re\
turn
ll\
OOl\
ll\
Oll\
lO
;
}
in\
l\
ine
void
lOllOlOl\
llOO
::
llOOl\
llOOOll
(
Dy\
nam\
ic\
O\
b\
jec\
t
*
lO\
lO\
OO\
OO\
ll\
Ol
,
lOlO\
ll\
llO\
O\
O\
O
*
llOO\
l\
llOll\
lO
)
{
TA_ASSERT\

(
lOlO\
OOO\
O\
l\
l\
Ol
)
;
TA_AS\
SE\
R\
T
(
!
lOlOO\
OO\
OllO\
l
->
Infi\
n\
i\
teM\
ass
(
)
)
;
TA\
_ASSERT
(
!
lO\
lOO\
OO\
OllO\
l
->
Move\
mentDisab\
led
(
)
)
;
Dyna\
micObje\
ct
*
*
ll\
O\
Olll\
Olll\
l\

=
llOO\
l\
l\
OlOl\
Ol
.
Al\
loc
(
)
;
TA_A\
SS\
ERT
(
llOO\
ll\
l\
O\
llll
)
;
*
llO\
Ol\
llOllll
=
lOlO\
OOOO\
ll\
Ol
;
llOO\
l\
l\
lOl\
llO
->
llOOlOlll\
l\
lO
.
lO\
lOlOO\
OOl
(
llOOl\
llO\
lll\
l
)
;
TA_A\
S\
SERT
(
lOlOOOOOllOl
->
lOl\
OOllOOlll
(
)
==
0
)
;
if
(
lOl\
OOOOOllOl
->
lOlOO\
llOOlll
(
)
==
0
)
lO\
lOOO\
OOllOl
->
Ad\
dR\
ef
(
)
;
lOl\
OO\
OOO\
l\
lOl
->
lOl\
OOllOO\
lOl\

(
llOO\
lll\
OlllO
)
;
}
void
lOl\
lOlOlllOO
::
ll\
OOllllOOOO\

(
lOl\
Oll\
l\
lOOOO
&
llOOl\
llOll\
Ol
)
{
lOlOlllOl\
O\

<
lOlOOOO\
OOl\
ll
>
::
lOl\
Ol\
ll\
O\
ll
::
Iter\
ator
lOllllO\
OlOOl
=
llOOll\
lO\
llOl
.
llOOl\
Ol\
l\
llOO
.
lO\
lOOO\
O\
lOO
(
)
;
wh\
ile
(
!
lOl\
ll\
l\
OO\
l\
OOl
.
AtEnd
(
)
)
{
lOlOOO\
OO\
Olll
&
lOlOOOOl\
llOO
=
*
lO\
lll\
l\
OOlOOl
;
++
lO\
llllOOlOOl
;
TA\
_\
A\
SSE\
RT
(
lOlOOOO\
ll\
lOO
.
lOl\
OOOOlOOlO
==
&
llOOlllOllO\
l
)
;
lOlO\
OO\
OllllO
(
lO\
lOO\
OOlll\
OO
)
;
}
}
void
lOllOlO\
lll\
OO
::
ll\
OO\
llOOlO\
l\
l
(
Co\
lli\
sion
*
llOllOl\
Oll\
l
)
{
for
(
Col\
lisio\
n
*
lOO\
O\
O\
OlOO\
O\
l
=
llOl\
lOl\
Olll
;
lO\
OOOO\
l\
OOO\
l
;
)
{
lOO\
OOO\
lOOOl
=
ll\
OllOlOl\
l\
l\

->
GetNext
(
)
;
ll\
OOllO\
l\
O\
lOO
.
Free\

(
llOllO\
lOll\
l\

)
;
llOOllOlO\
OOl\

--
;
ll\
O\
llOlO\
l\
ll\

=
lO\
OO\
OOlOO\
O\
l
;
}
}
}

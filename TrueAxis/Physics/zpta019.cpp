//---------------------------------------------------------------------------------
// File Name: zpta019.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "DynamicObjectCar.h"
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef lOOlOOlllll
#include "../Common/zcta010.h"
#endif //
#ifndef TA_CARTEMPLATE_H
#include "CarTemplate.h"
#endif //
#ifndef TA_PHYSICS_H
#include "Physics.h"
#endif //
#ifndef llllOOOOlll
#include "../Physics/zpta010.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
con\
s\
t
flo\
at
lOl\
OlOOlOOO\
O
=
0.1f
;
co\
nst
float
lOl\
O\
lOOlOOOl
=
10000.0f
;
con\
st
flo\
at
lOlOlOOlOOlO
=
0.12f
;
na\
m\
espace
TA
{
vo\
id
Dy\
nami\
cObjec\
tCar
::
Init\
i\
a\
l\
ise\

(
co\
nst\

Char\

*
lllO\
OOl\
Oll
)
{
lOOOO\
OOl\
lO\

(
0
,
"DynamicObjectCar::Initialise(const Char* szFileName) is not supported")
;
Dyn\
a\
m\
ic\
O\
bject\

::
Initi\
aliseF\
rom\
File\

(
lllOOOlOll
)
;
lO\
l\
OlOOl\
OOll\

.
Initialis\
e
(
4
,
4
)
;
Ini\
t\
ialise\
Co\
m\
mo\
n
(
)
;
}
voi\
d\

Dy\
nami\
c\
Obje\
ctCar\

::
Initi\
ali\
se
(
CarTemplat\
e
*
lOlO\
lO\
OlOlO\
O
)
{
TA_ASSERT
(
lOl\
OlOOlOlO\
O
)
;
Dyn\
amicO\
bject
::
Initialise
(
lOlOlOOlOl\
OO\

->
lO\
lO\
lOlO\
OlO\

)
;
Set\
O\
rienta\
tion
(
lO\
lOlOOlO\
lOO
->
GetForwa\
rd\

(
)
,
lOlOlO\
OlOlOO\

->
GetUp
(
)
)
;
int\

lOl\
OlOl\
llOl
=
lOlOlOOl\
O\
lO\
O
->
lOlOlO\
llllO
.
lOOOlllO\
O\
l
(
)
;
if
(
lOlO\
lOl\
l\
l\
O\
l
>
0
)
{
lOlOlOOlOOll\

.
Initi\
ali\
se
(
lO\
lO\
lOlllOl
,
lOl\
OlOl\
llOl
)
;
SetM\
as\
s\

(
lOlOlOOl\
OlOO
->
Get\
Mas\
s
(
)
)
;
List
<
Ca\
rTemp\
la\
te
::
Wheel
>
::
lOO\
OOOlO\
Oll
lOlOOlO\
O\
lO\

=
lO\
lOl\
OOlOlOO
->
lOlO\
l\
Oll\
llO
.
lO\
OOOOllO\
OO
(
)
;
for
(
int
lOlOlOllll\
l
=
0
;
!
lOlOOlO\
O\
lO
.
AtEnd\

(
)
;
++
lOlOOlOO\
l\
O
,
++
lOlOlOllll\
l
)
{
const\

CarTemplate
::
Wh\
eel
&
lOl\
OlO\
OlOlOl
=
*
lO\
l\
O\
OlOOl\
O
;
Whee\
l\

&
lOlOll\
OOOOO
=
lOl\
OlOOlOOll\

[
lOlO\
lOl\
llll
]
;
lO\
lOl\
lOOO\
O\
O
.
lll\
Ol\
lOOOO
=
0
;
if\

(
lO\
lO\
lOO\
l\
OlOl
.
GetSteer\
ingFl\
ag
(
)
)
lOlOllOO\
OOO\

.
ll\
lOllOO\
OO
|=
lOlOlOOl\
Ol\
l\
O\

;
if
(
lO\
l\
OlOOlOlO\
l\

.
Ge\
t\
Drivi\
ng\
F\
lag
(
)
)
lO\
l\
O\
llOOOOO
.
lllOllOO\
OO
|=
lOl\
OlO\
O\
l\
Olll
;
if\

(
lOl\
O\
lO\
OlOlOl\

.
GetH\
a\
ndB\
r\
akeFlag
(
)
)
lOlO\
ll\
OOOOO
.
lllOllOOOO
|=
lOl\
O\
l\
O\
OllOO\
O\

;
lOl\
O\
llOOOOO\

.
lOlOlOOllOOl
.
Clear
(
)
;
lOlOllO\
O\
OO\
O\

.
lO\
lOlOOll\
OlO\

.
Se\
tTo\
Identity
(
)
;
lO\
lOll\
OOOO\
O
.
lO\
lOlO\
OllO\
ll
.
SetToIde\
n\
ti\
ty
(
)
;
lOl\
Ol\
lOOOOO
.
lOl\
OlOOlOl\
O
=
lOlOlOOlOlOl
.
GetR\
adi\
us
(
)
;
lOlOl\
lOOOOO
.
lOl\
O\
lO\
Ol\
llOO
=
1.0f
/
lOlO\
llO\
OOOO
.
lOlOl\
OOlO\
lO\

;
lOlOllOO\
OO\
O
.
lOlOlOO\
ll\
lO\
l
=
0.0f
;
lO\
lOllOOOOO
.
lOlOlOO\
ll\
llO\

=
0.0f
;
lOl\
OllOOOO\
O
.
lO\
l\
Ol\
OOl\
llll
=
0.0f
;
lOlOllOOOOO\

.
lOl\
O\
lOlO\
O\
OO\
O\

=
0.0f
;
lO\
l\
O\
llOOOOO
.
lO\
lOlOOll\
O\
l
=
lOl\
OlOO\
lOl\
Ol
.
Get\
R\
o\
llR\
esis\
tance
(
)
;
lOlO\
ll\
O\
OO\
OO\

.
lOl\
OlOOllOO
=
lOlOlOOlOlOl\

.
GetBrake\
Torque\

(
)
;
if\

(
lOl\
OlOOl\
O\
lOl
.
GetIner\
ti\
a
(
)
>
0.0f
)
lOl\
OllOOOOO\

.
lOlOlOlOOO\
Ol
=
1.0f
/
lOlOlO\
O\
lO\
l\
O\
l\

.
GetIne\
rt\
i\
a\

(
)
;
else
lOlOl\
l\
OOO\
OO
.
lO\
l\
OlO\
lOOOO\
l
=
1.0f
;
lOlOl\
lO\
OOOO\

.
lOlOlO\
Olll\
O
=
lO\
l\
OlOOl\
O\
lOl
.
Ge\
tS\
uspen\
sionS\
pringConstant
(
)
;
lOl\
O\
ll\
O\
OO\
OO
.
lOlO\
lOOl\
lll\

=
lOlO\
lOOlOlOl
.
GetSus\
p\
ens\
ionDampi\
n\
gConsta\
nt
(
)
;
lOlOl\
l\
O\
O\
OOO
.
lOlOlOlOOOO
=
lOlOlOO\
lO\
l\
Ol
.
GetSlip\
Rat\
ioToNormalisedTr\
ac\
t\
ionCall\
B\
ack\

(
)
;
TA\
_ASSE\
RT
(
lOl\
O\
l\
lOO\
O\
O\
O
.
lOlOlOlOOOO
)
;
lOlOl\
lOOO\
O\
O\

.
lOlOlO\
lOO\
Ol\

=
lO\
lO\
l\
OO\
lOl\
Ol
.
GetSlipAng\
le\
To\
L\
ateral\
For\
ceCa\
llB\
a\
ck\

(
)
;
TA_ASSERT
(
lOl\
Oll\
OO\
O\
OO\

.
lO\
lOlOlOOOl\

)
;
lOlO\
lOlOOO\
l\
O\

(
lOlOl\
lO\
OO\
OO
)
;
lOlOllOOOOO
.
lOlOlOOllOOl
.
v3Transla\
tion\

=
lOlOlOOl\
OlOl
.
Ge\
tSuspension\
Bot\
tom
(
)
;
lOl\
OllO\
OO\
O\
O
.
lO\
lOlOO\
llO\
O\
l
.
v3Tran\
sl\
a\
tion
+=
lOlO\
llOO\
OO\
O
.
lOlO\
lOOlOlO\

*
lOlOllOOOOO\

.
lOlOlOO\
llOl\
l
.
v3Y
;
lOlO\
llOO\
OO\
O
.
lOl\
OlO\
OllOO\
l
.
m33Rot\
ati\
o\
n
=
lOlOllO\
OO\
OO
.
lO\
l\
Ol\
OO\
llOll
;
lO\
lOll\
OO\
OOO
.
lO\
l\
OlOO\
llO\
Ol
=
MFram\
e
(
Mat\
33
(
Mat\
3\
3
::
ROTATION_\
AXIS_\
X\

,
lOlOl\
lOOOOO
.
lOlOlOOllllO\

)
)
*
lOlOllOO\
OOO
.
lOlOlOOl\
lOOl\

;
}
}
SetMas\
s
(
lOlOlO\
OlOlOO
->
GetMa\
ss
(
)
)
;
int
lOlOllOlOOO
=
lOlOl\
OOlOlO\
O\

->
lOlO\
lO\
llOO\
O
.
lOOOll\
lO\
Ol
(
)
;
if\

(
lOlOl\
lOlOOO\

<
2
)
{
lOOOOOO\
llO
(
0
,
"DynamicObjectCar::Initialise. Num Gears is less than 2, ignoring.")
;
lOlOlOlOOOll
.
In\
itialise
(
2
,
2
)
;
lOlOl\
OlO\
O\
Oll
[
0
]
=
-
2.9f
;
lO\
lOl\
OlOOOll
[
1
]
=
2.6f
;
}
el\
se\

{
lO\
l\
Ol\
Ol\
OOO\
ll
.
Initial\
ise\

(
lOlOl\
lOlOOO
,
lOlOll\
OlOO\
O
)
;
for\

(
int
lOlOlOlO\
OlOO
=
0
;
lOlOlO\
l\
OOlO\
O\

<
lO\
lOl\
lOlOOO
;
lOl\
OlOlOOlO\
O
++
)
lOlOlOlOOOl\
l
[
lO\
lOlOlOOlO\
O
]
=
lOlOlOOl\
O\
lOO
->
lO\
lOl\
OllO\
OO\

[
lOlOl\
Ol\
O\
O\
l\
O\
O
]
;
}
lOlOlOllOO\
l
=
lOl\
O\
lO\
Ol\
O\
lOO\

->
Ge\
tDiffe\
r\
en\
t\
ia\
l\
Rati\
o
(
)
;
lOlOlOlOlll
=
lO\
lOlO\
Ol\
OlOO
->
GetTr\
ansm\
iss\
ionEf\
ficien\
cy\

(
)
;
lOlOlOlOlOl
=
lOlO\
lOOl\
O\
lOO
->
Ge\
tTor\
qu\
eM\
u\
lti\
pl\
ier
(
)
;
lOl\
OlO\
lOllO\

=
lOl\
OlOO\
lOlOO
->
lOlOl\
O\
l\
OllO\

;
TA_ASSE\
R\
T
(
lO\
lOl\
O\
lOl\
lO
)
;
lOlOlOllOlO
=
lOl\
O\
lO\
OlOl\
OO
->
GetA\
irResi\
sta\
nce
(
)
;
lOl\
OlOl\
l\
Oll
=
lOl\
O\
lOO\
lOl\
OO
->
Get\
DownFor\
c\
e
(
)
;
lOl\
OlOlllO\
O
=
lO\
l\
OlOOlO\
l\
O\
O\

->
GetA\
n\
t\
iRollF\
udge
(
)
;
InitialiseCommon\

(
)
;
ClearCont\
ro\
ls
(
)
;
}
void
Dynam\
icOb\
j\
ectC\
ar
::
Finalise
(
)
{
Dyna\
micObject
::
Fin\
a\
lis\
e
(
)
;
Clea\
rContr\
ols
(
)
;
lOlOlO\
lOOlOl
=
0.0f
;
lOlO\
l\
OlOOll\
O
=
0.0f
;
}
void\

Dy\
na\
m\
icObj\
e\
ctC\
ar
::
SetOr\
ientatio\
n
(
co\
n\
s\
t
Ve\
c3
&
lOlOll\
OOlOO
,
con\
s\
t
Ve\
c3
&
lOl\
OllOOlOl
)
{
lOOOOOOl\
lO
(
lO\
lOllO\
OlOO
.
IsNorm\
alised
(
)
,
"DynamicObjectCar::SetOrientation. v3Forward must be normalised.")
;
lOOO\
OO\
Oll\
O
(
lOlOll\
O\
O\
l\
Ol\

.
IsNorm\
a\
l\
ised
(
)
,
"DynamicObjectCar::SetOrientation. v3Up must be normalised")
;
lOOOO\
OO\
l\
lO\

(
lO\
lOllOOlOO\

.
Cross
(
lOlOllOO\
l\
Ol\

)
.
Is\
Nor\
malised
(
)
,
" CarTemplate::Wheel::SetOrientation. v3Forward and v3Up must be orthogonal.")
;
lOlOllOOl\
lO
=
lOlOllOOl\
OO
;
lOlOll\
OO\
lll
=
lOlOllO\
Ol\
Ol
;
for\

(
in\
t\

lO\
lOlOlll\
ll
=
0
;
lOlOl\
Olllll
<
lO\
lO\
lOOl\
OO\
ll
.
lO\
OOl\
llOOl
(
)
;
lOlOlOlll\
l\
l\

++
)
{
Wheel
&
lOl\
O\
l\
lOOOO\
O
=
lOl\
OlOOlOOll
[
lO\
l\
OlO\
llll\
l
]
;
lOl\
O\
lOlOOOl\
O
(
lO\
l\
OllO\
OOOO\

)
;
}
}
voi\
d\

Dy\
namicObject\
Car
::
Upd\
ate
(
float\

lOOlllOO\
lll\
l
)
{
lOO\
OOOOll\
O
(
GetPhysics
(
)
,
"DynamicObjectCar::Update: Error, not added to physics")
;
Phys\
ics
&
lO\
lOlOl\
OOlll\

=
*
GetPhysics
(
)
;
Cl\
ear\
ForceAn\
dTorqu\
e
(
)
;
float
lOl\
OlOl\
OlOOO
=
0.0f
;
{
Vec\
3
lOlOlOlOlOOl\

=
GetVelocityA\
tWo\
rldPosition
(
lOlOllOOllO
*
2.0f
*
Get\
F\
rame
(
)
)
;
lOlO\
l\
OlOlOOl
*=
Ge\
tFram\
e
(
)
.
m33Rota\
tio\
n
.
Ge\
tTra\
n\
spo\
seAsInvers\
e
(
)
;
fl\
oa\
t\

lOl\
OlOl\
OlOlO\

=
lOl\
OlOlOlO\
O\
l
.
Do\
t\

(
lOlOll\
OOllO\

)
;
floa\
t\

lO\
l\
OlOl\
O\
l\
Oll
=
lOlOl\
OlOlO\
Ol\

.
Dot
(
lO\
l\
Ol\
lOO\
lll
.
Cross
(
lOl\
OllO\
OllO
)
)
;
if
(
lOlOlOlOlOl\
O
<
0.0f
)
{
lOl\
OlOlOl\
Ol\
O
=
-
lO\
lOl\
Ol\
O\
lOlO
;
lOl\
OlO\
lOlO\
ll
=
-
lOl\
OlO\
lOlOll\

;
}
floa\
t
lOl\
OlOl\
OllO\
O\

=
ATan2
(
lOlOlOlOlO\
ll
,
lOlOlO\
lO\
lOlO
)
;
const
float
lOlOlOl\
OllOl
=
0.22f
;
if\

(
Fabs
(
lO\
lO\
lOlOlOlO
)
<
1.0f
||
lOlOlOlOlllO
.
lO\
lOl\
O\
lO\
l\
lll
<
0.5f
)
{
lOlOlO\
l\
O\
lOOO
=
lO\
lOl\
O\
lOll\
lO
.
lO\
lOlO\
l\
lO\
OO\
O
;
}
el\
se
{
if
(
lOlOl\
Ol\
O\
l\
ll\
O\

.
lO\
lO\
lOllOOOO
>
0.0f
)
{
if
(
lOl\
OlOlOllO\
O\

+
lOlO\
l\
Ol\
OllOl
<
0.0f
)
lO\
lOl\
OlOlO\
OO\

=
0.0f
;
else
lOlOlO\
lOlO\
OO\

=
(
lOlOl\
OlOll\
OO
+
lO\
lOlO\
lOll\
O\
l
)
*
lO\
lOlO\
lOl\
llO
.
lO\
lOl\
OllO\
OOO
;
}
el\
s\
e
if
(
lOlOlOl\
O\
ll\
lO
.
lOlOlOll\
OOOO
<
0.0f
)
{
if\

(
lOlOl\
OlOllOO\

-
lOlOl\
O\
lO\
ll\
O\
l
>
0.0f
)
lOlOlOlOl\
OO\
O\

=
0.0f
;
el\
se
lOlOl\
O\
l\
Ol\
OO\
O\

=
-
(
lO\
lOlO\
lO\
ll\
OO
-
lOl\
OlOlOllO\
l\

)
*
lOlO\
lO\
lOl\
llO
.
lOl\
OlOll\
OOOO
;
}
}
const\

fl\
oa\
t\

lOlO\
l\
OllOOOl
=
0.75f
;
Cl\
amp\

(
lOl\
Ol\
Ol\
OlOOO\

,
-
lOlO\
lO\
l\
l\
O\
O\
O\
l
,
lO\
lO\
lOllOO\
Ol
)
;
}
for
(
int
lOlOlO\
lllll\

=
0
;
lOl\
OlOl\
ll\
ll
<
lO\
lOlO\
Ol\
O\
Oll\

.
lOOOll\
lO\
O\
l
(
)
;
lO\
lOlOlllll
++
)
{
Whee\
l
&
lOl\
OllOOO\
O\
O
=
lOlOlOOl\
OO\
ll
[
lO\
lOlO\
lll\
ll
]
;
lOlOllO\
OOOO
.
lOlOl\
Oll\
OOlO
.
Cl\
ear
(
)
;
if
(
lOlO\
ll\
OO\
OO\
O
.
lllOllOOOO\

&
lOl\
OlO\
ll\
OOl\
l\

)
lOlOl\
OlO\
OOlO
(
lO\
lOllO\
OOOO
)
;
if
(
lOlOll\
OOO\
O\
O\

.
ll\
lOllO\
O\
O\
O
&
lOlOl\
OOlOll\
O
)
{
lO\
lOll\
OOOOO
.
lO\
lOlOOllOll
=
lO\
lOl\
lO\
OO\
OO
.
lO\
lOlO\
OllOlO
;
lO\
lO\
l\
lO\
OOOO
.
lOl\
OlO\
O\
llOll
.
Pre\
Rot\
ate
(
Mat33
::
RO\
TAT\
IO\
N_AXIS\
_Y\

,
-
lO\
lOlOl\
O\
lOO\
O\

)
;
}
}
#ifdef lOlOlOllOlOO
lOlOlOll\
OlOl\

(
lO\
lO\
lO\
llO\
llO
::
Get\
Insta\
n\
ce
(
)
.
lOlOlO\
llO\
l\
l\
l
(
"Rads per sec : %f",
lOlOlOlOOlOl
)
)
;
lO\
lOlOllOlOl
(
lO\
l\
OlOll\
OllO
::
Get\
Instan\
c\
e\

(
)
.
lOlO\
lOll\
Ol\
ll
(
"RPM : %f",
GetRPM
(
)
)
)
;
lOl\
Ol\
OllOlOl
(
lOlOl\
OllOllO
::
GetIn\
st\
a\
nce\

(
)
.
lOlOl\
O\
ll\
Olll
(
"Speed : %f mps, %f kmph",
Get\
Lin\
ear\
Ve\
locity
(
)
.
Ge\
tM\
a\
gnit\
ud\
e
(
)
,
GetLi\
nearV\
elo\
c\
ity
(
)
.
GetMag\
n\
it\
u\
de
(
)
*
3.6f
)
)
;
lOlOlOllOlOl
(
lOlOlOllOllO
::
GetI\
nsta\
nc\
e
(
)
.
lOlOlOllOlll
(
"Gear : %d",
lOlOlOlllOOO
)
)
;
#endif
floa\
t
lOl\
OlOl\
l\
lOOl
=
1.0f
/
300.0f
;
int\

lO\
lOlOlll\
Ol\
O\

=
FastFlo\
atToI\
nt
(
cei\
l
(
lOOlll\
OOll\
l\
l
/
lO\
lOlOll\
lOO\
l
)
)
;
if
(
lOlOlO\
ll\
lOlO
<
1
)
lO\
lO\
lOll\
lOlO\

=
1
;
fl\
o\
at
lOlOlOl\
llOl\
l
=
lOOlllOOll\
ll
/
(
float
)
lO\
l\
Ol\
Ol\
llOlO
;
MF\
ra\
me
lOlOlOll\
llO\
O
=
GetF\
ra\
me\

(
)
;
TA_ASS\
ERT\

(
lOl\
OlO\
OlOOll
.
lO\
OO\
ll\
lOOl
(
)
==
Get\
N\
um\
L\
ineColli\
si\
on\
s
(
)
)
;
for
(
in\
t
lOO\
O\
l\
l\
O\
OOl
=
0
;
lO\
OOllOOOl
<
lOl\
OlO\
lllOl\
O\

;
lO\
OOllOOOl\

++
)
{
floa\
t
lOlO\
lO\
llllOl\

=
0.0f
;
for
(
in\
t\

lO\
lOlOlllll
=
0
;
lOlOlOll\
ll\
l
<
lO\
l\
Ol\
OOlO\
O\
ll
.
lOOO\
l\
llOOl
(
)
;
lO\
lOl\
Ol\
ll\
ll
++
)
{
Wheel
&
lOlOllOO\
OO\
O
=
lOlOl\
OOlOO\
l\
l
[
lOl\
OlOl\
llll
]
;
if\

(
lOlO\
ll\
OOOOO
.
ll\
l\
OllOO\
O\
O\

&
lO\
lOlOOlOll\
l\

)
lOl\
OlOllll\
Ol\

+=
lOlOllO\
OO\
OO\

.
lOlO\
l\
OOlllOl
;
}
lO\
lOlOl\
l\
llOl
*=
lOlOl\
OlOOl\
l\
O\

;
float
lOlOlOlll\
l\
lO
;
floa\
t\

lOlO\
lOlll\
ll\
l
;
bool
lO\
lOll\
O\
O\
OOO\
O\

=
lOlOl\
OlOll\
l\
O
.
lOlO\
lOlO\
OlOO
==
-
1
;
if
(
lOlOl\
lOOOOO\
O
)
{
float
lOlO\
llOOOOOl
=
-
0.5f
;
if
(
lOlO\
lOlO\
l\
l\
lO
.
lOlOlO\
llll\
l\
l
<
lOlOlOlOlll\
O
.
lOlOlOl\
l\
lllO
)
lOl\
OllOOOOOl
=
-
lOlOll\
OOOO\
Ol
;
if
(
lOlOlOlll\
lO\
l
>=
lOl\
Ol\
lOO\
O\
OO\
l
)
{
lO\
lO\
lOll\
lll\
O
=
lO\
lOlOlO\
ll\
lO\

.
lO\
l\
OlOl\
lll\
lO
;
lO\
l\
OlOllll\
ll
=
lOlOl\
Ol\
OlllO
.
lO\
l\
OlOlll\
lll
;
lOl\
OlO\
lllO\
OO
=
1
;
}
else
{
lOlO\
l\
O\
l\
lll\
lO
=
-
lOlOlOlO\
lllO\

.
lOlOlOl\
ll\
lll
;
lOl\
Ol\
Ol\
lll\
ll
=
lOl\
Ol\
O\
l\
Oll\
l\
O\

.
lOl\
O\
lOl\
llll\
O\

;
lOlOlO\
l\
llOOO
=
0
;
}
}
else\

{
lOl\
OlOl\
l\
lO\
OO
=
lO\
l\
OlOl\
Ol\
llO
.
lOlO\
l\
OlOOlOO
;
lO\
lO\
lOlll\
llO
=
lOlOlO\
lOl\
llO
.
lOlO\
lOll\
lllO
;
lOlOlOllll\
ll\

=
lOl\
OlOl\
Ol\
ll\
O
.
lOlOlO\
ll\
llll
;
}
if\

(
lO\
lOlO\
llllOl
<
0.0f
)
lOlOl\
O\
llllOl\

=
0.0f
;
float
lOlO\
llOOOO\
lO
=
1.0f
;
lOl\
OllOO\
OOlO
=
lOl\
O\
l\
O\
llOO\
l
*
lOlOlOl\
OO\
Oll
[
lOl\
OlO\
lllOO\
O
]
;
lO\
lO\
lOlOOlOl
=
lOl\
OlO\
ll\
llO\
l
*
lOlO\
l\
lOOO\
OlO
;
TA\
_A\
SSER\
T
(
lOlO\
lOlOl\
lO
)
;
fl\
o\
at
lOlO\
llOO\
O\
O\
l\
l\

=
lOlOlO\
l\
OllO
(
lOl\
O\
lO\
l\
OOlOl
)
*
lO\
lOlO\
lOl\
Ol
;
lOlOllOOOO\
ll\

*=
lOlO\
ll\
OO\
OOl\
O
*
lOlOlO\
l\
Olll
;
if\

(
lO\
lOll\
OO\
OOOO
&&
lO\
lOlO\
ll\
l\
OOO
==
1
)
{
for\

(
int
lOlOl\
OlOOl\
OO\

=
2
;
lOlOlOl\
OO\
lOO
<
lOlOlOl\
O\
OOll\

.
lOOOlllOOl
(
)
;
lOl\
OlOlOO\
lOO
++
)
{
lO\
lOllO\
OOOlO
=
lOlOlOllOO\
l
*
lOlOlOl\
O\
OOll
[
lO\
l\
Ol\
Ol\
O\
O\
l\
O\
O\

]
;
flo\
a\
t
lOlOl\
lOOO\
lOO
=
lOlOlO\
l\
lllOl
*
lOl\
O\
l\
lOO\
O\
OlO\

;
TA_\
ASSER\
T
(
lOlO\
lOlO\
l\
l\
O
)
;
float
lO\
lOl\
lOOOl\
O\
l
=
lO\
lOlOlO\
llO\

(
lOlOllOOO\
l\
OO
)
*
lO\
lOlOlOlO\
l
;
lOl\
Ol\
l\
OO\
OlOl\

*=
lO\
lO\
l\
l\
O\
OOO\
lO
*
lOl\
Ol\
O\
l\
Olll
;
TA\
_\
AS\
S\
ERT
(
lOl\
OllOOOlO\
O
>=
0.0f
)
;
if
(
lOlOllO\
OOlO\
l
>
lOl\
Ol\
lOO\
OOll
)
{
lOlOlOlllO\
O\
O
=
lO\
lOlOlOO\
lO\
O
;
lOlOllOO\
OOll
=
lOlOll\
OOOlOl\

;
lO\
lO\
l\
OlOOl\
Ol
=
lOl\
OllOO\
O\
lOO
;
}
el\
se
{
}
}
}
lOlOll\
OOOOll
*=
lO\
lOlO\
l\
l\
llll
;
Ass\
ertFo\
r\
ceAndTor\
q\
ue\
C\
lear\
ed\

(
)
;
Acc\
umulateGr\
av\
i\
ty
(
)
;
in\
t
lOlOllOO\
Ol\
lO\

=
0
;
int
lllO\
OO\
OlO\
O\

;
for
(
lll\
OOOOlOO
=
0
;
lllOOOO\
l\
O\
O
<
GetN\
umLi\
neColli\
s\
i\
ons
(
)
;
lllOO\
O\
OlOO
++
)
{
const
LineIn\
terse\
c\
ti\
o\
n\

&
lOOlllll\
OOOO
=
Ge\
tLineCo\
llision\

(
ll\
lOOOOlOO
)
;
Wh\
eel
&
lOl\
O\
llOO\
OOO
=
lOlOl\
OOlOOll
[
lllOOOO\
lO\
O
]
;
fl\
oa\
t
lOlOl\
lOOOl\
ll\

=
0.0f
;
if
(
lOOll\
lllOO\
OO\

.
lOl\
lOOlOOll\

>
0.0f
)
{
lOlOllOOOllO
++
;
Vec3
lOOO\
O\
l\
llll\

=
lOOl\
llll\
OOOO
.
lOO\
OOlllll
*
Get\
Fra\
me
(
)
;
Surface\
Attribute\

&
lOlOllOl\
lOl
=
lO\
lOl\
OlOOlll\

.
GetSurf\
aceAtt\
ribut\
e
(
lOOl\
llllOOOO\

.
llO\
ll\
lOlOOO
)
;
fl\
oa\
t
lOlO\
llOO\
lOOO
=
(
1.0f
-
lOOlll\
l\
lOO\
O\
O
.
lOllOOlOOll
)
*
lOl\
OllO\
O\
OOO
.
lO\
lOlOOll\
l\
O
;
Vec3
lOlO\
l\
OlOlOOl
=
GetVelo\
c\
ityAtW\
or\
ldPosition
(
lOO\
OOllll\
l
)
;
if
(
lOOlllllOOOO\

.
lOlll\
OOlO\
OO
&&
lO\
Olllll\
OOOO\

.
lO\
l\
llOOl\
OOO
->
AddedTo\
P\
h\
ysics
(
)
)
{
lOl\
O\
l\
Ol\
O\
l\
O\
Ol
-=
lOOlllllOOO\
O
.
lOll\
lOOlO\
O\
O
->
GetVelocityA\
tWorl\
dP\
osit\
ion\

(
lOOOOll\
lll
)
;
}
flo\
at
lO\
OlOllOllll
=
lOO\
lllllO\
OOO
.
lOO\
O\
lO\
OOO\
O
.
Dot
(
lO\
l\
O\
lOlOl\
OOl\

)
;
lOlOlO\
lO\
l\
O\
Ol
-=
lOOlllllOO\
OO
.
lOOOlOOO\
OO
*
lO\
OlOl\
lOll\
ll
;
if
(
Fabs
(
lOO\
lOll\
O\
ll\
ll
)
>
1.0f
)
lOO\
lO\
llOll\
ll
=
Sign\

(
lOOlOl\
lO\
l\
l\
ll
)
*
1.0f
;
lO\
lOllO\
OlOO\
O
-=
lOlOll\
OOO\
OO
.
lO\
lOlO\
Ol\
lll
*
lOOl\
Ol\
lOllll
;
Vec\
3
lOlO\
llOO\
lOO\
l\

=
lOlOl\
lO\
OOOO
.
lOlO\
lO\
OllOl\
l
.
v3\
Z
*
GetFrame
(
)
.
m33R\
otation
;
lOl\
Oll\
O\
OlO\
Ol
-=
lO\
OlllllO\
OOO\

.
lO\
OOlO\
OOOO
*
lOOll\
lllOOO\
O\

.
lO\
O\
OlOO\
OOO
.
Do\
t
(
lO\
lOlO\
lO\
lOOl
)
;
float
lOl\
ll\
l\
Ol\
Ol
=
lO\
lOll\
OOl\
O\
Ol
.
Ge\
t\
M\
agnitude\

(
)
;
if
(
lOllllO\
l\
Ol\

<
0.001f
)
conti\
nue
;
lOlOllOOl\
OOl\

/=
lOl\
lllOlOl
;
float
lOlOllOOlO\
lO\

=
0.0f
;
fl\
oa\
t\

lOlO\
lll\
lOOl
=
0.0f
;
{
fl\
o\
at
lOlOllOOl\
Oll
=
lOlOllOOlO\
Ol
.
Dot
(
lOlOlOlOl\
OOl
)
;
floa\
t
lO\
l\
OllOllOO
=
0.0f
;
if\

(
Fabs
(
lOlOllO\
OlOll\

)
>
0.1f
)
{
lOlOllOllOO\

=
(
lOl\
Oll\
OO\
OOO
.
lO\
lOlOOlOlO
*
lO\
lO\
l\
lOO\
OOO
.
lOlO\
lOO\
lllOl
-
lOl\
OllOO\
lOl\
l
)
/
Fabs
(
lOlOl\
lO\
Ol\
Oll
)
;
TA_A\
SSERT
(
lOlOllOOOOO
.
lOlO\
lOlO\
OOO
)
;
if\

(
Fa\
bs
(
lO\
lOll\
OllOO
)
>
lOl\
OlO\
OlO\
O\
lO\

*
1.1f
)
{
lO\
lOl\
l\
Oll\
OO
=
lOlOlOlOlllO
.
lOl\
Ol\
lOO\
llOO\

*
Sign
(
lOlOl\
l\
O\
ll\
OO\

)
*
lO\
lO\
lOO\
lO\
OlO
+
(
1.0f
-
lOlOlOl\
OlllO
.
lOlOl\
lOOl\
lOO
)
*
lOlOl\
lOllOO
;
}
lOlO\
l\
lOO\
l\
OlO
=
lOlOllOOOO\
O\

.
lOlOl\
O\
l\
OOOO
(
lOl\
Oll\
Ol\
lOO\

,
lOlO\
llOl\
lO\
l
)
;
}
else\

{
lO\
l\
OllOOl\
OlO\

=
(
lOlOll\
O\
OOOO
.
lOlO\
lOO\
lO\
lO
*
lO\
lOllO\
O\
OOO
.
lOlOl\
O\
Oll\
lO\
l\

-
lO\
lOllOOl\
Oll
)
*
0.02f
;
}
Cl\
am\
pPosNeg
(
lOl\
Oll\
O\
Ol\
Ol\
O
,
200.0f
)
;
lOlOllllO\
Ol
=
lOlO\
ll\
O\
llO\
O
;
if
(
lOl\
OllO\
OOO\
O
.
ll\
lOll\
OOO\
O
&
lOlOlOO\
lO\
lll\

)
{
fl\
oat
lOl\
OllO\
O\
llOl
=
lO\
lOll\
OOOO\
l\
l
*
lO\
lO\
lOl\
O\
OllO
;
if
(
Fa\
bs
(
lO\
lOllOl\
lOO\

)
>
lOlOlOO\
lOOlO
)
lOlOll\
OOl\
lOl
*=
(
1.0f
-
lOl\
OlOlOl\
l\
lO
.
lOlO\
ll\
OOl\
lOO
)
;
lO\
lOll\
O\
OOlll
+=
lOlOllOOl\
lOl\

;
TA_\
ASSERT
(
Float\
I\
sOK\

(
lOlOl\
lO\
O\
Olll
)
)
;
float
lOl\
Oll\
OOlllO
=
lOlO\
l\
OllllO\
l
-
lOlO\
ll\
OOOOO
.
lOl\
O\
l\
OOl\
ll\
Ol\

;
lOlO\
llOOOl\
ll
+=
lOlOllOO\
ll\
lO
*
Fa\
bs
(
lOlOll\
OOl\
llO
)
*
lO\
lO\
l\
OOlOO\
O\
O\

;
TA\
_\
AS\
SERT
(
Fl\
oa\
tI\
sOK
(
lO\
lO\
ll\
OOO\
l\
l\
l\

)
)
;
}
}
Vec3\

lOlO\
llOOl\
lll
=
lOO\
l\
ll\
ll\
OOO\
O\

.
lOO\
Ol\
O\
O\
OO\
O
.
Cr\
oss
(
lOlOl\
lOOl\
OOl\

)
;
fl\
oa\
t\

lOl\
OllO\
lO\
O\
OO
=
0.0f
;
floa\
t
lOl\
OllOlOOOl
=
lOlOlO\
lOlOOl
.
Ge\
tMagnitudeSqrd
(
)
;
if
(
lO\
lOllOl\
OOOl
>
0.25f
)
{
lOlO\
lO\
lOl\
OOl
;
#ifdef lOlOllOlOOlO
float\

lOlOll\
llOO\
O
=
-
lO\
lOllO\
Oll\
l\
l
.
Dot
(
lOl\
OlOl\
O\
lOOl
)
/
Fa\
bs
(
lOl\
Ol\
lOOlOOl
.
Do\
t\

(
lO\
lOl\
OlO\
lO\
Ol
)
)
;
#else
flo\
at
lOlOl\
lllOOO\

=
-
ATan2
(
lO\
lOllOOl\
l\
ll\

.
Dot
(
lOlO\
lO\
l\
OlOOl
)
,
Fa\
bs
(
lO\
lOl\
lOOlO\
Ol
.
Dot
(
lOlOlOl\
O\
l\
OO\
l\

)
)
)
;
#endif //
TA_ASSERT
(
lOlOllOOOOO
.
lOl\
Ol\
OlOOOl
)
;
lOlOll\
OlOO\
O\
O
=
lOl\
O\
ll\
OOO\
O\
O
.
lO\
lOlOlOO\
Ol
(
lOlOlll\
lOOO
,
lO\
lOll\
l\
l\
OOl\

,
lO\
lOllOll\
O\
l
)
;
}
else\

{
lOlOllOlOO\
OO
=
-
lOl\
O\
llO\
Ol\
lll\

.
Dot
(
lOlOl\
OlOlOO\
l
)
*
2.0f
;
}
{
Vec3
lOlOl\
lOOllll
=
lO\
l\
Oll\
O\
O\
OOO
.
lO\
lOlOOl\
l\
Oll\

.
v3\
X
*
GetFr\
am\
e\

(
)
.
m3\
3R\
otation
;
float
lOlOll\
Ol\
OOl\
l
=
lO\
lO\
llOOllll
.
Do\
t\

(
lO\
Olllll\
OOO\
O
.
lOO\
OlO\
OOOO\

)
;
lO\
lOll\
Ol\
OO\
ll
=
1.0f
-
Fa\
b\
s
(
lOlOllOl\
OO\
l\
l
)
*
1.0f
;
Clam\
p
(
lOlO\
llOlOOll
,
0.0f
,
1.0f
)
;
lOl\
Ol\
lO\
lOO\
OO
*=
lOl\
OllOlO\
Oll
;
}
if
(
lO\
lOllOO\
lOOO
>
0.0f
)
{
Vec3
lOlOll\
O\
lOl\
O\
O\

;
lOl\
OllOlO\
OO\
O
*=
lOlOll\
OOl\
OOO
;
lOlOllOOlOl\
O
*=
lOlO\
ll\
OO\
l\
O\
O\
O
;
lOl\
OllOl\
OlOO
=
lOlOllOOllll
*
lOlOllO\
lOO\
OO
+
lO\
l\
Ol\
lO\
OlOOl
*
lOlOllOOlO\
lO\

;
Vec3
lOlO\
l\
lOlO\
l\
Ol\

=
lOOOOlllll\

;
lOl\
Ol\
lOO\
OO\
O\

.
lOlOlOll\
OOlO\

+=
lOOl\
llllOO\
OO
.
lOOOlO\
O\
OOO
*
(
lO\
lOllOOlO\
OO
*
lOlO\
l\
OlllO\
ll\

)
;
if\

(
lO\
Olll\
ll\
OO\
O\
O
.
lO\
lllOOlOOO
&&
lOOlllllO\
O\
O\
O
.
lO\
lllOOlOOO
->
AddedT\
oPh\
ysics
(
)
)
{
if\

(
!
lOOll\
l\
llOOOO
.
lO\
lllOO\
lOOO\

->
Infin\
it\
e\
Ma\
ss
(
)
&&
!
lOOlllllOO\
OO
.
lOl\
llOOlOOO
->
MovementDisa\
b\
l\
e\
d\

(
)
)
{
lOOlllllOO\
OO
.
lO\
lll\
OO\
lOO\
O
->
Se\
tToMovin\
g
(
)
;
TA_\
AS\
SERT\

(
GetMass
(
)
>
0.0f
)
;
floa\
t\

llOlOllOO\
OO
=
10.0f
*
lOOll\
lllOOOO
.
lOlllO\
Ol\
OOO
->
GetM\
ass\

(
)
/
GetMass
(
)
;
if
(
llO\
l\
OllOOO\
O\

>
1.0f
)
llO\
l\
Ol\
lOOOO\

=
1.0f
;
ll\
Ol\
Ol\
lOO\
OO
*=
0.25f
;
Vec3
lOOOOlllll\

=
lOOlllll\
OOOO
.
lOOOOlll\
ll
*
GetFr\
ame\

(
)
;
lOOl\
llllOO\
O\
O
.
lOlll\
OO\
lO\
OO
->
App\
l\
yImpulse
(
lOl\
OllOlOlOO
*
(
-
llO\
lOllOOOO
*
lOlO\
lOll\
l\
Oll\

)
,
lOOOO\
lllll
)
;
}
}
lOlOll\
OlO\
l\
OO\

+=
lOOlllllO\
OOO\

.
lOOOlO\
OO\
OO
*
lO\
lO\
llOOlO\
OO
;
if
(
lOlO\
lO\
lllOO
!=
0.0f
)
{
lO\
lO\
l\
lO\
l\
OlOl\

+=
(
lOlO\
llO\
Ol\
l\
l
*
GetFr\
ame
(
)
.
m33Rot\
atio\
n
)
*
lOl\
OlOlll\
OO
;
}
Acc\
u\
mulate\
Force\
An\
dT\
orque\

(
lO\
l\
OllOlOlO\
O\

,
lOlOll\
O\
l\
OlO\
l
)
;
}
lOl\
O\
llOO\
Olll
-=
lO\
l\
OllOOlOlO\

*
lO\
lO\
llOO\
OO\
O
.
lOlOlO\
OlOlO
;
TA\
_A\
SSE\
RT
(
Floa\
tI\
s\
OK
(
lOlOllOOO\
ll\
l
)
)
;
}
else
{
if
(
lO\
lOll\
O\
OOOO
.
lllOllOOOO
&
lO\
lOl\
OO\
l\
Olll
)
{
float
lOlO\
l\
l\
O\
Olll\
O\

=
lOl\
OlO\
lll\
l\
Ol\

-
lO\
lOllOOOOO\

.
lOlOl\
OOl\
ll\
Ol
;
lOlO\
llOO\
O\
ll\
l
+=
lOlO\
llO\
Ol\
ll\
O
*
Fa\
b\
s
(
lOl\
OllOOlllO
)
*
lOlO\
lOOl\
OOOO
;
TA_ASS\
ERT
(
FloatI\
s\
OK
(
lOlO\
l\
lOOOl\
l\
l
)
)
;
lOlOl\
l\
OO\
O\
ll\
l
+=
lOlOllOO\
OOll\

*
lO\
lO\
lOlOOllO
;
TA\
_\
ASSERT
(
Fl\
o\
atI\
sOK
(
lO\
lOllOOOl\
ll
)
)
;
}
}
lOlOll\
OOOll\
l
-=
lOl\
OllOO\
OOO\

.
lO\
lOlOOll\
Ol
*
lOlOll\
OOO\
OO
.
lOlOlOOlllO\
l
;
lO\
lO\
llOOOlll
-=
lOl\
O\
llOOO\
O\
O\

.
lOlOlO\
Ol\
lO\
O
*
lO\
lOl\
Olll\
llO
;
if\

(
lOlOl\
lOOOOO
.
lllOll\
OO\
OO
&
lOlOlO\
OllO\
O\
O\

)
{
lO\
lO\
l\
lOOOlll
-=
lOlO\
llOOO\
OO
.
lOlOlOO\
ll\
OO
*
2.0f
*
Si\
g\
n
(
lOlOll\
O\
OOO\
O
.
lOl\
OlOOl\
llOl
)
*
lO\
lOl\
OlOlllO
.
lOl\
Ol\
lOlOl\
l\
O
;
}
TA_A\
SSERT
(
Fl\
oatIsOK\

(
lOlO\
llO\
OOlll
)
)
;
float\

lOlOllO\
lOll\
l
=
lOlO\
ll\
OOOOO
.
lOlOlO\
OlllOl\

;
lO\
lOll\
O\
OO\
O\
O\

.
lOlO\
l\
OOlllOl
+=
lOlO\
llOOOlll\

*
lOlOlO\
lllOll
*
lO\
lOll\
O\
OOOO
.
lOlOlOl\
O\
OO\
Ol\

;
if\

(
Fa\
bs
(
lOlO\
llO\
OOOO
.
lOlO\
lO\
O\
ll\
lOl
)
>
lOlOlO\
OlOOOl
)
lOlO\
llO\
O\
OOO
.
lO\
lO\
l\
O\
OlllOl
=
Sign
(
lOl\
O\
ll\
OOOOO
.
lO\
lO\
lOOlllOl
)
*
lOl\
O\
lO\
OlOOO\
l
;
if\

(
(
lOlOlOlO\
lllO
.
lO\
lOllOlOllO
>
0.0f
&&
(
lOlOllO\
OO\
OO
.
lllOllO\
OOO\

&
lOlOl\
OOll\
OOO
)
)
||
(
!
lOlOll\
O\
OOOO\
O\

&&
lOlOlOlllllO
>
0.0f
)
)
{
if
(
lOl\
O\
ll\
O\
lOll\
l\

*
lOl\
OllOOOOO
.
lOl\
Ol\
O\
Ol\
llOl\

<=
0.0f
)
lOlO\
ll\
O\
O\
OO\
O
.
lOlOlOOlllO\
l
=
0.0f
;
}
}
Acc\
u\
mulat\
eLi\
nea\
r\
Force
(
-
lOl\
Ol\
OllOlO
*
GetLine\
a\
rVelocity
(
)
.
Ge\
t\
Magnitu\
de
(
)
*
Ge\
tLinearV\
eloc\
ity
(
)
)
;
if\

(
lOlOllO\
OOll\
O\

)
Accumu\
la\
teLinear\
Forc\
e
(
-
lOlOlOllOll\

*
GetLi\
ne\
a\
rVelo\
city
(
)
.
Get\
M\
a\
gni\
tude\
Sqrd\

(
)
*
lOlOll\
O\
Olll\

*
Ge\
tFrame
(
)
.
m33\
R\
o\
tation
)
;
Ap\
plyFor\
ce\
AndTorq\
u\
eT\
o\
V\
el\
o\
citie\
s
(
lO\
lOlOll\
lOll\

)
;
Clear\
F\
o\
rce\
AndTo\
rque\

(
)
;
Apply\
Velo\
cityTo\
N\
e\
xtFrame
(
lOlO\
l\
Oll\
lOl\
l\

)
;
for
(
ll\
lOOOOlOO
=
0
;
lllOOO\
Ol\
OO
<
Ge\
tNu\
mLineCo\
l\
l\
is\
io\
ns
(
)
;
lllOOO\
OlOO
++
)
{
con\
s\
t\

LineIntersec\
ti\
o\
n
*
lOO\
l\
OOOlOll
=
&
GetLin\
eC\
ol\
lision
(
ll\
l\
OOOOl\
O\
O\

)
;
LineIn\
te\
rs\
ection
&
lOOlllll\
O\
OOO
=
*
(
Lin\
e\
Intersectio\
n
*
)
lOOlOOOlOll
;
Whe\
e\
l\

&
lO\
lO\
llOO\
OO\
O
=
lO\
lOlO\
O\
l\
O\
O\
ll\

[
lllOOOOlOO
]
;
if\

(
lO\
O\
lll\
l\
lO\
OOO
.
lOl\
lOOlOOl\
l
<=
0.0f
)
continue
;
lOOl\
llll\
O\
OO\
O\

.
lO\
OOOlllll
*=
GetFrame
(
)
;
Vec3\

llOOlll\
llO
=
(
lOOl\
lll\
lOOO\
O\

.
lOOOOll\
l\
ll
/
GetFrame
(
)
)
*
Ge\
tNextFr\
am\
e
(
)
;
float
lllOl\
l\
l\
ll\
ll
=
(
lOOll\
lllO\
OO\
O
.
lO\
OOOl\
llll
-
llOOll\
lllO\

)
.
Dot
(
lO\
Ollll\
lOOOO
.
lOOO\
lOO\
OOO
)
;
llOOllll\
lO
+=
ll\
l\
Oll\
ll\
ll\
l
*
lOO\
lllllOOOO
.
lOOOlO\
OO\
OO
;
lOOll\
lllOO\
OO
.
lO\
llOOlO\
O\
ll\

+=
lllO\
ll\
lll\
ll
;
lOOlllllOOO\
O\

.
lOOO\
Oll\
lll\

=
ll\
OO\
lllllO
;
lOO\
ll\
ll\
lOO\
OO
.
lO\
OOOl\
llll
/=
GetNe\
xt\
Frame
(
)
;
}
ApplyNext\
Frame
(
)
;
}
Se\
tFrame\
Direct\

(
lO\
lO\
lO\
llll\
O\
O\

)
;
Up\
da\
teW\
or\
l\
d\
Spa\
ceIn\
er\
tialTensor
(
)
;
if
(
lOl\
OlO\
lllO\
lO\

<=
2
)
{
Apply\
Vel\
o\
cit\
yTo\
Ne\
x\
tFra\
m\
e
(
lO\
O\
lll\
O\
Olll\
l
)
;
}
else
{
if\

(
lOOlllOOl\
ll\
l\

>
0.0f
)
{
SetLinearV\
e\
l\
oci\
ty
(
(
GetNextCent\
erOfMass
(
)
-
GetCenterOfM\
ass\

(
)
)
/
lOOl\
llOOll\
l\
l
)
;
Mat33
lOOlllOlO\
O\
O\
O
=
GetFr\
a\
me
(
)
.
m33Rotation\

.
GetTrans\
p\
o\
seA\
sI\
n\
ve\
r\
s\
e
(
)
*
Get\
Nex\
tFr\
a\
me
(
)
.
m3\
3\
Rot\
ation\

;
Vec3
lOO\
OOOll\
l\
ll
;
fl\
oat
lOOO\
OlOOO\
OO\

;
lOOl\
llOl\
O\
O\
OO
.
Get\
Ro\
tationAxisAn\
d\
Magni\
t\
ude
(
lOOOO\
Ol\
llll\

,
lOO\
OO\
lOOO\
OO
)
;
SetAng\
ul\
a\
rVelocity
(
lOO\
O\
OOl\
l\
l\
l\
l\

*
lO\
OOOlOOO\
OO\

/
lOO\
ll\
lOOl\
l\
ll
)
;
}
}
for
(
int
lllO\
OOOlO\
O\

=
0
;
lllO\
O\
OO\
lOO
<
GetN\
um\
L\
i\
neCol\
lisi\
on\
s
(
)
;
ll\
lOO\
OOlOO
++
)
{
const
Li\
neInter\
sec\
tion
&
lOOl\
llllO\
OOO
=
Get\
L\
in\
e\
C\
ol\
li\
si\
on
(
lllOOOOlOO\

)
;
Wh\
e\
el
&
lOl\
Oll\
OO\
OOO
=
lO\
l\
O\
lO\
O\
l\
O\
Oll\

[
lll\
OOOOlOO
]
;
lO\
lO\
llOO\
OOO
.
lOlO\
l\
OOllll\
O
+=
lOl\
OllOOO\
OO
.
lO\
l\
OlO\
Ol\
ll\
Ol
*
1.0f
*
lO\
Ol\
ll\
OOllll
;
Wrap\
An\
gle\

(
lOlOllO\
OOO\
O
.
lO\
lOlO\
Olll\
lO
)
;
lO\
lO\
ll\
O\
O\
O\
OO
.
lOlO\
lOOllOOl
.
v3\
Trans\
lation
=
lOOl\
llll\
OOOO
.
lOOOOlllll
;
lOlOllOO\
OOO\

.
lOlO\
lO\
Ol\
lOOl
.
v3Tra\
nslation
+=
lO\
l\
OllO\
OOO\
O\

.
lOlOlO\
O\
l\
OlO
*
lO\
l\
OllOOO\
OO\

.
lOlOlOOll\
O\
ll
.
v3Y\

;
lO\
l\
Ol\
lO\
OOOO
.
lOlOlOOllO\
Ol\

.
m3\
3R\
o\
t\
at\
ion
=
lOlOllOOOOO
.
lO\
lOlOOllOl\
l
;
lOlOll\
O\
OOOO
.
lO\
lOlOOllOOl
=
MFrame\

(
Mat33
(
Mat3\
3\

::
ROTAT\
ION\
_AXIS\
_X
,
lOlOllO\
OOOO
.
lOlOl\
OOll\
l\
lO\

)
)
*
lOl\
OllO\
OOOO
.
lOlOlOO\
l\
lO\
Ol
;
if
(
lOOl\
l\
lllOOOO
.
lOl\
llOO\
lO\
OO
&&
lO\
Oll\
l\
ll\
OOOO
.
lOl\
llOOlO\
O\
O
->
Adde\
dT\
oP\
hysi\
cs
(
)
)
{
if
(
!
lOO\
ll\
l\
l\
lOOO\
O
.
lOl\
llOOl\
O\
O\
O
->
Infin\
it\
eMass\

(
)
&&
!
lOOlll\
l\
l\
OO\
OO
.
lO\
ll\
lOOlOO\
O
->
MovementDis\
a\
bl\
ed\

(
)
)
{
lOl\
OlOlO\
Ol\
ll
.
SetDy\
nam\
icOb\
ject\
IsM\
ov\
ing
(
lO\
O\
llll\
lO\
OOO
.
lOlllOOlOO\
O
)
;
TA_AS\
S\
ERT
(
GetMa\
ss
(
)
>
0.0f
)
;
fl\
o\
at
ll\
OlOll\
OOOO\

=
10.0f
*
lOOlll\
ll\
OOOO\

.
lOlllO\
OlOO\
O
->
GetMass
(
)
/
Get\
Mass
(
)
;
if
(
llOlO\
llOOOO\

>
1.0f
)
ll\
Ol\
OllOO\
OO\

=
1.0f
;
Vec\
3
lO\
OO\
O\
lllll\

=
lO\
Olll\
llO\
OOO
.
lOOOOll\
lll
*
Get\
Fra\
me
(
)
;
lO\
O\
lllllO\
O\
O\
O
.
lOlll\
OOlOO\
O\

->
Appl\
yImp\
u\
ls\
e\

(
lOlOll\
OOOO\
O
.
lOlOlOl\
l\
OOlO\

*
-
llOlO\
l\
lOO\
OO
,
lOOO\
Olllll
)
;
}
}
}
Cl\
e\
a\
r\
Li\
n\
eInte\
rse\
ct\
io\
n\
s\

(
)
;
}
void
DynamicO\
bject\
Car
::
Clear\
Co\
ntro\
ls
(
)
{
lOlOlOlOl\
llO
.
lOlOlOllO\
OOO
=
0.0f
;
lOlOlOlOlll\
O\

.
lOl\
OlOlll\
lll\

=
0.0f
;
lOlOlOl\
O\
lllO\

.
lOl\
Ol\
Ollll\
lO
=
0.0f
;
lOlO\
lOl\
O\
lll\
O\

.
lO\
lOl\
l\
OlOll\
O
=
0.0f
;
lOlOlO\
lO\
ll\
lO
.
lO\
lOlOlO\
ll\
ll
=
0.0f
;
lO\
l\
OlOlOlllO
.
lOlOllOOll\
O\
O
=
0.0f
;
lOlOlOlllOO\
O
=
1
;
}
voi\
d
Dy\
n\
am\
icO\
bje\
ctCa\
r
::
Upd\
ateCo\
ntrols\

(
fl\
oa\
t
lO\
lOlOl\
lOOOO\

,
float\

lOlOlOl\
lllll
,
float
lOlOlO\
lll\
l\
lO
,
flo\
at
lO\
l\
OllOlO\
l\
l\
O
,
float\

lO\
lOl\
OlO\
llll
,
flo\
a\
t
lO\
l\
OllOOllO\
O
,
in\
t
lOlOlO\
lOO\
lOO
)
{
lOlOlOlOlllO
.
lOlOlO\
l\
lO\
OOO
=
lOl\
OlOllOOO\
O
;
lOlO\
lOl\
O\
lll\
O
.
lO\
lOl\
Oll\
llll
=
lO\
l\
Ol\
O\
llllll
;
lOlO\
lOlO\
lllO\

.
lOlOlOllll\
l\
O
=
lO\
lOlO\
lllllO
;
lOlOlO\
lOl\
llO
.
lOl\
Ol\
lOlO\
l\
l\
O
=
lO\
l\
O\
l\
l\
Ol\
OllO
;
lO\
lOlO\
l\
Ol\
llO
.
lOlOlO\
lOl\
l\
ll
=
lOlO\
lOlOllll
;
lO\
l\
OlOlO\
l\
ll\
O\

.
lOlOl\
l\
O\
Ol\
l\
O\
O
=
lOlOl\
lOOllO\
O
;
lO\
lOlO\
l\
OlllO
.
lOlO\
l\
O\
lO\
O\
lOO
=
lO\
l\
OlOlOOl\
O\
O
;
}
flo\
a\
t
Dyn\
amicObjectCar
::
GetCarSpe\
edFromWhee\
ls
(
)
{
floa\
t
lOO\
l\
l\
ll\
O\
OOll
=
0.0f
;
for
(
int
lO\
l\
O\
l\
Olllll
=
0
;
lOlOlOlll\
l\
l
<
lOlOlO\
Ol\
OOll\

.
lOOO\
l\
l\
lOOl
(
)
;
lOlO\
lOlllll
++
)
{
Wh\
eel
&
lOlOllOO\
OOO\

=
lO\
lOlO\
Ol\
OOll\

[
lOlOlOlllll
]
;
if
(
lOlOllOOOOO\

.
lll\
OllOOOO
&
lOlOlOOlOl\
ll
)
lOOllllOOOll
+=
lOlOl\
l\
OOOOO
.
lOlOlOO\
l\
llOl
*
lOlOllOOOOO\

.
lOlO\
lOOlOlO
;
}
lO\
Olll\
l\
OOOll
*=
lOlOl\
OlOO\
ll\
O
;
ret\
ur\
n\

lOO\
llllOO\
O\
l\
l
;
}
Dy\
nam\
icObjectCa\
r
*
TAC_\
CAL\
L
Dy\
namicObjec\
t\
Car
::
Creat\
eNew
(
)
{
Dyna\
micOb\
ject\
Ca\
r
*
lOlOllOlOOl
;
lO\
OOOOllOl\
O
(
lOlO\
l\
lOlO\
Ol
,
DynamicObjectCar\

)
;
retu\
rn\

lO\
lOl\
lOlOOl
;
}
Dy\
nam\
icObje\
ctCar
::
Dyn\
am\
i\
cObj\
ectCa\
r
(
)
:
Dy\
n\
amic\
O\
b\
je\
ct
(
)
{
Cl\
e\
arCon\
trol\
s\

(
)
;
lO\
lOlOl\
lOOl
=
0.0f
;
lO\
lOl\
O\
lOl\
ll
=
0.0f
;
lOl\
OlOlO\
l\
Ol
=
0.0f
;
lOl\
O\
lOl\
O\
llO\

=
0
;
lO\
lOlO\
llOlO\

=
0.0f
;
lO\
l\
OlOllOll
=
0.0f
;
}
Dy\
na\
micObject\
Car
::
~
Dy\
n\
a\
m\
i\
cObje\
ct\
C\
ar\

(
)
{
Final\
i\
se
(
)
;
lOlOl\
OlO\
Ol\
O\
l
=
0.0f
;
lOlOlO\
l\
OO\
llO
=
0.0f
;
lOlO\
lOlOOOll
.
Fina\
l\
i\
s\
e
(
)
;
lOlOl\
O\
llO\
Ol
=
0.0f
;
lOlOl\
OlOlll\

=
0.0f
;
lOlOlO\
l\
OlOl\

=
0.0f
;
lO\
l\
OlO\
lOl\
lO
=
0
;
lOlOl\
O\
llOlO
=
0.0f
;
lOlOlOl\
lOll
=
0.0f
;
}
vo\
id
Dynami\
c\
ObjectC\
ar
::
Initialise\
C\
om\
m\
on
(
)
{
lOl\
Ol\
OlOOllO\

=
0.0f
;
for
(
in\
t
lOl\
O\
lOlllll\

=
0
;
lO\
lO\
lOl\
l\
lll
<
lOl\
Ol\
O\
OlOOl\
l\

.
lOO\
Oll\
lO\
Ol
(
)
;
lOlO\
l\
Oll\
lll
++
)
{
Wheel
&
lOlO\
llOOOOO\

=
lOl\
OlOOlOO\
ll\

[
lOlOlOll\
l\
ll
]
;
if\

(
lOlO\
llOOOO\
O
.
lll\
OllOOOO\

&
lOl\
O\
l\
OOl\
O\
lll
)
lOlO\
lOlOOllO
+=
1.0f
;
}
if\

(
lOl\
OlOl\
O\
OllO
>
0.0f
)
lO\
l\
OlOl\
O\
OllO
=
1.0f
/
lOl\
OlOlOOllO
;
else
lOlO\
l\
OlOOl\
lO
=
1.0f
;
lOlOlOlO\
OlOl
=
0.0f
;
}
void
Dynamic\
Ob\
jectCa\
r
::
lO\
lOlOlOO\
Ol\
O
(
Whee\
l
&
lO\
lO\
llOOOOO
)
{
lOlO\
llOOOO\
O
.
lOl\
OlO\
OllOl\
O\

.
SetToLookA\
t
(
GetF\
orward
(
)
,
GetUp\

(
)
)
;
lOl\
OllOOOOO
.
lO\
lOl\
OOll\
Ol\
O
.
Pr\
eRo\
tat\
e
(
Mat33
::
ROT\
ATION_A\
XIS_Z
,
lOlO\
ll\
OOO\
O\
O
.
lOlO\
lOOlll\
ll
)
;
lOl\
Ol\
lO\
O\
OOO
.
lOlOlO\
OllO\
ll
=
lO\
lO\
ll\
O\
OO\
OO
.
lO\
l\
OlOOl\
l\
OlO\

;
lOl\
O\
llOO\
OO\
O
.
lll\
Oll\
O\
OOO
&=
~
lOlO\
lOll\
OO\
ll
;
}
}

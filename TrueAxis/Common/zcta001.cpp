//---------------------------------------------------------------------------------
// File Name: zcta001.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "../Common/zcta000.h"
#ifndef lOOOOlOOll
#include "../Common/zcta012.h"
#endif //
#ifndef lOOOOlOlOO
#include "../Common/zcta021.h"
#endif //
#ifndef lOOOOlOlOl
#include "../Common/zcta006.h"
#endif //
namespa\
ce
TA
{
stati\
c
lOOOO\
l\
OllO
<
int
,
fal\
se
>
lOOOOlOlll
[
3
]
;
st\
a\
tic
lO\
OOOl\
OllO
<
int
,
fals\
e
>
lO\
OOOllOOO\

;
stat\
ic
lOOO\
Ol\
OllO\

<
int
,
fals\
e
>
lOOOOllO\
O\
l\

;
str\
uct
lO\
OOOllOl\
O
{
lOOO\
OllOl\
l
::
lOOOOlllOO
lOOOO\
lllOl
;
void\

*
lOO\
OO\
lll\
lO\

;
AA\
BB\

lOOO\
O\
O\
O\
lll
;
Vec3
lOOOOlllll
;
Vec3
lOOOlOO\
OOO
;
Vec3\

lOOOlO\
O\
OOl
;
}
;
st\
at\
ic
lO\
OOOllOlO\

*
lOOOlOOOlO\

=
0
;
const
float
lOOO\
l\
O\
OO\
l\
l
=
0.01f
;
#ifdef _DEBUG
sta\
t\
ic
in\
t
lOO\
OlO\
Ol\
O\
O
;
#endif //
str\
u\
ct
lO\
O\
O\
lOOl\
O\
l\

{
float
lOOOlO\
OllO
;
in\
t\

lO\
OOlOO\
lll
;
}
;
lOOOOl\
lOl\
l
::
lOO\
OOl\
lOll
(
)
{
lOOOlOlOOO
=
0
;
}
lOOOOllO\
ll
::
~
lOOOOl\
lO\
ll
(
)
{
Final\
is\
e
(
)
;
}
vo\
id
lOOO\
O\
llOll\

::
Init\
ia\
lise\

(
int\

lOO\
O\
l\
OlOOl\

)
{
lOOOlOlO\
lO
=
-
1
;
lOOOlOlOOO\

=
lOOOlOlOOl
;
if\

(
!
lO\
OOlOlOOO
)
return
;
lOO\
OlOlOll\

.
Ini\
tial\
ise
(
0
,
lOOOl\
OlOOl
*
2
-
1
)
;
lOOOlOllOO\

.
Initialis\
e
(
0
,
lOOO\
lOlOO\
l
)
;
}
vo\
i\
d
lOOOOll\
Oll
::
Finalise
(
)
{
lOOOlOlO\
l\
O
=
-
1
;
lOOOlOlOO\
O
=
0
;
lO\
OOlOlO\
ll
.
Fi\
nalise
(
)
;
lOO\
OlOllOO
.
Fin\
alise
(
)
;
}
vo\
id
lOO\
O\
Oll\
Oll
::
Ser\
ial\
i\
se\

(
Se\
ri\
aliser
&
lOOO\
lOllO\
l\

,
vo\
id
*
lOO\
OlOl\
ll\
O
)
{
lO\
OOlOllOl\

.
Ser\
ialise
(
lOOO\
lOlOlO\

)
;
lO\
OOl\
O\
l\
lOl\

.
Seri\
alis\
e\

(
lOOOlO\
l\
O\
OO
)
;
lOO\
OlOllOl
.
lOOOlOllll
(
lO\
OOlO\
lO\
l\
l
)
;
if
(
lOOO\
lOl\
lOl
.
lO\
OO\
llOO\
OO
(
)
)
lO\
O\
OlOllOO\

.
In\
itia\
lise
(
lO\
OO\
lOlO\
OO
,
lOO\
OlOlOOO
)
;
for
(
int\

lOOOll\
OOOl
=
0
;
lOO\
Oll\
OOOl\

<
lOO\
Ol\
OlO\
OO
;
lO\
OOll\
O\
OOl\

++
)
{
u3\
2
lOOOllO\
OlO
=
(
u3\
2\

)
(
(
u8\

*
)
lOO\
OlO\
llOO\

[
lO\
O\
OllO\
O\
Ol
]
-
(
u8
*
)
lOOOlOlllO\

)
;
lOOOlOllOl
.
Seri\
alise\

(
lO\
OO\
llOOlO
)
;
lOOOl\
OllOO
[
lOOOllOOOl
]
=
(
void
*
)
&
(
(
u8
*
)
lOOOlOlllO\

)
[
lOOOll\
OO\
lO
]
;
}
}
voi\
d
lOOOOllO\
ll
::
lO\
OOllOOll
(
Ser\
ial\
iser\

&
lOOOlOllOl
,
voi\
d
*
lOO\
OlOlllO\

)
{
TA\
_\
A\
S\
SERT
(
lOOOlOl\
lO\
l
.
lOOOllOOOO\

(
)
)
;
Fi\
nal\
i\
se\

(
)
;
lO\
O\
OlOllOl
.
Serialise
(
lOOO\
lOlOOO
)
;
lOOOlOlOl\
l
.
Initialise
(
lOOOlOl\
OOO
,
lOOOlOlOOO
*
2
-
1
)
;
lOOOlO\
l\
l\
OO
.
Ini\
tia\
lise
(
lOOOl\
O\
lOOO
,
lOO\
O\
lO\
lOO\
O\

)
;
u3\
2
lO\
OOllOlOO
;
lOOOlO\
llOl
.
Se\
r\
i\
a\
l\
ise
(
lO\
OOll\
O\
l\
OO
)
;
int
lOOO\
llO\
OOl
=
0
;
for
(
;
lOOOllOOO\
l\

<
lO\
O\
O\
l\
O\
lOO\
O
;
lO\
OO\
llOOOl
++
)
{
lOOOlOllOl\

.
Seri\
alise
(
lOOO\
lO\
lOll\

[
lOOOllO\
OOl\

]
)
;
u3\
2
lOOOllOO\
lO\

=
0
;
lO\
OOlOll\
Ol
.
Ser\
ial\
ise
(
lOO\
Ol\
lOOlO
)
;
lO\
OOlOllOO
[
lOO\
Ol\
lOOO\
l\

]
=
(
void
*
)
&
(
(
u8\

*
)
lOOO\
lOll\
lO
)
[
lOOO\
llOO\
lO
]
;
}
for
(
;
lO\
OOllOOOl
<
lO\
O\
OlOl\
O\
OO
*
2
-
1
;
lOOOll\
OOOl
++
)
{
AABB
lOO\
OOO\
Ol\
ll
;
lOOOl\
OllO\
l
.
Ser\
ialise
(
lOOO\
OOOlll
)
;
u3\
2
lOO\
OlOOlll
;
lOOOl\
OllOl\

.
Seria\
lise
(
lOOOlOO\
l\
ll\

)
;
lOOO\
lOllOl
.
Se\
rialise
(
lOOOlOO\
l\
ll\

)
;
}
lOOOll\
OlOl\

(
)
;
}
vo\
id\

lOOOOllOll
::
lOOO\
l\
lOll\
O
(
void\

*
lOO\
Ol\
lOlll\

,
con\
s\
t
AABB\

&
lOO\
OOOOlll
)
{
if
(
!
lOOO\
lOl\
OOO
)
return
;
lO\
OOlO\
lO\
ll
.
lOOOlllOOO
(
lO\
OOOOO\
ll\
l
)
;
lO\
OOl\
Ol\
lO\
O\

.
lOOOlll\
O\
O\
O\

(
lOOOllOlll
)
;
}
void
lOOOO\
l\
lOll\

::
lO\
O\
O\
ll\
O\
lOl
(
)
{
if
(
!
lOOOlOlO\
OO
||
!
lOO\
OlOlOll
.
lO\
OO\
ll\
lOOl
(
)
)
ret\
u\
rn
;
in\
t
lOOOl\
lOOOl
;
lOO\
Oll\
l\
Ol\
O
(
lOOOl\
O\
l\
Oll
.
lO\
O\
Olll\
O\
Ol
(
)
==
lOOO\
lOlOOO
,
"AABBTree::BuildTree. The number of items added with AABBTree::AddItem is less then specified in AABBTree::Initialise.")
;
lOOO\
lOlOO\
O
=
lO\
OOlOl\
Oll\

.
lOOO\
ll\
lO\
Ol\

(
)
;
if
(
lOOO\
lO\
lO\
O\
O
==
1
)
{
lOOOl\
OlOlO\

=
0
;
return\

;
}
lOO\
O\
OlOlll
[
0
]
.
Initia\
lise
(
lO\
OOlO\
lO\
OO\

,
lOO\
OlOlOO\
O\

)
;
lOOO\
OlOlll
[
1
]
.
Initialise
(
lOOOlOlOO\
O
,
lOOOl\
O\
lOOO\

)
;
lOOO\
OlOll\
l\

[
2
]
.
In\
it\
ia\
l\
i\
se
(
lO\
OOlOlO\
OO\

,
lO\
OO\
lOlOOO
)
;
lOOOO\
llOO\
O\

.
Initia\
lis\
e\

(
lOOO\
l\
OlOO\
O
,
lOOO\
lOlOO\
O
)
;
lO\
OOOl\
lOO\
l
.
Ini\
t\
ialise
(
lO\
OO\
lOl\
O\
OO
,
lOO\
OlOlO\
OO
)
;
lO\
OOlOO\
lOl
*
lOO\
OlllOll
=
0
;
lOOO\
l\
ll\
l\
OO
(
lOOO\
lll\
Ol\
l
,
lOOOlOO\
l\
Ol
,
lOOOlO\
l\
OOO\

)
;
TA_\
A\
SS\
ERT
(
lOO\
OlllOll
)
;
for\

(
int
lOOOll\
l\
lOl\

=
0
;
lOOOll\
llOl\

<
3
;
lOOOl\
l\
llO\
l
++
)
{
for
(
lOOOllOOOl
=
0
;
lO\
OOl\
lOOO\
l
<
lOOOlOlO\
OO
;
lOOOllO\
O\
O\
l
++
)
{
lOOOlll\
O\
ll
[
lOOOll\
O\
O\
Ol
]
.
lOOOlOOlll
=
lO\
OOllOOOl
;
lOOO\
ll\
lOll
[
lO\
OOl\
lOO\
Ol
]
.
lOOO\
lOOl\
lO\

=
lOOOlOlO\
ll
[
lOOOllO\
OOl
]
.
v3C\
e\
nte\
r
[
lOO\
Olll\
lO\
l\

]
;
}
lOOOlllllO\

<
lOOOlOOlOl
>
::
lO\
O\
Ol\
lllll
(
lOO\
Ol\
l\
lOll
,
lOOOlOlOO\
O\

)
;
for
(
lOOO\
ll\
OO\
Ol
=
0
;
lO\
O\
O\
llO\
OOl
<
lOOOl\
O\
lOOO
;
lOOOll\
OOOl
++
)
lOO\
OO\
l\
Olll
[
lO\
OOl\
lllO\
l
]
[
lO\
OOllOO\
Ol
]
=
lOO\
Oll\
lO\
ll
[
lOOOll\
OOOl
]
.
lO\
OOlOO\
ll\
l\

;
}
if
(
lO\
OOll\
lOll\

)
{
lOOlOOOO\
O\
O
(
lOOO\
lllOll
,
lOOOlOOl\
Ol
)
;
lOOOlll\
Ol\
l
=
0
;
}
int\

lOOlOOOO\
Ol
;
AABB\

lOOlO\
OOOl\
O
=
lOOO\
l\
OlO\
ll\

[
0
]
;
for
(
lOO\
lOO\
OO\
O\
l\

=
1
;
lOO\
lOO\
OO\
Ol
<
lOOOl\
OlOOO
;
lO\
Ol\
OOOOOl
++
)
lOOlOOOO\
lO\

+=
lO\
OO\
lO\
lOll\

[
lOOlOOOOOl
]
;
lO\
OO\
lOlOll
.
lOO\
OlllOO\
O
(
lOOlOOO\
OlO\

)
;
lOOl\
OOOOl\
l
(
0
,
lOOO\
lO\
lOOO
)
;
lO\
OO\
l\
O\
lOlO
=
lOOOlO\
lO\
OO\

;
fo\
r
(
lOO\
Oll\
OOOl
=
0
;
lOOOllO\
OOl\

<
lO\
O\
O\
lOlO\
OO
;
lOOO\
llOOOl
++
)
{
TA_\
ASSERT\

(
lO\
O\
OOlOll\
l\

[
0
]
[
lOO\
Ol\
lOO\
Ol\

]
==
lOOO\
OlOlll
[
1
]
[
lOOOllOOOl\

]
)
;
TA_A\
S\
S\
ERT
(
lO\
O\
O\
O\
l\
Olll\

[
0
]
[
lOOOllOO\
Ol
]
==
lOO\
OO\
lOlll\

[
2
]
[
lOOOl\
lO\
O\
Ol\

]
)
;
}
lOOOOl\
lOOl
.
Fi\
nali\
se
(
)
;
lO\
OO\
Ol\
lOO\
O\

.
Fin\
a\
li\
se\

(
)
;
lOOOOlOlll
[
2
]
.
Final\
ise
(
)
;
lOOOOlOll\
l\

[
1
]
.
Fi\
na\
lise
(
)
;
lOOOOlOllO
<
AAB\
B
,
false\

>
lOOlOOO\
lOO
;
lO\
OOO\
lOllO
<
vo\
id
*
,
false
>
lOO\
l\
OOO\
l\
Ol
;
lO\
OlO\
OO\
l\
OO
.
Ini\
tial\
is\
e
(
0
,
lOOOlO\
l\
OO\
O
)
;
lO\
OlOOO\
lOl
.
Initi\
a\
lis\
e\

(
0
,
lO\
OOlOl\
OOO\

)
;
for
(
lO\
OOll\
OOO\
l
=
0
;
lOO\
O\
llOOOl
<
lOOOl\
Ol\
OOO
;
lOO\
O\
llO\
OOl
++
)
{
lOO\
lOOO\
lOO
.
lOOOlllOOO
(
lO\
O\
OlOlOll
[
lO\
O\
Oll\
OO\
O\
l\

]
)
;
lO\
OlOOOl\
Ol
.
lOO\
O\
lllOO\
O\

(
lOOOlO\
llOO
[
lOOOllOO\
O\
l
]
)
;
}
for
(
lOOOllOO\
O\
l
=
0
;
lOOOllOOO\
l
<
lOOOlO\
l\
O\
O\
O
;
lOO\
Oll\
O\
O\
O\
l
++
)
{
lO\
O\
OlO\
lOl\
l
[
lOOOl\
lOOOl
]
=
lOOlO\
OOlOO
[
lO\
O\
OOlOlll
[
0
]
[
lOOOllOOOl\

]
]
;
lOO\
O\
lOllOO
[
lO\
OOllOOOl
]
=
lO\
OlO\
OOlOl
[
lOOO\
O\
lO\
lll\

[
0
]
[
lOO\
OllOOO\
l
]
]
;
}
lOO\
l\
OOOlOl
.
Finalise
(
)
;
lOOl\
OO\
OlOO
.
Finali\
se
(
)
;
lOOOO\
lOlll
[
0
]
.
Fi\
nal\
is\
e\

(
)
;
#ifdef _DEBUG
if
(
lOOlOOO\
llO
)
{
lOO\
O\
lOOl\
OO\

=
0
;
lOOlOO\
O\
lll
(
0
,
lO\
O\
OlOlOOO
,
lO\
OOlO\
lOlO\

+
1
,
lOOl\
O\
O\
OOl\
O
)
;
TA_ASSE\
RT
(
lOO\
O\
l\
O\
OlOO\

==
lOOOlOlOO\
O\

)
;
}
#endif //
}
vo\
id\

lOOOOl\
lO\
l\
l
::
lOOl\
OOO\
O\
ll\

(
int
lOOl\
OOlOOO\

,
int
lOOl\
O\
Ol\
O\
Ol
)
{
int\

lOO\
lOOlOl\
O\

;
int
lOOOllllOl\

;
int
lOO\
lOOlOll
=
(
lOOl\
OO\
lOOO
+
lOOlO\
O\
lOOl
)
>>
1
;
AABB\

lOOlOO\
llO\
O
[
3
]
;
AABB
lOOl\
O\
O\
l\
lOl
[
3
]
;
for
(
lOO\
Oll\
llOl
=
0
;
lOOOllllOl
<
3
;
lOOO\
llllO\
l
++
)
{
lOO\
l\
O\
OlOlO\

=
lO\
Ol\
OOlOOO
;
lO\
OlOOllOO\

[
lOOOlll\
l\
O\
l\

]
=
lOOO\
l\
O\
lO\
ll
[
lO\
O\
OOlOll\
l\

[
lOO\
O\
ll\
l\
lOl
]
[
lOO\
lOOlOlO
]
]
;
lOOlOO\
lOl\
O
++
;
fo\
r
(
;
lO\
OlOOl\
Ol\
O
<
lO\
OlOO\
lO\
ll\

;
lOOlO\
Ol\
OlO\

++
)
lOO\
lOOl\
lOO\

[
lO\
OOl\
lll\
Ol
]
+=
lOOOlOlOl\
l
[
lO\
OO\
OlO\
lll
[
lO\
O\
Olll\
lO\
l
]
[
lOOlOO\
lOlO
]
]
;
lO\
OlO\
O\
llOl
[
lOOOl\
lll\
Ol
]
=
lOO\
O\
lOlOll
[
lOO\
OOlOlll
[
lO\
OOllll\
O\
l
]
[
lOO\
l\
OO\
l\
OlO
]
]
;
lO\
Ol\
OO\
lO\
lO
++
;
for
(
;
lO\
O\
lO\
OlOlO
<
lOO\
lO\
O\
lOOl
;
lOOlOO\
lOlO
++
)
lOOlOOllOl
[
lOOOl\
lllOl\

]
+=
lOOOlO\
lOll
[
lOO\
OOlO\
lll
[
lOOOllllOl
]
[
lOOlOOlOl\
O
]
]
;
}
fl\
oat
lOOOO\
OlO\
Ol
=
lOOlOOllOO
[
0
]
.
v3Extent
.
Get\
Magn\
itud\
eSqr\
d
(
)
+
lOO\
lOO\
llOl\

[
0
]
.
v3E\
x\
te\
n\
t
.
Ge\
tMagnitudeSqrd\

(
)
;
flo\
a\
t\

lO\
OlO\
OlllO
=
lOOlOOl\
lOO
[
1
]
.
v3Ex\
ten\
t\

.
GetMa\
gn\
it\
u\
deSqrd
(
)
+
lOOlOOllOl
[
1
]
.
v3E\
xt\
e\
nt\

.
Ge\
tM\
a\
gnitudeS\
qrd
(
)
;
floa\
t
lOOlOO\
llll
=
lOOlOO\
llO\
O
[
2
]
.
v3Ex\
t\
ent
.
Get\
M\
agnit\
ud\
eSq\
r\
d
(
)
+
lOOlOO\
llOl
[
2
]
.
v3Extent
.
GetMagnitude\
S\
qrd
(
)
;
lOOO\
llllOl
=
0
;
if\

(
lOOOO\
OlOOl
>
lOOl\
OOll\
lO
)
{
lOOOO\
Ol\
O\
Ol
=
lOOl\
O\
O\
lllO
;
lOOOllll\
O\
l
=
1
;
}
if
(
lO\
OOO\
OlOOl\

>
lOO\
lO\
Ollll
)
{
lOOOOO\
lOOl\

=
lOOlOOll\
l\
l
;
lO\
OOlll\
lOl
=
2
;
}
for
(
lO\
O\
lO\
OlOlO\

=
lOOl\
OOlOOO
;
lO\
OlOOlOl\
O\

<
lOOlOOl\
O\
l\
l
;
lOOl\
OOl\
OlO\

++
)
lOO\
O\
OllO\
OO
[
lOO\
OOlO\
ll\
l
[
lOOOl\
lll\
Ol
]
[
lOOlOOlOl\
O
]
]
=
0
;
for\

(
;
lOOlO\
O\
l\
OlO
<
lO\
O\
l\
OOlOOl\

;
lOOlOOl\
OlO
++
)
lOO\
OOllO\
OO
[
lO\
OOOlOlll
[
lOOOllllO\
l
]
[
lOOl\
OOlOlO\

]
]
=
1
;
fo\
r
(
int\

lOOlO\
lOO\
OO\

=
0
;
lOOlOlOOOO
<
3
;
lOO\
lOl\
O\
O\
O\
O
++
)
{
if
(
lOOl\
OlO\
OOO\

==
lO\
OOllll\
O\
l
)
co\
ntinu\
e
;
in\
t
lO\
OlOl\
OO\
O\
l
=
0
;
for
(
lOOlOOlOlO
=
lOOl\
OOlOO\
O
;
lOO\
l\
OO\
l\
Ol\
O
<
lOO\
l\
O\
OlO\
Ol
;
lOOlOO\
lOlO
++
)
{
if
(
lOOOOll\
OO\
O
[
lOOOOlOlll\

[
lO\
Ol\
OlOO\
OO
]
[
lO\
OlOO\
l\
OlO\

]
]
==
0
)
lOOOO\
llOOl\

[
lOO\
l\
Ol\
OOOl\

++
]
=
lOOO\
O\
l\
O\
ll\
l\

[
lOOlOlOOO\
O\

]
[
lOOl\
OOlOlO\

]
;
}
fo\
r\

(
lOO\
lOO\
lOl\
O\

=
lO\
OlOOl\
OOO
;
lO\
OlOOlOlO
<
lOO\
l\
O\
O\
lOOl
;
lOOl\
O\
OlOlO
++
)
{
if\

(
lOOOOllOOO
[
lO\
O\
OOlOl\
ll\

[
lO\
OlOlOO\
OO
]
[
lOOlOOlOlO
]
]
!=
0
)
lO\
O\
OOll\
OO\
l
[
lOOlOlOOOl\

++
]
=
lO\
O\
OO\
lOl\
l\
l
[
lOOlO\
lOOO\
O
]
[
lOOlOOlO\
lO\

]
;
}
for
(
lOOlOOlOlO
=
lOOl\
OOl\
OOO
,
lO\
OlO\
lOOOl\

=
0
;
lOOlOOlOlO
<
lOOlOOl\
OOl
;
lOOlO\
O\
l\
OlO
++
,
lOOlO\
lOO\
Ol
++
)
lO\
OOO\
l\
Olll
[
lOOlO\
lO\
O\
O\
O
]
[
lO\
OlOO\
lO\
lO
]
=
lOO\
OO\
llO\
O\
l
[
lOOlOlOOOl
]
;
}
#ifdef _DEBUG
if
(
lOOlO\
OO\
llO
)
{
for
(
lO\
OlOO\
l\
OlO\

=
lO\
O\
lOOlO\
OO
;
lOO\
lOOlOlO
<
lO\
O\
lOOlOll
;
lOO\
lOOlOlO
++
)
{
TA_AS\
SE\
RT
(
lOO\
OO\
llOO\
O\

[
lOOOOlOlll
[
0
]
[
lOOlOOlOlO\

]
]
==
0
)
;
TA\
_AS\
SE\
RT
(
lOOO\
O\
llOOO
[
lOO\
OOlO\
lll
[
1
]
[
lOO\
l\
OOlOlO
]
]
==
0
)
;
TA_ASSER\
T\

(
lOO\
OOllOOO
[
lOOOOl\
Ol\
l\
l
[
2
]
[
lOOlOOl\
OlO
]
]
==
0
)
;
}
for
(
;
lOOl\
OO\
lOl\
O\

<
lOOlOO\
lO\
Ol
;
lO\
Ol\
OOl\
O\
lO\

++
)
{
TA\
_ASSERT
(
lOOOOllOO\
O\

[
lOOOOlO\
l\
ll
[
0
]
[
lOOlOOlOlO
]
]
==
1
)
;
TA\
_ASS\
ERT
(
lOOOOll\
OOO
[
lO\
OOOlOlll
[
1
]
[
lOOl\
OOlOl\
O
]
]
==
1
)
;
TA_ASSERT\

(
lO\
OOOllOOO
[
lOOO\
O\
lOl\
ll\

[
2
]
[
lOOlOOlOlO
]
]
==
1
)
;
}
}
#endif //
if
(
lOOl\
OO\
lOOO
+
1
<
lOOlOO\
lOll
)
lOO\
O\
lOlO\
ll
.
lOO\
O\
ll\
lO\
OO
(
lOOlO\
OllOO
[
lO\
OOll\
llOl
]
)
;
if
(
lOO\
l\
OOl\
Oll\

+
1
<
lOOl\
O\
O\
lOOl
)
lO\
OOl\
Ol\
O\
ll
.
lO\
OOlllOOO
(
lOOlO\
O\
ll\
Ol
[
lOOO\
llllO\
l
]
)
;
if
(
lOOlO\
Ol\
OOO
+
1
<
lOOlOO\
l\
O\
ll
)
lO\
OlOO\
OOll
(
lOOlOOlOO\
O
,
lO\
OlOOlOl\
l
)
;
if
(
lO\
OlOOlOll\

+
1
<
lOOlOOlOO\
l
)
lOOl\
O\
O\
O\
O\
l\
l
(
lOOlOOlOll
,
lOOlOO\
l\
OO\
l\

)
;
lOO\
O\
lOlOlO\

=
lO\
OOlOlO\
OO\

;
}
void
lOOOOll\
Ol\
l\

::
lOOlOlOOl\
O
(
co\
n\
st
AABB
&
lOOO\
O\
O\
Oll\
l\

,
lOO\
OOlll\
OO
lOOlOlO\
Oll
,
void\

*
lO\
OOOllllO
)
con\
st
{
if
(
lOOOl\
O\
l\
O\
lO
==
-
1
)
retu\
rn
;
if
(
!
lOOOOOO\
ll\
l
.
Inter\
sect\
s
(
lO\
O\
OlOlO\
ll
[
lOOOlOlOl\
O
]
)
)
return\

;
lOO\
O\
OllOlO
lOO\
lO\
lOlO\
O
;
lOO\
lO\
l\
OlO\
O\

.
lOOOOOOlll
=
lOOOOO\
Olll
;
lO\
OlOlO\
lOO
.
lO\
O\
OOlllO\
l
=
lOOlOlO\
Oll
;
lOOl\
OlOlOO
.
lOOOOl\
lllO\

=
lO\
OOOll\
llO\

;
lOOOOll\
OlO
*
lOOlOlOlO\
l
=
lOOOlOO\
O\
lO
;
lOOOlO\
OOlO
=
&
lOO\
lOlO\
l\
OO
;
lOOlOlOll\
O
(
0
,
lOOO\
l\
O\
l\
OOO\

,
lO\
OOlOl\
O\
lO
+
1
)
;
lOO\
Ol\
O\
OOlO
=
lOOl\
Ol\
OlOl
;
}
voi\
d
lOO\
OO\
llOll
::
lO\
OlOlOO\
lO
(
cons\
t
Vec3
&
lOOl\
OlOlll
,
cons\
t\

Ve\
c\
3
&
lOOOl\
OOOOO\

,
fl\
oa\
t
lO\
OlOl\
lOOO
,
lOO\
OOll\
l\
OO
lOO\
lOl\
OOll
,
void
*
lO\
OOO\
llllO
)
cons\
t
{
if
(
Fabs
(
lOO\
Ol\
OOOO\
O
.
x
)
>
0.999f
||
Fa\
bs
(
lO\
OOlO\
OOO\
O\

.
y
)
>
0.999f
||
Fa\
b\
s\

(
lOOOlOOOO\
O
.
z
)
>
0.999f
)
{
Vec3
lOO\
lOllOOl
=
lOOlOlO\
ll\
l\

+
lOOO\
lOOOOO
*
lOOlOll\
OO\
O
;
AABB
lOO\
OOOOll\
l
;
lO\
OOOO\
Ol\
l\
l
.
v3Ce\
nter
=
(
lO\
OlOl\
Olll
+
lO\
OlOl\
lOOl
)
*
0.5f
;
lOO\
O\
OOO\
lll
.
v3Extent
.
x
=
Fabs
(
lOOlOllO\
Ol
.
x
-
lO\
O\
lOlOlll
.
x
)
*
0.5f
;
lOO\
OO\
OOlll
.
v3\
Ext\
ent
.
y
=
Fabs\

(
lOO\
l\
OllOO\
l
.
y
-
lOO\
lO\
lOlll
.
y
)
*
0.5f
;
lO\
OO\
O\
O\
O\
ll\
l
.
v3Exten\
t\

.
z
=
Fabs\

(
lOO\
lOll\
OO\
l
.
z
-
lOO\
lO\
l\
O\
l\
ll\

.
z
)
*
0.5f
;
lO\
OlO\
lOOlO
(
lO\
OOOOOlll
,
lOO\
lOlOOll
,
lOO\
OOlll\
l\
O
)
;
ret\
u\
rn
;
}
if
(
lOOO\
l\
OlOlO
==
-
1
)
return
;
lOO\
O\
OllO\
lO
lO\
Ol\
OlOlOO
;
lOOlOlO\
lOO
.
lOOOOlll\
l\
l
=
lO\
OlOlOlll
;
lOOlOlO\
lO\
O
.
lOOOl\
O\
OOOO
=
lO\
OOl\
OOOO\
O
;
lOOlO\
lOlO\
O
.
lO\
OOlOOO\
Ol\

.
x
=
Fabs
(
lOOlOlO\
lOO
.
lOO\
Ol\
OOO\
OO\

.
x
)
>
lOOOlOO\
O\
ll
?
1.0f
/
lOOlOl\
OlOO
.
lO\
OOlO\
O\
O\
O\
O\

.
x
:
0.0f
;
lO\
Ol\
Ol\
O\
lOO
.
lOOOlO\
OOOl
.
y
=
Fa\
bs\

(
lOOlOlO\
lOO\

.
lO\
OOl\
O\
OOOO
.
y
)
>
lOO\
Ol\
OOO\
l\
l
?
1.0f
/
lOOl\
Ol\
OlOO
.
lOOOlOO\
O\
OO
.
y
:
0.0f
;
lO\
OlOl\
OlOO\

.
lO\
OOl\
OOOOl
.
z
=
Fab\
s
(
lOOlOlOlOO\

.
lOOO\
l\
OO\
OO\
O\

.
z
)
>
lOO\
OlOO\
Oll
?
1.0f
/
lOOlO\
l\
OlOO\

.
lOOOlOOOOO\

.
z
:
0.0f
;
lOO\
lO\
lOlOO
.
lOOOOlllO\
l
=
lOOl\
OlOOll
;
lOOlOlOl\
OO
.
lOOOOl\
lll\
O\

=
lOOO\
Ol\
lll\
O
;
lOO\
O\
Ol\
lOlO
*
lO\
Ol\
OlOlO\
l\

=
lOO\
OlOOOlO
;
lO\
OO\
l\
OOOlO\

=
&
lOOlOlO\
l\
O\
O
;
lOOlOlOll\
O\

(
0
,
lOOOl\
Ol\
OO\
O
,
lO\
OOlOlO\
lO\

+
1
,
0.0f
,
lOO\
lOllOOO\

)
;
lO\
OO\
l\
OOOlO
=
lOOlOlOlOl
;
}
stat\
i\
c
AABB
lOOlOll\
OlO
(
k_v\
3\
Zero
,
k_v3Zer\
o
)
;
con\
s\
t
AAB\
B
&
lOO\
OO\
ll\
Ol\
l
::
GetAABB
(
)
const
{
if
(
lOOOlOl\
OlO
!=
-
1
)
{
retu\
r\
n\

lOO\
OlOlO\
ll\

[
lOOOlOlO\
l\
O
]
;
}
else\

{
re\
t\
urn
lOOl\
OllOlO
;
}
}
vo\
id
lOOOOll\
Oll
::
lO\
O\
lOOO\
lll
(
in\
t
lOOlO\
OlO\
O\
O
,
int
lOOlOOlOOl
,
int\

lOOOlO\
Olll
,
con\
s\
t
AABB
&
lOOlOll\
Oll
)
const
{
#ifdef _DEBUG	
if\

(
!
lO\
Ol\
OOOllO\

)
retur\
n
;
if
(
lOOlOOl\
OOO
+
1
<
(
(
lOO\
lO\
OlOOO
+
lOO\
lOOlOO\
l
)
>>
1
)
)
{
const\

AABB
&
lO\
OlO\
l\
llOO\

=
lO\
O\
Ol\
OlOll
[
lOOOlOOlll
]
;
AABB
lO\
OOOO\
O\
ll\
l
=
lOOOlOlOl\
l
[
lOO\
OlOOlll\

]
;
lO\
OO\
O\
OOlll\

.
v3Ext\
ent\

*=
0.99f
;
TA_ASSERT
(
lO\
OOOOO\
lll
.
IsInside
(
lOOlOllOll\

)
)
;
lO\
OO\
l\
O\
Ol\
ll
++
;
int
lOOlOlllOl
=
lOOOlOOll\
l
;
if\

(
(
(
lO\
Ol\
O\
OlOOO\

+
lO\
O\
lOOlOOl\

)
>>
1
)
+
1
<
lOO\
lOOlOOl
)
lOOlOl\
llO\
l
++
;
lO\
Ol\
O\
OOll\
l
(
lOO\
lO\
OlOOO
,
(
(
lOO\
l\
OOlOOO\

+
lOOlOOlOOl
)
>>
1
)
,
lO\
O\
l\
O\
ll\
l\
Ol
,
lOO\
lOlllOO
)
;
}
els\
e
{
AA\
BB
lOOOOOOlll
=
lOOOlOlOll
[
lOO\
lOOl\
OOO
]
;
lOOOO\
OOlll\

.
v3Exte\
nt\

*=
0.99f
;
TA_AS\
SERT
(
lOOOOOO\
ll\
l\

.
Is\
Inside
(
lO\
OlOll\
Oll
)
)
;
lO\
OOlOO\
lO\
O\

++
;
}
if
(
(
(
lO\
Ol\
OO\
lOOO
+
lOOlOOl\
OOl\

)
>>
1
)
+
1
<
lOOlOO\
lOO\
l
)
{
const
AAB\
B
&
lOOl\
OlllOO
=
lOO\
OlO\
lOl\
l\

[
lOO\
Ol\
OOl\
l\
l\

]
;
AABB
lOOO\
O\
O\
Olll
=
lOOOlO\
lOll\

[
lOO\
O\
lOOl\
ll
]
;
lO\
OOOOO\
lll
.
v3Exte\
nt
*=
0.99f
;
TA_A\
SS\
ERT
(
lOOOOO\
Olll
.
Is\
Inside
(
lOO\
lOllOll
)
)
;
lOOl\
OOOlll
(
(
(
lOO\
lO\
O\
lOOO
+
lO\
O\
l\
OOlO\
Ol
)
>>
1
)
,
lOOl\
O\
OlO\
Ol
,
lO\
O\
OlOOlll\

+
1
+
(
(
lO\
OlOOlO\
O\
O
+
lOO\
lO\
OlO\
Ol
)
>>
1
)
-
lOO\
lOOlO\
O\
O
-
2
,
lOOlOl\
llOO
)
;
}
els\
e\

{
int
lOOlO\
lll\
lO
=
(
lOOlO\
O\
lOOO
+
lOO\
lOOl\
OO\
l\

)
>>
1
;
AABB
lO\
OO\
OOOlll
=
lOO\
OlOlO\
ll\

[
lOOlOllllO
]
;
lOOOOOO\
l\
ll
.
v3\
Ex\
tent
*=
0.99f
;
TA\
_ASSERT
(
lOO\
O\
O\
OOlll
.
Is\
Insid\
e
(
lOOl\
Ol\
lO\
ll
)
)
;
lOOOlO\
OlOO\

++
;
}
#endif //
}
#include <stdio.h>
void\

lOOOOl\
lOll
::
lO\
O\
lO\
lOllO
(
int
lOO\
l\
OOl\
OOO
,
in\
t
lO\
O\
l\
O\
O\
l\
O\
Ol\

,
int\

lO\
OOlOOlll\

)
con\
st\

{
if\

(
lOOl\
OOlOOO
<
(
(
lOOlOOl\
OOO\

+
lOOlOOlOO\
l\

)
>>
1
)
-
1
)
{
if
(
lOO\
OlOOOlO\

->
lO\
OOOOO\
lll
.
Inter\
sects
(
lOOOlO\
lOll
[
lO\
OO\
lOOll\
l
]
)
)
{
int
lOOlOl\
llll
=
lOO\
OlOOl\
l\
l\

+
1
;
if\

(
(
(
lO\
OlOO\
lOOO
+
lOOlOO\
lOOl
)
>>
1
)
<
lOOlOOlOOl
-
1
)
lO\
O\
lOlll\
ll\

++
;
lOOlOlO\
llO\

(
lOOl\
OOlOOO
,
(
(
lOOlOOlOOO
+
lO\
OlOOlOOl
)
>>
1
)
,
lOOlO\
llll\
l
)
;
}
lOOOlOOlll
++
;
}
else
{
if\

(
lOOOlOO\
OlO
->
lO\
O\
OOOOl\
ll
.
Intersec\
ts\

(
lOOO\
l\
Ol\
O\
l\
l
[
lO\
Ol\
OOlOOO
]
)
)
{
lOOO\
lO\
O\
Ol\
O\

->
lOOOOlllOl
(
(
lOOllOOO\
OO\

*
)
&
lO\
O\
OlOllO\
O
[
lOOlOO\
lOOO\

]
,
lOOOlOOOl\
O
->
lOOO\
OllllO
)
;
}
}
if
(
(
(
lOO\
l\
OOlOOO
+
lOOlOOlOOl
)
>>
1
)
<
lOOl\
OOl\
OOl\

-
1
)
{
if
(
lOOOl\
OOO\
lO\

->
lOO\
OOOOll\
l
.
Int\
ersec\
ts
(
lOO\
Ol\
OlOll\

[
lOOOlO\
Olll
]
)
)
{
lOOlOlOll\
O
(
(
(
lOOlOOlOO\
O
+
lOOlOO\
lO\
O\
l\

)
>>
1
)
,
lO\
OlO\
O\
lO\
Ol
,
lOO\
OlO\
Olll\

+
1
+
(
(
lO\
OlOOlOOO
+
lOOlOOlOOl\

)
>>
1
)
-
lOOlOOlO\
OO
-
2
)
;
}
}
el\
se
{
int
lOOlOll\
llO\

=
(
lOOlOO\
lOOO
+
lO\
O\
lO\
OlO\
Ol
)
>>
1
;
if\

(
lOOOlOOO\
lO
->
lOOO\
OOOll\
l
.
Inters\
ec\
t\
s
(
lOO\
OlOlOll\

[
lOOl\
OllllO\

]
)
)
{
lOOOl\
OOOlO
->
lOOO\
Ol\
llO\
l\

(
(
lOO\
ll\
O\
OOO\
O
*
)
&
lO\
OO\
lO\
ll\
OO
[
lOO\
lOl\
ll\
lO
]
,
lO\
OO\
l\
OOOlO
->
lOOO\
OllllO
)
;
}
}
}
void\

lOOO\
OllOll
::
lOOlOlO\
l\
l\
O
(
int
lOOlOOlOOO
,
in\
t
lO\
O\
lOOlOO\
l
,
in\
t
lOO\
O\
l\
OOlll\

,
float
lOO\
llO\
OO\
O\
l\

,
float\

lOOl\
lOOOlO
)
co\
ns\
t
{
TA_ASSERT
(
lOO\
OlO\
O\
OlO
)
;
if
(
lOOlOOlO\
OO
<
(
(
lOOlOOl\
O\
OO
+
lOOlOO\
lOOl
)
>>
1
)
-
1
)
{
float
lOOll\
OOO\
l\
l
=
lOOl\
lOOOOl
;
fl\
oat\

lOOl\
lO\
Ol\
OO
=
lO\
O\
llOOO\
l\
O
;
if
(
lOOllOOlO\
l
(
lOOllOOOll
,
lOOl\
lO\
Ol\
OO
,
lOOOlOl\
Ol\
l
[
lOOOlOOll\
l
]
)
)
{
in\
t
lO\
O\
l\
Olll\
ll
=
lOOOlOO\
lll\

+
1
;
if
(
(
(
lO\
OlOOl\
OOO
+
lOO\
lO\
Ol\
OOl
)
>>
1
)
<
lOOlO\
OlOOl
-
1
)
lO\
OlO\
l\
llll
++
;
lOO\
lO\
l\
OllO
(
lOO\
lOOlOOO
,
(
(
lO\
O\
lOOl\
O\
OO\

+
lOOl\
O\
OlOO\
l\

)
>>
1
)
,
lOOlOll\
lll
,
lO\
OllOO\
O\
l\
l
,
lOOl\
lO\
O\
lOO\

)
;
}
lO\
OOlOOl\
l\
l
++
;
}
els\
e\

{
fl\
oa\
t
lOOllOOOll
=
lOOll\
OO\
OOl
;
float
lO\
Ol\
lOOl\
OO\

=
lOOllOOOl\
O
;
if
(
lOOl\
lOOlOl
(
lO\
O\
ll\
OO\
O\
l\
l
,
lOOllO\
Ol\
O\
O
,
lOO\
Ol\
OlOll\

[
lO\
OlOOl\
OOO
]
)
)
{
lOO\
O\
lOOOlO
->
lOOOOll\
lOl
(
(
lOOllOOOO\
O
*
)
&
lOOOl\
OllOO\

[
lOOlO\
O\
lOOO
]
,
lO\
O\
OlOOOlO
->
lO\
OOOl\
lllO
)
;
}
}
if
(
(
(
lOOlOOlOOO
+
lO\
Ol\
OO\
l\
OOl\

)
>>
1
)
<
lOOlO\
O\
lOOl
-
1
)
{
if
(
lOOllOOlOl\

(
lOOllOO\
OOl
,
lO\
OllO\
OOl\
O
,
lOOOlO\
l\
Oll
[
lOO\
OlOOll\
l
]
)
)
{
lOO\
lOlOll\
O
(
(
(
lOO\
lO\
OlOOO
+
lOO\
l\
OOl\
OO\
l
)
>>
1
)
,
lOOl\
OOlO\
Ol
,
lOO\
OlO\
O\
lll
+
1
+
(
(
lO\
OlOOlOOO
+
lOOl\
OO\
lOOl
)
>>
1
)
-
lOO\
lO\
OlO\
O\
O
-
2
,
lOOll\
O\
OOOl
,
lOO\
llO\
OOlO
)
;
}
}
el\
se\

{
in\
t
lO\
Ol\
Ol\
ll\
lO
=
(
lOOl\
OOlOOO\

+
lOOl\
OO\
lOOl\

)
>>
1
;
if
(
lOO\
llOO\
lO\
l
(
lOOllOO\
OOl
,
lOOl\
lOOOlO\

,
lOOO\
lOl\
Oll
[
lOO\
l\
Olll\
l\
O
]
)
)
{
lOOOl\
OOO\
lO
->
lOOOOlll\
Ol
(
(
lO\
Ol\
lOOOOO
*
)
&
lOOOlOl\
lOO
[
lOOlO\
llllO
]
,
lOOO\
lOO\
OlO
->
lO\
OOO\
llllO
)
;
}
}
}
bo\
ol
lOOOOll\
Oll
::
lOOll\
OO\
lOl\

(
float
&
lO\
OllOOO\
Ol\

,
floa\
t
&
lOO\
ll\
O\
O\
OlO\

,
const
AABB
&
lOOOOOO\
ll\
l\

)
co\
n\
st
{
TA\
_ASS\
ERT
(
lOOOlOOOlO
)
;
flo\
at
lOOOO\
Ollll\

;
lOO\
OOOll\
ll
=
Sign
(
lOOOlOOOl\
O
->
lOOOlOOOOO\

.
x
)
;
if\

(
lOOOlOO\
O\
lO
->
lOOO\
lOOO\
OO
.
x
*
lO\
OO\
O\
Ollll
>
lOOO\
lO\
O\
O\
l\
l
)
{
floa\
t
lOOllOO\
llO
=
(
lOOOOOOlll\

.
v3\
Cen\
t\
er\

.
x
-
lOOO\
OOOlll\

.
v3Exten\
t
.
x
*
lOO\
OOOl\
lll
-
lOO\
OlO\
OOl\
O
->
lO\
OOOlllll
.
x
)
*
lOOO\
l\
OO\
OlO
->
lOO\
Ol\
OOOOl
.
x
;
if
(
lO\
Ol\
lOOOlO
<
lOOllOOl\
lO
)
re\
t\
u\
r\
n
fal\
s\
e
;
if\

(
lO\
OllO\
OOOl
<
lOOl\
lOOllO
)
lOOllOOOOl
=
lOO\
llO\
OllO
;
fl\
oa\
t
lOO\
llOO\
lll
=
(
lOOOO\
OOlll
.
v3\
Ce\
nter
.
x
+
lOOOOO\
Oll\
l
.
v3E\
xtent
.
x
*
lOOOOOllll
-
lOOO\
lOOOlO
->
lOOO\
Olllll
.
x
)
*
lOOOlOOO\
lO
->
lOOOlOOOOl\

.
x
;
if
(
lO\
O\
l\
lOOOOl\

>
lO\
Ol\
lOOl\
ll\

)
return
fa\
l\
s\
e
;
if\

(
lOOl\
lOO\
OlO
>
lO\
OllOOl\
ll
)
lOOl\
lOOO\
lO
=
lOOl\
lOO\
lll
;
}
el\
se
{
float
lO\
OllOl\
OO\
O\

=
lO\
OO\
lOOO\
l\
O
->
lO\
OO\
Olllll
.
x
+
lOO\
O\
lOO\
OlO\

->
lOO\
OlOOOOO\

.
x
*
lOOll\
OOOOl
;
if\

(
(
lO\
O\
ll\
OlOOO
-
lOO\
O\
O\
OOlll
.
v3C\
en\
ter
.
x
)
*
lOO\
OO\
Ollll\

>
lOOO\
O\
OOlll
.
v3Ex\
te\
nt\

.
x
)
ret\
urn\

fals\
e\

;
floa\
t
lO\
O\
llOlO\
Ol\

=
lOOOlOOOlO
->
lOO\
O\
O\
llll\
l
.
x
+
lOO\
O\
lOOOl\
O
->
lOOO\
lO\
O\
OOO\

.
x
*
lOOllO\
OOl\
O
;
if
(
(
lOOllOlOO\
l
-
lOOOO\
OOlll\

.
v3Cen\
ter\

.
x
)
*
lO\
OOOOllll
<
-
lOOOOOOll\
l
.
v3E\
xtent
.
x
)
ret\
urn
fal\
se
;
}
lOOOOOlll\
l
=
Sign
(
lOO\
OlOOOlO
->
lO\
O\
O\
lOOOOO
.
y
)
;
if\

(
lOOOl\
OOO\
lO
->
lOOO\
lO\
O\
OOO\

.
y
*
lOOOO\
Ol\
lll\

>
lOOOlOOO\
ll\

)
{
float
lOOllO\
OllO
=
(
lO\
OOO\
OOl\
ll
.
v3Center\

.
y
-
lO\
OOOOOl\
ll
.
v3Exten\
t\

.
y
*
lO\
O\
OOOllll
-
lOOOlOOOlO\

->
lO\
OOOl\
l\
l\
ll
.
y
)
*
lO\
OOlOOOl\
O
->
lOO\
Ol\
OOOO\
l
.
y
;
if
(
lOOl\
lOO\
OlO
<
lO\
OllOOll\
O
)
retur\
n
fa\
lse\

;
if
(
lO\
OllOOOOl
<
lO\
O\
llOOllO
)
lOOll\
O\
O\
OOl
=
lOO\
llOOl\
l\
O
;
floa\
t
lOOll\
OOlll
=
(
lOOOO\
OO\
lll\

.
v3\
Cente\
r
.
y
+
lOOOOOOl\
l\
l
.
v3Extent
.
y
*
lOO\
O\
OO\
llll
-
lOOOlOOOlO\

->
lO\
OOOll\
lll
.
y
)
*
lOOO\
lOOO\
lO
->
lO\
O\
OlOO\
OOl\

.
y
;
if
(
lOOl\
lO\
OO\
Ol
>
lO\
Ol\
lOOlll\

)
re\
tu\
rn\

fals\
e\

;
if
(
lOOllOOO\
lO\

>
lOOllOOlll
)
lO\
OllOOO\
l\
O
=
lO\
Oll\
OO\
lll
;
}
else
{
flo\
a\
t
lOOl\
lO\
lO\
lO
=
lOOO\
lOOOl\
O
->
lO\
O\
OOlllll\

.
y
+
lOOOl\
OO\
OlO
->
lOO\
OlOOOOO
.
y
*
lO\
OllOOOOl
;
if
(
(
lOOllOl\
Ol\
O
-
lOOOOO\
Olll
.
v3Center
.
y
)
*
lO\
OO\
OO\
lll\
l
>
lOOOOO\
O\
l\
ll
.
v3\
Ex\
tent\

.
y
)
ret\
ur\
n\

fal\
se
;
fl\
oat
lO\
OllOlO\
l\
l
=
lO\
OO\
lOOO\
l\
O
->
lOOOOl\
llll
.
y
+
lO\
O\
OlOOO\
lO
->
lO\
OOl\
O\
OOOO
.
y
*
lOO\
llOOOlO
;
if
(
(
lOO\
llO\
lOll\

-
lOO\
OO\
O\
Olll\

.
v3Ce\
nter
.
y
)
*
lOOOOOl\
lll
<
-
lOOOOO\
O\
lll
.
v3Ex\
te\
nt
.
y
)
return\

false
;
}
lOOOOOllll
=
Si\
gn
(
lOOOl\
OOOl\
O
->
lOOOlO\
O\
O\
OO
.
z
)
;
if
(
lOO\
OlOOOlO
->
lO\
OOlOOOOO
.
z
*
lO\
OOOOllll
>
lO\
O\
OlO\
O\
Oll\

)
{
flo\
a\
t
lOOllOOl\
lO
=
(
lO\
OOOOOlll
.
v3Cente\
r
.
z
-
lOO\
O\
OOO\
ll\
l\

.
v3Exte\
nt\

.
z
*
lOO\
OO\
Olll\
l
-
lOOOlO\
O\
OlO
->
lO\
OOOlllll\

.
z
)
*
lOO\
OlO\
OOl\
O
->
lO\
OOl\
O\
OOOl\

.
z
;
if
(
lO\
OllOO\
OlO
<
lOOll\
O\
OllO\

)
re\
turn
fals\
e
;
if
(
lOOllO\
OO\
Ol\

<
lOOllOO\
llO\

)
lOO\
llOO\
O\
Ol
=
lOOllOO\
llO\

;
fl\
oat\

lO\
OllOOl\
l\
l\

=
(
lOOO\
OOOl\
l\
l
.
v3Center\

.
z
+
lO\
OOOOOlll\

.
v3Ext\
ent
.
z
*
lOOOOO\
lll\
l
-
lO\
O\
OlOOOl\
O\

->
lOOOOl\
llll
.
z
)
*
lOO\
Ol\
OOOlO\

->
lOO\
OlO\
O\
OO\
l
.
z
;
if
(
lOO\
llOOO\
Ol
>
lO\
OllO\
Olll\

)
ret\
u\
r\
n
false
;
if
(
lO\
OllO\
OOlO
>
lO\
O\
llOO\
l\
ll
)
lOOllOOO\
lO\

=
lOO\
llOO\
lll
;
}
els\
e
{
flo\
at
lOOllOll\
OO
=
lOOOlOO\
OlO
->
lOOOOl\
llll
.
z
+
lOOOlOOOlO
->
lOOOlO\
O\
OOO
.
z
*
lO\
OllOOO\
O\
l
;
if
(
(
lOOllOl\
lOO
-
lOOO\
OO\
Ol\
ll
.
v3\
Cen\
te\
r\

.
z
)
*
lO\
OO\
O\
O\
ll\
ll
>
lO\
OOO\
OOlll\

.
v3\
Ex\
ten\
t
.
z
)
return\

fal\
se
;
float\

lO\
OllOll\
Ol
=
lOO\
O\
l\
OOO\
lO
->
lOOOOll\
lll
.
z
+
lO\
OOlOOOlO\

->
lOO\
Ol\
O\
O\
OOO
.
z
*
lO\
O\
l\
lOOOlO
;
if
(
(
lO\
OllOll\
Ol
-
lOOOOOOlll\

.
v3C\
enter
.
z
)
*
lOOOOOlll\
l\

<
-
lOOO\
O\
OOlll
.
v3Exten\
t
.
z
)
retu\
rn
false\

;
}
retu\
rn
true
;
}
}

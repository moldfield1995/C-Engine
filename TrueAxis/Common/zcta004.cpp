//---------------------------------------------------------------------------------
// File Name: zcta004.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "ConvexHull.h"
#ifndef lOlOlOllOO
#include "../Common/zcta009.h"
#endif //
#ifndef TA_RANDFUNC_H
#include "RandFunc.h" //
#endif //
#ifndef TA_GEOMETRY_H
#include "Geometry.h"
#endif //
namespace
TA
{
con\
st
flo\
at\

lOlOlOllOl
=
0.01f
;
class
Con\
v\
exHul\
l
::
lOlOl\
Oll\
lO
{
pub\
l\
i\
c
:
stru\
ct\

Polygon
;
st\
ru\
c\
t
lO\
lOlO\
lll\
l
{
enum\

Flag
{
lOlOll\
OOOO
=
0x1
,
lOlOllOOOl\

=
0x2
,
lOlOllOO\
lO
=
0x4
,
}
;
Vec3
lOOOO\
llll\
l\

;
Vec3
lOOOl\
OO\
OOO
;
u32\

lOlOllOOl\
l
;
float
lOlOllOlOO
;
float
lOlO\
l\
lOlOl\

;
Po\
l\
ygon\

*
lO\
lOl\
lOll\
O
;
lOlO\
lOl\
l\
ll
*
lOl\
O\
ll\
Oll\
l
;
}
;
stru\
ct
Polyg\
on
{
Vec\
3
lOO\
O\
lOOOO\
O
;
int
lOlOlllOOO\

;
int
lOOOlO\
Ol\
ll
;
float
lOlO\
lllO\
Ol
;
lO\
lO\
ll\
lOlO
<
lOl\
OlOllll
,
tru\
e\

>
::
lOl\
Oll\
lOll
lOlOllllOO\

;
}
;
st\
ru\
c\
t\

lOlOllllOl
{
Vec3
lOOOOlllll\

;
Vec3
lOOO\
l\
OOOOO
;
}
;
lOlO\
lO\
lll\
O\

(
)
{
}
~
lO\
l\
OlOlllO
(
)
{
Fi\
n\
ali\
se
(
)
;
}
vo\
id\

Initialise
(
int
lO\
lOlllllO
)
{
lOlOllll\
ll\

.
Ini\
tia\
li\
s\
e
(
lOlOlll\
llO
*
8
)
;
lOllOO\
OOO\
O
.
Initialise
(
0
,
lOlOlllllO
)
;
}
void\

Finalise
(
)
{
lOlOlll\
l\
ll\

.
Finalise
(
)
;
lOll\
OO\
OOOO\

.
Fi\
nalise
(
)
;
}
voi\
d
lOl\
lOO\
OO\
Ol\

(
const
Vec\
3
&
lOO\
O\
l\
O\
OOOO\

,
float
lO\
l\
Ol\
llOOl
,
bo\
ol
lO\
l\
lOOOOlO
)
{
TA_ASS\
ERT\

(
lO\
OOlOOO\
OO
.
IsN\
orm\
a\
lised
(
)
)
;
int\

lOllOOOOl\
l
;
{
floa\
t\

lOllOO\
O\
lOO
=
Cos
(
k_\
fPi
*
0.25f
*
0.125f
)
;
if
(
lOll\
O\
OOOl\
O
)
lOl\
lOO\
Ol\
OO
=
Cos
(
k_fPi
*
0.01f
)
;
for
(
lOllOO\
OOll\

=
0
;
lOllOOOOl\
l
<
lOll\
O\
OOOOO
.
lOO\
O\
lll\
OOl
(
)
;
lO\
llO\
O\
O\
Oll
++
)
{
Polygon
&
lO\
llOOO\
lOl
=
lOll\
O\
O\
O\
O\
OO\

[
lOll\
O\
OO\
Oll
]
;
if\

(
lOl\
lOOOl\
Ol
.
lOO\
OlOOOO\
O\

.
Dot\

(
lO\
O\
OlOO\
OOO\

)
>
lOll\
OOO\
l\
O\
O
)
ret\
urn
;
}
}
Poly\
gon
&
lO\
llOOOllO
=
lOl\
lO\
OOOOO\

.
lOOOlll\
OO\
O
(
)
;
lOl\
lOOOllO\

.
lOOO\
lOO\
OOO
=
lOOO\
lO\
OO\
OO
;
lO\
llOOOllO\

.
lOlOlllOO\
l
=
lOlOlllOO\
l
;
lOllO\
OOllO
.
lOlOl\
llO\
OO
=
lOllO\
OOO\
OO\

.
lOOOlllO\
Ol
(
)
-
1
;
lO\
llOOO\
llO\

.
lOOOlOO\
lll
=
-
1
;
for
(
lOllOO\
OOl\
l
=
0
;
lOllO\
OO\
O\
ll\

<
lOllOOOOO\
O
.
lO\
O\
OlllOOl\

(
)
-
1
;
lOllO\
OOOll
++
)
{
Poly\
gon
&
lO\
llOOO\
lOl
=
lOl\
lO\
OOO\
OO\

[
lOll\
OO\
OOll
]
;
Vec3
lOll\
OO\
Ol\
ll
;
Vec\
3
lO\
ll\
OOlO\
OO\

;
if
(
!
lOll\
OOlO\
Ol
(
lOllOO\
OlOl\

.
lOO\
OlOOOO\
O\

,
lO\
llOOOlOl\

.
lO\
lOlll\
OOl
,
lOl\
lOOOllO
.
lOOOlO\
OOO\
O
,
lOllO\
O\
OllO
.
lOlOl\
l\
lO\
Ol
,
lO\
ll\
OOOlll
,
lO\
llOOlOOO
)
)
conti\
nu\
e\

;
lOl\
O\
l\
Olll\
l
*
lOllO\
OlOlO
=
lOllOO\
lOll
(
lOllOOOlll\

,
lOllOOlOOO\

,
lOllO\
OOl\
lO\

,
lOllOOOl\
Ol
)
;
lOlOlOl\
lll\

*
lO\
llO\
OllOO
=
lOllOO\
lOll\

(
lO\
l\
l\
OOO\
ll\
l
,
lO\
l\
lOOlOOO
,
lOl\
l\
O\
O\
O\
l\
Ol
,
lOl\
lO\
OOllO
)
;
if
(
lOl\
lOOlOl\
O\

&&
lO\
ll\
OOl\
lOO
)
{
lOll\
OO\
lO\
lO
->
lOlOl\
lO\
l\
ll\

=
lOll\
OOllOO
;
lOllOOllO\
O
->
lOlOl\
l\
Olll
=
lOllO\
Ol\
OlO
;
TA_ASSERT
(
lOllOO\
l\
OlO
->
lOl\
Oll\
Olll
->
lOlO\
l\
l\
Ol\
ll
==
lOllOOlOlO
)
;
}
}
}
bo\
ol\

lOllOO\
llOl\

(
lOOOOl\
Ol\
lO
<
in\
t\

>
&
lOllOOl\
llO
,
lO\
OO\
OlOllO
<
int
>
&
lOl\
lOOllll
,
lO\
O\
OO\
lOl\
lO
<
Vec3
,
false
>
&
lOl\
l\
O\
lOOOO
)
{
for
(
int\

lOll\
Ol\
OO\
Ol
=
0
;
lOllOlO\
OO\
l
<
lOllOOOOO\
O
.
lOOOlllOOl
(
)
;
lOl\
lOlOOOl
++
)
{
Pol\
ygon
&
lOl\
l\
OlOOlO
=
lOllOOOOOO
[
lOllOlOO\
Ol\

]
;
for
(
in\
t
lOllOlO\
Ol\
l\

=
0
;
lOllO\
lOOll
<
lOllOOOO\
OO
.
lO\
OOll\
lO\
O\
l
(
)
;
lO\
ll\
OlO\
O\
ll\

++
)
{
Pol\
ygo\
n
&
lOl\
lOl\
OlOO\

=
lO\
l\
l\
O\
OOO\
OO
[
lOllO\
lO\
Oll
]
;
lO\
l\
l\
OlOlOl
lOlOOl\
O\
OlO
=
lOllOlOOlO\

.
lO\
lOl\
l\
llO\
O
.
lOlOOOOl\
O\
O\

(
)
;
for
(
;
!
lO\
l\
OO\
lO\
OlO
.
AtEnd
(
)
;
)
{
lOlOl\
Oll\
l\
l\

&
lOl\
l\
Ol\
Ol\
l\
O
=
*
lOlOOlOOl\
O
;
++
lOlOO\
lOOl\
O
;
const
fl\
oa\
t\

lOll\
OlO\
lll
=
0.01f
;
co\
ns\
t\

boo\
l\

lOllOl\
lOOO\

=
(
lOllOlOl\
O\
O
.
lO\
O\
OlOOOOO
.
Dot\

(
lOllOlOllO
.
lOO\
OOlll\
ll
+
lOl\
lOlO\
l\
lO\

.
lOOO\
l\
OOOOO\

*
lOllO\
lOllO\

.
lOlOl\
lOlOO
)
-
lOllOl\
O\
l\
OO
.
lOlOlllOO\
l
>
lO\
l\
lO\
lOll\
l
&&
lOllOlOl\
OO
.
lO\
OOlO\
OO\
OO
.
Do\
t
(
lO\
llOlOllO
.
lOOO\
O\
l\
llll\

+
lOllO\
lO\
l\
l\
O
.
lOO\
O\
lOOOO\
O\

*
lOllOlOllO\

.
lO\
lOll\
O\
lOl
)
-
lOllO\
lOlOO
.
lOl\
OlllOOl
>
lO\
ll\
OlO\
lll
)
;
cons\
t
boo\
l\

lO\
ll\
O\
ll\
O\
Ol\

=
(
lOllOl\
OllO
.
lOlOllOlOO
>=
lOll\
Ol\
OllO\

.
lOl\
Oll\
OlOl
-
lO\
llOlOll\
l
)
;
const
bool\

lOllO\
llO\
l\
O\

=
(
lOllOlOllO
.
lOlO\
llOOl\
l\

&
(
lO\
l\
OlO\
llll
::
lOlOllOOO\
O
|
lO\
lO\
lOl\
lll
::
lOlOllO\
OOl\

)
)
!=
(
lOlOlOl\
lll
::
lOl\
OllOOOO
|
lOlO\
l\
Oll\
l\
l\

::
lOlO\
l\
lOOOl
)
;
if
(
lO\
llO\
llOOO
||
lOllOl\
lOOl
||
lOllO\
llOlO
)
{
if\

(
lOll\
OlOl\
l\
O
.
lOl\
Ol\
lOl\
ll
)
{
TA\
_ASSERT
(
lOllOlO\
llO\

.
lOlO\
l\
lOll\
O
)
;
TA_ASSERT
(
lOllOlOl\
l\
O\

.
lOlOl\
lO\
lll
->
lOlOl\
lOlll
==
&
lO\
llOlOll\
O
)
;
lOl\
lOl\
O\
llO
.
lOlOllO\
lll
->
lOlOllOl\
l\
l
=
0
;
lO\
ll\
O\
lO\
l\
lO
.
lOlOl\
lOllO
->
lOlOlll\
lO\
O\

.
lOOllll\
lll
(
lO\
l\
lOlOllO
.
lOl\
Ol\
lOll\
l
)
;
lO\
lOllllll
.
Free
(
lO\
l\
l\
OlOl\
lO
.
lOlOllOlll
)
;
lOl\
lO\
l\
OllO
.
lOlOllOl\
ll
=
0
;
}
lOl\
lO\
lOOlO
.
lOlOllllOO
.
lOOlllll\
ll
(
&
lOll\
OlOl\
lO\

)
;
lOlO\
llllll
.
Free
(
&
lO\
ll\
OlO\
llO
)
;
}
}
}
}
in\
t
lOl\
lO\
ll\
Ol\
l
=
0
;
int\

lO\
llOll\
lOO
=
0
;
in\
t
lOl\
lO\
OO\
Ol\
l
;
fo\
r\

(
lOllOOOO\
ll
=
0
;
lO\
llOOO\
O\
ll
<
lOll\
OOOO\
OO\

.
lOOOl\
llOOl
(
)
;
lOllOO\
O\
Oll\

++
)
{
Pol\
ygon\

&
lOllO\
OOlOl
=
lOllO\
O\
OOOO
[
lO\
llO\
OOOl\
l\

]
;
int
lOl\
lOlllOl
=
lOllOOOlO\
l\

.
lO\
lO\
ll\
llOO\

.
lOOOl\
llOOl
(
)
;
if
(
lOl\
lO\
lllOl
>=
3
)
{
lO\
ll\
O\
lllO\
O
+=
lOl\
lO\
ll\
lOl\

;
lOllO\
O\
OlOl\

.
lOOO\
lO\
O\
ll\
l\

=
lOllOllOll
;
lOl\
lOl\
lOl\
l
++
;
}
else
{
lOl\
lOOOlOl
.
lOO\
O\
lOOll\
l
=
-
1
;
}
}
lOO\
OO\
lO\
l\
lO
<
Vec3
,
false
>
lOllOll\
llO
;
lOllOllllO
.
In\
it\
ia\
lis\
e
(
0
,
lOllO\
ll\
lO\
O
)
;
int
lOl\
lOlllll
=
lOllOllO\
ll
+
lOllOl\
l\
lOO
*
2
;
lOllOOlll\
O
.
In\
iti\
a\
lise
(
lO\
llOlll\
l\
l
,
lOllO\
lllll
)
;
lOllO\
Ol\
lll
.
Init\
i\
ali\
se\

(
0
,
lOl\
lOllOll
)
;
lO\
llOll\
Oll
=
0
;
in\
t
lOOOl\
l\
OOlO
=
0
;
fo\
r
(
lOllOOOO\
ll
=
0
;
lOllOOOOll\

<
lOllO\
OO\
OO\
O
.
lOOOl\
l\
lOOl\

(
)
;
lOllO\
O\
OOl\
l
++
)
{
Polygon
&
lO\
llOO\
O\
lOl
=
lOllO\
OOOOO
[
lOl\
lOOOOll
]
;
if
(
lO\
l\
lO\
OO\
lOl
.
lOOOlOOll\
l
==
-
1
)
conti\
nue
;
lOllOOOlOl
.
lOO\
OlOO\
l\
ll\

=
-
1
;
int\

lOll\
lOOO\
OO
=
lOOOllOOl\
O\

;
lOl\
l\
OOlllO\

[
lOOOl\
lOO\
l\
O\

++
]
=
0
;
int\

lOll\
lO\
OOOl
=
-
1
;
Ve\
c\
3\

lOl\
llOOO\
lO
=
k_\
v\
3Zero
;
int
lOll\
lOO\
Oll
=
0
;
fo\
r
(
;
;
)
{
lO\
llOlOl\
O\
l
lOlOOlOOl\
O
=
lOll\
OOOlOl
.
lOlOll\
llOO
.
lO\
lOOOOlOO
(
)
;
lOl\
OlOll\
ll
*
lO\
l\
llOOl\
OO
=
0
;
floa\
t
lOlllOO\
l\
O\
l
=
k_fMaxFl\
oat
;
bo\
o\
l\

lOll\
lOO\
llO\

=
false
;
fo\
r\

(
;
!
lOlOOl\
OOlO\

.
At\
En\
d
(
)
;
++
lOlOOlOOlO
)
{
lOlOlOlll\
l\

&
lOllO\
lOl\
lO
=
*
lO\
lO\
Ol\
O\
Ol\
O
;
TA_ASSE\
R\
T
(
(
lOllOl\
Oll\
O
.
lO\
lOl\
lOO\
ll\

&
(
lOl\
O\
l\
O\
l\
l\
l\
l
::
lOlO\
llOO\
O\
O
|
lOlOlOll\
ll
::
lOlOll\
OO\
Ol
)
)
==
(
lO\
lOlOlll\
l\

::
lOl\
OllOOOO
|
lO\
lOlO\
ll\
ll
::
lOlOl\
lOOOl
)
)
;
if\

(
lOl\
l\
lOOlOO
==
&
lO\
ll\
OlOllO
)
conti\
nu\
e\

;
if\

(
lOlllOOOOl
==
-
1
)
{
lO\
lllOOlOO
=
&
lOl\
lOl\
O\
llO
;
bre\
ak
;
}
else
{
Vec3
lOOO\
Ol\
OOOl
=
lO\
ll\
OlOllO\

.
lOO\
OOl\
llll
+
lOllO\
l\
OllO
.
lOOOlOOOOO
*
lO\
llOl\
OllO\

.
lOl\
OllOlOO\

;
float
lO\
lllOOlll
=
(
lOO\
OOlOO\
Ol
-
lOlllOOOlO
)
.
GetMagnitud\
e\
S\
qrd
(
)
;
if\

(
lOlllOOlOl
>
lOlllOO\
ll\
l
)
{
lO\
ll\
lOOlOl
=
lOl\
ll\
OOlll
;
lOl\
llOOlO\
O\

=
&
lOl\
l\
OlO\
llO
;
if
(
lO\
lllOOlOO
->
lO\
l\
OllOO\
l\
l\

&
lOl\
OlO\
llll
::
lO\
lOllOOlO
)
lOlll\
O\
OllO
=
true
;
els\
e
lOlllOO\
llO
=
fa\
lse
;
}
}
}
if
(
lOlllOOllO
)
bre\
ak\

;
TA_\
AS\
SE\
RT
(
lOl\
llOOO\
l\
l
==
0
||
lO\
lllOO\
lO\
l
<
0.001f
)
;
lOll\
l\
OOOll\

++
;
TA_ASS\
ER\
T\

(
lOlllOO\
l\
OO
)
;
lOlllOOl\
OO
->
lOlOllOOll\

|=
lO\
lOlO\
ll\
ll
::
lOlOll\
OOlO\

;
lO\
l\
ll\
O\
OOO\
l
=
lOl\
lO\
lOOOO
.
lOOOl\
llO\
O\
l
(
)
;
Vec\
3
lOOOOlO\
OOl
=
lOll\
lOOlOO\

->
lO\
OOOl\
ll\
l\
l
+
lOlllOOlOO
->
lO\
OOl\
OOO\
OO
*
lO\
ll\
lO\
OlO\
O
->
lOl\
OllOl\
OO
;
int\

lOl\
llOlO\
OO\

;
for
(
lOlllOlOOO
=
0
;
lOl\
llOlOOO
<
lOll\
OllllO
.
lO\
OOll\
lO\
Ol
(
)
;
lOl\
ll\
OlOOO
++
)
if
(
(
lOllOllll\
O
[
lOl\
llO\
lOOO
]
-
lOOOO\
lOOO\
l
)
.
GetMa\
gnitude\
S\
qrd
(
)
<
0.0001f
)
br\
eak
;
if\

(
lO\
lll\
Ol\
OO\
O
==
lO\
llOl\
lllO
.
lOOOl\
l\
lOOl
(
)
)
lOl\
lOlll\
l\
O
.
lO\
OOl\
llOO\
O
(
lOO\
OOlOOOl
)
;
lO\
l\
lOOl\
llO
[
lOOO\
ll\
OOlO\

++
]
=
lO\
ll\
l\
OlO\
OO\

;
TA_AS\
S\
ERT
(
lOlllOOl\
OO
->
lOlOllO\
llO
)
;
lOllO\
Ol\
llO
[
lOOOllO\
Ol\
O
++
]
=
lO\
l\
ll\
OO\
lOO
->
lOlOl\
lO\
l\
l\
O
->
lO\
lOl\
llOOO
;
lOl\
l\
lOOO\
l\
O\

=
lOlllOOlO\
O
->
lOO\
OOl\
l\
ll\
l\

+
lOl\
llOOlO\
O
->
lO\
OO\
l\
OO\
OOO
*
lOlllOOlO\
O\

->
lOlOll\
OlOl
;
}
if
(
lO\
l\
ll\
OOOll
<
3
)
{
lO\
OOllOOlO
=
lOlllOOO\
OO\

;
}
els\
e
{
lO\
llOOO\
l\
Ol
.
lOOOl\
O\
Olll
=
lO\
llOO\
lll\
l
.
lOOO\
lllO\
Ol\

(
)
;
lOl\
lOOllll
.
lO\
O\
Oll\
l\
O\
O\
O\

(
lOll\
l\
OOOOO
)
;
lO\
l\
lOO\
lllO
[
lOl\
llO\
O\
OOO
]
=
lOl\
l\
lO\
OOll\

;
}
}
for
(
lOllOOO\
Oll
=
0
;
lO\
llOO\
O\
Oll
<
lO\
llOO\
ll\
ll
.
lO\
O\
OlllOOl\

(
)
;
lOllOOO\
Oll
++
)
{
int
lO\
OOll\
O\
OlO
=
lO\
llOOllll\

[
lOllOOO\
O\
ll
]
;
for
(
int
lO\
lllOlOO\
l
=
lOllOOl\
l\
lO\

[
lOOOll\
OOlO
++
]
;
--
lOlll\
Ol\
OOl
>
0
;
)
{
lOO\
Ol\
lOOlO
++
;
lO\
l\
lOOlllO
[
lOOOllOOlO
]
=
lO\
llO\
O\
OO\
OO\

[
lOllOOl\
l\
l\
O
[
lOOO\
llOOl\
O
]
]
.
lOO\
O\
lO\
O\
lll
;
if
(
lO\
llOOll\
lO
[
lOO\
Ol\
lOO\
lO
]
==
-
1
)
{
TA_\
AS\
SERT
(
0
)
;
return\

false
;
lO\
llO\
OlllO
[
lO\
OOllOO\
lO\

]
=
lOllOOll\
l\
l\

[
lOllOOOOl\
l
]
;
}
lOO\
Ol\
lO\
OlO
++
;
}
}
lOllOlOOOO\

.
Initia\
lise
(
lOllOllllO\

.
lO\
O\
Olll\
OOl\

(
)
,
lOllOllllO
.
lOOOlllOO\
l
(
)
)
;
fo\
r
(
int
lOlllOlOOO
=
0
;
lOlll\
OlO\
OO
<
lOllO\
llll\
O
.
lO\
OO\
l\
llO\
Ol
(
)
;
lOl\
llOlOO\
O
++
)
lOll\
OlOOOO\

[
lOlll\
O\
lOO\
O\

]
=
lOllOllll\
O\

[
lOlllO\
lO\
OO
]
;
lOllOllllO\

.
Fina\
l\
is\
e
(
)
;
lOllO\
Ollll
.
lOl\
O\
OOOlO\
l
(
)
;
return
true\

;
}
voi\
d\

lOlllOlO\
l\
O
(
)
{
TA_ASSERT
(
0
)
;
}
priv\
at\
e
:
lOlOl\
llOlO
<
lO\
lOlOllll
,
tru\
e\

>
lOlOll\
lll\
l\

;
lOO\
OOlOll\
O\

<
Polyg\
on\

,
fa\
lse
>
lOllO\
O\
OOOO
;
typ\
ede\
f
lOlO\
lll\
O\
lO
<
lOl\
O\
lOl\
ll\
l
,
tr\
u\
e
>
::
lOlOl\
l\
lOl\
l
::
Ite\
r\
ato\
r
lOl\
l\
Ol\
OlOl
;
lOlOl\
Ol\
lll
*
lO\
llOO\
lOl\
l
(
const
Ve\
c3
&
lOOOOl\
ll\
ll
,
const
Vec\
3
&
lOOOl\
O\
OOOO
,
Polygon
&
lOl\
lOlOOlO\

,
Polygon
&
lOl\
l\
OlO\
lOO\

)
{
lO\
l\
OlOlll\
l
*
lOlll\
OlOl\
l\

=
lO\
l\
Ollllll
.
Al\
loc\

(
)
;
lO\
llO\
l\
OlO\
l
lO\
lOOl\
OO\
lO\

=
lOllO\
lOOlO\

.
lOlO\
lll\
lOO\

.
lO\
l\
OOOOlOO\

(
)
;
lOlllOl\
O\
ll
->
lOOO\
Ollll\
l\

=
lOOOOllll\
l
;
if
(
lOllOl\
OlOO
.
lO\
OOl\
OO\
OO\
O
.
Dot
(
lO\
O\
OlO\
OOO\
O
.
Cros\
s
(
lOl\
l\
OlO\
OlO
.
lOOO\
lOOOOO\

)
)
>
0.0f
)
lO\
lll\
OlOll
->
lOOOlO\
OOOO
=
lOOOlO\
OOOO
;
els\
e
lO\
lllOl\
O\
l\
l
->
lOOOlO\
OOOO\

=
-
lO\
OO\
lOOO\
OO
;
lOl\
llO\
lOl\
l
->
lO\
lOllOl\
OO\

=
-
100.0f
;
lOlll\
OlO\
ll
->
lOlO\
l\
l\
O\
lOl
=
100.0f
;
lO\
lllOl\
Ol\
l
->
lO\
l\
OllO\
Ol\
l
=
0
;
lOl\
llOlOl\
l
->
lOlOllOllO\

=
&
lO\
llOl\
Ol\
OO
;
lOlll\
O\
l\
O\
ll\

->
lOl\
OllOlll
=
0
;
fo\
r
(
;
!
lO\
lOOlOO\
l\
O\

.
AtEnd\

(
)
;
++
lOlOOlO\
OlO
)
{
lO\
lOlOll\
ll
&
lO\
l\
lOlO\
l\
l\
O
=
*
lO\
lOOlOOlO
;
Vec3
lOlllOllOO
=
k_v3Zero\

;
if\

(
!
lOlllOllOl
(
lOO\
O\
Ol\
ll\
l\
l\

,
lO\
OOlOOOOO
,
lO\
llOlOllO
.
lO\
OOOll\
l\
ll
,
lO\
llOlOl\
lO
.
lOOOlOOOOO
,
lOlllO\
llOO
)
)
contin\
u\
e
;
fl\
oat
lOl\
ll\
Ol\
llO
=
lOll\
Ol\
O\
l\
lO
.
lOO\
OlO\
OOOO
.
Dot
(
lO\
ll\
lO\
llOO
-
lOl\
lOlO\
l\
lO
.
lO\
OOOlllll\

)
;
TA\
_ASSERT\

(
lOllO\
lOllO
.
lOOOlO\
OO\
OO
.
Dot
(
lO\
llOlOlOO\

.
lOOOlOOOOO
)
!=
0
)
;
if
(
lOllOlO\
ll\
O
.
lO\
OOl\
OO\
O\
OO
.
Dot\

(
lOllOlO\
lO\
O
.
lOOO\
lOOOOO
)
>
0.0f
)
{
if
(
lO\
l\
llOlllO\

<
lO\
llO\
lOllO
.
lO\
lO\
llOlO\
l
)
{
lOllOlO\
llO\

.
lOl\
O\
llO\
lOl
=
lOl\
l\
lOlll\
O
;
lOllO\
l\
Ol\
lO
.
lOl\
Ol\
lOOll
|=
lO\
lO\
lO\
llll\

::
lOlO\
l\
lOOOl
;
}
}
els\
e\

{
if
(
lO\
lllOl\
llO
>
lOll\
OlOll\
O
.
lOlOllOlO\
O\

)
{
lOll\
OlOllO\

.
lOlOl\
lOlO\
O
=
lO\
lllOlllO
;
lOl\
lOlO\
llO
.
lO\
lOl\
lOOll
|=
lOl\
O\
l\
Olll\
l
::
lO\
lOl\
lOOOO
;
}
}
lOlllOlll\
O
=
lOl\
llO\
lOl\
l
->
lOOOlOO\
O\
O\
O\

.
Dot
(
lOlll\
OllOO
-
lOlllOl\
O\
ll
->
lOOOO\
ll\
lll
)
;
TA_ASSE\
R\
T
(
lO\
lllOl\
O\
l\
l\

->
lOOOl\
OOOOO\

.
Do\
t
(
lOl\
l\
OlO\
O\
lO\

.
lO\
OOlOOOOO
.
Cro\
ss
(
lOllOlOllO
.
lOOO\
l\
OO\
O\
OO
)
)
!=
0
)
;
if
(
lOlllOlOll
->
lOOOlOOO\
O\
O
.
Dot
(
lOllO\
lOOlO
.
lO\
OOlO\
OO\
OO
.
Cr\
oss
(
lOllO\
lO\
llO
.
lOOOlOOOO\
O
)
)
<
0.0f
)
{
if
(
lOlll\
Ol\
Oll
->
lO\
lOl\
l\
O\
l\
Ol
>
lOl\
ll\
OlllO
)
{
lOlllOl\
Ol\
l
->
lOl\
OllOlOl
=
lOll\
lOl\
l\
lO
;
lO\
lll\
OlOll
->
lOlOl\
l\
OOl\
l
|=
lO\
lOlO\
llll
::
lOlO\
llOO\
O\
l
;
}
}
els\
e\

{
if
(
lOlll\
OlllO
>
lOlllO\
lOl\
l
->
lOlO\
ll\
OlOO
)
{
lO\
ll\
lOlOll\

->
lOlOll\
OlOO
=
lOll\
lO\
lllO\

;
lOlll\
OlOll
->
lOlO\
llOOl\
l
|=
lOlOlOll\
l\
l
::
lOl\
OllO\
OOO\

;
}
}
}
lOllO\
lOOlO
.
lOlOllllOO\

.
lOl\
OlO\
O\
OO\
l\

(
lO\
lllO\
lOll
)
;
{
lOl\
lOlO\
l\
O\
l\

lOlO\
Ol\
O\
OlO\

=
lOllOl\
O\
OlO
.
lOlOllll\
OO
.
lOl\
OOOO\
lOO
(
)
;
for
(
;
!
lOl\
OOl\
O\
OlO
.
AtE\
nd\

(
)
;
)
{
lOlOlOllll
&
lOll\
Ol\
Oll\
O
=
*
lOlOOlO\
OlO\

;
++
lOl\
OO\
lO\
O\
l\
O
;
cons\
t
fl\
oat
lOl\
lOlO\
lll\

=
0.0001f
;
if
(
lO\
llOlO\
ll\
O\

.
lOlOl\
lOlO\
O\

>=
lOllOlOllO
.
lOlOllOlO\
l
-
lOllOl\
Olll
)
{
if
(
lOl\
llOlO\
ll
==
&
lOl\
lO\
lOllO
)
lOlllO\
lOl\
l
=
0
;
if\

(
lOllO\
lOllO
.
lO\
l\
OllOlll
)
{
TA\
_ASSE\
RT
(
lOl\
lOlOl\
lO
.
lOl\
OllOllO
)
;
lOll\
Ol\
Ol\
lO
.
lOl\
OllOll\
l
->
lOlO\
ll\
O\
ll\
l\

=
0
;
lOll\
O\
lOllO\

.
lOlO\
llOl\
lO
->
lOlOllllOO\

.
lO\
Olllllll
(
lO\
l\
l\
O\
lOl\
lO
.
lO\
lOllO\
l\
ll
)
;
lO\
lOllll\
ll
.
Fr\
ee
(
lOllOl\
Ol\
lO
.
lOlOl\
lOl\
ll\

)
;
lOll\
O\
l\
Ol\
l\
O
.
lOlOllOll\
l
=
0
;
}
lOllO\
l\
OOlO
.
lO\
lOll\
llOO
.
lOOlllll\
l\
l\

(
&
lOllOlOllO\

)
;
lOl\
Oll\
llll
.
Fr\
ee\

(
&
lOllO\
lOl\
lO
)
;
}
}
}
retu\
rn
lOlllOl\
Ol\
l
;
}
bo\
o\
l\

lOllOOlOOl
(
const
Vec3
&
lOlllOlll\
l
,
float
lOlll\
lO\
OOO\

,
cons\
t
Ve\
c3\

&
lOl\
lll\
OOO\
l
,
fl\
oa\
t
lOllllO\
Ol\
O
,
Vec3\

&
lOl\
l\
llOOll
,
Vec3
&
lO\
llllO\
lOO
)
{
Vec3
lOllOOlOOO
=
lO\
lll\
Ollll
.
Cr\
oss\

(
lOllllO\
OOl
)
;
float
lOllllO\
lOl
=
lOl\
l\
OO\
lOOO
.
Ge\
tM\
agnit\
u\
de
(
)
;
if
(
lOllllO\
lOl\

<
0.01f
)
return
fa\
lse
;
lOllOOlOOO
/=
lOllll\
OlO\
l
;
if\

(
!
lOll\
l\
Oll\
Ol\

(
lOll\
l\
Olll\
l\

*
lOllll\
OOOO
,
lOl\
lOOlO\
OO
.
Cross
(
lO\
ll\
lOllll
)
,
lOl\
ll\
lOOOl
*
lOl\
lllOOl\
O
,
lO\
ll\
OOl\
OOO\

.
Cross
(
lO\
llllO\
OOl
)
,
lO\
llllOOll\

)
)
ret\
urn
fa\
lse
;
lOl\
lllOlOO
=
lOll\
OO\
lO\
OO
;
re\
tur\
n
tr\
ue
;
}
bo\
o\
l\

sta\
tic
lO\
l\
llOllOl
(
co\
n\
st
Vec3\

&
lOll\
llOllO
,
const
Vec3
&
lO\
lll\
Ollll
,
const
Vec\
3
&
lOl\
lllOl\
ll
,
const
Ve\
c3
&
lOllll\
OOOl
,
Vec3
&
lOlllOllO\
O
)
{
con\
st\

floa\
t\

lOl\
lOlOlll
=
0.0001f
;
Vec3\

lOll\
lllO\
OO
=
lOlllO\
ll\
l\
l
.
Cro\
s\
s
(
lOl\
lll\
O\
OO\
l
)
;
Ve\
c3\

lOlllllO\
Ol
=
lO\
lllllOOO
.
Cross
(
lOllll\
OOO\
l
)
;
float
lOll\
ll\
l\
O\
lO
=
lOl\
lll\
l\
OOl
.
Dot
(
lOllllOll\
O
-
lOll\
llOlll
)
;
float
lO\
ll\
lllOll\

=
lOlllll\
OOl
.
Dot
(
lOl\
l\
llOl\
l\
O
+
lOlllO\
llll
-
lOll\
llOl\
l\
l
)
;
fl\
o\
a\
t
lOlll\
l\
llOO\

;
if\

(
Fab\
s\

(
lO\
lllllOll
-
lO\
llll\
lO\
lO
)
<
lOllOlOll\
l
)
re\
t\
ur\
n
fa\
l\
s\
e\

;
el\
s\
e\

lOlll\
lllOO
=
lOl\
ll\
llOl\
O
/
(
lOllll\
lOlO
-
lOl\
llllOl\
l
)
;
lOll\
lOl\
lOO
=
lO\
llllOl\
lO
+
lOll\
lOll\
l\
l\

*
lOlllll\
lOO
;
retu\
rn
true
;
}
}
;
st\
ruct\

Co\
nv\
exH\
ul\
l
::
lOllllllOl
{
boo\
l
lOlll\
l\
l\
ll\
O
;
bool
lOl\
l\
llll\
ll
;
bool
llOOOOOO\
OO
;
bool\

ll\
OOOOOOO\
l
;
int
ll\
OOOOOO\
lO
;
int\

llOOOOO\
Oll
;
int
ll\
OOOOOlOO
;
in\
t
llO\
OOO\
OlO\
l
;
int
llOOOOO\
llO
;
int\

llOOOOOll\
l
;
int
llOOOO\
lOO\
O
;
Ve\
c3
lO\
OOlOOOOO
;
static
int
TA\
C_CALL
llOOOOl\
OOl\

(
int\

lOOOlOOlll
)
{
re\
turn
(
lOOOlOO\
ll\
l
+
1
<
3
)
?
lOO\
O\
lO\
O\
lll\

+
1
:
0
;
}
st\
a\
t\
ic
in\
t
TAC\
_CALL
ll\
OOOO\
lOl\
O\

(
int
lOO\
OlOOlll
)
{
retu\
rn
(
lOO\
OlOO\
lll
-
1
>=
0
)
?
lOO\
O\
lOOl\
ll
-
1
:
2
;
}
int
&
llO\
OOOlOl\
l
(
int\

lO\
OOlO\
Oll\
l
)
{
re\
tu\
rn
(
&
llOOOOOOl\
l
)
[
lOOOlO\
Oll\
l
]
;
}
const\

in\
t
&
llOOOO\
lO\
ll
(
int
lOOOlOO\
lll
)
const\

{
re\
turn\

(
&
llOOO\
O\
O\
O\
l\
l
)
[
lOOOlOOlll\

]
;
}
int
&
ll\
OOOOllOO\

(
int
lO\
O\
OlOOlll
)
{
TA_AS\
S\
E\
RT
(
lOO\
O\
lO\
O\
lll
>=
0
&&
lOOOlOOl\
ll\

<
3
)
;
retu\
rn
(
&
llOOOOOl\
lO
)
[
lOOOlOOl\
l\
l
]
;
}
const\

int
&
llOOOO\
llOO
(
in\
t
lO\
OOlOOlll
)
const
{
TA\
_ASS\
ERT
(
lO\
OOlOOlll
>=
0
&&
lO\
OOlOOl\
ll\

<
3
)
;
return
(
&
ll\
OOOOOll\
O
)
[
lOOOlOOlll
]
;
}
int
llO\
O\
O\
OllOl\

(
int\

lOOO\
lOOl\
ll\

)
const
{
return
llOO\
OO\
lOll
(
lO\
OOlOOll\
l\

)
;
}
int\

llOOO\
O\
lllO
(
int
lOOOlOOl\
ll\

)
co\
n\
st
{
re\
turn
ll\
OOO\
Ol\
Ol\
l\

(
llOOOO\
lO\
Ol\

(
lOO\
OlO\
Olll
)
)
;
}
}
;
ConvexHu\
ll
::
Conve\
x\
Hu\
ll
(
)
{
llOO\
OOllll\

=
fal\
s\
e
;
}
Conv\
ex\
Hull
::
~
Conve\
xHull
(
)
{
Fin\
alis\
e
(
)
;
}
bo\
o\
l\

static
lOl\
llOllOl
(
con\
st
Vec3\

&
lOllllOl\
lO
,
co\
nst\

Vec\
3
&
lO\
ll\
lOllll
,
const\

Ve\
c3
&
lOllllO\
lll
,
const\

Ve\
c3\

&
lO\
llllOOO\
l
,
Vec\
3
&
lOl\
llOllOO
)
{
con\
st
float
lOll\
Ol\
Oll\
l\

=
0.0001f
;
Vec3
lOl\
ll\
ll\
O\
OO\

=
lOlllOllll
.
Cro\
ss
(
lOll\
l\
l\
OOOl\

)
;
Vec3\

lOll\
l\
llO\
Ol\

=
lOllll\
l\
O\
OO\

.
Cross
(
lO\
l\
l\
llOOOl
)
;
fl\
oat\

lOlllllOlO\

=
lO\
l\
llll\
OOl\

.
Dot
(
lO\
llllOl\
lO\

-
lOl\
l\
llOll\
l\

)
;
floa\
t
lOl\
llllOll
=
lOlllllOOl\

.
Dot
(
lOllllOl\
l\
O
+
lOl\
llOllll
-
lOllll\
Olll
)
;
flo\
at
lOllllllOO
;
if
(
Fabs\

(
lOlll\
llO\
ll
-
lOllll\
lO\
lO
)
<
lO\
llOlOlll
)
return
false
;
els\
e\

lOllllllO\
O
=
lOlll\
llOlO\

/
(
lOll\
ll\
l\
OlO\

-
lOl\
l\
ll\
l\
O\
ll\

)
;
lOlll\
O\
ll\
OO
=
lO\
llll\
Ol\
lO
+
lOll\
lO\
ll\
ll
*
lO\
ll\
lll\
lOO
;
return\

tru\
e\

;
}
bool
stati\
c
lOllOOlOOl\

(
const
Ve\
c3
&
lOlllOll\
l\
l
,
float
lOll\
l\
lOOO\
O\

,
co\
n\
st\

Vec3\

&
lO\
ll\
ll\
OOOl\

,
float
lO\
llllOOlO
,
Vec3\

&
lOllllOOll
,
Vec\
3
&
lOllllOlOO
)
{
Vec3\

lO\
llOO\
lOO\
O
=
lOll\
lOl\
lll
.
Cr\
oss
(
lOllllOOOl
)
;
float
lOllllOlO\
l\

=
lOllOOlOOO
.
Get\
Mag\
nit\
u\
de\

(
)
;
if
(
lO\
llllOlO\
l
<
0.01f
)
return
fa\
lse
;
lOll\
OOlOOO
/=
lO\
llllOlOl
;
if\

(
!
lOlll\
OllOl
(
lO\
lllOllll\

*
lO\
ll\
llOO\
OO
,
lO\
ll\
OOlOOO
.
Cross
(
lO\
lll\
O\
llll
)
,
lOlll\
lOO\
Ol
*
lOllllOOlO
,
lOllO\
OlOO\
O
.
Cross
(
lOllllOOO\
l
)
,
lOllll\
OO\
l\
l\

)
)
ret\
urn
false\

;
lOllllOl\
O\
O\

=
lOllOOlOOO
;
retur\
n
true\

;
}
struct
llOOOl\
OO\
OO\

;
str\
uct
llO\
OO\
l\
OOOl\

{
in\
t
llOOOlOOl\
O
;
int
ll\
OOOl\
OOll
;
llOO\
OlOOO\
O
*
ll\
OOOlOl\
O\
O
;
ll\
OO\
OlOOO\
O
*
lOlOll\
Ol\
lO
;
ll\
O\
OOlOOOl
*
ll\
O\
OOl\
OlOl
;
}
;
struct
ll\
OOO\
lO\
OO\
O
{
float
lOlOlll\
OOl\

;
boo\
l\

llOOOlO\
llO
;
bo\
ol
llOOOlOll\
l
;
int
lOO\
O\
lOOll\
l\

;
llOOO\
lO\
O\
OO
*
ll\
O\
OOll\
O\
OO
;
llOOO\
lOOO\
O
*
llOOOllOOl
;
lO\
lOll\
l\
Ol\
O
<
llO\
OOlOOOl
,
tr\
ue\

>
::
lOlOl\
ll\
Oll
ll\
OO\
OllO\
lO\

;
Vec3
lO\
OO\
lOOO\
OO
;
}
;
type\
de\
f
lOlOl\
ll\
OlO
<
llOO\
O\
lO\
OOO
,
tr\
ue
>
::
lO\
lOll\
lOl\
l
::
It\
erator
ll\
O\
OOllO\
ll
;
typedef
lOlOlllO\
l\
O
<
llOOOl\
OOO\
l
,
tr\
ue
>
::
lOl\
OlllOll
::
It\
e\
ra\
to\
r
llO\
OOlllOO
;
bool
ConvexH\
ull
::
Initi\
alise
(
const
Vec\
3
*
llOO\
Ol\
l\
lOl
,
int
llOOOl\
l\
llO
,
in\
t\

llOOOlllll\

)
{
float
ll\
OOlOOOOO
=
0.0f
;
fl\
oat\

ll\
O\
OlOOOOl
=
0.125f
;
RandF\
u\
nc
::
Ta\
RandSe\
ed
(
0
)
;
for
(
int
llOOlOOOlO
=
0
;
llOO\
lOO\
O\
lO\

<
20
;
llOOlOOOlO
++
)
{
if\

(
ll\
OOl\
OOOll
(
llOOOl\
ll\
Ol\

,
llOO\
OllllO\

,
ll\
OOO\
l\
llll
,
llOO\
lOO\
OOO
,
llO\
OlOO\
O\
Ol
)
)
{
re\
turn\

true
;
}
if
(
llO\
OOOll\
ll
)
{
llOOlO\
OOOO
+=
0.00002f
;
}
if
(
llOO\
lOOlOO
)
{
if
(
ll\
OOlOOO\
Ol\

==
0.0f
)
ll\
OO\
lOOO\
OO\

+=
0.00001f
;
ll\
O\
OlOOO\
O\
l
*=
0.75f
;
if\

(
ll\
OOlOO\
OO\
l\

<
0.001f
)
ll\
OOlOOOOl
=
0.0f
;
}
if\

(
!
llOOOO\
llll
&&
!
llOOl\
OOlOO\

)
{
return
false\

;
}
}
return
false
;
}
boo\
l\

ConvexHu\
ll
::
Initia\
li\
s\
e
(
const
Vec3
*
ll\
O\
OlOOlO\
l
,
const
Vec3
*
ll\
OOlO\
O\
llO
,
int\

llO\
Ol\
O\
O\
lll
)
{
lOlOlO\
lll\
O\

llOOlOl\
OO\
O
;
ll\
OO\
l\
Ol\
OOO
.
In\
itiali\
se
(
llOOlOOlll
)
;
fo\
r
(
int
llOOlOlOOl
=
0
;
ll\
O\
OlOl\
OOl
<
llOO\
lOOl\
l\
l\

;
llO\
Ol\
OlO\
Ol
++
)
{
TA\
_\
ASSER\
T
(
llOO\
l\
OO\
lOl
[
llOOlOlO\
Ol
]
.
IsNo\
rm\
alis\
ed
(
)
)
;
llOOlOlOOO
.
lOllOOOOO\
l
(
llOOlO\
OlOl\

[
llOO\
l\
OlO\
Ol
]
,
ll\
OOl\
O\
O\
lOl
[
llOOlOlO\
Ol
]
.
Do\
t
(
llO\
O\
lO\
OllO
[
llOOl\
OlOOl
]
)
,
true
)
;
}
return
Ini\
tiali\
se\

(
llOOlOlOOO\

)
;
}
vo\
id
Conv\
exHu\
ll
::
Finalis\
e
(
)
{
ll\
O\
O\
lOlOlO
.
Clear
(
)
;
llOO\
l\
O\
l\
Oll
.
Cle\
a\
r
(
)
;
llO\
O\
lOll\
OO
.
Cl\
ear
(
)
;
}
boo\
l\

Con\
vexH\
u\
l\
l
::
In\
itia\
lise\

(
lOl\
OlOl\
llO
&
llOO\
lOlOO\
O
)
{
if
(
!
llOOl\
Ol\
OOO
.
lOl\
lOOllOl
(
llOO\
l\
O\
l\
OlO\

,
llO\
Ol\
OlO\
ll
,
llOOlOllO\
O
)
)
return
fa\
lse
;
if
(
llOOlOl\
Oll
.
lOOO\
lllOOl
(
)
<
4
)
return
fals\
e
;
retu\
r\
n
tru\
e
;
}
bo\
ol\

Conv\
e\
xHu\
ll
::
llO\
O\
lO\
OOll
(
con\
st\

Ve\
c3
*
ll\
OO\
OlllO\
l
,
in\
t\

llOOOl\
ll\
lO
,
in\
t
llOOOlll\
l\
l\

,
fl\
oa\
t\

ll\
OO\
lOO\
OOO
,
fl\
oat
llOO\
lOOOOl
)
{
llOOO\
O\
llll
=
false
;
llOO\
lOO\
lO\
O\

=
fal\
se
;
lOlO\
l\
ll\
O\
l\
O
<
llOOO\
lOO\
OO
,
true\

>
llOO\
l\
Oll\
Ol
;
lO\
lOlllO\
lO
<
llOOOlOOOO
,
true
>
::
lOlOl\
llOll
llOOl\
OlllO
;
lOlOll\
lOl\
O\

<
llO\
OOlOO\
Ol
,
true\

>
llO\
OlOllll
;
ll\
OOlOllOl
.
Initial\
ise
(
llOOOll\
llO\

)
;
llOOlOl\
ll\
l
.
In\
i\
tiali\
se\

(
ll\
OO\
OllllO
)
;
float
llOOl\
lO\
OO\
O
=
1.0f
;
float
ll\
O\
OllO\
O\
Ol
=
1.0f
;
flo\
at
llOOllOOlO
=
0.0f
;
Ve\
c3
ll\
OO\
llOO\
ll
;
ll\
OOllOO\
ll\

.
Clear
(
)
;
floa\
t
llOO\
ll\
OlOO
=
0.0f
;
int
ll\
O\
Ol\
l\
OlOl
=
0
;
int\

ll\
OO\
llOllO
=
0
;
in\
t
llO\
OllO\
lll
=
-
1
;
{
if
(
llOO\
OllllO
<
3
)
{
lOO\
OlllOlO\

(
0
,
"ConvexHull::Initialise, Failed because number of points is less then 3")
;
}
in\
t
lOl\
ll\
OlOO\
O
;
fl\
oat\

llO\
Ol\
llOOO
=
0.0f
;
fo\
r
(
in\
t
lOOOll\
O\
OO\
l
=
0
;
lOO\
O\
l\
lOOOl\

<
3
;
lO\
OOll\
OOOl
++
)
{
in\
t\

llOOl\
ll\
O\
Ol
=
0
;
int
llO\
O\
lllOlO\

=
0
;
fl\
oa\
t
lOO\
O\
OOlOOO
=
llO\
OOlllOl
[
llOO\
ll\
lOOl
]
[
lO\
OOl\
lO\
OO\
l\

]
;
float\

lOOO\
O\
OlO\
O\
l
=
llOOOlll\
O\
l
[
llOO\
l\
llOlO\

]
[
lOOOl\
lO\
OOl
]
;
for
(
lOlllOlO\
OO
=
1
;
lOll\
lOlO\
OO
<
llOOOllllO
;
lOlllOlOOO\

++
)
{
if
(
lOOOOOlO\
O\
O
<
llOOOlll\
Ol
[
lOlll\
OlOO\
O
]
[
lOOOllOO\
Ol\

]
)
{
llOOll\
lOOl\

=
lO\
lll\
Ol\
O\
OO
;
lO\
OOOOlOOO
=
ll\
OOO\
lllOl
[
lOlllOl\
O\
O\
O
]
[
lOOOl\
lOOOl
]
;
}
if
(
lOOOOOlOO\
l\

>
llOOO\
lllOl
[
lOlllOl\
OOO
]
[
lO\
OO\
llO\
OOl\

]
)
{
llOOlllO\
lO\

=
lO\
lll\
O\
lOO\
O\

;
lOOOOOlO\
O\
l
=
llOOO\
l\
llOl
[
lO\
ll\
lOlO\
OO\

]
[
lOOOl\
l\
OOOl
]
;
}
}
if
(
llOOl\
ll\
O\
OO
<
lOOO\
O\
OlOOO
-
lO\
O\
OOOlOOl\

)
{
llOOll\
l\
OOO\

=
lOO\
OO\
Ol\
OOO\

-
lOOOOO\
l\
OOl
;
llOOll\
Ol\
Ol\

=
llOO\
lllOOl
;
llO\
Oll\
O\
llO
=
llOO\
ll\
lOlO
;
}
}
llO\
Oll\
O\
OO\
O\

=
llOOl\
l\
l\
OOO
;
Ve\
c3
lOOOlOOOOO
=
llOOOll\
lO\
l
[
ll\
OOllOl\
l\
O\

]
-
llOOOll\
lOl
[
ll\
O\
O\
llO\
lOl
]
;
floa\
t
lOlll\
lOlOl\

=
lOOO\
lOO\
OO\
O
.
Ge\
tMagni\
tu\
de
(
)
;
if\

(
lOlll\
l\
O\
lO\
l
<=
k_f\
Mi\
nFlo\
a\
t
)
{
lOO\
O\
lllO\
lO
(
0
,
"ConvexHull::Initialise, Failed because hull is too small")
;
return
fa\
lse
;
}
TA_ASS\
ERT\

(
ll\
OOllOlOl
!=
llOOl\
lO\
llO
)
;
lOO\
O\
lOO\
OOO
/=
lO\
ll\
ll\
Ol\
Ol
;
flo\
at
lOOOOOl\
OOO
=
0.0f
;
for
(
lOl\
ll\
OlOOO
=
0
;
lOlllOlOOO
<
llOOOlll\
lO\

;
lOl\
llOlOOO
++
)
{
fl\
oat\

lOl\
Oll\
lO\
Ol
=
lOOOlO\
OO\
OO
.
Cro\
ss
(
ll\
O\
O\
O\
lll\
Ol
[
llOO\
l\
lOlOl
]
-
llOO\
O\
ll\
lOl
[
lO\
l\
llOlOOO\

]
)
.
Get\
Magnit\
ude\
Sqrd\

(
)
;
if
(
lOOO\
OOl\
OO\
O
<
lOlOlllOOl
)
{
lOO\
OOOlOOO
=
lOlO\
lllOOl
;
llO\
Oll\
O\
ll\
l
=
lO\
lll\
O\
lOO\
O
;
}
}
if
(
llOO\
llOll\
l
==
-
1
||
llO\
OllO\
lll\

==
llOOllOlOl\

||
llOOllOlll
==
llO\
Oll\
OllO
)
{
lOOOl\
llOl\
O
(
0
,
"ConvexHull::Initialise, Failed because hull is too small or narrow")
;
return
fa\
ls\
e\

;
}
Ve\
c3\

llOOlllOll\

=
(
llOO\
Ol\
l\
lOl
[
ll\
OOl\
lOllO
]
-
llO\
O\
OlllOl
[
llOOllO\
lOl
]
)
.
Cross
(
llOOOlllOl
[
ll\
OOllO\
lll
]
-
llOOOlllO\
l
[
llO\
OllO\
lOl
]
)
;
lOlll\
lOl\
Ol
=
llOOlllOll
.
GetM\
agnitude
(
)
;
if
(
lOllllOl\
O\
l
<=
k_fMinF\
l\
oat\

)
{
lO\
O\
O\
lllOlO\

(
0
,
"ConvexHull::Initialise, Failed because hull is too small or narrow")
;
retu\
rn
false
;
}
llOO\
lllOll
/=
lOlll\
l\
OlOl
;
if
(
lOOO\
O\
Ol\
OOO
<
(
llO\
O\
llO\
O\
O\
O
*
ll\
O\
OllOOOO\

)
*
(
0.04f
*
0.04f
)
)
{
lOOO\
lllO\
lO
(
0
,
"ConvexHull::Initialise, Failed because hull is too small or narrow")
;
return\

false\

;
}
{
fl\
oa\
t
lO\
OOO\
OlO\
OO\

=
llOOO\
lllOl
[
0
]
.
Dot\

(
llO\
O\
lllOl\
l
)
;
fl\
oat\

lOOOOOlO\
O\
l\

=
lOOO\
OO\
lOOO
;
fo\
r
(
lOlll\
O\
lO\
OO
=
1
;
lOlll\
OlOO\
O\

<
llO\
OOllllO
;
lO\
lllO\
lOOO
++
)
{
float
lOlllOlllO
=
llO\
OOlllOl
[
lO\
ll\
lOlOOO\

]
.
Dot\

(
ll\
OOll\
lOll
)
;
if
(
lOOOOOlOOO\

<
lOlllOlll\
O\

)
lOOOO\
OlOOO
=
lOlllOlll\
O
;
if
(
lOO\
O\
OOl\
OOl\

>
lOlllO\
ll\
lO
)
lO\
O\
O\
OOl\
OO\
l
=
lOlllOlllO
;
}
flo\
at
ll\
OO\
llllOO
=
lO\
OO\
O\
O\
lOOO
-
lO\
O\
OO\
OlO\
Ol
;
if
(
ll\
OOll\
llOO
<
llOOl\
lOOO\
O
*
0.1f
)
{
llOOllOOOl\

=
(
llO\
Oll\
l\
lOO
/
llOOllOOOO
*
10.0f
)
;
if\

(
llO\
OllOOOl\

<
0.01f
)
llO\
O\
ll\
OlO\
O\

=
-
llOOll\
OOOO
*
0.00001f
;
if\

(
llOOllO\
OO\
l\

<
0.75f
)
{
ll\
OOllOOlO
=
(
llOO\
ll\
OOOO
*
0.075f
-
llOOl\
lllOO
)
*
0.25f
;
}
if
(
llO\
Ol\
lOO\
Ol\

<
0.5f
)
llO\
O\
llOO\
Ol
=
0.5f
;
}
}
llOOllOO\
ll
=
llOOlllO\
ll
;
}
lOOOOlOl\
lO
<
Vec3\

>
lOl\
l\
OlOO\
OO
;
lOOOOlOl\
lO
<
u3\
2
>
llOOllll\
O\
l
;
if
(
llOOllOO\
l\
O
!=
0
)
{
llO\
OllllOl
.
Initia\
li\
se\

(
llO\
OOllllO
*
2
,
ll\
OOOl\
lll\
O
*
2
)
;
lOll\
O\
lOOOO
.
Ini\
tiali\
se
(
0
,
llOOO\
l\
l\
llO
*
2
)
;
fo\
r
(
int
lOlllOlOO\
O
=
0
;
lOl\
l\
lOlO\
O\
O
<
llOOOllllO
;
lO\
lllOlOOO
++
)
{
Vec3
llO\
O\
lllllO\

=
llOOOll\
lOl\

[
lOll\
lOlOOO
]
;
if
(
llOOlO\
OOO\
O
!=
0.0f
)
{
ll\
OOlllllO
.
x
+=
Ra\
n\
dFu\
nc
::
Ta\
RandBetwee\
nPos\
N\
eg
(
llOOlOOOOO
*
ll\
OO\
llOOOO
)
;
llOO\
ll\
lll\
O
.
y
+=
RandFun\
c
::
TaR\
andBetwe\
e\
nPosNeg
(
llO\
O\
lO\
OOOO
*
llOOll\
OOO\
O\

)
;
llOOll\
lll\
O
.
z
+=
Rand\
F\
unc
::
TaRandBet\
weenPo\
sNeg
(
llOOlOOOOO\

*
llOOll\
O\
O\
OO\

)
;
}
lOl\
lOl\
OO\
O\
O\

.
lOOOll\
lOO\
O
(
llOO\
l\
lll\
lO
-
llOOllO\
OlO\

*
0.5f
*
ll\
O\
Ol\
lOOll
)
;
lOllO\
l\
OOO\
O
.
lO\
O\
OlllOOO
(
ll\
OOll\
lllO
+
llOOllOO\
l\
O
*
0.5f
*
llOOllOOll
)
;
}
}
else
{
llOO\
ll\
l\
lOl
.
In\
i\
t\
ial\
i\
se\

(
ll\
OOO\
l\
lll\
O
,
llO\
OOllllO
)
;
lOllOl\
OOOO\

.
In\
iti\
a\
lise
(
0
,
llO\
OO\
l\
ll\
lO\

)
;
for
(
int
lOlllOlOOO
=
0
;
lO\
lllOlOOO
<
ll\
OOOllllO\

;
lOlllOlOOO
++
)
{
lOll\
OlO\
OO\
O
.
lO\
O\
O\
lllOOO
(
ll\
OOO\
l\
l\
lO\
l
[
lOlllOlOO\
O
]
)
;
}
if
(
llOOl\
OOOOO
!=
0.0f
)
{
for
(
int
lO\
l\
ll\
OlO\
OO
=
0
;
lOl\
l\
lOlOOO
<
llOO\
Ollll\
O
;
lOll\
l\
O\
lOOO
++
)
{
Vec3
&
llO\
Olllll\
O\

=
lOllO\
lO\
OOO
[
lOll\
lOlO\
OO
]
;
ll\
OOll\
lllO
.
x
+=
Rand\
F\
unc
::
TaRand\
BetweenPosNeg
(
llOOlO\
OOO\
O
*
llO\
Ol\
lO\
OOO
)
;
ll\
OO\
l\
lll\
l\
O
.
y
+=
Ra\
ndFunc
::
Ta\
Rand\
Bet\
we\
enP\
o\
sNe\
g
(
llO\
OlOOOOO
*
llOOll\
OO\
O\
O
)
;
llOO\
ll\
lllO\

.
z
+=
Ra\
nd\
Fu\
nc
::
TaRa\
nd\
BetweenPosN\
eg
(
llOOlOOOOO
*
llOOl\
l\
OOOO
)
;
}
}
}
llOOlll\
lOl
.
lO\
Ollll\
O\
l\
O
(
)
;
llOOlll\
lOl\

[
llOOllO\
l\
O\
l
]
=
1
;
llOOlll\
lOl
[
ll\
OOllOllO
]
=
1
;
llOOllllOl
[
ll\
OOll\
O\
lll
]
=
1
;
{
llOOOlOOO\
O
*
ll\
OOllllll
=
llO\
O\
lO\
l\
l\
Ol
.
Al\
loc\

(
)
;
llO\
OOlOOOO
*
llOlO\
OO\
OOO
=
ll\
OOl\
O\
ll\
Ol
.
Alloc
(
)
;
ll\
O\
Ol\
Ol\
llO\

.
lOl\
OlOOOOl
(
llO\
Ol\
l\
l\
l\
ll
)
;
llO\
Ol\
O\
ll\
l\
O
.
lOl\
O\
lOOOOl
(
llOl\
OOO\
OOO\

)
;
llO\
OOlOO\
Ol
*
llOlO\
OO\
OO\
l\

=
llOOlOll\
ll
.
Allo\
c
(
)
;
llOOOlO\
OOl\

*
llOlO\
O\
OO\
l\
O\

=
llOO\
l\
Oll\
ll
.
Alloc
(
)
;
ll\
O\
OOlO\
O\
Ol
*
llOlOOOO\
ll
=
llOOl\
Ollll
.
All\
oc
(
)
;
llOO\
ll\
ll\
ll
->
llOOOl\
lOlO
.
lOl\
OlOO\
O\
Ol
(
llOl\
OO\
OOOl\

)
;
llO\
O\
ll\
ll\
ll\

->
llO\
OOl\
l\
OlO
.
lOlOlOO\
OOl
(
llOlOOOOlO\

)
;
llOOl\
lll\
ll
->
llOOOllOlO\

.
lOl\
OlO\
OOOl
(
llO\
lO\
OOOll\

)
;
llOlO\
OO\
OOl
->
llOO\
OlOl\
O\
O\

=
ll\
OO\
l\
l\
llll
;
ll\
OlOOOOlO
->
llO\
OO\
lO\
l\
OO
=
llOO\
lllll\
l\

;
llOl\
O\
OO\
Ol\
l
->
llOOOl\
Ol\
OO
=
ll\
OOlllll\
l
;
llOOOlOOOl
*
ll\
O\
l\
OOOlO\
O\

=
llOO\
lO\
llll
.
All\
oc
(
)
;
llOOOlOOOl
*
llO\
lOO\
OlO\
l
=
ll\
OO\
l\
Ollll
.
Allo\
c
(
)
;
llO\
OOlO\
OOl\

*
llOlOO\
Oll\
O\

=
llO\
OlOl\
lll
.
All\
o\
c\

(
)
;
ll\
OlO\
OOOOO
->
llOO\
Ol\
lO\
lO\

.
lO\
lOlOOOO\
l\

(
llOlOOOlO\
O
)
;
llOlOOOO\
OO
->
llOOOllO\
lO
.
lO\
l\
O\
l\
OOOOl
(
llOlOOOl\
Ol
)
;
llOlO\
O\
OOO\
O\

->
ll\
OOOll\
OlO
.
lOlO\
lO\
OO\
Ol
(
ll\
O\
l\
OOOl\
l\
O
)
;
llOlO\
OO\
lOO\

->
llO\
OOlOlOO
=
llOlOOOOOO
;
ll\
Ol\
OOO\
lOl\

->
llOO\
O\
lOlO\
O
=
llOlOOO\
OO\
O
;
llOlOO\
OllO
->
llO\
OO\
lOl\
OO
=
ll\
Ol\
OOOO\
OO
;
llOlOOO\
OOl\

->
llOOOl\
OOlO
=
llOOllOl\
Ol
;
llOl\
O\
OOOOl\

->
ll\
O\
OOlOO\
ll
=
llOOllOllO\

;
llOlO\
OOO\
Ol
->
llOOOlOlOl
=
ll\
O\
lOOOll\
O\

;
llO\
l\
O\
OOO\
Ol
->
lOlOllO\
llO\

=
llOlOOOO\
O\
O
;
llOlOO\
OO\
lO\

->
llOO\
OlOOlO
=
llOOllO\
llO
;
llO\
l\
OOO\
Ol\
O
->
ll\
OOOlOOl\
l\

=
llOOll\
Ol\
l\
l
;
ll\
O\
lO\
OOOlO\

->
llO\
OOlO\
lO\
l
=
ll\
OlOOOlOl
;
llO\
lO\
OOOlO\

->
lOlOllO\
ll\
O
=
ll\
O\
l\
O\
OO\
OOO
;
llOlOOOOll
->
llOO\
O\
l\
O\
O\
lO
=
ll\
OOll\
Olll
;
llOlOO\
OOll\

->
llOOO\
l\
OOll\

=
llOOllOlOl
;
llOlO\
OO\
O\
ll\

->
llOOOlOlO\
l
=
llOl\
OOOlO\
O\

;
llOl\
OO\
O\
Oll
->
lOl\
O\
llOllO
=
llOl\
OO\
OO\
O\
O
;
llOOllllll\

->
lOOOlOO\
OO\
O\

=
(
lOll\
Ol\
OOO\
O
[
llOOll\
O\
l\
ll
]
-
lO\
llOl\
OO\
OO
[
llOOllOlOl
]
)
.
Cross
(
lO\
llOlOOO\
O
[
llO\
Oll\
O\
llO
]
-
lOllOl\
OOO\
O
[
llOOllOlO\
l
]
)
;
llO\
O\
ll\
llll
->
lOOOlOOOOO
.
Nor\
m\
alise
(
)
;
llOOllll\
ll
->
lO\
lO\
lllOOl
=
llOOl\
lllll\

->
lOOOl\
O\
OOOO
.
Do\
t
(
lO\
llO\
lOOO\
O\

[
ll\
OOllO\
lOl\

]
)
;
llO\
O\
l\
lllll
->
ll\
OO\
O\
l\
OllO\

=
fa\
lse
;
llOOl\
llll\
l
->
ll\
OOOlOll\
l\

=
fals\
e\

;
llOO\
llllll
->
lOOOl\
OOll\
l
=
0
;
ll\
OO\
ll\
llll
->
llOO\
O\
ll\
OOO
=
0
;
llOOl\
lllll
->
llOOOllOOl
=
0
;
llOlO\
OOl\
lO
->
llOOO\
lOO\
ll
=
llOO\
ll\
O\
lOl
;
ll\
O\
lOOOllO\

->
llOOOl\
OOl\
O\

=
llOOll\
Oll\
O\

;
llOlOO\
OllO
->
ll\
OOOlOlOl
=
ll\
O\
lO\
O\
O\
OO\
l
;
llOlOOOl\
lO
->
lO\
lO\
llOllO
=
ll\
OOll\
l\
l\
l\
l
;
ll\
O\
lOOOlOl
->
llOOO\
lOOll
=
ll\
OOl\
lOl\
lO
;
ll\
O\
lOOOlO\
l
->
llO\
OOl\
OO\
lO\

=
llO\
OllO\
lll
;
llOl\
OOOlOl
->
ll\
OOOl\
O\
l\
Ol
=
llOl\
O\
O\
OO\
l\
O
;
llOlOOO\
l\
Ol
->
lO\
lOl\
lOllO
=
llOOl\
lll\
ll
;
llOlOOOlOO\

->
llOOOlOOll\

=
llOOllOlll
;
llOl\
OOO\
lOO
->
llOOOl\
OOlO\

=
llOOllOl\
Ol
;
llOlOO\
OlO\
O
->
llOOOlOlO\
l
=
llOlOOOOll
;
llOlOOOlO\
O\

->
lO\
lO\
ll\
OllO
=
llO\
Olllll\
l
;
ll\
Ol\
OOOOOO\

->
lOOO\
lO\
OOOO
=
-
ll\
OOllllll
->
lOOOlO\
OOO\
O
;
llO\
lOOOO\
OO\

->
lOOOlOOOOO
.
No\
rmalise
(
)
;
llO\
lO\
OOOOO
->
lO\
lO\
lllOO\
l
=
llOlOO\
OOOO\

->
lO\
OO\
lOOOOO
.
Dot
(
lOllO\
lOOOO\

[
llOOl\
lOlO\
l
]
)
;
llOlOOOO\
O\
O
->
llOO\
O\
lOllO
=
fals\
e
;
llOlO\
OO\
OO\
O
->
ll\
OO\
OlOl\
ll
=
fals\
e
;
llOlO\
O\
O\
OOO
->
lOOOl\
OO\
ll\
l
=
0
;
llOlOO\
O\
O\
OO
->
llOOO\
ll\
OOO
=
0
;
llOlOOOO\
O\
O\

->
llOO\
OllO\
Ol\

=
0
;
}
lOOO\
OlO\
llO
<
llO\
O\
OlOO\
OO
*
>
ll\
OlOO\
Olll\

;
lO\
O\
OO\
l\
Ol\
lO
<
ll\
O\
OOlO\
OOO\

*
>
llOlO\
Ol\
OOO
;
llOlO\
OOlll
.
Initiali\
s\
e
(
0
,
64
)
;
llOlOOlOOO\

.
Init\
i\
ali\
se
(
0
,
64
)
;
lOOOOlO\
l\
lO
<
llOOOlO\
O\
Ol
*
>
llO\
lOOlOO\
l\

;
llOl\
OO\
lOOl
.
Ini\
tialise\

(
0
,
64
)
;
co\
nst
fl\
oa\
t\

llOlOOl\
O\
lO\

=
0.025f
*
llO\
OllOOOO\

*
llO\
OllO\
OOl\

;
bo\
o\
l
ll\
OlOO\
lOl\
l\

=
true
;
wh\
ile
(
llOlOOlOll
)
{
llOlOOlOll\

=
false\

;
for
(
llOOO\
llOll
llOlOOllO\
O
=
llOOlO\
l\
llO
.
lOl\
O\
OOO\
lOO
(
)
;
!
ll\
OlOO\
llOO\

.
AtEn\
d\

(
)
;
)
{
llO\
OO\
l\
OOOO
&
llOlO\
OllOl
=
*
ll\
OlOOll\
O\
O\

;
++
llOlO\
OllOO
;
int
ll\
O\
lOO\
l\
llO
=
-
1
;
{
llOO\
OlOOO\
O
&
lOl\
lOOO\
lOl
=
llO\
lOOllOl
;
if
(
lOll\
OOOlOl\

.
ll\
O\
O\
OlOllO
)
co\
nti\
n\
ue
;
TA\
_\
ASS\
E\
RT
(
!
lO\
llOO\
OlOl
.
llOO\
OlO\
l\
ll
)
;
float
lO\
OOOO\
lOO\
O
=
llOl\
OO\
l\
OlO\

;
for
(
in\
t
lOlllO\
lOOO
=
0
;
lO\
ll\
lO\
lOOO
<
lOllO\
lOOOO
.
lOOOlllOOl
(
)
;
lOl\
ll\
OlOO\
O
++
)
{
if
(
llO\
OllllOl
[
lOl\
llOlOOO
]
)
conti\
nue\

;
cons\
t\

Vec3\

&
llOOllll\
lO
=
lO\
ll\
OlOOO\
O
[
lOlllOl\
O\
O\
O
]
;
fl\
oa\
t
lOlOll\
lOOl
=
lOllOOOlOl
.
lOO\
OlOO\
O\
O\
O
.
Dot
(
llOOl\
lll\
lO\

)
-
lOllO\
OOl\
Ol\

.
lOlOlllO\
Ol
;
if
(
lOOOO\
Ol\
OO\
O\

<
lOlOlllO\
Ol
)
{
lOOOOOlOO\
O
=
lOl\
OlllOOl\

;
llOl\
OO\
lllO
=
lO\
lllOlOOO\

;
}
}
if
(
llOlO\
O\
ll\
lO\

==
-
1
)
{
lOllO\
OOlOl
.
llOOO\
lOll\
O
=
true
;
cont\
inue
;
}
llOlO\
OlOll
=
true
;
llOOllllO\
l\

[
ll\
O\
l\
OOl\
l\
l\
O\

]
=
1
;
}
Vec3
&
llOOlllllO
=
lOllOlO\
OO\
O
[
llOlOOlllO
]
;
llOlO\
OO\
lll
.
Clear
(
)
;
llOl\
OOlOOO
.
Clear
(
)
;
lOOOOl\
O\
llO
<
llOOOlO\
OOO
*
>
*
llOl\
OOl\
ll\
l\

=
&
llOlOOOlll
;
lOO\
O\
OlO\
llO
<
ll\
OOOl\
OOOO
*
>
*
llOlOlOOOO
=
&
llOlOOlOO\
O
;
ll\
OlO\
Oll\
l\
l\

->
lOO\
OlllOO\
O
(
&
llOlOOllO\
l
)
;
llOlO\
OlOO\
l
.
Clear\

(
)
;
while\

(
llO\
lOOllll
->
lO\
OOlllO\
Ol
(
)
>
0
)
{
for\

(
int\

lOOO\
l\
l\
OO\
Ol
=
0
;
lOOOllOO\
Ol
<
llO\
lOOll\
l\
l
->
lOOOll\
lOOl
(
)
;
lOO\
OllOOOl
++
)
{
llOOO\
lOOOO\

*
llOOOlO\
lOO
=
(
*
llOl\
O\
Olll\
l\

)
[
lOOOll\
OO\
O\
l\

]
;
for\

(
llO\
OOlllOO
llOlOlOOO\
l
=
llOOOlOlO\
O
->
llOOO\
llO\
lO
.
lOlOOOOlOO
(
)
;
!
llOlOlOOOl
.
AtEnd
(
)
;
++
llOlOlOOOl\

)
{
ll\
OOOlO\
O\
Ol\

&
llOlOlOOl\
O\

=
*
llOlOlOOOl
;
TA_ASSE\
RT
(
llO\
lOlO\
Ol\
O\

.
llO\
OOlOlOO\

==
llO\
OOlOl\
OO
)
;
if\

(
llO\
l\
Ol\
O\
OlO
.
lOlOllOllO\

)
{
TA_ASSER\
T
(
llOlOlOOlO\

.
llOO\
O\
lOl\
Ol
)
;
TA_\
ASSE\
RT
(
llOlO\
lOOlO
.
ll\
OO\
OlO\
l\
Ol\

->
lO\
l\
O\
l\
lOllO
)
;
TA_AS\
SER\
T
(
llO\
lO\
lOOlO
.
llO\
OO\
l\
OlOl
->
lO\
lOllO\
ll\
O
==
ll\
OOOlOlOO
)
;
TA_\
ASSE\
RT
(
ll\
O\
lO\
lOOlO
.
ll\
OOOlO\
lOl
->
llOOOlOlOl
)
;
TA_ASSER\
T
(
llO\
l\
O\
lOOlO\

.
llOOOlO\
lOl
->
llOOOlOlOl
==
&
llO\
lOl\
O\
OlO
)
;
TA\
_ASS\
E\
R\
T
(
llOlO\
l\
O\
Ol\
O
.
ll\
O\
O\
OlO\
OlO
==
ll\
OlOl\
OOlO\

.
llOOOlOlOl
->
ll\
OOO\
lO\
Ol\
l
)
;
TA_\
ASSERT
(
ll\
OlO\
lOOl\
O
.
llOOO\
l\
O\
Ol\
l\

==
llOl\
OlOOlO\

.
llOOOlOl\
O\
l\

->
ll\
OOOlOO\
lO
)
;
if
(
llOlOlOOlO
.
lOlOl\
lOllO\

->
lOOO\
lOOOOO
.
Do\
t
(
llOOll\
l\
l\
lO
)
-
llO\
l\
OlO\
O\
l\
O\

.
lOlO\
l\
lOllO
->
lO\
lO\
lll\
OOl
>
llOOllOlOO
)
{
if
(
!
llOl\
O\
lO\
OlO\

.
lOlOllOl\
l\
O
->
llOOO\
lOlll
)
{
ll\
Ol\
OlOO\
OO
->
lO\
OOlllOOO
(
ll\
OlOlOOlO
.
lOl\
O\
ll\
O\
llO
)
;
llOlOl\
OOl\
O
.
lOl\
OllOllO
->
ll\
OOOlOll\
l\

=
true
;
}
}
el\
se
{
llOl\
OOlOOl
.
lOOOlllOO\
O
(
ll\
O\
lOl\
OOlO\

.
llOOOlO\
lOl
)
;
}
llOlOlO\
O\
lO
.
ll\
O\
OOlOlOl\

->
lO\
lOllOll\
O
=
0
;
llOlOl\
O\
OlO
.
llOOO\
l\
OlO\
l\

->
ll\
O\
OOlOlOl
=
0
;
}
else
{
TA_A\
SS\
ERT\

(
llOlOlOOlO
.
llOOOlO\
lO\
l
==
0
)
;
}
llOlOlO\
O\
l\
O\

.
llOOOlOl\
OO
=
0
;
}
llO\
Ol\
Ollll
.
ll\
OlOl\
OOll
(
ll\
OO\
O\
lOlOO
->
ll\
OOOl\
l\
O\
lO
)
;
if
(
&
(
*
llOlOOllO\
O
)
==
llOO\
Ol\
O\
lOO
)
{
if
(
!
ll\
OlO\
O\
l\
lO\
O\

.
AtEnd
(
)
)
++
ll\
OlO\
OllOO
;
}
llO\
O\
lO\
ll\
lO
.
lOOll\
lll\
ll
(
ll\
O\
OOlO\
lOO\

)
;
llO\
OlO\
ll\
Ol
.
Free
(
ll\
OOO\
lO\
lO\
O
)
;
}
llOlOOllll
->
Cle\
ar\

(
)
;
Swap\

(
llO\
lOO\
llll
,
llOlOlOOOO
)
;
}
ll\
OlOOOlll
.
Clear
(
)
;
llO\
lO\
OlOOO
.
Clear
(
)
;
lOOOOlOl\
l\
O\

<
ll\
OO\
OlOOO\
O
*
>
&
llOlOl\
OlO\
O
=
llOl\
OOOlll\

;
lOOO\
OlO\
llO
<
llOOOlO\
O\
O\
O
*
>
&
ll\
OlOlOlOl
=
ll\
O\
lOOlOO\
O
;
{
for
(
int\

llOlOlOl\
lO
=
0
;
llOlOlOllO\

<
llOlOO\
lOOl
.
lOOOll\
lOOl
(
)
;
llOlOlOl\
lO
++
)
{
ll\
O\
OOlOOOl
&
llOlOl\
OOlO
=
*
ll\
O\
lO\
Ol\
OOl
[
ll\
OlOlOl\
lO
]
;
TA\
_AS\
SERT
(
llO\
lOlOOlO\

.
llO\
O\
OlOlO\
O
)
;
TA_ASS\
ERT
(
!
llOlO\
lO\
OlO
.
lOlO\
llOllO
)
;
TA\
_ASSER\
T
(
!
ll\
OlOlOO\
lO\

.
llOOOl\
OlOl
)
;
{
ll\
Ol\
OlOlOl
.
lO\
OO\
ll\
lOOO
(
llO\
l\
OlOOlO
.
llOOOlOl\
OO
)
;
llOOOlO\
OOO
*
llOOOlO\
l\
OO
=
llOOlO\
ll\
Ol\

.
Al\
lo\
c
(
)
;
llOOlO\
l\
ll\
O
.
lOlOlOOOO\
l
(
llO\
O\
Ol\
OlOO
)
;
llOOOlOlOO
->
llOOO\
lOllO
=
false
;
llOO\
OlOlOO
->
lOOOlO\
O\
lll
=
0
;
llOOOlOlOO
->
ll\
OOOlO\
lll\

=
fa\
lse
;
ll\
OOO\
lOlOO
->
ll\
O\
OOll\
OOO
=
0
;
ll\
OOO\
lOlOO
->
llOOO\
llOO\
l
=
0
;
ll\
OOO\
l\
O\
OOl
*
llOl\
OlO\
lll
=
llO\
O\
l\
Ollll
.
Al\
l\
oc
(
)
;
ll\
OOOlOO\
Ol
*
llO\
lOllO\
OO
=
llOOlO\
ll\
l\
l
.
Alloc
(
)
;
llOOOlOOOl
*
llOlO\
llOOl
=
llOOlO\
llll
.
Allo\
c
(
)
;
llOOO\
lOlOO
->
llOOOllOlO
.
lOlOlO\
OO\
Ol
(
llOlOlO\
lll\

)
;
ll\
O\
OO\
lOlO\
O
->
llOOOll\
OlO
.
lOlOl\
O\
OO\
O\
l
(
llOlOll\
O\
OO
)
;
ll\
OOOlO\
l\
OO
->
llOOO\
l\
lOl\
O
.
lOlO\
lOOOO\
l\

(
llOlO\
llOOl
)
;
llO\
lOlOl\
ll\

->
ll\
OOOlO\
lOO
=
llOO\
Ol\
O\
lOO
;
llOlO\
ll\
OO\
O\

->
llOOOlOlOO
=
llOOO\
lOlOO\

;
llOl\
OllOO\
l
->
llOO\
OlOl\
OO
=
llO\
OOl\
OlO\
O
;
int\

ll\
OOllOlOl
=
llOl\
OOlllO
;
int
llOO\
llOllO
=
llOlO\
lOO\
lO\

.
llOO\
Ol\
OOll
;
int
ll\
O\
O\
ll\
Ol\
ll
=
llO\
lOlOO\
lO
.
ll\
O\
OOlOOl\
O\

;
llO\
lO\
lOl\
l\
l\

->
llOOOlOOlO\

=
ll\
OOl\
lO\
l\
Ol\

;
llOlO\
lOl\
l\
l
->
llOOOlO\
Oll\

=
ll\
OOl\
lOllO\

;
llOlO\
lOl\
ll
->
lOlO\
l\
l\
OllO
=
0
;
llOl\
OlOlll\

->
llO\
O\
OlO\
l\
O\
l
=
0
;
llOlOllOO\
O
->
llO\
OO\
lOOlO
=
ll\
OOl\
l\
OllO
;
ll\
OlOllO\
OO
->
llOOOlOOll
=
llOOll\
Olll
;
ll\
OlOllOOO
->
lOlO\
l\
lO\
l\
lO
=
llOlOlO\
OlO
.
llOOO\
lOlOO
;
llOl\
OllO\
O\
O
->
llOO\
Ol\
OlOl
=
&
llO\
lO\
l\
OO\
lO
;
llO\
lOllOOl
->
ll\
OOOlOOl\
O
=
llO\
OllOlll
;
llO\
lO\
llOOl
->
ll\
OOOlOO\
ll\

=
llOOl\
lOlO\
l
;
llOlOll\
OOl\

->
lOlOl\
l\
OllO\

=
0
;
llO\
lOl\
lOO\
l
->
llOOOl\
OlOl
=
0
;
ll\
OO\
OlO\
lOO
->
lO\
OOl\
OOO\
OO
=
(
lO\
l\
l\
OlOOOO\

[
llO\
O\
llOlll\

]
-
lOllO\
l\
OOO\
O
[
llOOll\
Ol\
Ol
]
)
.
Cr\
o\
ss
(
lO\
l\
lOl\
OO\
OO
[
llOOll\
OllO\

]
-
lO\
l\
l\
OlOO\
OO
[
llOO\
l\
lOlOl
]
)
;
llOOOl\
O\
l\
OO
->
lOOOlOOO\
OO
.
Normalise
(
)
;
llOOOlO\
l\
OO\

->
lO\
lOl\
llOOl
=
llOO\
Ol\
Ol\
OO\

->
lOO\
OlO\
OOO\
O\

.
Dot
(
lOl\
lOlO\
OOO
[
llO\
O\
llOlOl
]
)
;
llO\
lOlO\
OlO
.
ll\
OOOl\
Ol\
Ol
=
llO\
lOl\
lOOO
;
ll\
OlO\
lOOlO
.
lO\
lOllOllO
=
llOOOlOl\
OO
;
llOlOlOlOO
.
lOO\
OlllOO\
O
(
llOOO\
lOlOO
)
;
TA_A\
SSERT
(
llOlOlO\
OlO\

.
llO\
OOl\
O\
O\
lO\

==
llOlOlOOlO
.
llOOO\
l\
OlOl
->
llOOOl\
OO\
ll
)
;
TA_A\
SS\
ERT
(
ll\
O\
lOl\
OO\
l\
O
.
llOOOlOOl\
l
==
llOlOlOO\
l\
O
.
ll\
OOOlO\
lOl
->
llO\
OOlOO\
lO
)
;
}
}
}
for
(
int\

llOl\
OllOlO
=
0
;
llOlOll\
OlO
<
ll\
OlO\
lOlOO
.
lOOO\
l\
llO\
Ol
(
)
;
ll\
O\
lOllOlO
++
)
{
llOOOlOOOO
&
lOll\
OlOO\
lO
=
*
llOlOlOlOO\

[
ll\
Ol\
Ol\
lOlO
]
;
for
(
int
llOl\
Oll\
O\
ll
=
llOlOllOlO\

;
ll\
OlOl\
lO\
ll
<
llOl\
OlOlOO
.
lOOOlllO\
O\
l
(
)
;
ll\
OlOllO\
l\
l\

++
)
{
ll\
OOOlOOO\
O\

&
lO\
llO\
l\
OlOO\

=
*
llOlOlOlOO\

[
llOl\
OllOll
]
;
fo\
r\

(
ll\
OOOlllOO\

llOl\
O\
l\
llOO
=
lOllO\
lOOlO
.
ll\
OOOll\
OlO\

.
lOlOOO\
OlOO
(
)
;
!
llOlOl\
llO\
O\

.
AtEnd\

(
)
;
)
{
llOOOlOOO\
l
&
llO\
lOll\
lOl
=
*
llOlOl\
llOO
;
++
llOlOl\
llOO\

;
if
(
llO\
lOl\
l\
lOl
.
lOl\
OllOl\
lO
)
{
TA_AS\
SERT
(
ll\
O\
l\
O\
ll\
lO\
l\

.
llOOOlOl\
O\
l
)
;
TA_\
A\
SSERT
(
llOl\
OlllOl
.
llO\
OOl\
O\
lOl\

->
llOOOlOl\
Ol\

)
;
TA_ASSERT
(
llO\
lOlllOl
.
ll\
OO\
O\
lOlOl
->
llOO\
Ol\
OlOl
==
&
llOlOl\
l\
lOl
)
;
conti\
nu\
e
;
}
TA_ASSERT
(
!
llOlOll\
lOl
.
lOlO\
ll\
O\
l\
lO
)
;
TA\
_\
ASS\
ERT
(
!
ll\
OlOl\
l\
l\
Ol
.
llOOO\
lO\
lOl
)
;
TA_A\
SSERT\

(
llOl\
O\
lllO\
l
.
ll\
OOOlO\
lO\
O
=
&
lOl\
lOl\
OOlO
)
;
for
(
ll\
OOOlllOO
llOlOlll\
lO
=
lO\
ll\
OlO\
l\
OO
.
llOOOl\
lOlO\

.
lOlO\
O\
OOlOO
(
)
;
!
llO\
l\
O\
ll\
llO
.
At\
En\
d\

(
)
;
)
{
llOOO\
l\
O\
OO\
l
&
ll\
OlO\
ll\
lll\

=
*
ll\
O\
lOl\
lllO
;
++
llOlOl\
ll\
lO
;
if
(
llOlOlllll\

.
lO\
lOll\
O\
llO
)
{
TA_\
A\
S\
S\
ERT
(
llOlOlllll\

.
ll\
O\
OOl\
OlO\
l
)
;
TA\
_A\
SSERT
(
ll\
Ol\
Olllll
.
ll\
OOO\
lO\
l\
Ol
->
llOO\
O\
lOlOl
)
;
TA_A\
S\
SE\
RT\

(
llOlOlllll\

.
llOOOlOlOl
->
llO\
O\
O\
lOlOl
==
&
llOlO\
ll\
ll\
l
)
;
con\
t\
inu\
e\

;
}
TA_AS\
SERT
(
!
llOl\
Ol\
llll
.
lO\
l\
OllOllO
)
;
TA\
_ASSERT\

(
!
llO\
lO\
l\
llll
.
llOO\
O\
lOlO\
l
)
;
TA_ASSERT
(
llO\
lOlll\
ll
.
llOOOl\
OlOO\

=
&
lO\
llOlOlO\
O\

)
;
if
(
llO\
lOl\
llOl
.
llOO\
OlOOl\
O
==
llOlOlllll
.
llOO\
OlO\
O\
ll
&&
llOlOlllO\
l
.
llOOOlOOll\

==
llOlOlll\
ll
.
llOO\
Ol\
OOlO\

)
{
if
(
ll\
O\
lOl\
llOl
.
llOOOlOlOO\

==
llOlO\
ll\
lll\

.
llO\
OO\
lOlOO
)
{
TA_ASSER\
T
(
&
lO\
llOlO\
O\
lO\

==
llOlOlllO\
l
.
llOOO\
lOlOO
)
;
TA_A\
SSERT
(
&
lOll\
OlO\
O\
lO
==
&
lO\
llO\
lOlO\
O
)
;
if
(
&
(
*
llOlO\
ll\
l\
OO
)
==
&
ll\
O\
lOllll\
l
)
++
llOlOlllOO
;
if
(
&
(
*
llO\
lOllllO
)
==
&
llOlOlllOl
)
++
ll\
OlOl\
ll\
lO
;
lO\
l\
lOlOO\
lO
.
llO\
OOllOlO
.
lOO\
l\
ll\
l\
lll
(
&
ll\
OlOlll\
Ol
)
;
llOOlO\
llll
.
Free
(
&
llOlOlllOl
)
;
lOl\
lOl\
OOlO
.
ll\
OOOl\
lOl\
O
.
lO\
Ol\
ll\
llll
(
&
llOlOlllll
)
;
llO\
OlOllll\

.
Free\

(
&
llOlO\
l\
llll
)
;
}
els\
e
{
llOlOl\
llOl\

.
llOOOlOl\
O\
l
=
&
llOlOllll\
l
;
llOlO\
ll\
l\
l\
l\

.
llOO\
OlO\
lOl
=
&
ll\
Ol\
O\
lllOl
;
llOlOlllOl
.
lOl\
Ol\
lO\
l\
lO
=
&
lOll\
O\
lOl\
OO
;
llOlOlllll
.
lOlOllOll\
O\

=
&
lOl\
l\
OlOOlO\

;
}
br\
ea\
k
;
}
}
}
}
}
Ve\
c3
v3\
Cent\
er
;
v3\
C\
e\
nt\
er
.
Cl\
ear
(
)
;
int
llOllO\
OO\
O\
O
=
0
;
for\

(
in\
t\

lO\
lll\
O\
l\
OO\
O
=
0
;
lO\
ll\
lOlOO\
O
<
lO\
ll\
OlOOOO
.
lO\
OO\
lll\
OOl\

(
)
;
lOl\
llO\
lO\
O\
O
++
)
{
if
(
llOOllllOl
[
lOlllOlOO\
O
]
)
{
llOll\
OOOOO\

++
;
v3Cent\
er
+=
lO\
llO\
lOOOO
[
lOlllOlOOO
]
;
}
}
if
(
llO\
ll\
OOO\
OO
<
3
)
{
llOOOOllll
=
tru\
e
;
retur\
n
fa\
l\
se
;
}
v3\
C\
e\
nter
/=
(
fl\
o\
a\
t
)
llOllOO\
OOO
;
for
(
in\
t
llO\
llOOOOl
=
0
;
llO\
llOO\
OOl\

<
llOl\
Ol\
OlOO
.
lOO\
Oll\
lOOl
(
)
;
ll\
OllOOO\
O\
l\

++
)
{
llO\
OOlOOOO
&
lOllOOOlO\
l
=
*
ll\
O\
lOl\
O\
l\
OO\

[
llO\
llOOOOl
]
;
if
(
lOllOOOlOl
.
lOOOlOOOOO
.
Dot
(
v3\
Cen\
te\
r\

)
-
lOllO\
OOlOl
.
lOlOll\
l\
O\
Ol\

>
llO\
lOOlOlO
)
{
llOOOOllll
=
tr\
ue
;
return
false\

;
}
}
boo\
l
llO\
l\
l\
OOOl\
O
=
tru\
e
;
whil\
e
(
ll\
O\
l\
lOOO\
lO\

)
{
llOllOO\
OlO
=
false\

;
}
}
}
if\

(
llO\
OlOO\
O\
Ol\

!=
0
)
{
bool\

llOll\
OOOll\

=
true
;
whi\
le\

(
llO\
llOO\
O\
ll
)
{
llOllOOOll
=
fal\
s\
e
;
llOOOlOO\
O\
l
*
llOllO\
OlO\
O
=
0
;
flo\
at
llOllOOl\
O\
l
=
k_fMaxF\
l\
oa\
t\

;
fo\
r\

(
llOOOll\
Oll\

llOlOOllOO
=
llO\
O\
lOl\
ll\
O\

.
lO\
lOOO\
OlO\
O
(
)
;
!
llO\
lOO\
l\
lOO
.
AtEnd
(
)
;
++
llOl\
OOll\
O\
O
)
{
ll\
OO\
OlOOOO\

&
lOl\
lO\
O\
OlOl
=
*
llOlOOl\
l\
OO
;
for
(
llO\
OO\
l\
llOO
ll\
O\
lOlllOO
=
lOllOO\
O\
lOl\

.
ll\
OOOll\
Ol\
O
.
lOlOO\
OOl\
O\
O
(
)
;
!
llOlO\
l\
llO\
O\

.
AtEnd
(
)
;
++
llOlOlllOO\

)
{
ll\
OOOlOOOl\

&
llO\
l\
O\
lllOl
=
*
ll\
OlO\
l\
llOO
;
TA\
_AS\
SER\
T\

(
llOlOl\
llOl
.
lOlOl\
lO\
l\
lO
)
;
if
(
llOlOlllOl
.
lO\
lOll\
Oll\
O\

->
lOO\
O\
lOOOO\
O\

.
Dot\

(
lO\
llOOOlO\
l
.
lOOOl\
OO\
O\
OO
)
<
0.0f
)
co\
ntinu\
e
;
Ve\
c3
llOl\
lOOllO
;
llO\
llO\
OllO
.
Clea\
r
(
)
;
in\
t
llO\
llOO\
lll
=
0
;
for
(
llO\
O\
OlllO\
O
llO\
l\
Oll\
llO
=
llOl\
Olll\
Ol
.
lOlOllOl\
l\
O
->
llOO\
O\
llOlO\

.
lOlOOOOl\
OO
(
)
;
!
llOlOllllO
.
AtEn\
d
(
)
;
++
llOlO\
l\
lllO
)
{
llO\
OOlO\
OO\
l\

&
ll\
Ol\
OlllOl
=
*
llOlOll\
llO
;
llOllOOllO
+=
lOll\
OlO\
OOO
[
llOlOl\
llO\
l\

.
llO\
O\
OlOOlO\

]
;
llOl\
lOOl\
l\
l
++
;
}
TA_ASSERT
(
llOllOO\
lll\

>
0
)
;
if\

(
llOllOOl\
ll\

>
0
)
{
llOllOOl\
lO
/=
(
flo\
at
)
llOllO\
O\
ll\
l\

;
floa\
t
lOlll\
O\
ll\
lO
=
lOllOOOlOl
.
lOO\
OlO\
OOO\
O\

.
Do\
t\

(
ll\
O\
llOOl\
l\
O\

)
-
lOllOOOlOl\

.
lOlOlllO\
O\
l
;
if\

(
Fabs
(
llOl\
lOOlOl\

)
>
Fab\
s
(
lOlllOl\
l\
l\
O
)
)
{
llO\
llOO\
lOl
=
lOll\
lOl\
l\
lO\

;
llOllOOlOO
=
&
llOl\
O\
lllOl
;
}
}
}
}
if
(
llOllOOlO\
O
&&
Fab\
s
(
ll\
O\
llO\
O\
lO\
l
)
<
ll\
OlOO\
lOlO
*
ll\
OOlO\
OOOl
)
{
ll\
OllOOlOO
->
llOO\
OlOlO\
O
->
llOOO\
l\
lO\
lO
.
ll\
Oll\
OlO\
OO
(
llOllOO\
lO\
O
->
lOlOl\
lOl\
lO
->
llOOOl\
l\
Ol\
O
)
;
ll\
OOO\
l\
OOOO\

*
ll\
OOO\
lOl\
OO
=
llOllO\
OlOO\

->
llOOO\
lOlO\
O
;
llOO\
OlOOO\
O
*
lOl\
OllOl\
l\
O
=
llO\
l\
lOOlOO
->
lOlOllOllO
;
llOOOl\
llOO
ll\
OlOlll\
OO
;
for\

(
llOlOll\
l\
OO\

=
llOOO\
lO\
lOO\

->
llOO\
OllO\
lO\

.
lO\
lOO\
OO\
lOO\

(
)
;
!
llOl\
O\
lll\
O\
O\

.
At\
E\
nd
(
)
;
)
{
llO\
OO\
lOOOl
&
llO\
lOl\
l\
lOl\

=
*
llOlOl\
ll\
OO\

;
++
llOlOlll\
OO
;
if\

(
llOlOll\
lOl
.
lOlOllOllO
==
lOlOll\
Oll\
O
||
ll\
Ol\
Ol\
llO\
l
.
lOlOllOl\
lO\

==
llOOOl\
OlOO
)
{
llO\
O\
O\
lO\
lO\
O
->
llOOOll\
O\
lO\

.
lO\
Olllllll\

(
&
llOlO\
lllOl
)
;
llO\
O\
lOll\
ll
.
Free\

(
&
llOl\
O\
lll\
Ol\

)
;
continue
;
}
if
(
llOlOlllOl\

.
llO\
OOlOl\
Ol
->
lOlOllO\
llO
==
lO\
lO\
llO\
l\
lO\

)
ll\
OlOlllO\
l
.
ll\
OO\
OlOlOl
->
lOlOllOllO
=
llOOOlOlOO
;
ll\
O\
lOll\
lOl
.
llO\
OOl\
Ol\
O\
O\

=
llO\
OOl\
O\
lOO\

;
}
lO\
lO\
l\
llOl\
O
<
llO\
OOlOOOl
,
true
>
::
lOlOlll\
Ol\
l
llOllOlOOl
;
llO\
l\
Oll\
l\
OO
=
llOOOl\
Ol\
OO
->
ll\
OO\
OllOlO
.
lO\
lO\
O\
OOl\
OO
(
)
;
if\

(
!
ll\
OlOl\
llOO\

.
AtE\
nd\

(
)
)
{
llOOOlOO\
Ol
*
llOl\
lOl\
O\
lO
=
&
*
ll\
O\
l\
Ol\
llOO
;
ll\
OOOlOl\
O\
O
->
llOOO\
llOlO
.
lO\
Olllll\
ll
(
llO\
l\
lOlOlO
)
;
llO\
llO\
lO\
Ol
.
lOlO\
lOOOO\
l
(
llOllOl\
OlO\

)
;
bo\
ol
llOl\
lOlOll
=
false
;
while
(
!
llOll\
OlOl\
l
)
{
llOl\
lOlOll\

=
tr\
u\
e
;
for
(
llOlOlll\
OO
=
llOOO\
lOlO\
O
->
llOO\
O\
llOl\
O\

.
lO\
lOO\
OO\
l\
OO
(
)
;
!
llOl\
O\
ll\
lOO
.
AtEn\
d\

(
)
;
)
{
llOO\
OlOOOl
&
ll\
OlOlllOl
=
*
llO\
lOlllO\
O\

;
++
ll\
O\
l\
Oll\
lOO
;
if
(
llOlOl\
ll\
O\
l
.
ll\
OO\
Ol\
O\
OlO\

==
llOllOlOlO\

->
llOOOlOOll\

)
{
llO\
OOlO\
lO\
O\

->
llOOOllOlO
.
lOO\
ll\
ll\
lll
(
&
llOlOlllO\
l
)
;
llO\
llOlOOl
.
lO\
lOlO\
OOO\
l
(
&
ll\
O\
lOll\
lO\
l
)
;
llO\
llOl\
OlO
=
&
ll\
OlOlllOl
;
ll\
OllOlOll\

=
fal\
se
;
bre\
ak
;
}
}
if\

(
llOll\
Ol\
Oll\

&&
!
ll\
OO\
OlO\
lOO\

->
ll\
OOOllOlO
.
lOl\
OO\
OOlOO\

(
)
.
AtEnd\

(
)
)
{
ll\
OO\
O\
lOOOl\

&
llOl\
O\
lllOl
=
*
llOOOlOlOO
->
llOOOllOl\
O\

.
lOl\
OOOOlOO
(
)
;
llOO\
OlOl\
O\
O
->
llOOO\
llOl\
O
.
lOO\
ll\
lllll
(
&
ll\
Ol\
OlllOl
)
;
llOllO\
l\
O\
O\
l
.
lOlOlOO\
OO\
l
(
&
llO\
lOlllOl
)
;
llO\
llOlOlO
=
&
ll\
OlOlllOl
;
llOllOlOl\
l\

=
fal\
se\

;
}
}
TA_\
ASSERT
(
ll\
OOOlO\
lO\
O\

->
llO\
OO\
llOlO
.
lOlOOO\
O\
lOO
(
)
.
AtE\
nd
(
)
)
;
llOOOl\
O\
lO\
O
->
llOOO\
llOlO
.
llOl\
lO\
llOO
(
llOllOlOOl
)
;
}
{
Vec3
llOllOllOl
;
Vec3
lOOO\
lOO\
O\
O\
O
;
Ve\
c\
3
ll\
OllO\
lll\
O\

;
lOOOlOOOOO
.
Cl\
ear
(
)
;
llO\
ll\
Ol\
llO
.
Clear
(
)
;
boo\
l
llOOOOO\
OO\
O
=
true
;
int\

llO\
ll\
O\
Olll\

=
0
;
for
(
llO\
OOlllO\
O\

llOlOlO\
O\
Ol
=
ll\
OOOlOl\
OO
->
llO\
O\
OllO\
l\
O\

.
lOl\
O\
OOOlOO\

(
)
;
!
llOlO\
lOOO\
l\

.
At\
End
(
)
;
)
{
ll\
O\
O\
O\
lOO\
O\
l
&
llOlOlOOlO
=
*
llOlOlOOO\
l
;
++
llOlOlOOO\
l
;
if
(
llOlOlOOOl
.
At\
End
(
)
)
br\
eak\

;
llOl\
lOOlll
++
;
if\

(
llOOO\
OO\
OOO
)
{
llOO\
OOO\
OOO\

=
fals\
e
;
llOllOllOl
=
lOllOlOOOO
[
ll\
OlOl\
OO\
l\
O
.
llO\
O\
Ol\
O\
O\
ll
]
;
}
else
{
Vec\
3
lll\
ll\
l\
lll\

=
lOllOlOOO\
O
[
ll\
OlOlOOlO
.
llO\
OOlOOll
]
-
ll\
Oll\
Ol\
lOl\

;
Ve\
c3
lOOOO\
OO\
OOO\

=
lOllO\
lO\
O\
OO
[
llO\
lOl\
O\
OlO
.
ll\
OOOlOOlO\

]
-
llOllOl\
lOl\

;
lO\
O\
OlOOOOO
+=
Ve\
c3
::
Cros\
s
(
ll\
l\
llllll\

,
lOOOOOOOO\
O\

)
;
}
llOll\
Oll\
lO
+=
lOll\
OlOOOO\

[
llOlOlOO\
lO
.
ll\
OO\
OlOOl\
l
]
;
}
if
(
ll\
Oll\
OOlll
>
1
)
{
llO\
llO\
l\
llO
/=
(
fl\
o\
a\
t
)
(
ll\
O\
ll\
OO\
lll
)
;
lOOOlOOOO\
O\

.
Nor\
mal\
ise
(
)
;
llO\
OOlOlOO
->
lOOO\
lO\
OOO\
O
=
lOOOlOOOOO
;
llOOOlOl\
O\
O
->
lO\
l\
O\
lll\
O\
Ol
=
ll\
OOOlOlOO\

->
lOOOlOOOOO
.
Do\
t
(
ll\
Oll\
Olll\
O
)
;
}
}
ll\
O\
OlOl\
l\
l\
O
.
lOOlllll\
ll
(
lOlO\
llOl\
lO
)
;
llO\
Ol\
OllOl
.
Free
(
lO\
lOllO\
ll\
O
)
;
ll\
Oll\
O\
OO\
ll
=
tr\
ue
;
}
}
int
ll\
OllOllll
=
20
;
floa\
t
ll\
Olll\
O\
OOO
=
0.0f
;
for
(
int
lOOOllOOOl
=
0
;
lOOOll\
OOOl
<
llOl\
lO\
llll
;
lOOOllOOOl
++
)
{
llOOOllOl\
l
llOlOOllOO
;
fl\
oat
llOlllOO\
Ol
=
(
flo\
at\

)
lO\
OOl\
l\
OOOl
*
(
1.0f
/
5.0f
)
;
if\

(
llOll\
l\
OOOl
>
1.0f
)
llOll\
lOO\
Ol
=
1.0f
;
llO\
lllO\
OOO
=
0.0f
;
fo\
r
(
llO\
lOOll\
OO
=
llOO\
lOll\
lO
.
lOlO\
O\
O\
OlO\
O
(
)
;
!
llO\
lOOl\
lOO
.
At\
E\
nd
(
)
;
++
llOl\
OO\
l\
l\
OO
)
{
ll\
OOOl\
OO\
O\
O\

&
lOll\
OOOlOl
=
*
llO\
lO\
OllOO
;
for
(
ll\
O\
OO\
lllOO
ll\
OlOlOO\
Ol
=
lOll\
OO\
Ol\
Ol
.
ll\
OOOllOl\
O
.
lOl\
OOOO\
lOO
(
)
;
!
llOlOlOOO\
l
.
At\
E\
nd
(
)
;
++
llO\
lOlOOO\
l
)
{
llOOOlOOOl
&
ll\
Ol\
OlOOl\
O
=
*
ll\
OlOlOOO\
l
;
Vec\
3
&
llOOl\
llllO
=
lOllOlO\
OOO
[
llO\
lO\
lOOlO
.
llOO\
OlOOll
]
;
float\

lOlll\
OlllO
=
lOllOOOl\
Ol
.
lO\
OOl\
OOOOO\

.
Dot
(
llO\
Olll\
llO
)
-
lO\
l\
lOOOlOl\

.
lO\
l\
O\
lllOOl
;
llO\
lllOOOO\

+=
Fa\
bs\

(
lOl\
llO\
l\
llO\

)
;
llOOllll\
lO
-=
lOlllOlllO
*
lOllOO\
OlOl
.
lOOOlOOOOO\

*
llOlll\
OOOl
;
}
}
if
(
(
lOOOll\
OOOl
&
3
)
==
0
||
lOOO\
llO\
OOl
==
ll\
OllOl\
ll\
l
-
1
)
for\

(
llO\
lO\
O\
llOO
=
llOOl\
O\
l\
l\
l\
O\

.
lOlOO\
OO\
l\
OO
(
)
;
!
llOlOOll\
OO
.
At\
End
(
)
;
++
llOl\
O\
OllO\
O
)
{
llOOOl\
OOOO\

&
lOl\
lOOOlOl\

=
*
ll\
OlO\
OllO\
O\

;
{
Ve\
c\
3
llO\
llOllOl
;
Ve\
c3\

lOOO\
l\
O\
O\
OO\
O
;
Ve\
c3
llOllOlllO
;
lOO\
OlOOO\
OO
.
Clea\
r
(
)
;
ll\
OllO\
ll\
l\
O
.
Clear\

(
)
;
boo\
l
llO\
OOO\
O\
OO\
O
=
true
;
int
llOllOOl\
ll
=
0
;
fo\
r
(
llOOOl\
llOO
llOl\
O\
lOOO\
l
=
lOl\
l\
OO\
O\
lOl\

.
llO\
O\
OllOlO
.
lO\
lOO\
O\
Ol\
OO
(
)
;
!
ll\
Ol\
OlOOOl
.
AtEnd
(
)
;
)
{
llOOOl\
OO\
Ol\

&
llOlOlO\
Ol\
O
=
*
llOlOl\
O\
OOl
;
++
llOl\
Ol\
OOO\
l
;
if
(
ll\
OlOl\
OOOl
.
At\
End\

(
)
)
br\
ea\
k
;
llO\
llOOl\
ll
++
;
if
(
ll\
OOOOOOOO
)
{
llOOO\
OOOOO
=
fa\
lse\

;
llOl\
l\
Ol\
lOl
=
lOll\
O\
l\
OOO\
O
[
llOlO\
lOO\
lO
.
llO\
OO\
lOOll
]
;
}
else
{
Vec3
lllll\
ll\
ll
=
lO\
llO\
lO\
OOO
[
llOlOl\
OOlO
.
llOO\
O\
lOOll
]
-
llOllO\
llOl
;
Ve\
c\
3
lOOOOOOOOO
=
lOllOlOOOO
[
llO\
lOl\
O\
OlO
.
llOO\
OlOO\
lO
]
-
ll\
OllO\
llOl
;
lOO\
OlOOOOO
+=
Vec\
3
::
Cro\
ss
(
lllll\
ll\
l\
l\

,
lOO\
OOOOOOO\

)
;
}
llO\
ll\
O\
lllO
+=
lOllOlOOO\
O\

[
ll\
OlOl\
OOlO
.
ll\
OOO\
l\
OOll
]
;
}
if
(
llOll\
OOlll\

>
1
)
{
ll\
O\
llOlllO
/=
(
float
)
(
llO\
l\
lOO\
l\
ll\

)
;
lOOOlOO\
OOO
.
Norm\
alise\

(
)
;
lOl\
lO\
OOlOl
.
lOO\
OlOOO\
OO
=
lO\
O\
Ol\
OO\
O\
O\
O
;
lO\
llO\
O\
OlOl
.
lOlOlll\
OOl
=
lOl\
l\
O\
OOlOl\

.
lOOOlOOOOO\

.
Dot
(
llOllOl\
llO
)
;
}
}
}
}
if
(
ll\
OlllO\
O\
OO
>
0.1f
*
llOOllOOOO
)
{
llOO\
lOOlOO
=
tr\
ue\

;
retu\
r\
n
false\

;
}
}
{
int
llO\
l\
llOOlO\

=
0
;
int
llO\
lllO\
Ol\
l
=
0
;
llOOO\
llOll
llO\
lOOll\
O\
O
;
fo\
r
(
llOl\
OO\
llO\
O
=
llO\
O\
lOl\
l\
lO
.
lOlOO\
OOl\
O\
O\

(
)
;
!
ll\
OlOOllOO
.
AtEnd
(
)
;
++
ll\
O\
lOOll\
OO
)
{
llOOOlOO\
OO\

&
lOl\
l\
O\
OOl\
O\
l
=
*
llO\
lOOl\
lOO\

;
lO\
ll\
O\
OO\
lOl
.
lO\
OOl\
OOlll
=
ll\
OlllOOlO
;
llOlllO\
O\
lO
++
;
for\

(
llOOOll\
lOO
llOlOlll\
OO
=
lOl\
lO\
OOlOl
.
llOO\
Oll\
OlO
.
lOlOOOOl\
O\
O
(
)
;
!
llOlO\
lllOO
.
AtE\
n\
d
(
)
;
++
llO\
lOlllOO
)
{
llOOOlOOOl
&
llOlOll\
lOl
=
*
llOlO\
l\
llO\
O
;
llOlllOOll\

++
;
TA\
_ASSERT
(
ll\
OlOlllOl
.
lOlOllOllO
)
;
Vec3
ll\
OllOOllO
;
llOllO\
Oll\
O
.
Cl\
ear
(
)
;
int
llOllO\
Olll
=
0
;
int\

llOl\
llOlO\
O
=
-
1
;
for
(
llOOO\
l\
llOO
llOlOl\
lllO
=
llO\
lOlll\
Ol\

.
lOlOllOl\
l\
O
->
llOOOl\
lOl\
O\

.
lO\
lOOOO\
l\
OO
(
)
;
!
llOlOllll\
O
.
AtEnd
(
)
;
++
llOlOl\
ll\
lO\

)
{
llOO\
O\
l\
OOO\
l
&
ll\
Ol\
OlllOl
=
*
llOlO\
llllO
;
llO\
llOOllO
+=
lOl\
lOlOOO\
O\

[
llO\
lOlll\
O\
l
.
ll\
O\
OOlOOlO
]
;
ll\
Oll\
OOlll\

++
;
if\

(
llO\
l\
ll\
O\
lOO
!=
-
1
&&
llOl\
Olll\
O\
l
.
llO\
O\
OlOO\
ll
!=
llOll\
l\
Ol\
OO
)
{
ll\
OOlO\
O\
l\
O\
O
=
true
;
llOO\
O\
Ol\
l\
ll
=
true
;
ret\
urn
fa\
l\
se\

;
}
llO\
ll\
l\
OlOO
=
ll\
Ol\
Ol\
llOl\

.
ll\
OOOl\
OO\
lO
;
}
if
(
llOllOOlll
>
llOO\
O\
lllll
)
{
llOOl\
OOl\
OO\

=
true\

;
re\
tu\
rn
fa\
ls\
e
;
}
TA_ASSER\
T
(
llOll\
OOll\
l\

>
0
)
;
if
(
llOllOOlll\

>
0
)
{
ll\
OllOO\
llO
/=
(
flo\
at
)
llOll\
OOl\
l\
l\

;
flo\
at
lOll\
lOll\
lO
=
lOl\
l\
O\
O\
OlOl
.
lO\
OOlO\
O\
OOO\

.
Do\
t\

(
llOl\
l\
OO\
ll\
O
)
-
lOllOOOlOl
.
lOlOl\
llOOl
;
flo\
at
ll\
OlllO\
l\
O\
l
=
-
llOl\
O\
OlOlO
*
0.000001f
;
if
(
llO\
OlOOOOl
<
0.01f
)
ll\
O\
ll\
lO\
lOl
=
ll\
OlO\
OlO\
lO
*
0.0001f
;
if
(
lOlllOlllO
>
llOlllOlOl\

)
{
ll\
OO\
lOO\
lOO
=
true\

;
ret\
ur\
n\

fal\
se
;
}
}
}
}
lO\
OOOl\
OllO
<
int
,
false\

>
llOl\
ll\
OllO
;
llOlll\
O\
llO
.
In\
iti\
al\
ise\

(
0
,
lOllOlOOOO
.
lOO\
Oll\
lO\
Ol
(
)
)
;
in\
t
ll\
Oll\
l\
Ol\
ll
=
0
;
for
(
in\
t\

lOlllOl\
O\
OO
=
0
;
lOlllOlOOO
<
lOl\
lOlOOO\
O
.
lOOOll\
lOOl
(
)
;
lOll\
lO\
lOOO
++
)
{
if
(
ll\
OO\
ll\
llOl\

[
lOll\
lO\
l\
OOO
]
)
llOll\
lO\
ll\
O
.
lOO\
O\
lllOOO\

(
llOll\
l\
Olll
++
)
;
else
llOll\
lOl\
lO
.
lOOOl\
ll\
OOO\

(
0
)
;
}
ll\
OOlOl\
l\
OO
.
In\
itialise\

(
0
,
ll\
Ol\
llOlll
)
;
for
(
int\

lOlllOlOOO\

=
0
;
lOll\
lOl\
OOO
<
lOl\
lOlOOOO
.
lOOOlll\
OOl\

(
)
;
lOl\
l\
l\
O\
lO\
OO\

++
)
{
if
(
llOOl\
lllOl
[
lOl\
llOlOOO\

]
)
llOOlOll\
OO\

.
lO\
OOlllOOO
(
lOllO\
l\
OOO\
O
[
lOl\
ll\
O\
lOO\
O
]
)
;
}
TA\
_AS\
SE\
RT
(
llOOl\
Ol\
lOO
.
lO\
OOlll\
O\
O\
l
(
)
==
llOlllO\
lll
)
;
int
lOllO\
lllll\

=
llOlllOOlO
+
llOlllOOll\

*
2
;
ll\
OOlOlOlO\

.
Ini\
tialise\

(
0
,
lOl\
lOll\
lll
)
;
llO\
OlOl\
Oll
.
Initi\
al\
i\
se
(
0
,
ll\
Oll\
lOOlO\

)
;
for
(
llO\
lO\
OllOO
=
ll\
OOl\
O\
ll\
l\
O
.
lO\
lO\
OOOlO\
O\

(
)
;
!
ll\
Ol\
O\
O\
l\
lO\
O
.
At\
End
(
)
;
++
llOlO\
O\
l\
lOO
)
{
llOOOlOOO\
O\

&
lOllOOO\
lOl
=
*
llOlO\
O\
llO\
O
;
ll\
OO\
lOlO\
ll
.
lOO\
Oll\
lOOO
(
ll\
O\
O\
lOl\
O\
l\
O
.
lO\
OOlll\
OO\
l\

(
)
)
;
ll\
OOlOlOlO
.
lO\
O\
Olll\
O\
OO
(
lOl\
lOOOlOl
.
llOOO\
l\
lOl\
O
.
lOOOl\
ll\
OO\
l
(
)
)
;
int
llOlOlOl\
lO
=
0
;
fo\
r
(
llO\
OOlllO\
O
llOl\
OlOOOl
=
lO\
l\
lOOO\
lO\
l
.
llOOOllOlO
.
lOlOOOOl\
OO
(
)
;
!
llOlOlO\
OOl
.
AtE\
n\
d
(
)
;
++
llOl\
OlOOO\
l\

)
{
llOOOl\
OO\
O\
l\

&
llOlOlO\
Ol\
O
=
*
llO\
lO\
lOO\
O\
l\

;
llOOlOlO\
lO\

.
lO\
OOlllOO\
O
(
llO\
l\
llO\
llO
[
llOlO\
lOOlO\

.
llOOO\
lOOl\
l
]
)
;
llOOlOlO\
lO\

.
lOOOlll\
OO\
O\

(
llOlOlOOlO\

.
lOlOllOllO
->
lO\
OOl\
OOl\
ll
)
;
llOlO\
lOl\
l\
O\

++
;
}
}
TA_A\
SSE\
R\
T
(
llOO\
lOlOlO
.
lO\
O\
O\
l\
l\
lOOl
(
)
==
llO\
Ol\
O\
lOlO
.
lOO\
llllOll\

(
)
)
;
TA\
_\
ASS\
ERT
(
ll\
OOlOlOll
.
lOOOlllOOl\

(
)
==
llOOlOlOll\

.
lOO\
llll\
Oll\

(
)
)
;
}
re\
t\
ur\
n
true
;
}
}

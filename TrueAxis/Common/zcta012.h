//---------------------------------------------------------------------------------
// File Name: zcta012.h
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef lOOOOlOOll
#define lOOOOlOOll
#ifndef TA_TYPES_H
#include "Types.h"
#endif //
#ifndef llOlllllOl
#include "../Common/zcta015.h"
#endif //
#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
#ifndef lOlOOlOlOO
#include "../Common/zcta007.h"
#endif //
name\
spa\
c\
e
TA
{
#define lOOllOlOOlO(lOOlOllOlOO)
#define lOOllOlOOll(lOOlOllOlOO)
clas\
s
TAC\
OMMO\
N_\
CLA\
SS\

Serial\
ise\
r
{
publ\
ic
:
Ser\
ial\
is\
er
(
)
{
lOOllOl\
O\
lOO
=
0
;
}
Serial\
is\
e\
r
(
lOOO\
O\
OOlOll\

&
lOOllO\
lO\
lOl
)
{
lOO\
llOlOlO\
O
=
0
;
Ini\
tiali\
s\
e\

(
lOO\
ll\
OlOlO\
l
)
;
}
~
Ser\
ia\
l\
i\
s\
er
(
)
{
Finalise\

(
)
;
}
void
Initiali\
se
(
lO\
OOOOOl\
Oll\

&
lO\
O\
llOlOlOl\

)
{
TA_A\
S\
SER\
T
(
lOOllO\
lO\
lOO\

==
0
)
;
lOOl\
l\
O\
lO\
lOO
=
&
lOO\
l\
lOlOlO\
l
;
}
void
Finalise
(
)
{
lOOllO\
lOlO\
O
=
0
;
}
templ\
a\
t\
e
<
cl\
ass
Ty\
pe
>
void
Se\
ria\
l\
ise
(
Ty\
pe
&
lOO\
lllllO\
O\

)
{
TA_\
A\
SSERT
(
lOOllOlOlO\
O
)
;
lOOllOlO\
lOO
->
lOlOOllOl\
O
(
&
lOOll\
l\
l\
lOO
,
siz\
eo\
f
(
Type
)
)
;
}
void
ll\
lOlOlOlO
(
voi\
d
*
lO\
Ol\
l\
lOO\
OO
,
int\

lOOl\
l\
lOllO
)
{
TA_A\
S\
SE\
RT
(
lO\
O\
llOlOlOO
)
;
lO\
Oll\
OlOlOO\

->
lO\
lOOl\
lOlO
(
lOOl\
llOOOO\

,
lO\
Ol\
llOll\
O\

)
;
}
template
<
class
Type\

>
void\

lO\
OOlO\
llll
(
Type
&
lOOl\
lOlOl\
lO
)
{
int
lOOlllOllO
=
lOOllO\
lOllO
.
lOOO\
lllOOl
(
)
;
Seria\
l\
ise\

(
lO\
OlllO\
llO
)
;
if
(
lOOO\
ll\
OOOO
(
)
)
lOO\
llOlO\
llO
.
Initialis\
e
(
lOOlllOl\
l\
O
,
lOOl\
llOllO
)
;
lllO\
l\
OlOlO
(
&
lOOllOlOllO
[
0
]
,
lOO\
lll\
O\
llO\

*
lO\
OllOlOl\
l\
O
.
lOlOO\
OOO\
l\
l\

(
)
)
;
}
template
<
class\

Ty\
pe
>
void\

lOO\
l\
lOlOlll\

(
Type
&
lOOllOl\
O\
l\
l\
O
)
{
in\
t
lOOll\
lO\
llO
=
lOOllO\
lOllO
.
lOOOlllO\
Ol
(
)
;
Se\
riali\
se
(
lO\
Olll\
Oll\
O
)
;
if
(
lO\
OO\
ll\
O\
OO\
O
(
)
)
lOOl\
l\
Ol\
OllO
.
Ini\
t\
ia\
l\
is\
e
(
lOO\
lllOl\
lO
,
lOOlllOll\
O
)
;
for
(
int
lOOO\
ll\
OOO\
l
=
0
;
lOOOl\
lOOOl
<
lOOlllOll\
O
;
lO\
OOllOOO\
l
++
)
lOOllOlOllO
[
lO\
OOllO\
O\
Ol
]
.
Serialise\

(
*
this
)
;
}
templat\
e
<
clas\
s
Ty\
p\
e
>
void\

lOOll\
O\
llO\
OO
(
Type
&
lO\
OllOllOOl\

)
{
int
lOOlllOl\
l\
O
=
lO\
OllOl\
lOOl\

.
lOO\
OlllOOl\

(
)
;
Serialise
(
lOOll\
lOl\
lO\

)
;
if\

(
ll\
lO\
l\
OOl\
l\
l
(
)
)
{
cl\
ass
Type\

::
Itera\
tor
lOl\
OOlOOlO
;
lOlOO\
lOO\
lO
=
lO\
Ol\
lOllOOl\

.
lOl\
OOOOlOO
(
)
;
for
(
;
!
lOlOOlOO\
lO
.
AtE\
nd
(
)
;
++
lOlOOlOOlO\

)
(
*
lO\
lOOlOOlO\

)
.
Se\
r\
iali\
se
(
*
th\
is
)
;
}
else
{
fo\
r\

(
in\
t
lOO\
Ol\
lO\
OO\
l
=
0
;
lO\
OO\
ll\
OOOl
<
lOOlllOl\
lO\

;
lOOOl\
lOOOl
++
)
lOOl\
l\
O\
l\
lOO\
l
.
lOOO\
l\
llO\
OO
(
)
.
Ser\
ial\
is\
e
(
*
this
)
;
}
}
boo\
l
lOOOllO\
OOO
(
)
{
TA_\
AS\
S\
ERT
(
lO\
OllOlOlO\
O
)
;
ret\
urn
lOOl\
lO\
l\
Ol\
OO\

->
lO\
OO\
ll\
OO\
OO
(
)
;
}
bo\
ol
ll\
lOlOOll\
l
(
)
{
TA_ASSERT\

(
lOOll\
OlOlOO
)
;
return
lO\
Ol\
l\
OlOlOO
->
lllOlOOll\
l
(
)
;
}
private
:
lOOOO\
O\
O\
lOl\
l
*
lOOllOlOlOO\

;
}
;
}
;
#endif //

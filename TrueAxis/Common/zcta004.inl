//---------------------------------------------------------------------------------
// File Name: zcta004.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
#ifndef TA_MATHS_H
#include "Maths.h"
#endif //
#ifdef TA_SSE2
#include <xmmintrin.h>
#include <emmintrin.h>
#endif //
namespac\
e
TA\

{
#define lOOOOlllOOO(lllOOlllOO, lOOOOlllOOl, lllOlOOOOO)											\
do																					\
{																					\
	(lllOOlllOO).M11() lOOOOlllOOl (lllOlOOOOO).M11(); (lllOOlllOO).M12() lOOOOlllOOl (lllOlOOOOO).M12(); (lllOOlllOO).M13() lOOOOlllOOl (lllOlOOOOO).M13();			\
	(lllOOlllOO).M21() lOOOOlllOOl (lllOlOOOOO).M21(); (lllOOlllOO).M22() lOOOOlllOOl (lllOlOOOOO).M22(); (lllOOlllOO).M23() lOOOOlllOOl (lllOlOOOOO).M23();			\
	(lllOOlllOO).M31() lOOOOlllOOl (lllOlOOOOO).M31(); (lllOOlllOO).M32() lOOOOlllOOl (lllOlOOOOO).M32(); (lllOOlllOO).M33() lOOOOlllOOl (lllOlOOOOO).M33();			\
} while (0)
#define lOOOOlllOlO(lllOOlllOO, lOOOOlllOOl, lllOlOOOOO)									\
do																					\
{																					\
	(lllOOlllOO).M11() lOOOOlllOOl lllOlOOOOO; (lllOOlllOO).M12() lOOOOlllOOl lllOlOOOOO; (lllOOlllOO).M13() lOOOOlllOOl lllOlOOOOO;									\
	(lllOOlllOO).M21() lOOOOlllOOl lllOlOOOOO; (lllOOlllOO).M22() lOOOOlllOOl lllOlOOOOO; (lllOOlllOO).M23() lOOOOlllOOl lllOlOOOOO;									\
	(lllOOlllOO).M31() lOOOOlllOOl lllOlOOOOO; (lllOOlllOO).M32() lOOOOlllOOl lllOlOOOOO; (lllOOlllOO).M33() lOOOOlllOOl lllOlOOOOO;									\
} while (0)
inline
Mat\
3\
3\

::
Mat33\

(
)
{
}
in\
l\
in\
e
Mat\
33\

::
Mat\
33
(
cons\
t
Mat33
&
lOO\
O\
Oll\
lO\
ll
)
{
lOO\
OOlllOOO
(
*
th\
is
,
=
,
lO\
OOOlllOll\

)
;
}
inline
Mat\
33\

::
Mat\
33
(
fl\
oa\
t
lOOOOllllOO
,
flo\
at
lOOO\
OllllOl\

,
floa\
t\

lOO\
OOllll\
lO
,
fl\
oat
lOO\
OOlll\
ll\
l
,
float\

lOOO\
lO\
O\
O\
O\
OO
,
flo\
at
lOOOl\
OOOOO\
l
,
fl\
oat
lOOOlOOOOlO
,
floa\
t
lO\
OOlOOOOll\

,
fl\
o\
at
lOOOlOOOlOO
)
{
M11
(
)
=
lOOOOl\
l\
llOO
;
M12
(
)
=
lOOO\
OllllOl
;
M13\

(
)
=
lOOOOllll\
lO
;
M21
(
)
=
lOO\
OOllllll
;
M22
(
)
=
lOO\
OlOO\
OO\
OO\

;
M2\
3
(
)
=
lOOO\
l\
OOO\
OOl
;
M3\
1\

(
)
=
lO\
O\
OlOOOOl\
O
;
M32\

(
)
=
lOOOlOOOOl\
l
;
M33
(
)
=
lO\
OOlOO\
OlOO\

;
}
in\
l\
i\
n\
e
voi\
d
Mat3\
3
::
In\
itialis\
e\

(
Ro\
tati\
onAx\
is
lOOOOllO\
OlO
,
fl\
oat\

lO\
OO\
OlOOOOO\

)
{
sw\
itc\
h
(
lO\
OOOll\
OO\
lO\

)
{
ca\
se
RO\
TATION_A\
XIS_\
X
:
SinAnd\
Cos
(
lOOOOl\
OOOOO\

,
M23
(
)
,
M22
(
)
)
;
M11
(
)
=
1.0f
;
M1\
2
(
)
=
0.0f
;
M13
(
)
=
0.0f
;
M21
(
)
=
0.0f
;
M31\

(
)
=
0.0f
;
M32
(
)
=
-
M23
(
)
;
M33
(
)
=
M2\
2
(
)
;
bre\
ak
;
ca\
se
ROTAT\
I\
ON\
_\
AXI\
S_Y
:
Si\
nAn\
dCos
(
lOOO\
OlOOO\
O\
O
,
M13
(
)
,
M1\
1\

(
)
)
;
M12\

(
)
=
0.0f
;
M21
(
)
=
0.0f
;
M22
(
)
=
1.0f
;
M23
(
)
=
0.0f
;
M31
(
)
=
-
M13\

(
)
;
M32
(
)
=
0.0f
;
M33
(
)
=
M1\
1
(
)
;
break
;
cas\
e
RO\
TATI\
ON_AX\
I\
S_Z\

:
SinAndC\
os
(
lOOOOlOOO\
OO\

,
M1\
2
(
)
,
M11
(
)
)
;
M13\

(
)
=
0.0f
;
M21
(
)
=
-
M1\
2
(
)
;
M2\
2
(
)
=
M11
(
)
;
M2\
3\

(
)
=
0.0f
;
M3\
1
(
)
=
0.0f
;
M3\
2\

(
)
=
0.0f
;
M33
(
)
=
1.0f
;
break\

;
def\
aul\
t
:
ll\
lOOl\
OOOO
;
}
}
in\
l\
in\
e
vo\
id
Ma\
t33
::
SetToLookD\
o\
wn\
Vector
(
const
Ve\
c3
&
lOOO\
lOO\
OlOl
)
{
lOOOO\
OOl\
lO
(
lOO\
OlOO\
OlOl\

.
IsNorma\
lised
(
)
,
"Mat33::SetToLookDownVector. v3Vector isn't normalised.")
;
v3Z
=
lOOOlOO\
OlOl\

;
int
lOO\
OlO\
OOllO
[
3
]
;
lOOOl\
OO\
O\
l\
Ol
.
Ge\
t\
A\
x\
isOrder\

(
lO\
OOlOOO\
ll\
O
)
;
Ve\
c3\

lO\
OOlO\
OOlll
=
Vec\
3
::
Ge\
tUnitV\
ec\
tor
(
lOO\
O\
lOO\
Ol\
lO
[
2
]
)
;
v3X\

=
lOOO\
lOO\
O\
l\
Ol\

.
Cross
(
lO\
O\
OlOOO\
lll
)
;
v3X
.
Norma\
lis\
e
(
)
;
v3\
Y
=
v3Z
.
Cr\
oss
(
v3X
)
;
}
inl\
ine
void
Mat33
::
SetT\
oLoo\
kA\
t\

(
const
Vec3\

&
lOOOlOO\
O\
lO\
l\

,
const
Ve\
c3
&
lO\
OOlOOl\
OOO
)
{
lOOOO\
OO\
llO\

(
lOOOlOO\
OlOl\

.
Is\
N\
ormali\
sed
(
)
,
"Mat33::SetToLookAt. v3Vector isn't normalised.")
;
lOOOOO\
O\
llO
(
lO\
OOlOOlOOO
.
IsNorm\
a\
lised\

(
)
,
"Mat33::SetToLookAt. v3UpVector isn't normalised.")
;
v3Z
=
lOOOlO\
OOlOl\

;
v3X\

=
lOO\
O\
l\
OO\
lOOO\

.
Cr\
o\
s\
s\

(
lOOOlOOOl\
Ol
)
;
float
lOllllOlOl
=
v3X
.
Ge\
t\
Mag\
nitude\

(
)
;
if
(
lOllllOlO\
l
<
0.000001f
)
{
lOOOOOO\
l\
lO
(
0
,
"Mat33::SetToLookAt. v3Vector and v3UpVector are parallel")
;
Set\
ToIdenti\
ty
(
)
;
}
els\
e
{
v3\
X\

/=
lOllll\
O\
l\
O\
l
;
v3Y
=
v3Z
.
Cross
(
v3X
)
;
}
}
inli\
ne
floa\
t\

&
Ma\
t\
33
::
operator
(
)
(
int\

lO\
OOl\
OOlOOl
,
in\
t
lOO\
OlOOl\
OlO\

)
{
re\
t\
urn
(
&
v3X
)
[
lO\
OOl\
OOlOO\
l
]
[
lOOOl\
O\
Ol\
OlO
]
;
}
in\
lin\
e\

float
Ma\
t\
3\
3
::
op\
erat\
or
(
)
(
int
lOOOlO\
Ol\
OOl\

,
int\

lOOO\
lOO\
lO\
lO
)
const
{
re\
t\
urn
(
&
v3X\

)
[
lOOOlOOlOO\
l
]
[
lOOOl\
O\
O\
l\
O\
l\
O\

]
;
}
inline
Vec3
&
Mat33\

::
opera\
tor
[
]
(
int
lOOOlOOl\
O\
Ol
)
{
ret\
urn\

(
&
v3X
)
[
lOOO\
lOOlOOl
]
;
}
inli\
ne
const
Vec\
3\

&
Mat33
::
operato\
r
[
]
(
int\

lOO\
OlOOlOOl
)
const
{
re\
tu\
rn\

(
&
v3X
)
[
lO\
OO\
lO\
Ol\
O\
O\
l
]
;
}
inli\
ne
Mat\
33
&
Mat\
33
::
op\
erat\
or
*=
(
const
Mat33\

&
lO\
OO\
Oll\
lOll
)
{
MulI\
n\
Plac\
e\

(
*
thi\
s\

,
lO\
OOOlll\
Oll
)
;
re\
turn
*
this
;
}
in\
line\

Mat33\

&
Mat\
33
::
opera\
tor
/=
(
con\
st
Mat33
&
lOO\
OO\
lllOll
)
{
Mu\
lB\
yTrans\
p\
o\
se\
In\
Place\

(
*
thi\
s\

,
lOOOOlllO\
ll
)
;
return
*
this
;
}
in\
l\
ine\

Mat33\

&
Ma\
t3\
3
::
op\
erat\
or
+=
(
co\
nst
Mat33
&
lOO\
O\
OlllOl\
l
)
{
lOOOOl\
llOOO
(
*
this
,
+=
,
lOOOOl\
l\
l\
O\
l\
l
)
;
re\
t\
ur\
n\

*
this\

;
}
inli\
ne\

Mat3\
3\

&
Mat33
::
ope\
rator
-=
(
const\

Mat\
33
&
lOOOOll\
l\
Ol\
l\

)
{
lOOO\
OlllOO\
O
(
*
thi\
s
,
-=
,
lOOOO\
l\
llOll\

)
;
re\
turn
*
this\

;
}
in\
l\
in\
e
Ma\
t3\
3
&
Mat33
::
opera\
tor\

*=
(
floa\
t\

lOOOOOlll\
O
)
{
lOOO\
Olll\
OlO
(
*
this\

,
*=
,
lOOO\
O\
O\
l\
ll\
O
)
;
re\
turn\

*
this
;
}
inl\
ine\

Mat33
&
Mat\
33
::
ope\
rator\

/=
(
float
lOOOO\
OlllO
)
{
lO\
OO\
OOlllO\

=
1.0f
/
lOOO\
O\
Oll\
lO
;
lO\
O\
O\
OlllOlO
(
*
th\
is
,
*=
,
lOOOO\
Oll\
lO\

)
;
return\

*
th\
is
;
}
inl\
ine
const\

Mat33\

&
Ma\
t33\

::
operato\
r
+
(
)
const
{
retur\
n
*
th\
is
;
}
in\
l\
ine
Mat33\

Mat33
::
operator
-
(
)
const
{
Mat3\
3
lllOlOOOOl
;
lOOO\
O\
l\
l\
l\
OO\
O
(
ll\
lOlOOO\
Ol
,
=
,
-
*
this
)
;
re\
tur\
n
ll\
lOlO\
OOOl
;
}
inl\
in\
e\

Mat\
33\

Mat\
3\
3
::
operator
*
(
const
Mat33
&
lO\
O\
OO\
l\
llOll
)
co\
n\
s\
t
{
Mat33
lll\
OlOOO\
Ol
;
Mul
(
*
this
,
lOOOOlll\
Oll
,
ll\
lOlOOO\
Ol
)
;
ret\
ur\
n
lllO\
l\
OOOOl
;
}
inline
Mat33
Ma\
t33\

::
opera\
tor
/
(
co\
nst
Mat33\

&
lO\
O\
OOl\
llOll
)
const\

{
Mat\
33
lllOlO\
O\
OOl
;
MulByTransp\
ose
(
*
th\
is\

,
lOOO\
O\
lllOll\

,
ll\
lOlOO\
OOl
)
;
return
lllO\
lOOOOl
;
}
inl\
in\
e
Ma\
t33
Mat\
3\
3
::
oper\
ato\
r
+
(
const
Mat33
&
lOO\
OOlllOl\
l
)
const
{
Ma\
t33
ll\
lOlOOOOl\

;
lOO\
O\
O\
l\
l\
l\
OO\
O
(
lll\
OlOO\
OOl
,
=
,
*
thi\
s
)
;
lO\
O\
OOlllOO\
O
(
lllO\
lOO\
O\
Ol
,
+=
,
lO\
OOO\
ll\
l\
Oll
)
;
re\
turn
lllOlOOO\
O\
l
;
}
inlin\
e\

Ma\
t33
Ma\
t\
3\
3
::
opera\
tor
-
(
co\
nst
Mat\
33
&
lOO\
O\
Ol\
llOl\
l
)
const
{
Ma\
t33\

lllOlO\
OOO\
l\

;
lOOO\
O\
l\
l\
lOO\
O
(
lllOlOOOOl
,
=
,
*
this
)
;
lOO\
OOlll\
O\
O\
O
(
lll\
Ol\
OOOOl
,
-=
,
lOOOOlllO\
ll\

)
;
ret\
urn\

ll\
lOlOOO\
Ol
;
}
in\
lin\
e\

Mat\
33
Mat\
33
::
ope\
r\
ator\

*
(
fl\
o\
a\
t
lOOOOOll\
lO\

)
const
{
Ma\
t33\

lllOlO\
OO\
Ol
;
lOO\
OOlllO\
OO
(
lllOl\
O\
O\
OOl
,
=
,
*
thi\
s
)
;
lO\
O\
OOll\
l\
OlO
(
lllOlOOOO\
l
,
*=
,
lOOOOOlll\
O
)
;
return\

lllOlO\
OOO\
l
;
}
inline\

Mat3\
3
Mat\
33\

::
op\
era\
tor\

/
(
fl\
oat
lOOO\
OOlllO\

)
co\
n\
st
{
Mat\
3\
3\

lllOlOOO\
O\
l\

;
lOOOOll\
l\
OO\
O
(
lllOlO\
OOOl\

,
=
,
*
this
)
;
lOOOO\
Ol\
llO
=
1.0f
/
lOO\
OO\
OlllO
;
lOOOOlll\
OlO
(
ll\
lOl\
OO\
OOl
,
/=
,
lOOO\
OOlllO
)
;
retur\
n
lllOlOOOOl
;
}
inline
Mat33\

oper\
ato\
r
*
(
fl\
oa\
t\

lOOOOOlllO\

,
const
Mat33
&
lOOOOl\
l\
l\
O\
ll
)
{
Mat33\

lllOlOOOO\
l\

;
lO\
OO\
Oll\
lOO\
O\

(
lllOl\
OOOOl
,
=
,
lOOO\
OlllOll\

)
;
lOOOOlll\
OlO
(
lllO\
l\
OOOOl
,
*=
,
lOO\
OOOll\
lO
)
;
re\
t\
u\
rn
lllOlO\
OOOl
;
}
inlin\
e
Vec\
3
TA\
_\
FAS\
T\
_CA\
LL
op\
e\
rator
*
(
co\
nst
Vec3
&
lll\
l\
lll\
ll\

,
co\
ns\
t
Mat\
3\
3
&
lllO\
Olllll
)
;
#ifdef TA_SSE2
lOl\
OlOl\
OOO\

inline
vo\
id
TA\
_F\
AS\
T_CA\
L\
L\

lOOOlO\
Ol\
Oll
(
Vec3
*
lOl\
O\
lOOll\
l
lOOOlOOl\
l\
OO
,
co\
nst\

Ve\
c3
*
lOlOlOOll\
l
lO\
O\
Ol\
OOl\
lO\
l\

,
const
Mat33
*
lO\
lO\
lO\
Oll\
l\

lOOOl\
OOlllO
)
{
ll\
lOOl\
O\
OOl\

(
(
vo\
id
*
)
lOO\
O\
lOOllOO
!=
(
void
*
)
lOOOlOOllOl
)
;
lll\
OOlO\
O\
Ol
(
(
void\

*
)
lOOOl\
OOllOO
!=
(
void
*
)
lO\
OOlOOlllO
)
;
ll\
lOO\
lOO\
O\
l\

(
(
void\

*
)
lO\
O\
OlO\
O\
llO\
l
!=
(
void
*
)
lO\
OOlOOl\
llO
)
;
__\
m12\
8\

lO\
O\
OlOO\
llll
;
__m\
12\
8
lOOOl\
O\
lOOOO
;
__m12\
8
lO\
OOlO\
lO\
OO\
l
;
__\
m\
1\
28
lOOOl\
Ol\
OOlO
;
const
__m1\
28
lOO\
O\
lOl\
OO\
l\
l
=
*
(
cons\
t
__m128
*
lOlOlOO\
l\
ll
)
lOOOlO\
Oll\
O\
l
;
const
__m1\
28
lOO\
OlOlOlO\
O\

=
*
(
cons\
t
__\
m1\
2\
8
*
)
&
lOOOlOO\
ll\
lO
->
v3\
X
;
const
__m\
128
lO\
OOlO\
lOlOl\

=
*
(
const
__m\
128
*
)
&
lO\
OOlOO\
lllO
->
v3Y
;
const
__m128
lOO\
O\
lOlO\
llO
=
*
(
con\
st
__m\
12\
8\

*
)
&
lO\
OO\
lOOl\
llO\

->
v3Z\

;
lOOOlOO\
lll\
l
=
(
__\
m128
&
)
_mm_\
shuffl\
e\
_e\
pi32
(
(
const
__\
m1\
28\
i
&
)
lO\
O\
O\
lO\
lOO\
ll
,
_M\
M_\
S\
HUFFLE
(
0
,
0
,
0
,
0
)
)
;
lOO\
OlO\
lOOOO
=
(
__m1\
28\

&
)
_mm_s\
huffle\
_e\
pi3\
2\

(
(
const
__m1\
2\
8i
&
)
lOO\
OlOlO\
Oll
,
_MM_\
SH\
U\
FFL\
E
(
1
,
1
,
1
,
1
)
)
;
lOO\
Ol\
OlOO\
Ol
=
(
__\
m1\
2\
8
&
)
_mm\
_\
s\
h\
u\
ffle_epi3\
2
(
(
const\

__m\
128i
&
)
lOOOlOlOO\
ll
,
_M\
M_SHUF\
FLE\

(
2
,
2
,
2
,
2
)
)
;
lO\
OOlOlOOlO
=
_mm_mul_ps
(
lOOOlOOllll
,
lOO\
OlO\
lO\
lO\
O\

)
;
lOO\
Ol\
O\
lOOOO
=
_mm\
_\
mul\
_p\
s
(
lO\
OO\
l\
OlOO\
OO\

,
lOOOlO\
lOlO\
l
)
;
lO\
O\
OlOlOOOl\

=
_mm_\
mul_\
ps
(
lOOOlOlOOOl
,
lOOOlO\
lOllO\

)
;
lOOOl\
OlOOlO
=
_mm_\
add_ps
(
lOOOl\
OlOOl\
O
,
lOOOlO\
lOO\
OO
)
;
lOO\
OlOlOOl\
O
=
_mm\
_add\
_p\
s
(
lOO\
OlOl\
OOlO
,
lOOOlOl\
O\
O\
Ol
)
;
*
(
__\
m128
*
)
lOOOlOO\
llO\
O
=
lOOOl\
OlOO\
lO
;
}
#endif
#ifdef TA_SSE2
lOlOlO\
lO\
O\
l
Vec3
TA_FAST_C\
ALL
opera\
tor
*
(
co\
nst
Vec3
&
lllllll\
ll
,
const
Mat33
&
lllOO\
lllll
)
{
Vec3
lOOOlOlOll\
l\

;
lOOOl\
OOl\
O\
ll
(
&
lO\
OOlO\
lOll\
l
,
&
lll\
llllll
,
&
lllOO\
llll\
l
)
;
return
lOOOlOlOlll
;
}
#else
inlin\
e\

Vec3\

TA\
_\
FA\
ST_CA\
L\
L
operat\
or
*
(
cons\
t
Ve\
c\
3
&
lllllllll
,
const
Mat\
33\

&
ll\
l\
OO\
lllll
)
{
Vec3
lOOOlOlOlll
;
lOOOl\
O\
lOlll
.
x
=
ll\
ll\
llll\
l
.
x
*
lllOOl\
llll
.
M11\

(
)
+
lll\
llllll
.
y
*
lllOOl\
ll\
ll
.
M21
(
)
+
lllll\
l\
lll\

.
z
*
ll\
l\
OOl\
lll\
l\

.
M31
(
)
;
lOO\
Ol\
Ol\
Ol\
ll
.
y
=
lllllll\
l\
l
.
x
*
ll\
lOOlll\
ll
.
M12
(
)
+
llllllll\
l
.
y
*
lllOOlllll
.
M22
(
)
+
ll\
lll\
llll\

.
z
*
ll\
lO\
O\
lllll
.
M32
(
)
;
lO\
O\
OlOlOlll
.
z
=
ll\
lllllll
.
x
*
lllOOl\
l\
lll\

.
M1\
3
(
)
+
lllll\
l\
l\
ll
.
y
*
lll\
OO\
ll\
lll
.
M23
(
)
+
llllllll\
l
.
z
*
lll\
OOll\
ll\
l
.
M33
(
)
;
return
lOOOl\
O\
lOlll
;
}
#endif
inl\
ine
Vec3
opera\
t\
or
/
(
const
Vec3
&
ll\
l\
lll\
lll\

,
con\
s\
t
Mat\
3\
3\

&
ll\
l\
O\
Olll\
ll
)
{
Vec3
lOO\
OlOlOll\
l
;
lOOO\
OOOllO
(
ll\
l\
OOlllll\

.
IsOrth\
o\
go\
na\
l\

(
)
,
"Vec3 operator / (const Vec3& v3A, const Mat33& m33B). The matrix is not orthogonal.\n""(operator / assumes orthogonal for speed)")
;
Mat33
::
Mu\
lBy\
Tran\
spos\
e
(
llllll\
l\
l\
l
,
lllOOll\
ll\
l
,
lOOOlOlO\
ll\
l
)
;
re\
turn
lOOOlOl\
Ol\
ll\

;
}
in\
l\
in\
e
Ve\
c3
&
operator
*=
(
Vec3
&
lllll\
llll\

,
const
Mat33\

&
lllO\
Olll\
ll
)
{
llll\
llll\
l
=
lllllll\
ll
*
lllOOl\
ll\
ll
;
ret\
u\
rn\

ll\
lllllll
;
}
inline\

Vec\
3
&
operator
/=
(
Vec3\

&
lllllllll\

,
const\

Mat3\
3
&
lllOO\
l\
llll
)
{
llll\
l\
l\
lll
=
llll\
ll\
lll
/
lll\
OOllll\
l\

;
return
lllllllll
;
}
inl\
i\
ne\

bo\
ol
Mat33
::
ope\
rator
==
(
const\

Mat33\

&
lOOO\
Oll\
lOl\
l
)
const
{
ret\
u\
rn
v3\
X\

==
lOOO\
OlllO\
ll
.
v3X
&&
v3\
Y
==
lOOOOll\
lO\
ll
.
v3Y\

&&
v3\
Z
==
lOOOO\
lllOll
.
v3\
Z
;
}
inline\

bo\
ol
Mat\
33
::
op\
e\
rator
!=
(
cons\
t\

Mat33
&
lOOOOlllO\
ll\

)
const
{
ret\
ur\
n
v3\
X
!=
lO\
OOOl\
ll\
Oll
.
v3X
||
v3Y
!=
lOO\
OOlllOl\
l
.
v3Y
||
v3\
Z
!=
lOOO\
Oll\
l\
Oll
.
v3Z\

;
}
inline
float
Ma\
t\
33\

::
Get\
Det\
e\
rminant
(
)
const
{
lO\
lOOl\
O\
OOl
(
"Mat33::GetDeterminant. Not implemented.")
;
return
1.0f
;
}
inline\

fl\
oat\

Ma\
t33
::
Get\
Dete\
rmin\
a\
nt
(
con\
st
Mat33
&
lOO\
O\
Ol\
l\
lOll
)
{
retu\
r\
n
lOOOO\
ll\
lOl\
l
.
GetDe\
ter\
mina\
nt
(
)
;
}
inl\
ine
vo\
id
Mat\
33
::
In\
v\
e\
rt
(
)
{
*
this
=
GetIn\
v\
ers\
e
(
)
;
}
in\
li\
ne
Mat33
Ma\
t3\
3
::
Get\
I\
nve\
rse
(
const
Mat3\
3\

&
lOO\
OOlllOl\
l\

)
{
retur\
n
lO\
OOO\
l\
l\
lOll
.
Get\
Inverse
(
)
;
}
inline\

Mat33
Ma\
t\
33
::
Get\
Inverse\

(
)
const
{
Ma\
t33
lO\
O\
OlO\
l\
lO\
OO
;
lO\
O\
OlOl\
l\
O\
OO
.
M11
(
)
=
(
M2\
2\

(
)
*
M33
(
)
-
M3\
2
(
)
*
M23
(
)
)
;
lO\
O\
Ol\
Ol\
lO\
OO
.
M21
(
)
=
-
(
M21\

(
)
*
M33\

(
)
-
M31\

(
)
*
M23
(
)
)
;
lOOOlOl\
l\
OOO
.
M31
(
)
=
(
M21
(
)
*
M3\
2\

(
)
-
M31
(
)
*
M22\

(
)
)
;
float
lO\
O\
OlOl\
l\
OOl
=
M11
(
)
*
lOO\
O\
lOllOO\
O
.
M1\
1
(
)
+
M12
(
)
*
lO\
O\
OlOl\
l\
O\
OO\

.
M21
(
)
+
M13
(
)
*
lOOO\
lO\
llOOO
.
M31
(
)
;
lOOO\
O\
OOl\
lO
(
lOOOl\
Oll\
OOl
!=
0.0f
,
"Mat33::GetInverse. The matrix is singular.")
;
lOOOlOllO\
OO
.
M12
(
)
=
-
(
M12
(
)
*
M33
(
)
-
M32
(
)
*
M13
(
)
)
;
lOOOlOll\
OO\
O\

.
M2\
2
(
)
=
(
M11
(
)
*
M33
(
)
-
M31
(
)
*
M13\

(
)
)
;
lOOOlOllOOO
.
M32
(
)
=
-
(
M1\
1\

(
)
*
M32
(
)
-
M31
(
)
*
M1\
2
(
)
)
;
lOOOl\
OllO\
OO\

.
M13
(
)
=
(
M12\

(
)
*
M23\

(
)
-
M22
(
)
*
M1\
3
(
)
)
;
lO\
O\
OlOllOOO
.
M23
(
)
=
-
(
M11
(
)
*
M23
(
)
-
M2\
1
(
)
*
M13
(
)
)
;
lOOOlOl\
lOO\
O\

.
M33
(
)
=
(
M1\
1
(
)
*
M22
(
)
-
M21\

(
)
*
M12
(
)
)
;
float
lOO\
OlOllO\
lO
=
1.0f
/
lOOOlOllOO\
l
;
lOOOlOllOOO
*=
lOOOlOl\
lOl\
O
;
re\
tur\
n
lOOOlOllOO\
O
;
}
in\
lin\
e
vo\
i\
d
Mat33
::
Ort\
hogon\
ali\
se\

(
)
{
lOOOOOO\
llO\

(
!
v3\
X\

.
IsZe\
ro
(
)
,
"Mat33::Orthogonalise. Orthogonalise Failed")
;
v3X
.
Norm\
alis\
e\

(
)
;
v3Y
=
v3\
X
.
Cross
(
v3Y\

)
.
Cross\

(
v3X
)
;
lOOOO\
OOll\
O
(
!
v3Y
.
IsZe\
r\
o
(
)
,
"Mat33::Orthogonalise. Orthogonalise Failed")
;
v3\
Y
.
No\
r\
m\
al\
is\
e\

(
)
;
v3\
Z
=
v3X
.
Cr\
o\
s\
s
(
v3Y
)
;
}
inlin\
e
bool
Mat\
33
::
IsO\
rthogonal
(
)
con\
s\
t
{
co\
ns\
t
flo\
at
lOOOl\
O\
l\
l\
Oll
=
0.005f
;
floa\
t
lO\
OOO\
Oll\
lO
=
Vec\
3\

::
Do\
t
(
Ve\
c\
3
::
Cr\
o\
ss\

(
v3X
,
v3Y\

)
,
v3Z\

)
;
floa\
t
llOlll\
OOO\
O\

=
Fab\
s
(
lOOOO\
OlllO
-
1.0f
)
;
retur\
n
llOl\
llO\
OOO\

<
lO\
OO\
l\
Oll\
Ol\
l
;
}
in\
l\
i\
n\
e
void
Mat33
::
Set\
ToIdenti\
ty
(
)
{
M11\

(
)
=
1.0f
;
M12
(
)
=
0.0f
;
M13
(
)
=
0.0f
;
M21\

(
)
=
0.0f
;
M2\
2
(
)
=
1.0f
;
M23
(
)
=
0.0f
;
M31
(
)
=
0.0f
;
M32
(
)
=
0.0f
;
M33\

(
)
=
1.0f
;
}
inl\
ine\

Ma\
t33
Ma\
t\
33
::
GetI\
denti\
ty\

(
)
{
Mat3\
3
lllOl\
OOOOl
;
lllO\
lOOO\
O\
l
.
SetToIden\
t\
ity
(
)
;
retu\
rn
ll\
lOlOO\
OOl
;
}
inline\

vo\
id
Mat\
33
::
Tra\
nspos\
e
(
)
{
*
th\
is
=
GetTran\
sp\
o\
se
(
)
;
}
inlin\
e
Mat\
33
Mat\
33
::
Ge\
tTra\
nspose
(
const
Ma\
t33
&
lOOOOlllOll
)
{
retu\
rn
lOOOOlllOll
.
GetTranspos\
e
(
)
;
}
inline
Ma\
t3\
3
Mat33\

::
Ge\
tT\
ransp\
o\
s\
e
(
)
co\
n\
st
{
Ma\
t3\
3
ll\
l\
OlOOOOl
;
ll\
lOlOOOOl
.
M11\

(
)
=
M11\

(
)
;
lll\
O\
lO\
O\
OOl
.
M12\

(
)
=
M21\

(
)
;
lllO\
lOOOO\
l\

.
M1\
3\

(
)
=
M3\
1\

(
)
;
lll\
O\
lO\
OO\
O\
l\

.
M2\
1
(
)
=
M12
(
)
;
lll\
OlOOOOl
.
M22
(
)
=
M22
(
)
;
lllOl\
OOOO\
l\

.
M23
(
)
=
M3\
2\

(
)
;
lllOl\
OO\
OOl\

.
M31
(
)
=
M13
(
)
;
lllOl\
OOO\
Ol
.
M32
(
)
=
M2\
3\

(
)
;
lllOl\
O\
OOOl
.
M3\
3\

(
)
=
M33
(
)
;
return
lllOl\
OOOO\
l\

;
}
inline
void\

Mat3\
3
::
TransposeAsI\
n\
ve\
r\
t\

(
)
{
*
this
=
Ge\
t\
Tra\
n\
s\
po\
seAsInv\
e\
rse\

(
)
;
}
in\
li\
ne
Mat\
33
Mat\
33\

::
GetTrans\
pose\
AsIn\
v\
e\
r\
se
(
con\
s\
t
Ma\
t\
33
&
lOOOOlllOll\

)
{
return\

lOOOOll\
lO\
ll\

.
GetTr\
an\
sp\
os\
eAs\
Inve\
rse
(
)
;
}
inline
Ma\
t3\
3
Mat33\

::
Ge\
tTr\
an\
sposeAsI\
nver\
s\
e
(
)
co\
nst
{
lOO\
OO\
OOl\
lO
(
IsOrtho\
g\
o\
nal\

(
)
,
"Mat33::GetTransposeAsInverse. The matrix is not orthogonal.")
;
re\
tur\
n\

Ge\
t\
Transpos\
e
(
)
;
}
}

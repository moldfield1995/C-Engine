//---------------------------------------------------------------------------------
// File Name: zcta003.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

namespace
TA\

{
te\
mplat\
e
<
cla\
ss\

Typ\
e
>
List
<
Type
>
::
Lis\
t
(
)
{
lO\
O\
OOOlOl\
ll\

=
0
;
lOO\
OOOllOOl
=
0
;
}
te\
m\
plate
<
class
Type\

>
Lis\
t\

<
Ty\
pe
>
::
~
List
(
)
{
Fi\
n\
al\
ise
(
)
;
}
te\
mp\
la\
te\

<
class\

Type
>
void
List
<
Type
>
::
Fi\
nal\
i\
s\
e\

(
)
{
Clea\
r
(
)
;
}
te\
mplat\
e\

<
class
Type
>
void
Lis\
t\

<
Typ\
e
>
::
Cl\
ear
(
)
{
while
(
lOOOOOlO\
lll
)
{
lO\
O\
llO\
O\
OO\
O
*
lOOll\
lOOOl
=
lOOOOOl\
Ol\
l\
l
;
lOO\
OOOlOlll
=
lO\
OOO\
OlOlll
->
lOO\
OOOl\
O\
OO\
l\

;
lO\
Ol\
OOOO\
OO
(
lOOlllO\
O\
Ol
,
lOO\
l\
l\
O\
OOO\
O
)
;
}
lO\
OO\
OOl\
lO\
Ol
=
0
;
}
templat\
e
<
cl\
as\
s\

Type
>
int
List
<
Type
>
::
lO\
OOll\
lOOl\

(
)
const\

{
int
lOOl\
llOl\
lO
=
0
;
for
(
lO\
O\
O\
O\
OlOOl\
l
lOlO\
O\
l\
OOl\
O
=
lOO\
OOOl\
lOOO
(
)
;
!
lOlO\
O\
lOOlO\

.
At\
En\
d\

(
)
;
++
lOl\
OOl\
OOlO
)
lOO\
ll\
lOllO
++
;
ret\
urn
lO\
OlllOl\
l\
O\

;
}
templa\
te
<
cl\
a\
ss
Type
>
bool
Li\
st
<
Type\

>
::
lOOOOOl\
OlO\
O
(
)
co\
ns\
t
{
retu\
rn
!
lOOOO\
OlOl\
ll
;
}
templ\
a\
t\
e
<
clas\
s
Type
>
Type
&
Li\
st
<
Type
>
::
operator\

[
]
(
int
lOOOlOO\
ll\
l
)
{
lO\
OO\
O\
OOll\
O
(
lOOOl\
OOl\
ll\

>=
0
,
"List::operator []. Index out of bounds.")
;
Iter\
ator
lO\
l\
OO\
l\
O\
OlO\

=
lO\
lOOOOl\
OO
(
)
;
for\

(
in\
t
llOllOOll\
l
=
0
;
ll\
OllOOl\
l\
l\

!=
lOOOlOO\
lll\

;
++
llOl\
l\
OOlll
,
++
lOlOOlO\
Ol\
O
)
{
lOOOOOOll\
O
(
!
lOlOOlOOlO\

.
At\
End
(
)
,
"List::operator []. Index out of bounds.")
;
}
retu\
rn\

*
lOlOO\
lOO\
l\
O
;
}
temp\
l\
ate
<
class
Type
>
co\
nst\

Ty\
pe
&
List
<
Ty\
pe
>
::
op\
er\
ator\

[
]
(
int\

lOOOlOOlll
)
co\
ns\
t
{
lOOOOOO\
llO\

(
lOOOlOOlll
>=
0
,
"List::operator []. Index out of bounds.")
;
It\
era\
tor
lOlOOlO\
O\
lO
=
lO\
l\
O\
O\
OO\
lO\
O
(
)
;
for\

(
in\
t\

llOllOO\
lll
=
0
;
llOll\
OO\
lll\

!=
lOOOlOO\
l\
ll
;
++
lOOOl\
O\
O\
lll
,
++
lOl\
OOlO\
Ol\
O
)
{
lOOOOOOllO\

(
!
lOlOOlOOlO\

.
At\
E\
nd
(
)
,
"List::operator []. Index out of bounds.")
;
}
re\
t\
urn
*
lOl\
O\
OlO\
OlO
;
}
tem\
p\
la\
te
<
cl\
ass
Type
>
Ty\
pe\

&
List
<
Type\

>
::
lO\
OOlll\
OOO
(
)
{
if
(
lO\
O\
OO\
O\
l\
l\
OOl
)
{
lOOOOOllOlO
(
lOO\
OOOllO\
Ol
->
lOO\
O\
OOlOO\
Ol
,
lO\
O\
l\
lOO\
OOO
)
;
lOOOOOl\
l\
OO\
l
=
lOOOOO\
llOOl
->
lOOOOOlOOO\
l
;
}
else\

{
TA_ASSE\
RT
(
lOOO\
O\
O\
lO\
l\
ll\

==
0
)
;
lO\
OOOOll\
OlO
(
lOOOO\
Oll\
OOl
,
lO\
OllOOO\
OO
)
;
lO\
OOO\
Ol\
Ol\
ll
=
lOO\
O\
OOll\
OO\
l
;
}
lOOOOO\
llOO\
l
->
lOOO\
OO\
lOOOl
=
0
;
retu\
r\
n
lOOOOO\
l\
lOOl
->
lOOO\
OOlO\
O\
lO\

;
}
temp\
late
<
class
Type\

>
vo\
id
Li\
st
<
Typ\
e
>
::
lOO\
OOO\
lO\
lO\
l
(
co\
n\
st\

Typ\
e\

&
lOOO\
l\
O\
OllO
)
{
lOOl\
l\
O\
OOO\
O
*
lOOlllO\
OOl\

=
lOOOO\
OlOll\
l\

;
if
(
lO\
OlllOOO\
l\

->
lO\
OOO\
OlOO\
l\
O
==
lOOOlOO\
llO
)
{
lOOOOOl\
Olll
=
lO\
OlllO\
OOl\

->
lO\
O\
O\
OOlOO\
O\
l\

;
if
(
lO\
O\
OOOlOlll\

==
0
)
lOOO\
OOll\
O\
Ol
=
0
;
lOOl\
OOOO\
OO
(
lOO\
lllOOOl
,
lO\
O\
llOOOOO\

)
;
ret\
u\
rn\

;
}
while
(
lOOlllO\
OOl\

->
lOO\
O\
O\
O\
l\
OOO\
l
)
{
lOOllOOOOO
*
lOOOOOl\
OOO\
l
=
lO\
O\
ll\
l\
OOOl\

->
lOOO\
OOlOOOl
;
if
(
lOOOOOlOOOl
->
lOO\
OO\
OlO\
O\
lO
==
lOOOlOO\
ll\
O\

)
{
lOOl\
llOO\
Ol
->
lOOO\
OO\
l\
OOO\
l\

=
lO\
O\
OO\
OlO\
O\
O\
l
->
lOO\
OO\
O\
lOOOl\

;
if
(
lOOO\
OOlO\
OO\
l
==
lOO\
OOOllOOl
)
lOOOOOll\
OOl\

=
lOOl\
llO\
O\
Ol\

;
lOOlO\
O\
OOO\
O\

(
lO\
OO\
O\
O\
lOOOl
,
lOO\
llOOOO\
O
)
;
retur\
n
;
}
lOO\
l\
llOOOl
=
lOOOOOlOOO\
l\

;
}
}
temp\
late
<
clas\
s
Ty\
pe
>
vo\
i\
d
List\

<
Ty\
pe
>
::
lO\
Olll\
ll\
ll\

(
con\
st
Ty\
pe
*
lOOOO\
O\
lOllO\

)
{
lOOllOOOO\
O
*
lOOlllOOOl
=
lO\
OO\
OOlOlll\

;
if
(
&
lOOll\
lOO\
Ol
->
lOOOOOlOO\
l\
O
==
lOOO\
O\
Ol\
O\
llO
)
{
lOO\
OOOlO\
lll
=
lO\
O\
lllOO\
O\
l
->
lOOO\
OO\
lOO\
Ol
;
if\

(
lOOOOOlO\
l\
ll\

==
0
)
lOOOOO\
l\
l\
OO\
l
=
0
;
lOOlOO\
OOOO
(
lO\
O\
lll\
O\
OOl\

,
lOOl\
l\
O\
OOOO
)
;
return
;
}
whi\
le
(
lOO\
lllOOOl
->
lOO\
O\
OOlO\
OO\
l
)
{
lOOllOOOO\
O\

*
lOOOOOl\
OOO\
l\

=
lOO\
lll\
OO\
Ol
->
lO\
O\
OOOlOOOl
;
if\

(
&
lOO\
OOOlOOOl\

->
lOOOOOlOO\
lO
==
lO\
O\
OOOl\
OllO
)
{
lOOlllOO\
O\
l\

->
lOOOO\
O\
lO\
O\
Ol\

=
lO\
O\
O\
O\
OlOO\
Ol
->
lOOO\
O\
O\
lOOOl
;
if
(
lOOOOO\
lO\
OOl
==
lOOO\
OOll\
OOl
)
lOOO\
OOllO\
Ol
=
lO\
Ol\
llOOOl
;
lOOl\
O\
OOO\
OO
(
lOO\
OOOlOOOl
,
lOOllOOOOO
)
;
return
;
}
lOOll\
lO\
OO\
l\

=
lO\
OOOOlOOOl
;
}
}
}

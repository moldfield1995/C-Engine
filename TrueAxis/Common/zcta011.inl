//---------------------------------------------------------------------------------
// File Name: zcta011.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
namesp\
ac\
e
TA\

{
inl\
ine
Vec3\

oper\
at\
or
*
(
flo\
at\

lO\
OOOOlll\
O
,
co\
nst
Vec\
3
&
llllOOlOOl
)
{
Vec\
3
lOOO\
lO\
lOlll
(
lOOOOOl\
llO
*
llllOOlOOl
.
x
,
lOO\
O\
OO\
lll\
O
*
llllO\
Ol\
OOl
.
y
,
lOOOOOlll\
O\

*
llllOOlO\
Ol
.
z
)
;
retur\
n\

lOOOl\
OlO\
ll\
l\

;
}
in\
line
int\

Vec\
3\

::
GetGreatestAxis
(
)
con\
st
{
fl\
oa\
t
lOlO\
OOO\
OO\
lO\

=
Fab\
s\

(
x
)
;
flo\
a\
t
lOl\
OOOOOOll\

=
Fabs
(
y
)
;
fl\
oat
lOl\
O\
O\
OOO\
lOO
=
Fabs\

(
z
)
;
if
(
lOlOOOOOOl\
O
>
lOlO\
OOOOO\
l\
l\

)
{
if\

(
lOlOOOOOOlO
>
lOlO\
OOO\
OlOO
)
re\
turn
AXIS_X
;
else
re\
turn\

AXIS_Z
;
}
el\
s\
e\

{
if
(
lOlOO\
OO\
OOll
>
lO\
lO\
OO\
OO\
l\
O\
O
)
return
AXIS_Y\

;
else
re\
t\
urn
AXIS\
_Z\

;
}
}
inl\
ine
vo\
i\
d
Vec3\

::
Ge\
tAxisOr\
der
(
int
llll\
O\
O\
lOll
[
3
]
)
co\
nst
{
flo\
at\

lOlO\
O\
OOOOl\
O\

=
Fabs
(
x
)
;
floa\
t\

lOlOOO\
O\
OOl\
l
=
Fa\
bs
(
y
)
;
floa\
t
lOlOOOOOl\
O\
O
=
Fa\
bs
(
z
)
;
if
(
lO\
lO\
OO\
OOOlO
>
lOlOOOOOOll
)
{
if
(
lOlO\
OOOOO\
l\
O
>
lO\
lOOOO\
OlOO
)
{
ll\
llOOlOll
[
0
]
=
AXI\
S_\
X
;
if
(
lOl\
OO\
OOO\
O\
l\
l
>
lOl\
OOOOOl\
O\
O\

)
{
ll\
llOOl\
Oll\

[
1
]
=
AXI\
S_Y
;
llll\
OOlOll
[
2
]
=
AXIS_Z
;
}
el\
s\
e
{
llllOOlO\
ll
[
1
]
=
AXI\
S_Z
;
llllOOl\
Oll
[
2
]
=
AXIS_Y\

;
}
}
el\
se\

{
llll\
OO\
l\
O\
ll\

[
0
]
=
AXIS_\
Z
;
llll\
OOlOll\

[
1
]
=
AXIS_X\

;
llllOOl\
Ol\
l
[
2
]
=
AXI\
S_Y\

;
}
}
els\
e\

{
if
(
lOlOOOOOOll\

>
lO\
l\
O\
OOOOlOO
)
{
llllO\
Ol\
Oll
[
0
]
=
AX\
IS\
_\
Y
;
if\

(
lO\
lOOOOO\
OlO
>
lOlOOOOO\
l\
O\
O\

)
{
llllOOlOl\
l
[
1
]
=
AXIS\
_\
X
;
llll\
OO\
lOl\
l
[
2
]
=
AXI\
S_Z
;
}
else
{
ll\
l\
lOOl\
Ol\
l
[
1
]
=
AX\
IS_Z
;
lll\
lOO\
lOl\
l
[
2
]
=
AXI\
S_X
;
}
}
el\
se\

{
lll\
lOOl\
Oll
[
0
]
=
AXI\
S_\
Z
;
llllOOlOll\

[
1
]
=
AX\
IS\
_Y\

;
lll\
l\
OO\
lO\
ll\

[
2
]
=
AXI\
S\
_X
;
}
}
TA_AS\
SERT
(
Fa\
b\
s
(
Ge\
tAx\
is
(
ll\
ll\
OO\
lOll
[
0
]
)
)
>=
Fa\
bs
(
GetA\
xi\
s
(
llllOOl\
Oll
[
1
]
)
)
)
;
TA\
_ASSERT
(
Fab\
s
(
GetA\
xis
(
llllOOlOll\

[
1
]
)
)
>=
Fabs
(
GetA\
xi\
s
(
llllO\
Ol\
Oll
[
2
]
)
)
)
;
}
in\
line
const
Ve\
c\
3
&
Vec3
::
GetU\
n\
itVect\
or
(
int
lOOOl\
OOl\
ll\

)
{
swi\
tch
(
lO\
OOlOOlll
)
{
cas\
e
AXIS_X
:
retu\
rn
k_v3UnitX
;
break
;
ca\
se\

AXI\
S_Y
:
return
k_v3Un\
i\
tY
;
bre\
ak
;
case
AX\
IS_Z\

:
re\
tu\
r\
n
k_v3Un\
itZ
;
bre\
a\
k
;
defa\
ult
:
lllOO\
lOOOO
;
return
k_v3Unit\
X\

;
}
}
inline\

bool
Vec3\

::
IsE\
qua\
lWit\
h\
InError
(
co\
nst
Vec3
&
llllO\
OlO\
O\
l
,
fl\
o\
at
llOll\
l\
OOO\
O
)
co\
nst
{
Vec3
lOlOO\
O\
OO\
l\
Ol
=
*
th\
is
-
lll\
lO\
OlOOl
;
re\
t\
urn\

Fabs
(
lO\
lOO\
OOO\
lOl
.
x
)
<=
llO\
lllOOOO
&&
Fabs\

(
lO\
lOOO\
O\
Ol\
Ol\

.
y
)
<=
ll\
Ol\
l\
lOOOO
&&
Fab\
s\

(
lOlOOOOOl\
Ol
.
z
)
<=
llO\
ll\
l\
O\
OOO\

;
}
}

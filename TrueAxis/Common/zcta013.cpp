//---------------------------------------------------------------------------------
// File Name: zcta013.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define lOOOllOOOOl
#include "MemoryMgr.h"
#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
#ifndef TA_TYPES_H
#include "Types.h"
#endif //
#ifdef TA_MSVC
#include <malloc.h>
#endif //
#ifdef TA_GCC
#include <malloc.h>
#endif //
#include <stdlib.h>
name\
s\
pace
TA
{
#ifndef DOXYGEN
#ifdef _DEBUG
int\

lO\
OO\
lOllllO
=
0
;
ch\
ar
*
lOO\
OlOll\
l\
ll\

=
0
;
#endif //
stat\
i\
c
Memory\
Mgr
::
FnA\
llocCallB\
ack
lOOOllOOlOl\

=
0
;
static
MemoryMgr
::
FnFreeCallB\
ack
lO\
OOll\
OOllO
=
0
;
static
MemoryMgr
::
FnD\
bgAllocCal\
lBac\
k
lOOOl\
l\
O\
Olll
=
0
;
st\
ati\
c\

Memo\
ryM\
gr
::
FnDb\
gF\
reeCa\
l\
lB\
a\
ck\

lOOOllO\
l\
O\
O\
O
=
0
;
stat\
ic\

int
lO\
OOllO\
l\
OO\
l\

=
0
;
st\
atic
in\
t
lOO\
Ol\
lOlOlO\

=
0
;
#endif //
bo\
ol\

TA\
C\
_CALL
Mem\
or\
yMgr
::
SetAlloc
(
FnAllocCallB\
ack\

lOOOllOlO\
ll
)
{
if
(
lOO\
OllOlOOl\

!=
0
&&
lOOO\
l\
lOl\
O\
lO
!=
0
)
retur\
n
false
;
lO\
O\
O\
llO\
OlOl
=
lOOOll\
OlOll
;
return
true\

;
}
boo\
l\

TAC_C\
A\
LL
Memory\
M\
gr
::
Set\
Free
(
FnFr\
e\
eC\
allB\
ack
lOOOllOll\
O\
O\

)
{
if\

(
lOO\
O\
l\
lOl\
OOl
!=
0
&&
lOOO\
l\
l\
O\
lOlO
!=
0
)
retu\
rn
false
;
lOO\
O\
ll\
O\
Ol\
lO
=
lOOOllOllOO
;
ret\
urn
tr\
ue\

;
}
bool
TAC_CAL\
L
Me\
moryM\
gr
::
SetDbgAllo\
c\

(
FnD\
bg\
A\
ll\
ocCallBac\
k
lO\
OOllOllOl
)
{
if\

(
lOOOll\
OlOO\
l
!=
0
&&
lOOOl\
l\
OlOlO\

!=
0
)
retu\
r\
n
false
;
lOOO\
llOOll\
l
=
lO\
OOl\
l\
OllOl
;
return
true
;
}
bool\

TAC_CAL\
L
Mem\
o\
ryMgr
::
SetDbgFre\
e
(
Fn\
DbgFreeCallBack\

lOOO\
llOl\
llO\

)
{
if\

(
lO\
OO\
l\
lO\
lOOl
!=
0
&&
lOOOl\
lO\
lOlO\

!=
0
)
return
false
;
lOOO\
l\
lO\
lOO\
O
=
lOOOllOlllO
;
retu\
rn
tr\
ue
;
}
void\

TA\
C_CALL
MemoryMgr
::
lOOOl\
lOOOlO
(
)
{
lO\
O\
Ol\
lOlOO\
l\

++
;
}
voi\
d
TAC_C\
AL\
L
Memory\
M\
gr
::
lOOO\
llOO\
O\
l\
l
(
)
{
lO\
OOll\
O\
lOOl
--
;
TA_\
ASSERT\

(
lOOOllOlOOl\

>=
0
)
;
}
vo\
id
*
TAC_CALL
Memory\
Mg\
r
::
DbgAllo\
c
(
unsigned
int\

lOOlllOll\
O\

,
unsign\
ed\

int
lO\
OOllO\
llll\

,
co\
ns\
t
char
*
lllOOO\
l\
O\
ll
,
int
lllOOOO\
l\
OO
)
{
lO\
O\
Ol\
lOlO\
lO\

++
;
void
*
lO\
Ol\
llOOOO
;
if
(
TA
::
lOOOllOOlll
)
lO\
Ol\
l\
lO\
OOO\

=
TA
::
lOOOll\
OOlll\

(
lO\
O\
lllOllO\

,
lOOO\
llO\
l\
lll
,
lllOO\
OlOll
,
lllOOO\
OlOO
)
;
els\
e\

#if defined(lOlOlOOllO)
return
memalign\

(
lOOOllO\
ll\
ll
,
lO\
OlllOl\
lO
)
;
#elif defined(TA_GCC)
retu\
rn\

__mi\
n\
gw_ali\
gn\
ed_malloc
(
lOOll\
lOl\
lO\

,
lOO\
OllOllll
)
;
#else
re\
tu\
r\
n\

_a\
lign\
ed_\
m\
al\
loc\

(
lOO\
lllO\
ll\
O
,
lOOOllO\
llll
)
;
#endif
lOOO\
OOOllO
(
(
(
uS\
ize
)
lOOll\
lOOOO\

&
(
lO\
OO\
llOll\
ll
-
1
)
)
==
0
,
"MemoryMgr::DbgAlloc: memory not aligned.")
;
retu\
rn
lOOlll\
OO\
OO
;
}
void\

TAC_CA\
L\
L
Me\
moryMgr
::
Dbg\
Fr\
ee
(
vo\
id
*
lO\
OOlOll\
lO\
O\

,
co\
n\
st
char
*
lllO\
OO\
lOl\
l\

,
int
lll\
OOOOl\
O\
O\

)
{
lOOOll\
OlOlO\

--
;
lOOOOOOllO
(
lOOO\
l\
l\
O\
l\
Ol\
O
>=
0
,
"MemoryMgr::Free: More memory deallocated then allocated")
;
if
(
TA
::
lO\
O\
OllOlO\
OO
)
TA
::
lOOOllOlO\
O\
O
(
lO\
O\
O\
l\
OlllOO
,
lllOOOl\
Oll
,
ll\
lO\
OOOlOO\

)
;
el\
se
#if defined(lOlOlOOllO)
fre\
e
(
lO\
OO\
lO\
lllOO
)
;
#elif defined(TA_GCC)
__mingw_a\
l\
igned_\
fr\
ee
(
lOOOlOlllO\
O
)
;
#else
_a\
ligne\
d_free
(
lOO\
OlO\
ll\
lOO\

)
;
#endif
}
voi\
d
*
TA\
C_\
CA\
LL\

Memory\
Mgr
::
Alloc
(
uns\
igned
int
lOOlllOll\
O\

,
unsigne\
d\

in\
t
lOOOl\
lOllll
)
{
lOO\
O\
llOlOlO\

++
;
if
(
TA
::
lOOOllOOl\
Ol
)
retu\
r\
n
TA
::
lOOOllO\
OlOl\

(
lO\
O\
l\
llO\
l\
l\
O
,
lOOO\
llO\
llll
)
;
el\
se
#if defined(lOlOlOOllO)
retu\
rn
mem\
al\
i\
g\
n
(
lOOOllOll\
ll\

,
lO\
Olll\
Ol\
l\
O\

)
;
#elif defined(TA_GCC)
return
__m\
i\
n\
gw_\
a\
li\
gne\
d_ma\
lloc
(
lO\
Olll\
O\
llO\

,
lO\
OOllOll\
ll
)
;
#else
return\

_alig\
ne\
d_malloc
(
lO\
Oll\
lOllO
,
lOOOllOlll\
l
)
;
#endif
}
voi\
d
TAC_CA\
LL
Memo\
r\
yMgr
::
Fr\
ee
(
void\

*
lOOOl\
Oll\
lOO
)
{
lO\
OOll\
OlO\
lO
--
;
lOOOOOOllO
(
lOO\
O\
llOlO\
lO
>=
0
,
"MemoryMgr::Free: More memory deallocated then allocated")
;
if
(
TA
::
lOO\
OllOOl\
lO
)
TA
::
lOOOll\
OOll\
O
(
lO\
O\
OlOlllOO
)
;
else
#if defined(lOlOlOOllO)
fr\
ee
(
lO\
OOl\
OlllOO
)
;
#elif defined(TA_GCC)
__m\
ingw\
_aligned\
_\
fr\
ee
(
lOOOlO\
ll\
lO\
O
)
;
#else
_aligne\
d_f\
ree
(
lOO\
OlOl\
llOO\

)
;
#endif
}
int
TAC\
_CA\
LL
Me\
mo\
ryMgr
::
Get\
Nu\
m\
All\
oc\
a\
tio\
n\
s\
UnF\
reed\

(
)
{
retur\
n
lOOOllOlOlO
;
}
}

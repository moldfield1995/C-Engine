//---------------------------------------------------------------------------------
// File Name: zcta009.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef TA_MEMORYMGR_H
#include "MemoryMgr.h"
#endif //
na\
me\
spac\
e\

TA
{
te\
mpl\
ate
<
clas\
s
Type
>
lOOllOl\
lO\
l\
l
<
Typ\
e
>
::
lOOll\
O\
l\
lOll\

(
)
{
TA_ASSE\
R\
T\

(
sizeof
(
lO\
OllOOOO\
O\

)
>
si\
ze\
of
(
0
)
)
;
lO\
lO\
OlOllO
=
0
;
lOlOOO\
lOOl
=
0
;
lOOllOll\
lOl
=
0
;
lOOll\
O\
l\
l\
lOO
=
0
;
}
template
<
cla\
ss\

Type
>
lOO\
llO\
l\
lO\
ll
<
Type\

>
::
~
lOOllOll\
Oll\

(
)
{
Finalise\

(
)
;
}
tem\
plate
<
class
Type
>
voi\
d
lOOl\
lO\
l\
lOll
<
Type
>
::
In\
iti\
ali\
s\
e
(
int
lOOlllO\
llO
)
{
TA_A\
SS\
E\
R\
T
(
lOOlllO\
llO
>
0
)
;
lO\
lOO\
OlO\
Ol
=
lOOlllOllO
;
lOOllOlllOO
=
lOlOOOlOOl
;
lOO\
Oll\
l\
l\
OO\

(
lOlO\
OlOllO
,
lO\
O\
llOOO\
OO
,
lO\
lOOOlO\
Ol
)
;
TA_ASSERT\

(
lOlO\
Ol\
Oll\
O
)
;
lOO\
llOlll\
Ol
=
lOl\
OO\
lOllO
;
int
lO\
OO\
l\
lO\
OOl
;
for\

(
lOOOllOOO\
l
=
0
;
lOOO\
ll\
OOOl
<
lOlOOOlOOl\

-
1
;
lOOOllO\
OOl
++
)
{
lO\
Ol\
lOlll\
lO\

(
lOlOOlOll\
O
[
lO\
OOllOO\
O\
l\

]
)
=
&
lOlOO\
lO\
llO
[
lO\
OOllOOO\
l
]
+
1
;
}
}
te\
mplate
<
class
Typ\
e
>
void
lOO\
llOllOll
<
Ty\
pe
>
::
Finalise
(
)
{
TA_ASS\
ERT
(
lOOllOl\
l\
lOO
==
lOlOOOlOOl
)
;
lO\
l\
OOOlOOl
=
0
;
lOOll\
O\
lllOl\

=
0
;
lOOll\
Oll\
lOO
=
0
;
lOlO\
O\
O\
lllO
(
lOlOOlOl\
lO\

,
lO\
Ol\
l\
OOOOO
)
;
lOlO\
OlOl\
lO\

=
0
;
}
template\

<
class
Type\

>
Ty\
pe
*
lOOl\
lO\
ll\
Oll
<
Typ\
e
>
::
All\
oc
(
)
{
TA_ASSERT
(
lO\
lO\
OlO\
llO\

)
;
if
(
!
lO\
Ol\
l\
O\
lll\
Ol
)
re\
turn
0
;
Type
*
lOOl\
l\
Olllll
=
&
lOOll\
OlllO\
l
->
lOOOOOlO\
O\
l\
O
;
lOO\
llOlll\
Ol
=
lOOll\
Ol\
ll\
lO
(
*
lOO\
ll\
O\
lllO\
l
)
;
TA\
_\
AS\
SERT\

(
(
u32
)
lOOllOlll\
Ol
-
(
u32
)
lO\
lOO\
lOllO
<
lO\
lO\
OOlOOl
*
sizeof
(
lO\
O\
l\
lOOOOO\

)
)
;
lOO\
l\
l\
Ol\
llOO
--
;
re\
turn
lO\
OllO\
ll\
l\
l\
l\

;
}
te\
m\
plate
<
clas\
s\

Ty\
p\
e\

>
void
lOO\
l\
lOll\
Ol\
l
<
Type
>
::
Fr\
ee\

(
Ty\
p\
e
*
lOOlll\
O\
OOO
)
{
TA\
_ASSERT
(
lOl\
O\
OlOllO
)
;
TA_AS\
SERT
(
(
u32
)
lOO\
ll\
lOOO\
O\

-
(
u32
)
lOlOO\
lO\
l\
l\
O
<
lOlOOOlOO\
l\

*
si\
z\
e\
of
(
lO\
Ol\
lOOOO\
O
)
)
;
lO\
OllOOO\
OO
*
lOOll\
lOOOl
=
reinterpr\
et_ca\
s\
t
<
lO\
Ol\
lOOO\
O\
O\

*
>
(
lO\
Oll\
l\
OOOO
)
;
lOOllOl\
l\
ll\
O
(
*
lOO\
l\
llOO\
Ol
)
=
lOOllOlllO\
l\

;
lO\
O\
llOlllOl
=
lOO\
l\
ll\
O\
OOl
;
lOOllOll\
lOO
++
;
}
}

//---------------------------------------------------------------------------------
// File Name: zcta013.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

namespace
TA
{
__\
forceinlin\
e
Vec3
TA_V\
E\
C3_\
CA\
LL
op\
era\
tor
*
(
co\
n\
st
Vec\
3
&
lllllllll\

,
con\
st
Vec3
&
lOO\
OOO\
O\
O\
OO
)
{
ret\
urn
(
Vec3
&
)
_mm_mu\
l\
_ps\

(
(
__m128
&
)
lllll\
ll\
ll\

,
(
__\
m128
&
)
lOOO\
OOOOO\
O
)
;
}
__fo\
rce\
i\
nlin\
e\

Vec\
3\

TA\
_VEC3\
_CA\
LL
ope\
rat\
o\
r
*
(
fl\
o\
at
lll\
lOOO\
O\
Ol
,
const
Ve\
c3
&
lO\
O\
OO\
OO\
OOO\

)
{
Vec3
lOO\
OO\
l\
lOl\
ll
=
lOOOOO\
O\
OOO
;
__m128\

lOlOO\
lll\
l\
O\
O\

=
_mm_set\
_p\
s1
(
lll\
lOOOO\
Ol
)
;
(
__m128
&
)
lO\
OOOllOlll
=
_m\
m\
_mul\
_ps
(
(
__\
m128
&
)
lOOO\
Oll\
Ol\
ll
,
lOlOO\
l\
lll\
OO
)
;
return\

lOOO\
OllOlll
;
}
__\
forcei\
nl\
ine\

Vec3\

TA_V\
EC3_CALL\

opera\
t\
or
*
(
co\
ns\
t\

Vec\
3\

&
lOOOOOOOOO\

,
float
llll\
OOOOOl
)
{
Ve\
c3
lOOOO\
l\
lO\
lll
=
lO\
OOOOOOO\
O
;
__m12\
8\

lO\
lOOllll\
OO\

=
_mm\
_set1_ps
(
lll\
l\
OOOOO\
l
)
;
(
__m\
128
&
)
lOOOOll\
O\
ll\
l
=
_m\
m_m\
ul_p\
s
(
(
__m1\
28
&
)
lO\
OO\
OllO\
lll
,
lOlOO\
llllOO\

)
;
return
lOOOOllOlll
;
}
te\
m\
plate
<
clas\
s
lOlOOOl\
OOOO
,
cla\
ss\

lO\
lOO\
OlOO\
O\
l
>
__\
forcein\
line\

float
TA_VEC3_CALL
operat\
o\
r
*
(
cons\
t\

lOlOOOOOl\
lO
::
lOl\
OOl\
O\
l\
Ol\
O
<
lOlO\
O\
OlOO\
O\
O
>
&
lO\
lOOl\
ll\
lOl
,
con\
st
lO\
lOOOOOl\
lO\

::
lOlOOlOlOl\
O
<
lOlO\
OOlO\
OOl
>
&
lOl\
OOl\
l\
lll\
O\

)
{
ret\
ur\
n
(
(
Vec\
3
&
)
lO\
lOOl\
lllO\
l\

.
lOlOOlOlOll
(
)
*
(
Vec3
&
)
lOlOOllll\
lO\

.
lOlOOl\
Ol\
O\
ll\

(
)
)
.
x
;
}
templ\
ate
<
clas\
s
Ty\
pe
>
__\
fo\
rceinline
float
TA_VEC3_C\
ALL
ope\
rator\

*
(
flo\
at\

llllOOOOOl\

,
co\
nst
lOlOO\
O\
OOl\
lO
::
lOlOOlOlO\
lO
<
Type
>
&
lOlOOll\
ll\
l\
O
)
{
ret\
ur\
n
llllO\
OO\
OOl
*
lO\
lOOllll\
lO
.
lO\
lOO\
lOllOO
(
)
;
}
te\
m\
plate
<
class\

Ty\
pe\

>
__for\
ceinline\

float
TA\
_VEC3_\
CALL
ope\
rat\
or
*
(
cons\
t
lOlO\
OOOO\
llO\

::
lOl\
OOlO\
lO\
l\
O
<
Type\

>
&
lO\
lOOl\
llllO\

,
floa\
t
ll\
ll\
O\
OOOO\
l
)
{
retu\
rn
lOlOO\
ll\
lll\
O\

.
lOlOOlOllO\
O
(
)
*
lll\
lOOOOOl\

;
}
template
<
cla\
ss\

Typ\
e
>
__f\
or\
ceinline\

Vec3
TA_VEC3_C\
A\
L\
L
ope\
r\
at\
or
*
(
con\
s\
t
Vec3
&
llllll\
lll
,
const
lO\
lOOOOO\
l\
lO
::
lOl\
OOlO\
lO\
lO
<
Type
>
&
lOlO\
OlllllO
)
{
return
lll\
l\
lllll
*
(
Vec3
&
)
lO\
lOOlllll\
O
.
lOl\
OO\
lOl\
Ol\
l
(
)
;
}
templ\
ate
<
cla\
ss\

Ty\
pe
>
__\
f\
or\
ceinli\
n\
e
Vec\
3\

TA\
_VEC3_CALL
op\
er\
at\
o\
r
*
(
con\
s\
t
lO\
lO\
O\
OOO\
llO\

::
lOlOOlOlOlO\

<
Type\

>
&
lOlOO\
lllllO
,
const
Vec3
&
ll\
lllllll
)
{
re\
t\
urn
(
Vec3
&
)
lOlO\
Ollll\
lO
.
lO\
lOO\
lOl\
Ol\
l
(
)
*
llllll\
lll\

;
}
__fo\
rce\
inline
Vec3
TA_VEC3_\
CALL
op\
era\
to\
r\

/
(
const
Vec3
&
ll\
lllllll\

,
const
Vec3\

&
lO\
OOOOO\
OOO
)
{
re\
turn
(
Ve\
c3\

&
)
_m\
m_d\
iv\
_p\
s\

(
(
__\
m128
&
)
llll\
lllll
,
(
__m1\
28
&
)
lOO\
O\
OOOOO\
O
)
;
}
__\
fo\
rcei\
n\
lin\
e\

Vec3\

TA\
_VEC3_CAL\
L
op\
era\
tor
/
(
co\
ns\
t
Ve\
c3\

&
lOOOOO\
OOO\
O\

,
float
ll\
llOOOO\
Ol
)
{
Vec3
lOOO\
Oll\
Olll
=
lOOOOOOOOO
;
__m\
128\

lOl\
OOll\
llO\
O
=
_mm_\
set_ps1
(
llllO\
OOOOl
)
;
(
__m\
128
&
)
lOOOOllOlll
=
_m\
m_div_p\
s
(
(
__m\
128
&
)
lOOO\
OllOlll
,
lOlOOllllOO
)
;
retu\
rn
lOOO\
O\
llOlll\

;
}
templat\
e\

<
cla\
ss
lO\
l\
O\
OOlOO\
OO
,
cla\
s\
s
lOl\
OO\
OlOOO\
l
>
__forceinl\
i\
n\
e
floa\
t
TA_\
VEC3_CALL
op\
e\
rato\
r
/
(
co\
ns\
t
lOlOOO\
OOllO
::
lO\
lO\
OlOlO\
lO
<
lOlOO\
OlOOO\
O\

>
&
lOlO\
Ol\
l\
llO\
l
,
cons\
t\

lOlOOOOO\
llO
::
lOlO\
OlOl\
Ol\
O\

<
lOlOOOlOOOl
>
&
lO\
lOOl\
ll\
l\
lO
)
{
re\
turn
(
(
Ve\
c3
&
)
lOlO\
Ol\
l\
ll\
Ol
.
lOlO\
OlOl\
O\
ll
(
)
/
(
Vec\
3
&
)
lOlOO\
l\
llll\
O
.
lO\
lOO\
lOlOll\

(
)
)
.
x
;
}
templa\
te
<
cl\
a\
ss
Typ\
e
>
__force\
inl\
in\
e\

float\

TA_V\
E\
C3_C\
A\
LL
operat\
o\
r
/
(
floa\
t\

llllOOOOOl
,
cons\
t
lOl\
OOO\
OOllO
::
lOlO\
OlO\
lO\
lO
<
Type
>
&
lOl\
O\
O\
ll\
lllO\

)
{
ret\
u\
rn
ll\
l\
lOOOOOl
/
lO\
lO\
OlllllO\

.
lOlOO\
lOllOO
(
)
;
}
tem\
pla\
t\
e
<
class
Type
>
__\
forc\
e\
inline
float
TA_V\
EC3_CALL
ope\
r\
ator
/
(
co\
n\
s\
t
lOlOOO\
O\
OllO
::
lOlO\
OlOlOlO
<
Type
>
&
lOlOOllll\
lO
,
flo\
at
llllOO\
OOOl
)
{
ret\
urn
llllO\
OOOOl
/
lOlO\
Oll\
ll\
lO\

.
lO\
lOO\
lOllOO\

(
)
;
}
te\
m\
p\
late\

<
cl\
ass
Type\

>
__for\
ceinli\
ne
Vec\
3
TA\
_VEC\
3_CALL
opera\
to\
r
/
(
co\
nst
Ve\
c\
3
&
ll\
l\
l\
l\
l\
ll\
l
,
cons\
t
lOl\
OOOOOllO\

::
lO\
lOOlO\
lOl\
O
<
Ty\
pe
>
&
lOl\
OOl\
llllO
)
{
ret\
ur\
n\

lllllllll
/
(
Vec3
&
)
lOlOOl\
llllO\

.
lO\
lOOlOlOl\
l\

(
)
;
}
templa\
te\

<
class
Type
>
__forcein\
line
Vec\
3
TA_VEC3_CAL\
L
oper\
ato\
r
/
(
co\
ns\
t\

lO\
l\
O\
OOO\
O\
llO\

::
lOlO\
O\
lO\
lOlO\

<
Type\

>
&
lOlOO\
l\
llllO\

,
con\
s\
t
Vec3
&
llllll\
l\
ll
)
{
return\

lllllll\
l\
l\

/
(
Vec\
3\

&
)
lOlOOlllllO\

.
lO\
lO\
OlOlOl\
l
(
)
;
}
__\
for\
ceinline
Vec3
TA\
_VEC3\
_CALL
op\
e\
rato\
r\

+
(
const
Ve\
c\
3
&
lllllllll
,
const
Ve\
c3
&
lOO\
OOOOOOO\

)
{
Vec3\

lOlOOl\
lOOlO
;
(
__m\
128
&
)
lOl\
O\
O\
llOOl\
O\

=
_mm_\
add_ps\

(
(
__\
m\
12\
8
&
)
lllll\
llll
,
(
__m128
&
)
lOOO\
OO\
OOOO
)
;
re\
turn\

lOlOOllO\
O\
lO
;
}
__\
forc\
ein\
li\
ne
Ve\
c\
3
TA_VEC3_C\
ALL
op\
e\
rator
-
(
const\

Vec3
&
ll\
l\
llllll
,
const
Vec\
3
&
lOOOOOOOO\
O
)
{
Ve\
c3\

lOlOOl\
lO\
OlO
;
(
__m12\
8\

&
)
lOlOOll\
OOlO\

=
_mm_sub\
_ps
(
(
__m128
&
)
lll\
l\
lllll
,
(
__m128\

&
)
lO\
OO\
OOOOOO
)
;
return\

lO\
lOOl\
lOO\
lO
;
}
__f\
orc\
einline
Ve\
c3\

&
TA_VEC3\
_CALL\

operat\
or\

*=
(
Vec3
&
llll\
l\
lll\
l\

,
fl\
o\
at
lll\
l\
OOO\
Ol\
O\

)
{
__m12\
8
lOl\
OO\
lll\
lOO
=
_mm_s\
et\
_p\
s1
(
ll\
l\
lOO\
OOlO
)
;
llll\
l\
lll\
l\

=
(
Ve\
c3
&
)
_m\
m_m\
ul\
_ps\

(
(
__\
m1\
28
&
)
lllll\
llll
,
lOlOOllllOO
)
;
return
lll\
lll\
lll
;
}
te\
mplate\

<
clas\
s
Type
>
__forceinline\

Vec3
&
TA\
_VEC3_\
CALL
op\
era\
tor
*=
(
Vec3
&
lllllllll\

,
con\
s\
t
lO\
lOOOOOllO
::
lOlOOlOlO\
lO
<
Type
>
&
lOlOOlllll\
O
)
{
llllllll\
l\

=
(
Vec3\

&
)
_mm_\
m\
ul_\
p\
s
(
(
__\
m12\
8
&
)
llllllll\
l
,
(
__m12\
8
&
)
lOlOOlll\
llO\

.
lO\
l\
OOl\
O\
lO\
l\
l\

(
)
)
;
re\
t\
u\
rn\

lll\
lllll\
l\

;
}
__f\
orcei\
nli\
n\
e\

Vec\
3
&
TA\
_\
VEC\
3_CAL\
L\

op\
erato\
r
/=
(
Vec\
3\

&
llll\
l\
llll
,
floa\
t
lll\
l\
OOOOl\
O\

)
{
__m1\
28
lO\
lOO\
llll\
OO
=
_mm_\
set\
_\
ps\
1
(
ll\
llOOOOl\
O
)
;
lllllllll
=
(
Vec3
&
)
_mm\
_div_p\
s\

(
(
__m12\
8
&
)
lll\
lllll\
l
,
lO\
l\
O\
Ollll\
OO
)
;
re\
turn
llll\
l\
ll\
ll
;
}
template\

<
clas\
s
Type\

>
__f\
o\
rce\
inline
Vec\
3
&
TA_VEC3\
_C\
A\
L\
L
ope\
rat\
or
/=
(
Vec\
3
&
llllll\
lll\

,
con\
st
lOlOOO\
OOllO
::
lOlOOl\
OlOlO
<
Type
>
&
lO\
lOO\
l\
ll\
ll\
O
)
{
lllllllll
=
(
Vec3\

&
)
_mm_di\
v_ps\

(
(
__m128
&
)
ll\
ll\
llll\
l
,
(
__m128\

&
)
lO\
lOOl\
llllO
.
lOlOOlOlOl\
l\

(
)
)
;
return\

lllll\
l\
lll\

;
}
__\
forcei\
nl\
ine
in\
t
Vec3
::
GetG\
reatestAx\
is
(
)
con\
st
{
flo\
at
lO\
lOOOO\
OOlO
=
Fab\
s
(
x
)
;
float
lOlO\
OO\
OOOll\

=
Fabs
(
y
)
;
flo\
at\

lOl\
OOOOOlOO
=
Fabs
(
z
)
;
if
(
lO\
l\
OOOOOOl\
O
>
lO\
l\
O\
O\
OOOOll
)
{
if
(
lOlOOOOOO\
lO
>
lOlOO\
OOO\
l\
OO
)
retur\
n
AXI\
S\
_X
;
else
return
AX\
IS_\
Z
;
}
els\
e
{
if
(
lOl\
O\
O\
OO\
OOl\
l\

>
lOlOOOO\
Ol\
OO
)
ret\
urn
AXI\
S\
_Y\

;
else
return
AXIS\
_\
Z
;
}
}
__\
fo\
r\
c\
ei\
nline\

vo\
i\
d
Vec3
::
Get\
AxisOr\
d\
er
(
int\

llllOOl\
Oll
[
3
]
)
const
{
floa\
t
lOl\
OOOOO\
Ol\
O
=
Fabs\

(
x
)
;
float
lOl\
O\
O\
O\
OOOll
=
Fab\
s
(
y
)
;
floa\
t\

lOl\
OOO\
OOlOO
=
Fabs
(
z
)
;
if
(
lOlOOOO\
OO\
lO
>
lOl\
OOOOOOll
)
{
if
(
lOl\
O\
O\
OOOOlO\

>
lOl\
OOO\
O\
OlOO
)
{
llllOOlOll\

[
0
]
=
AXIS\
_X
;
if
(
lO\
lOO\
OO\
OO\
l\
l\

>
lOl\
OOOOO\
lO\
O
)
{
llll\
OOl\
O\
ll
[
1
]
=
AXIS_Y
;
llll\
O\
Ol\
Oll
[
2
]
=
AXIS_Z
;
}
el\
se
{
ll\
llOOlO\
ll
[
1
]
=
AX\
IS_\
Z
;
llllO\
OlO\
l\
l
[
2
]
=
AX\
IS\
_Y
;
}
}
else
{
ll\
llOOl\
Oll
[
0
]
=
AX\
IS_Z
;
ll\
l\
l\
OOl\
Oll
[
1
]
=
AXI\
S\
_\
X
;
ll\
llOO\
lOl\
l\

[
2
]
=
AX\
I\
S_\
Y
;
}
}
el\
s\
e
{
if
(
lOlOOOOOOll
>
lO\
l\
OO\
OO\
OlOO
)
{
ll\
llO\
OlOl\
l
[
0
]
=
AXIS_Y
;
if
(
lOlOOOO\
OOlO
>
lOlO\
OOOO\
l\
OO
)
{
llllOOlOl\
l
[
1
]
=
AXI\
S_X\

;
llll\
OO\
l\
Ol\
l
[
2
]
=
AXIS_Z
;
}
else
{
ll\
llOOlOl\
l
[
1
]
=
AXIS_Z
;
llll\
OO\
lOll\

[
2
]
=
AXIS_\
X
;
}
}
els\
e
{
lll\
l\
OOlOl\
l\

[
0
]
=
AXIS_Z\

;
llllOOlOll
[
1
]
=
AX\
IS_Y
;
llll\
OOlO\
l\
l
[
2
]
=
AX\
IS_X
;
}
}
TA_\
ASSERT\

(
Fabs
(
Get\
Axis
(
llllOO\
lO\
ll
[
0
]
)
)
>=
Fabs
(
GetAx\
i\
s
(
llllO\
Ol\
Ol\
l
[
1
]
)
)
)
;
TA_\
ASSER\
T
(
Fabs\

(
Get\
Axis
(
ll\
l\
lO\
O\
lOll
[
1
]
)
)
>=
Fabs\

(
GetAx\
i\
s
(
llllOOlOl\
l
[
2
]
)
)
)
;
}
__f\
orc\
ei\
nline\

const
Ve\
c3\

&
Vec3
::
Get\
UnitVe\
ctor
(
in\
t
lO\
OOlOOlll
)
{
switc\
h
(
lO\
OOl\
O\
Olll
)
{
ca\
s\
e\

AX\
I\
S\
_X
:
ret\
u\
r\
n
k_v3Uni\
tX
;
br\
eak\

;
case
AXIS_Y\

:
re\
t\
urn\

k_v3U\
nitY
;
break
;
ca\
se
AXIS_Z\

:
return
k_v3Unit\
Z
;
br\
e\
ak
;
defaul\
t\

:
lllOOl\
OOO\
O
;
re\
turn
k_v3Uni\
t\
X\

;
}
}
inl\
in\
e
bo\
o\
l
Ve\
c3
::
IsEq\
ual\
Wit\
h\
InEr\
ror
(
const
Ve\
c\
3\

&
llllOOlOOl
,
fl\
oat
ll\
O\
lll\
OOOO
)
co\
ns\
t
{
Vec3\

lOlOOOO\
OlO\
l
=
*
this
-
llllO\
OlOOl
;
retu\
rn
Fa\
b\
s
(
lOlOOOO\
Ol\
Ol
.
x
)
<=
llOll\
lOOOO
&&
Fabs\

(
lOlOOOOOl\
Ol
.
y
)
<=
llOl\
ll\
OOO\
O\

&&
Fabs
(
lO\
l\
OOOOOlOl\

.
z
)
<=
ll\
OlllOO\
OO\

;
}
}

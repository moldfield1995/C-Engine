//---------------------------------------------------------------------------------
// File Name: zcta014.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "MFrame.h"
nam\
espa\
ce
TA
{
vo\
id\

MFram\
e\

::
Mir\
r\
or
(
const
Ve\
c3\

&
lOO\
OlllO\
OOO
,
const
Vec3
&
lOOOlllOOOl
)
{
lO\
OOO\
O\
O\
ll\
O
(
lOOO\
lllO\
OOO
.
IsNo\
r\
malised
(
)
,
"MFrame::Mirror. v3DirectionToMirror isn't normalised.")
;
v3\
T\
r\
an\
slati\
on
-=
2.0f
*
lOO\
O\
l\
ll\
OOOO
.
Dot
(
v3\
Translation
-
lOOOll\
lO\
OOl
)
*
lOOO\
l\
llOOOO
;
lO\
OOOO\
OllO
(
m33\
R\
ot\
a\
t\
ion
.
IsOr\
thogo\
n\
al\

(
)
,
"MFrame::Mirror. Matrix isn't Orthogonal")
;
Mat33
lOOOlllOOl\
O
;
lOO\
O\
lllO\
O\
l\
O
.
SetToL\
o\
ok\
Do\
w\
nVector\

(
lOOOlll\
OO\
OO\

)
;
float\

lOO\
Olll\
OOl\
l
=
lOOO\
lllOOlO\

.
v3Y
.
Dot
(
m33Rota\
ti\
on\

.
v3X
)
;
flo\
at\

lOO\
OlllOlOO
=
lO\
O\
O\
ll\
lOOlO
.
v3X
.
Dot
(
m3\
3Ro\
tat\
io\
n
.
v3X
)
;
fl\
oat\

lOO\
O\
ll\
lOl\
O\
l
=
lOOO\
lllO\
O\
l\
O\

.
v3X\

.
Dot
(
m33R\
otation\

.
v3Y\

)
;
float
lOOOlllOllO
=
-
lOOOlllOO\
l\
O
.
v3Y
.
Do\
t
(
m33Ro\
tation\

.
v3Y
)
;
Mat3\
3
lOOOl\
llOlll
;
if\

(
lOOOlllOOl\
l
*
lO\
OOlllO\
Oll
+
lOOOlllOlO\
O
*
lOOOlllOlOO
>
lO\
OOlllO\
l\
O\
l\

*
lOOO\
l\
llOlO\
l
+
lOOOlllOllO
*
lOOOlllOllO
)
lOOO\
l\
llOlll\

.
Initial\
ise
(
lOOO\
lll\
OOO\
O\

,
ATa\
n2
(
lOO\
OlllOOll
,
lO\
OOl\
ll\
O\
lO\
O
)
)
;
el\
se
lOOOlll\
Oll\
l
.
Init\
ia\
lis\
e
(
lOOO\
lll\
OOO\
O
,
ATan2
(
lO\
O\
Oll\
lOlO\
l
,
lO\
OOl\
llO\
llO\

)
)
;
m33R\
otation
*=
lOO\
Ol\
l\
lOll\
l\

.
GetTranspo\
s\
eAsInve\
rs\
e\

(
)
;
m3\
3\
Ro\
tat\
io\
n\

=
m3\
3Ro\
t\
a\
ti\
o\
n
.
GetT\
ransp\
os\
eAsI\
n\
verse\

(
)
;
m33\
Ro\
tatio\
n
*=
lO\
OOlllOll\
l
;
lOOO\
O\
O\
Ol\
lO\

(
m33Rotat\
ion
.
IsO\
rth\
ogon\
al
(
)
,
"MFrame::Mirror. Matrix isn't Orthogonal")
;
}
#define lOOOOlOlllO(lOOOllOOOl, lOOlOOlOlO) (((float*)lOOOOlOllll)[((lOOOllOOOl) - 1) * 4 + ((lOOlOOlOlO) - 1)])
void
MFrame\

::
In\
itiali\
se\

(
D3DXM\
ATR\
IX
*
lOO\
OO\
lO\
ll\
l\
l\

)
{
m3\
3\
Rotation
.
M11
(
)
=
lOOO\
OlOlllO
(
1
,
1
)
;
m3\
3\
Rotati\
on\

.
M12\

(
)
=
lO\
OO\
OlOll\
lO
(
1
,
2
)
;
m33Rotati\
on\

.
M13\

(
)
=
lOO\
OOl\
O\
ll\
lO\

(
1
,
3
)
;
m33\
Rota\
t\
i\
on\

.
M2\
1
(
)
=
lO\
OOOlOlllO
(
2
,
1
)
;
m33R\
otat\
ion
.
M2\
2
(
)
=
lOOO\
OlO\
lllO
(
2
,
2
)
;
m33R\
o\
tation
.
M23
(
)
=
lOO\
OOlOlllO
(
2
,
3
)
;
m33R\
ot\
atio\
n\

.
M31
(
)
=
lOOOOl\
O\
lll\
O
(
3
,
1
)
;
m33\
Rota\
tion
.
M32
(
)
=
lOOOOlOll\
lO
(
3
,
2
)
;
m3\
3Rot\
atio\
n\

.
M33
(
)
=
lOOOO\
l\
O\
l\
l\
lO\

(
3
,
3
)
;
v3Tra\
nsla\
tion
.
x
=
lOOO\
Ol\
O\
lll\
O
(
4
,
1
)
;
v3T\
ran\
slatio\
n\

.
y
=
lO\
O\
OOlO\
l\
ll\
O
(
4
,
2
)
;
v3Transl\
ati\
o\
n\

.
z
=
lOOO\
OlOl\
llO
(
4
,
3
)
;
}
void\

MF\
ra\
me
::
GetAsD3\
DMa\
trix
(
D3DX\
MATRIX
*
lO\
O\
OOl\
Ollll
)
cons\
t\

{
lO\
OOOlOl\
ll\
O
(
1
,
1
)
=
m33\
Rotatio\
n
.
M11\

(
)
;
lOO\
OO\
lO\
lllO\

(
1
,
2
)
=
m33R\
o\
t\
ati\
on
.
M12
(
)
;
lO\
O\
OOlOll\
lO
(
1
,
3
)
=
m33Rotation\

.
M13
(
)
;
lOOOOlOlllO
(
1
,
4
)
=
0.0f
;
lOOOOlOll\
lO
(
2
,
1
)
=
m3\
3\
Rotation\

.
M21
(
)
;
lOO\
OOlOll\
lO\

(
2
,
2
)
=
m33Rotation
.
M22
(
)
;
lOO\
OOlOl\
l\
lO
(
2
,
3
)
=
m33\
Rotation
.
M23\

(
)
;
lOO\
OO\
lO\
lllO
(
2
,
4
)
=
0.0f
;
lOOOOlOlllO
(
3
,
1
)
=
m33\
Ro\
ta\
ti\
on
.
M3\
1
(
)
;
lO\
OO\
OlOl\
ll\
O
(
3
,
2
)
=
m33\
R\
o\
t\
ation
.
M32
(
)
;
lOOO\
O\
lOl\
llO
(
3
,
3
)
=
m33R\
o\
t\
ation\

.
M33\

(
)
;
lO\
O\
O\
OlO\
lllO
(
3
,
4
)
=
0.0f
;
lOOOOlO\
l\
l\
lO\

(
4
,
1
)
=
v3\
Trans\
lati\
on
.
x
;
lOOOOl\
Olll\
O
(
4
,
2
)
=
v3T\
ra\
ns\
lation
.
y
;
lOO\
O\
O\
lOl\
ll\
O
(
4
,
3
)
=
v3Tra\
ns\
l\
a\
tion\

.
z
;
lO\
OO\
OlOl\
llO
(
4
,
4
)
=
1.0f
;
}
#undef lOOOOlOlllO
#define lOOOllllOOO(lOOOllOOOl, lOOlOOlOlO) (((float*)lOOOllllOOl)[((lOOOllOOOl) - 1) * 4 + ((lOOlOOlOlO) - 1)])
void
MF\
r\
am\
e
::
InitialiseFr\
o\
mOp\
enGlMatrix
(
const
flo\
at
*
lO\
OOllllOO\
l
)
{
m33R\
ota\
ti\
o\
n\

.
M11
(
)
=
lOOO\
llll\
OOO\

(
1
,
1
)
;
m3\
3Rotation
.
M12\

(
)
=
lOOOllllOOO
(
1
,
2
)
;
m33Ro\
tatio\
n
.
M13
(
)
=
lO\
O\
Olll\
l\
OOO\

(
1
,
3
)
;
m3\
3R\
o\
tat\
ion\

.
M21
(
)
=
lOOOl\
ll\
l\
OOO\

(
2
,
1
)
;
m33Ro\
tation
.
M22\

(
)
=
lO\
O\
Olll\
lOO\
O
(
2
,
2
)
;
m33Ro\
tation
.
M23\

(
)
=
lOOOllllOOO
(
2
,
3
)
;
m33Rotat\
ion
.
M31
(
)
=
lOOOllllOOO
(
3
,
1
)
;
m3\
3Rota\
tion
.
M32
(
)
=
lOOOl\
ll\
l\
OO\
O\

(
3
,
2
)
;
m3\
3Rot\
ation
.
M33
(
)
=
lOO\
OllllOOO\

(
3
,
3
)
;
v3Tr\
ans\
lat\
ion
.
x
=
lOOOl\
ll\
lOOO
(
4
,
1
)
;
v3Translati\
on
.
y
=
lOOO\
llllOOO\

(
4
,
2
)
;
v3\
T\
r\
a\
nslat\
i\
o\
n
.
z
=
lOO\
O\
llllO\
OO
(
4
,
3
)
;
}
voi\
d
MFrame
::
Get\
OpenGl\
M\
at\
rix
(
floa\
t
*
lO\
OOllllO\
O\
l
)
con\
st
{
lOOO\
ll\
llO\
OO
(
1
,
1
)
=
m3\
3\
R\
o\
ta\
tion
.
M11\

(
)
;
lO\
O\
OllllOOO
(
1
,
2
)
=
m3\
3Rota\
tion
.
M12
(
)
;
lOOOllllOOO
(
1
,
3
)
=
m33Rotatio\
n
.
M13
(
)
;
lO\
OOl\
lllOO\
O
(
1
,
4
)
=
0.0f
;
lOOO\
l\
l\
l\
l\
O\
OO
(
2
,
1
)
=
m3\
3Rota\
tion\

.
M2\
1\

(
)
;
lO\
OOll\
llO\
OO
(
2
,
2
)
=
m33Rotati\
on
.
M22
(
)
;
lOOO\
llll\
OOO
(
2
,
3
)
=
m33Rota\
t\
i\
on
.
M23
(
)
;
lOOO\
llll\
OOO
(
2
,
4
)
=
0.0f
;
lOO\
O\
l\
ll\
lO\
OO
(
3
,
1
)
=
m33Rotat\
io\
n
.
M31
(
)
;
lO\
O\
O\
llllOOO
(
3
,
2
)
=
m33Ro\
tation
.
M32\

(
)
;
lOOOllllOOO\

(
3
,
3
)
=
m33Ro\
t\
a\
tion\

.
M3\
3
(
)
;
lO\
O\
Oll\
l\
lOO\
O
(
3
,
4
)
=
0.0f
;
lOOOlll\
l\
OOO\

(
4
,
1
)
=
v3Tran\
slation
.
x
;
lOOOll\
llOOO
(
4
,
2
)
=
v3Translatio\
n
.
y
;
lOOOllll\
O\
OO
(
4
,
3
)
=
v3Tr\
a\
n\
sla\
tion
.
z
;
lOOOl\
lllOO\
O
(
4
,
4
)
=
1.0f
;
}
#undef lOOOllllOOO
}

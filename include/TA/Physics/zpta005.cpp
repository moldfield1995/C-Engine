//---------------------------------------------------------------------------------
// File Name: zpta005.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define llOllOlOOll
#define lOllOllOOlO
#include "CollisionObjectAABBMesh.h"
#ifndef lOOllOllll
#include "../Common/zcta001.h"
#endif //
#ifndef lOlOOlllOO
#include "../Common/zcta003.h"
#endif //
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_ERROR_H
#include "../Common/Error.h"
#endif //
#ifndef llOllOOlOOO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_COLLISION_H
#include "Collision.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef llOllOlOlOO
#include "../Physics/zpta003.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
namespac\
e
TA
{
stati\
c
co\
ns\
t\

in\
t
ll\
Ol\
lOlOlOl
=
6
;
st\
ruc\
t
ll\
OllOl\
Ol\
lO
{
Vec3
lOOlOl\
Olll
;
Vec3
lOOO\
lOOOO\
O
;
floa\
t\

lO\
O\
lO\
ll\
OOO
;
Colli\
sion
*
llOllO\
lOl\
ll
;
con\
st
Collis\
ion\
ObjectAABBMe\
s\
h\

*
llOllOllOOO
;
boo\
l
lO\
llllOlO\
OO
;
}
;
str\
u\
ct
llO\
llO\
ll\
OOl
{
Col\
lisio\
n\
Ob\
j\
ectCach\
edPol\
yD\
a\
ta\

*
llO\
llOllOlO
;
const
CollisionOb\
j\
ec\
tAAB\
BMesh
::
Data
*
llOl\
lO\
llOl\
l
;
bool
llOl\
lOll\
l\
O\
O
;
}
;
#ifndef DOXYGEN
enum
ll\
OllOlllO\
l
{
ll\
OllO\
l\
ll\
lO
=
0xF0000000
,
llOl\
lOllll\
l
=
0x80000000
,
}
;
#endif //
void
CollisionObje\
ct\
A\
ABBMesh
::
Initialis\
e
(
int\

lO\
l\
lOll\
lOl\

,
int
ll\
Oll\
lOOlO
,
int\

llO\
lll\
OOOOO
)
{
if
(
lOlOO\
lOllO
)
{
lO\
O\
OOOO\
ll\
O
(
0
,
"CollisionObjectAABBMesh::Initialise. Already initialised.")
;
Finalis\
e
(
)
;
}
lOOOO\
OllOlO
(
lO\
lOOlO\
ll\
O
,
Data
)
;
lOlO\
OlO\
llO
->
llOll\
l\
OOOOl
.
Initialise
(
0
,
lO\
l\
lOl\
ll\
Ol
)
;
int
ll\
OlllOOO\
lO
=
llOlll\
OOl\
O
*
ll\
Oll\
O\
l\
Ol\
Ol\

+
ll\
OlllOOO\
OO\

;
lOlOOlOllO
->
lOll\
OOlllO
.
Initi\
alise
(
0
,
llOl\
llOO\
OlO
)
;
lO\
lOOlOllO
->
llOlllOOOll\

=
0
;
lOlOOlOl\
lO
->
llOlllOOlOO
.
Initia\
l\
ise
(
llOl\
llOOl\
O
)
;
}
void
Col\
li\
s\
i\
o\
nObjec\
t\
AABBM\
esh\

::
Fi\
n\
al\
i\
s\
e
(
)
{
if
(
lOlO\
O\
lOllO
)
{
lOOl\
O\
OO\
OO\
O\

(
lOl\
OOl\
OllO\

,
Data\

)
;
lOlOOlO\
l\
lO
=
0
;
}
}
void
Co\
llisio\
nO\
b\
je\
ct\
A\
ABBMesh
::
Ser\
i\
alis\
e\

(
Ser\
ial\
iser
&
lO\
O\
OlOllOl\

,
co\
nst
Version\

&
ll\
lOlOOlO\
O
)
{
lOOOOOOl\
lO\

(
lllOlOOlOO
<=
llOllO\
OllOO
,
"CollisionObjectAABBMesh::Serialise. The version number is too new.")
;
if
(
lO\
O\
Ol\
OllOl
.
lllOlOO\
lll
(
)
)
{
if
(
!
lOlOOlOll\
O
)
{
lO\
OOl\
l\
lO\
lO
(
0
,
"CollisionObjectAABBMesh::Serialise. Object not initialised, save failed.")
;
ret\
urn\

;
}
}
el\
se
{
if
(
lOlOOlOllO
)
{
lOOOOO\
OllO\

(
0
,
"CollisionObjectAABBMesh::Initialise. Already initialised.")
;
Finali\
s\
e
(
)
;
}
lOOOO\
OllOlO
(
lOlOOlOllO
,
Data\

)
;
}
lOOOlOll\
O\
l
.
lO\
O\
OlO\
lll\
l
(
lOl\
OOl\
Ol\
lO\

->
lOl\
lO\
O\
lll\
O
)
;
lOO\
Ol\
Ol\
lOl
.
lOOO\
lO\
l\
lll
(
lO\
lO\
O\
lOllO\

->
ll\
O\
lllOOO\
Ol
)
;
if
(
ll\
l\
OlOOlOO
>=
Vers\
ion\

(
1012
,
0
)
)
{
lOlOO\
lOllO\

->
llOlllOOlOO
.
Seriali\
se
(
lOOO\
lOllOl
,
&
lO\
l\
OOlO\
l\
lO
->
lO\
l\
l\
OOll\
lO\

[
0
]
)
;
}
else
{
TA_AS\
SERT
(
lOOOl\
Ol\
l\
Ol
.
lO\
O\
OllO\
OO\
O\

(
)
)
;
lO\
OOll\
lOlO
(
0
,
"CollisionObjectAABBMesh::Initialise. Old file format is being loaded, this may be slow.")
;
lOl\
OO\
lOll\
O
->
ll\
OlllOOlO\
O
.
lOOOllO\
Oll
(
lO\
OOlOl\
l\
Ol\

,
&
lOlOOlOllO
->
lO\
ll\
OO\
l\
llO\

[
0
]
)
;
}
}
voi\
d
Collisi\
on\
Obje\
ctA\
ABBMesh
::
Render
(
)
{
lOlOOlllOl
llOlllO\
OlO\
l
;
llOlll\
OOlOl
.
In\
i\
tialise\

(
&
lOlOOlOl\
lO
->
lOllO\
O\
lll\
O
[
0
]
,
lOl\
O\
Ol\
O\
llO
->
lO\
llOOlllO\

.
lO\
OOlll\
OOl
(
)
*
sizeof\

(
int
)
)
;
for
(
;
;
)
{
Poly\
g\
on\

*
llOlll\
OOllO
=
(
Pol\
ygo\
n\

*
)
llOll\
lOO\
lOl\

.
lOl\
Ol\
OOlO\
l
(
)
;
TA_ASSER\
T
(
llOlllOOllO
->
lOllOl\
l\
lO\
l\

<
lOlllOO\
lOll
)
;
fo\
r
(
in\
t
lO\
OOllOOOl
=
0
;
lOOOllOOOl
<
llOll\
lOOllO
->
lOl\
lO\
lll\
Ol\

;
lO\
OOll\
O\
OO\
l
++
)
{
Vec3
&
ll\
llOOOOll
=
lOlOOl\
OllO
->
llOlll\
OOOOl\

[
llOlllOOllO
->
llO\
llllOl\
O
[
lOO\
Ol\
lOOOl
]
]
;
Vec3
&
llll\
O\
O\
Ol\
O\
O
=
lOl\
O\
Ol\
OllO
->
llO\
ll\
lOO\
O\
Ol\

[
llOlll\
OOl\
lO
->
llOllllOl\
O
[
lOOOl\
lOOOl
+
1
<
ll\
Oll\
lOO\
l\
l\
O\

->
lO\
ll\
OlllOl\

?
lO\
OOl\
l\
O\
OOl
+
1
:
0
]
]
;
Physic\
sRende\
r
::
RenderLine
(
llllOOOOl\
l
,
lll\
lOOO\
lOO
,
0xffff0000
)
;
}
ll\
Ol\
llOO\
lOl\

.
lOl\
OlOOlO\
O
(
si\
zeof
(
float\

)
*
4
)
;
ll\
Ol\
llOOlO\
l
.
lOl\
OlOO\
OlO
(
)
;
ll\
OlllO\
Ol\
Ol
.
lO\
lOlOOOlO\

(
)
;
llOlllOOlOl\

.
lO\
l\
O\
lOOl\
O\
O
(
llOlllOOllO\

->
lO\
llOlllOl
*
sizeof\

(
int
)
)
;
if\

(
llOlllO\
OlOl\

.
AtE\
nd\

(
)
)
br\
eak
;
}
}
void
Coll\
is\
ionObj\
e\
c\
tA\
A\
BBMesh
::
AddVer\
tex
(
const
Vec\
3
&
llO\
OlllllO
)
{
lOl\
OOlOllO
->
llOlllO\
OOOl
.
lOOO\
lllOOO
(
llOOll\
ll\
lO\

)
;
}
void
Co\
lli\
sionObjectAAB\
BMe\
sh\

::
AddPo\
lygo\
n\

(
int
lOllOl\
llOl
,
const\

int
*
ll\
Ol\
l\
lOOlll
,
u32
ll\
Ol\
l\
lOlOOO\

)
{
if
(
lO\
ll\
Oll\
lOl
<
3
)
{
lOOO\
OO\
Ol\
lO
(
0
,
"CollisionObjectAABBMesh::AddPolygon. nNumVertices is < 3.")
;
retu\
r\
n
;
}
con\
st\

in\
t
llO\
l\
llOl\
OO\
l
=
lOlOOlOl\
lO\

->
lOl\
lOOl\
llO
.
lO\
OOlllOO\
l
(
)
;
lOl\
O\
O\
l\
OllO
->
lOl\
l\
OOlllO\

.
lOOll\
l\
l\
lOl
(
llO\
llOlOlOl\

+
lOl\
l\
Oll\
lOl\

)
;
Pol\
ygon
*
llO\
l\
l\
lO\
O\
l\
lO
=
(
Polygo\
n
*
)
&
lOl\
O\
OlOll\
O
->
lOll\
OOll\
lO
[
ll\
Olll\
OlOOl
]
;
ll\
O\
lll\
O\
Ol\
lO
->
llO\
lllOlOOO
=
llOl\
llOlOO\
O
&
0xFFFFFFF
;
llO\
lllOOllO\

->
lOllOlllOl\

=
lOllOlllOl
;
if\

(
llO\
lllO\
Oll\
O
->
lO\
ll\
Olll\
Ol
>
lOlll\
OOlOll
)
{
lOOOO\
OOllO\

(
0
,
"CollisionObjectAABBMesh::AddPolygon. nNumVertices is > k_nMaxNumVerticesInPolygon.")
;
llOll\
lO\
O\
ll\
O
->
lOll\
O\
lllOl
=
lOlllOOlO\
ll
;
}
int
lOlllO\
lOOl
;
for
(
lOlllO\
l\
O\
Ol
=
0
;
lOlll\
OlOOl\

<
llOlllO\
O\
llO
->
lOllOlllOl
;
lOlll\
OlOOl
++
)
{
lO\
OOOOOllO
(
llOl\
llO\
O\
l\
ll
[
lOlllOlOOl\

]
>=
0
,
"CollisionObjectAABBMesh::AddPolygon. Vertex index is invalid.")
;
lO\
O\
OOOOllO
(
llO\
ll\
lOOl\
ll
[
lOll\
lOlOOl
]
<
lOlO\
OlOl\
l\
O
->
ll\
Olll\
OO\
OO\
l
.
lOOO\
lllOO\
l
(
)
,
"CollisionObjectAABBMesh::AddPolygon. Vertex index is invalid.\n Make sure add the vertices a polygon needs before the polygon")
;
llOl\
ll\
OOl\
l\
O
->
ll\
Ol\
lllOlO
[
lOlllOlOOl\

]
=
llOl\
l\
lOOl\
l\
l
[
lOlllOl\
OOl\

]
;
}
{
Vec3
lOOOl\
O\
O\
OO\
O\

;
lOOOlO\
OO\
OO
.
Cl\
ear\

(
)
;
fl\
o\
at
lOlll\
lO\
l\
Ol\

=
0.0f
;
fo\
r
(
lOl\
l\
lOl\
OOl
=
0
;
lOlllO\
lOO\
l
<
lOl\
l\
O\
lllOl
-
2
;
lOll\
lOlOOl
++
)
{
Vec3
lllllllll
=
lO\
lOOlO\
llO
->
llOlllOOOO\
l
[
ll\
Ol\
llOOllO
->
llOl\
lllOlO
[
2
+
lOlllOlOOl
]
]
-
lO\
l\
OOl\
O\
llO
->
llOlll\
O\
OO\
Ol
[
llO\
lllO\
Oll\
O\

->
llOllll\
OlO
[
0
]
]
;
Vec3
lOOOO\
OOOOO\

=
lOlO\
OlOl\
l\
O
->
ll\
OlllOOOOl\

[
ll\
O\
ll\
lO\
O\
llO
->
llOll\
llOlO\

[
1
+
lOlllO\
l\
OOl
]
]
-
lOlO\
O\
lO\
llO
->
llOl\
l\
l\
OOOOl
[
llOl\
llOOllO
->
ll\
O\
lll\
lOlO
[
0
]
]
;
lOO\
O\
l\
OO\
O\
O\
O\

+=
Vec3
::
Cro\
ss
(
lllllllll
,
lOO\
OOOOOOO
)
;
fl\
oa\
t
ll\
OlllO\
l\
OlO\

=
ll\
lllll\
ll
.
Ge\
tMagnitude
(
)
;
if
(
lOlll\
l\
O\
lOl
<
llO\
ll\
lO\
l\
OlO
)
lO\
ll\
ll\
OlOl
=
ll\
Ol\
l\
lO\
lOlO
;
}
if
(
lOOOl\
OO\
OOO\

.
GetMagn\
i\
tu\
de
(
)
<=
lOllllOl\
O\
l\

*
0.0001f
||
lOllll\
Ol\
Ol\

==
0.0f
)
{
lOOO\
ll\
lOlO
(
0
,
"CollisionObjectAABBMesh::AddPolygon. Zero area polygon found. Ignoring.")
;
llO\
l\
l\
lO\
OllO
->
llOlllOlOOO
|=
llOllOll\
ll\
l\

;
lO\
OOlOOO\
OO
.
Cle\
ar
(
)
;
}
else
{
lOO\
O\
lOOOOO\

.
Normalise\

(
)
;
}
ll\
Oll\
lO\
Oll\
O
->
ll\
OlllOlOl\
l\

=
lOO\
OlOO\
O\
OO
.
x
;
llO\
l\
ll\
O\
Oll\
O
->
llOl\
ll\
Oll\
OO
=
lOOOlOOO\
OO
.
y
;
llOlllOOllO
->
llOlllOllO\
l
=
lOOO\
lO\
OO\
OO
.
z
;
ll\
Olll\
O\
Oll\
O
->
llOlllOlll\
O
=
lOlO\
OlOll\
O
->
llOll\
lOOOl\
l\

++
;
}
}
vo\
id
Col\
l\
ision\
Obje\
ctAAB\
BMesh\

::
Fi\
ni\
shed\
AddingGeome\
try
(
)
{
lOOO\
OOOll\
O
(
lOlOOlOllO
->
llOll\
lOO\
OOl\

.
lOOOlllOOl
(
)
==
lOlO\
O\
l\
OllO
->
llO\
lllOOOO\
l
.
lO\
OllllOll
(
)
,
"CollisionObjectAABBMesh::FinishedAddingGeometry. The number of vertices added does not match the vertices specified in the call to CollisionObjectAABBMesh::Initialise.")
;
lOOOOOOl\
lO
(
lOlOOlOllO
->
lO\
llOOl\
l\
l\
O\

.
lOO\
OlllOOl
(
)
==
lOlOOlOllO\

->
lO\
llOOlllO
.
lOO\
l\
lll\
O\
ll
(
)
,
"CollisionObjectAABBMesh::FinishedAddingGeometry. The added polygon data size does not match the expected size calculated from the parameters provided in CollisionObjectAABBMesh::Initialise.")
;
for
(
int
llO\
lll\
OlOOl
=
0
;
llOl\
llOlOOl
<
lOlOOl\
Ol\
lO
->
lOl\
lO\
OlllO
.
lO\
O\
Olll\
OOl
(
)
;
)
{
Polyg\
o\
n
*
llOOOlOlOO\

=
(
Po\
lygon
*
)
&
lOlOOlO\
llO
->
lOllOOl\
llO\

[
llOll\
l\
OlOOl\

]
;
ll\
Oll\
lOlOO\
l\

+=
llO\
ll\
Ol\
Ol\
Ol
+
llO\
OOlO\
lO\
O
->
lOll\
Oll\
lOl
;
if
(
(
llOOOlO\
lO\
O
->
llOll\
l\
OlOOO
&
llOll\
Ollll\
l
)
==
0
)
llOlllOll\
l\
l\

(
llO\
OOlOlOO
)
;
}
lOlO\
OlO\
llO
->
llOlllOOlOO
.
lOOOl\
lOlOl
(
)
;
}
#ifndef DOXYGEN
void
TAC_CALL
ll\
Oll\
ll\
OOO\
O
(
lO\
OO\
O\
llOll
::
lOOll\
OOOOO\

*
lOOll\
l\
OO\
Ol\

,
voi\
d
*
lO\
OlllO\
O\
O\
O
)
{
TA_A\
SS\
ERT
(
lO\
O\
l\
llOO\
O\
O
)
;
llOll\
OlOllO\

&
ll\
OllllO\
OOl
=
*
(
llOllO\
l\
OllO\

*
)
lOOlll\
OOOO
;
con\
st
Collis\
io\
nObje\
c\
tAAB\
B\
Mesh
::
Polygon
*
ll\
OOOl\
OlOO\

=
(
Coll\
isionO\
bje\
ctAAB\
B\
M\
e\
sh
::
Po\
l\
ygon
*
)
lOO\
lll\
O\
OOl
->
Ge\
tDa\
ta
(
)
;
const\

CollisionObje\
ctAABB\
M\
esh\

::
Da\
t\
a
*
llOllO\
llOll\

=
llO\
l\
ll\
lOOO\
l
.
llOllOllO\
O\
O
->
Get\
Dat\
a
(
)
;
Ve\
c3
ll\
Oll\
llOOlO
;
ll\
Ol\
ll\
lOOlO
.
x
=
llO\
OOlOlOO
->
ll\
O\
lllOlOll\

;
llO\
lll\
lOO\
lO
.
y
=
llOOO\
l\
OlO\
O\

->
llO\
lllOll\
OO\

;
llOll\
llOO\
l\
O
.
z
=
llO\
O\
OlOl\
OO
->
llOlllOll\
Ol
;
fl\
oat
ll\
OllllOO\
ll
=
llOlll\
lOOlO
.
Do\
t
(
ll\
OllO\
l\
l\
Ol\
l
->
llOl\
l\
lO\
OOOl
[
ll\
OOO\
lO\
l\
OO\

->
llOll\
llOlO\

[
0
]
]
)
;
fl\
oat
ll\
O\
llll\
OlOO
=
ll\
Oll\
llOOlO\

.
Do\
t
(
ll\
Olll\
lOOOl\

.
lOO\
l\
OlOl\
ll
)
-
llOllllOOll\

;
float
ll\
Oll\
ll\
OlOl
=
llOlll\
lO\
l\
OO\

+
llOlll\
lOOl\
O
.
Dot
(
ll\
Ollll\
OOOl
.
lOOO\
lO\
O\
O\
OO
)
*
ll\
OllllO\
OOl
.
lO\
Ol\
Ol\
lOOO
;
if
(
llOllllOlO\
O
<=
0.0f
||
llOl\
l\
l\
lOlOl
>=
0.0f
)
retur\
n
;
fl\
oa\
t
lllOlllllO\

=
llO\
lll\
lOlO\
O
/
(
ll\
Ol\
lllOlOO\

-
ll\
Oll\
ll\
OlOl
)
;
if
(
ll\
Oll\
l\
lOOO\
l\

.
ll\
Oll\
OlO\
l\
ll\

->
lll\
Olllll\
O
<
lllOlll\
l\
lO
)
re\
t\
urn
;
Vec\
3
lOl\
l\
lOl\
llOO
=
llOllllOOOl
.
lO\
Ol\
OlOl\
l\
l\

+
(
llOll\
llOOOl
.
lOOOlOO\
OO\
O
)
*
(
lllOlllllO
*
llOl\
lllOOOl\

.
lOOlO\
ll\
OOO
)
;
fo\
r\

(
int
llOlOlOllO
=
0
;
llOl\
OlOll\
O
<
ll\
OOO\
lOlOO
->
lO\
llOlllOl\

;
llOlOlOllO\

++
)
{
co\
n\
st
Vec3\

&
lll\
llllll\

=
llOl\
lO\
l\
lOll
->
llOlll\
O\
OOOl\

[
ll\
OOO\
lOlOO
->
llOllll\
OlO
[
llOlO\
lOllO
]
]
;
const
Vec3
&
lOOOOO\
O\
OOO
=
llOl\
Ol\
O\
llO
+
1
<
llO\
OOl\
O\
lOO\

->
lOllO\
ll\
lOl\

?
ll\
O\
ll\
O\
ll\
Ol\
l
->
llOll\
lOO\
OOl
[
llO\
O\
Ol\
O\
l\
OO\

->
ll\
Olll\
lOlO
[
llOlO\
l\
OllO
+
1
]
]
:
llOllO\
llOll
->
llOll\
l\
O\
OOOl\

[
llOOOlOlOO\

->
llOlll\
lOl\
O\

[
0
]
]
;
Vec3
llOlll\
l\
OllO\

=
llOl\
lllO\
OlO
.
Cr\
oss
(
lOOO\
OOOOOO
-
ll\
llll\
ll\
l\

)
;
if
(
llOllllOllO
.
Dot
(
lOlllOll\
lOO
-
llll\
ll\
lll
)
>
0.005f
)
ret\
urn
;
}
ll\
Oll\
ll\
O\
OOl\

.
llO\
llO\
lOlll\

->
lOl\
OllOOll
|=
Collision
::
FL\
AG_C\
OL\
LISION_OC\
CURRED
|
Collisio\
n
::
FLAG_N\
EW\
_C\
OLLIS\
IO\
N\

;
llOllllO\
OOl\

.
llOll\
OlOll\
l
->
lll\
Oll\
l\
llO
=
lll\
O\
lll\
llO
;
llO\
l\
lllO\
OO\
l\

.
llOllOl\
Ol\
ll
->
lOl\
lOO\
lOOl\
l
=
lllOlllll\
O
*
ll\
Ollll\
OOO\
l
.
lOOl\
Ol\
lOO\
O
;
llOll\
llOOO\
l
.
llOllOlOll\
l\

->
lOllO\
Ol\
OOlO
=
llOOOlOlO\
O
->
ll\
Oll\
lOlOOO
;
ll\
Olll\
l\
OO\
Ol
.
ll\
Ol\
lOlO\
ll\
l
->
lO\
OOOllll\
l\

=
lOlll\
OlllOO
;
llOl\
lllOOOl\

.
llOllOlO\
lll
->
lOOOlOO\
O\
OO
=
llO\
llllOOl\
O
;
llO\
llllOO\
Ol\

.
llOll\
O\
lOl\
ll
->
SetCo\
l\
l\
i\
s\
i\
onObj\
ec\
tA
(
const_\
cas\
t
<
Collisio\
nO\
b\
j\
ect\
AABBMesh
*
>
(
ll\
OllllOOO\
l
.
llO\
ll\
OllO\
OO
)
)
;
llO\
lll\
lOOOl
.
llOll\
OlOl\
ll
->
lOllOllO\
Ol\
l
=
llOO\
OlOlOO
->
llOl\
ll\
Ol\
llO
;
ll\
Olll\
lOOOl\

.
lO\
llllO\
lO\
OO
=
true
;
}
#endif //
bool
Collision\
Ob\
jectAAB\
BM\
esh\

::
Te\
stL\
ineForC\
ollision
(
con\
s\
t
Vec\
3\

&
lOOlOlOl\
ll
,
const
Ve\
c3
&
lO\
OOlOOOO\
O\

,
float
lOOlOllO\
OO
,
Co\
ll\
isi\
o\
n
&
ll\
Olll\
lOl\
ll
)
cons\
t
{
llOll\
O\
lOllO\

llOllllOOOl
;
ll\
OllllOO\
Ol\

.
lOOlOlOlll
=
lOOlOlOlll\

;
ll\
OllllO\
OOl
.
lOOOlO\
O\
OOO
=
lOOOl\
OOOOO
;
llOl\
l\
l\
lOOOl
.
lOOlOllO\
OO
=
lO\
OlOllOOO
;
llOll\
llOOOl
.
llOllOlOl\
ll
=
&
llOl\
ll\
lOlll\

;
llO\
ll\
ll\
O\
OOl
.
llO\
llOl\
lOO\
O
=
th\
is
;
llOll\
ll\
OOOl\

.
lOl\
lllOlOOO
=
false
;
lOlOOlOl\
lO
->
llOll\
lOO\
l\
OO
.
lO\
OlOlOOlO
(
lOO\
l\
O\
lO\
lll
,
lOOOlO\
OOO\
O
,
lO\
O\
lOl\
lO\
OO
,
llOllllOO\
OO
,
&
llO\
llllO\
OO\
l
)
;
return\

llO\
llllOOOl
.
lO\
llllOl\
OOO
;
}
#ifndef DOXYGEN
void\

TA\
C_C\
ALL
ll\
O\
l\
ll\
llOOO\

(
lOO\
OOl\
lOll
::
lOOllOO\
OO\
O\

*
lO\
OlllOOOl
,
void
*
lOOlllO\
OOO
)
{
llOl\
l\
OllOOl
*
lOOO\
O\
llllO
=
(
ll\
Ol\
l\
Ol\
lOOl
*
)
lO\
Oll\
lOO\
O\
O
;
Co\
llisio\
nObj\
ectC\
ache\
dP\
o\
lyDa\
ta\

&
llOlll\
llOOl
=
*
lOOOOllll\
O
->
llO\
llOllOlO
;
static\

Vec3\

llOlllllOlO
[
lOl\
llO\
O\
lOll
]
;
Co\
llis\
ionObj\
e\
ct\
AABB\
Mesh
::
Po\
lygo\
n
*
ll\
OlllllO\
l\
l
=
(
Col\
lisionO\
bjectAAB\
BMesh
::
Pol\
yg\
on\

*
)
lO\
OlllOOO\
l
->
GetData\

(
)
;
TA_ASSERT
(
llOll\
lllOll
->
lO\
l\
lOll\
lO\
l
>=
3
)
;
Co\
llision\
Objec\
tCachedP\
o\
lyData
::
Po\
lygon
*
llOlllll\
l\
O\
O
=
llOll\
lllOOl\

.
GetN\
ewP\
olygon
(
ll\
OlllllOll
->
lOl\
lOl\
llO\
l
)
;
if
(
!
llOlllll\
l\
OO
)
{
if
(
!
lOOO\
OllllO
->
llOllOl\
l\
lOO
)
{
lOOOOllllO\

->
llO\
llOlllOO
=
true
;
}
return
;
}
ll\
O\
llllllOO\

->
llOlllOlO\
OO\

=
llOlllllOll
->
llO\
lllOl\
OOO\

;
ll\
O\
lllll\
lO\
O
->
llOlllOl\
llO
=
llO\
l\
llllOll\

->
llOl\
llOlllO
;
llOllllllOO
->
lOl\
lO\
lllOl
=
llOlll\
l\
lOll
->
lOllOlllOl
;
TA\
_ASSER\
T
(
llO\
lllll\
lOO
->
lOl\
lOl\
llOl
>=
0
)
;
TA_ASS\
ERT\

(
llO\
lllll\
lO\
O
->
lO\
llOl\
l\
lO\
l
<
lOl\
llOOlOll
)
;
co\
nst\

Ve\
c3
llO\
lllll\
lOl\

(
llO\
l\
llllOll
->
llOl\
l\
lO\
lOl\
l\

,
llOll\
lll\
O\
l\
l
->
ll\
Oll\
l\
O\
llO\
O
,
llOlllll\
O\
ll\

->
llO\
lllO\
ll\
Ol\

)
;
llOll\
llllOO
->
lO\
OOlOO\
OO\
O
=
ll\
Ol\
llll\
lO\
l\

;
TA_ASS\
E\
RT
(
llO\
llll\
ll\
OO
->
lOllOlllOl
<=
lOll\
lOOlOll\

)
;
for
(
int
lOO\
Ol\
lO\
OOl
=
0
;
lOO\
O\
llOOOl\

<
llOl\
lllll\
OO
->
lOllOlllOl\

;
lOOOl\
lOOOl
++
)
{
co\
ns\
t
Vec\
3
&
llllOOOOl\
l\

=
lO\
OO\
Oll\
ll\
O
->
llOll\
Ol\
lO\
l\
l
->
llOlll\
OO\
OOl
[
llOl\
llllOl\
l
->
llOllllOl\
O
[
lOO\
OllO\
O\
Ol
]
]
;
con\
st\

Ve\
c\
3
&
lll\
lO\
O\
OlOO
=
lOOOOlll\
l\
O
->
ll\
O\
l\
lOl\
l\
Ol\
l
->
llOl\
l\
lOOOOl
[
llOlllllO\
l\
l
->
ll\
OllllOlO
[
lOOOllOOOl
<
llO\
ll\
ll\
llOO
->
lOllO\
lll\
Ol\

-
1
?
lOOO\
l\
lOO\
Ol\

+
1
:
0
]
]
;
ll\
Ol\
ll\
lll\
OO
->
llOl\
l\
llOlO
[
lOO\
O\
l\
lO\
OOl
]
.
lO\
OOOlll\
ll\

=
llllOOO\
O\
ll
;
Vec3
lOlllOlO\
l\
ll
=
llOlll\
lllOl
.
Cr\
os\
s
(
llllOOOOll
-
lll\
l\
OOO\
l\
OO\

)
;
TA_\
ASSERT
(
lOl\
llOlO\
lll\

.
Get\
Mag\
n\
it\
ud\
e\

(
)
>
0.0f
)
;
lOll\
lOlOlll
.
Normalis\
e
(
)
;
llOlll\
lllOO
->
llOllll\
OlO
[
lOOO\
llOO\
O\
l
]
.
lOlllOl\
Olll
=
lOlll\
OlOlll
;
}
}
#endif //
voi\
d\

Co\
lli\
sion\
Obj\
e\
ctA\
ABB\
Mesh
::
Ca\
che\
d\
LocalPolygons
(
CollisionObj\
e\
ctCac\
hedPolyData
&
ll\
Olll\
llOO\
l
,
const
AABB\

&
lO\
OOO\
OOlll\

,
void
*
llOlllllllO
)
co\
ns\
t
{
TA_ASSERT
(
lOlOOlOllO
)
;
llOllO\
ll\
O\
Ol
llOl\
llll\
lll
;
llOl\
lllllll
.
ll\
Ol\
l\
OllOlO
=
&
llOl\
l\
l\
llOOl\

;
llOllllllll\

.
llO\
ll\
Oll\
O\
ll
=
Get\
Da\
ta
(
)
;
llOllllllll
.
llOl\
lOll\
l\
OO
=
false
;
lOlO\
Ol\
Ol\
lO
->
llOl\
llOO\
l\
O\
O
.
lOOlOl\
OOlO
(
lOOO\
OOOlll
,
llOll\
ll\
l\
OO\
O
,
&
ll\
O\
ll\
lll\
lll\

)
;
}
cons\
t
AABB
&
Colli\
sionObjec\
tAABBM\
e\
sh
::
Ge\
tAA\
BB
(
)
const
{
TA_\
AS\
S\
ERT\

(
lOlO\
OlO\
llO
)
;
retu\
rn\

lOlOOlO\
llO
->
llOlllOO\
l\
O\
O
.
GetAABB
(
)
;
}
Col\
l\
i\
si\
on\
ObjectAAB\
BM\
e\
s\
h
*
TA\
C_\
C\
ALL
Co\
l\
li\
s\
ionObje\
ct\
AABB\
Mesh\

::
Creat\
eNe\
w
(
)
{
Col\
l\
isi\
o\
nO\
bjectAAB\
BMesh
*
lOl\
OllOlOOl\

;
lOOO\
OO\
ll\
OlO
(
lOlOllOlOOl
,
Col\
lisio\
nObje\
ctA\
ABBMes\
h
)
;
return
lOlO\
llOlOOl
;
}
void\

Col\
lisionObje\
ctAA\
BBMesh
::
llOl\
l\
lOl\
l\
ll
(
Polygon
*
ll\
OOOlOlO\
O
)
{
lOOOOOOll\
O
(
llOO\
OlO\
lO\
O\

->
lOllO\
ll\
lOl
>
2
,
"CollisionObjectAABBMesh::AddPolygonToAABBTree. pPolygon->nNumVertices is less than 3")
;
AABB\

lOOOOOOll\
l
;
lOOOOOOlll\

.
Ini\
tialise
(
lO\
lO\
OlOllO
->
ll\
Olll\
OOOOl
[
llOOO\
l\
OlOO
->
llOllllO\
l\
O
[
0
]
]
,
k_v3Ze\
ro
)
;
for
(
int
lOlll\
OlOOl
=
1
;
lOll\
lO\
lO\
O\
l
<
ll\
OOOlO\
l\
OO
->
lOllOl\
llOl
;
lOll\
l\
OlOOl
++
)
lOOOO\
O\
Ol\
ll
.
Exp\
andTo\
Fi\
t\

(
lO\
lOOlOllO
->
llOlllOOO\
O\
l
[
llOOOl\
O\
l\
O\
O
->
llO\
l\
lllOlO
[
lOlll\
Ol\
OOl
]
]
)
;
float
lOOO\
OOlOO\
O
=
lOO\
OOOO\
lll\

.
v3E\
xt\
ent
[
lO\
O\
OOOOlll
.
v3\
Ex\
te\
nt
.
Ge\
tGreat\
estAx\
i\
s\

(
)
]
;
lOOO\
OO\
O\
ll\
l
.
v3Ex\
ten\
t
.
x
+=
lO\
O\
O\
OOl\
OO\
O
*
0.001f
;
lO\
OOOOOlll
.
v3E\
xt\
e\
nt
.
y
+=
lO\
OOO\
OlO\
OO\

*
0.001f
;
lO\
OO\
OOOl\
ll\

.
v3Ext\
ent
.
z
+=
lO\
OO\
O\
Ol\
OOO\

*
0.001f
;
lO\
l\
O\
O\
lOll\
O\

->
llO\
lllOOlO\
O
.
lOOOllOllO\

(
llOOOl\
O\
l\
OO\

,
lOOO\
OOOlll
)
;
}
Collision\
Obj\
ectAAB\
BMesh\

::
Coll\
i\
si\
onObje\
ct\
AABBMe\
sh
(
)
:
Col\
lisio\
nObject\
C\
om\
plex
(
)
{
lOlO\
OlOl\
lO
=
0
;
}
Colli\
si\
onO\
bjectAA\
BBM\
e\
sh\

::
~
Colli\
sion\
Object\
A\
A\
BBM\
esh
(
)
{
Finalise\

(
)
;
}
}

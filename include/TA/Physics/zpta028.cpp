//---------------------------------------------------------------------------------
// File Name: zpta028.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef DOXYGEN
#include "../Physics/zpta014.h"
#ifndef TA_DEBUG_H
#include "../Common/Debug.h"
#endif //
#ifndef TA_VECTOR_H
#include "../Common/Vector.h"
#endif //
#ifndef lOOlOOlllll
#include "../Common/zcta010.h"
#endif //
#ifndef lOOllOllll
#include "../Common/zcta001.h"
#endif //
#include <memory.h>
#ifdef _DEBUG
#endif //
#ifdef _DEBUG
#endif
#define llOlOOllOlOl "Physics solver failed"
na\
mesp\
ace
TA
{
#define llOlOOllOllO(lOOOlOlllOO, Type) { if (lOOOlOlllOO) { lOlOOOlllO(lOOOlOlllOO, Type); lOOOlOlllOO = 0; } }
#define llOlOOllOlll(lOOOlOlllOO, Type) { if (lOOOlOlllOO) { lOOlOOOOOO(lOOOlOlllOO, Type); lOOOlOlllOO = 0; } }
lO\
OlO\
llOllO\

(
ll\
OlOOll\
lO\
OO\

)
;
lOOlOllOllO
(
ll\
OlO\
Oll\
lOO\
l
)
;
lOO\
lOllOll\
O
(
llO\
lO\
Olll\
OlO
)
;
lOOlOllOllO
(
ll\
OlOOll\
lOll
)
;
lO\
OlOl\
lOllO
(
llOlOOl\
ll\
lO\
O
)
;
lOOl\
OllOl\
lO
(
llOl\
OOlll\
l\
Ol
)
;
lOOl\
Oll\
Oll\
O
(
ll\
OlOOllll\
lO\

)
;
lOOlOl\
lOllO\

(
llO\
l\
OO\
lllll\
l\

)
;
lOOlO\
l\
lO\
l\
lO
(
llOl\
Ol\
OOOO\
OO
)
;
#ifdef _DEBUG
st\
ati\
c
fl\
oat\

llOlOl\
OO\
O\
OOl
=
0.0f
;
#endif //
class
llOl\
OlOOOOl\
O
{
publi\
c
:
struct
{
u3\
2
llOlOl\
OOOO\
ll\

;
u16
ll\
Ol\
OlOOO\
lOO\

;
u16
ll\
OlOl\
OOOlOl\

;
u8\

llO\
lOl\
OO\
OllO
[
8
]
;
}
llOlOl\
OOO\
lll
;
char\

ll\
OlO\
l\
OOlO\
O\
O\

[
64
]
;
ch\
ar
llOlOl\
OOlOOl\

[
64
]
;
llOlOlOOOOlO
(
)
{
llOlOlO\
O\
Olll\

.
llO\
lOlOO\
OO\
ll
=
0x2b7fb481
;
ll\
Ol\
O\
l\
OO\
Ol\
l\
l
.
ll\
OlOlO\
O\
OlOO
=
0xf039
;
llO\
lO\
lO\
O\
Oll\
l
.
ll\
OlOlOOO\
lOl\

=
0x11d6
;
llO\
l\
O\
l\
OO\
O\
lll
.
llO\
lOlO\
OOl\
l\
O
[
0
]
=
0x8e
;
ll\
OlOl\
OOOlll
.
llOl\
OlOOOllO
[
1
]
=
0x2d
;
llOl\
OlO\
O\
Ol\
ll
.
llOlOlOOO\
llO
[
2
]
=
0x0
;
ll\
OlOlO\
OOlll
.
llOlOlOOOllO\

[
3
]
=
0x8
;
llOlOlOO\
O\
lll
.
llOlO\
lOO\
Ol\
lO
[
4
]
=
0xa1
;
ll\
OlO\
lOOOlll
.
ll\
O\
lO\
lOOO\
l\
l\
O
[
5
]
=
0x2a
;
llO\
lO\
l\
OOOlll
.
llOl\
O\
lOOO\
ll\
O
[
6
]
=
0x13
;
ll\
Ol\
OlO\
OO\
l\
l\
l
.
ll\
OlOlOOOl\
lO
[
7
]
=
0x5a
;
co\
nst
char\

ll\
Ol\
Ol\
OO\
l\
O\
lO\

[
]
=
"OrE^`d>@YdjSDeeg\nyBv;v;vDkPv=Pi?sGy?XtZnmJJz^";
co\
nst
char
llOlOl\
OOlOll
[
]
=
"True Axis Physics SDK";
int
lOOOllOOOl
;
for
(
lOO\
OllOO\
O\
l
=
0
;
llOl\
OlOOlO\
lO
[
lOO\
Oll\
O\
O\
Ol
]
!=
0
;
lOOOllOOO\
l
++
)
ll\
OlOlOOl\
OOO
[
lOOOllOO\
Ol
]
=
llOl\
O\
lO\
OlO\
l\
O
[
lO\
OOllOOO\
l
]
;
for
(
lOOOllOOO\
l
=
0
;
ll\
O\
lOl\
OO\
lOll
[
lOOOllO\
OOl
]
!=
0
;
lOOOll\
O\
OO\
l\

++
)
llOlOlOOlOOl
[
lOOOllOOOl
]
=
llO\
lOl\
O\
Ol\
Oll
[
lO\
O\
O\
ll\
OO\
O\
l
]
;
}
}
;
namespace\

llOlOlOOllOO
{
class
llOlOlOO\
l\
lOl\

{
publi\
c
:
llOl\
Ol\
OOllOl
(
)
{
lOl\
OO\
lO\
ll\
O
=
0
;
lO\
lOO\
OlOlO
=
0
;
lO\
lOOO\
lO\
Ol
=
0
;
}
~
ll\
OlOlOOllOl
(
)
{
Finalise
(
)
;
}
void\

Initi\
alis\
e
(
int
lO\
OlllO\
ll\
O
)
{
lOlOO\
OlOlO
=
lOO\
lll\
O\
l\
lO
;
TA_ASSER\
T
(
lOlOOO\
lO\
lO
>
0
)
;
lOl\
OOO\
l\
OOl
=
0
;
lOOOl\
l\
llOO\

(
lOlO\
O\
lOllO
,
float
,
lOlO\
OOl\
OlO\

)
;
#ifdef llOlOlOOlllO
llOlOlO\
O\
llll\

.
In\
i\
tia\
lise\

(
0
,
256
,
256
)
;
#endif //
}
voi\
d\

Fi\
n\
ali\
se
(
)
{
llOlOOllOll\
O
(
lOlOOlO\
llO\

,
flo\
at\

)
;
lO\
l\
OOOl\
OlO\

=
0
;
lOlO\
OOlOOl\

=
0
;
#ifdef llOlOlOOlllO
llO\
lOlOOl\
lll
.
Clea\
r
(
)
;
#endif //
}
floa\
t
*
llOlOlOlOOOO\

(
in\
t\

lOO\
ll\
lOllO
)
{
if\

(
lOl\
O\
OOlOO\
l
+
lOO\
lllOl\
lO
>
lOlOO\
OlO\
l\
O\

)
return
0
;
flo\
at
*
llOlOlOlOOOl
=
&
lOl\
O\
OlOll\
O\

[
lOlO\
O\
OlOOl\

]
;
lO\
lOO\
O\
l\
O\
Ol
+=
lOOlllOl\
lO\

;
#ifdef llOlOlOOlllO
ll\
OlOlOOllll\

.
lOOOlllOOO
(
llOlOlOlOOO\
l
)
;
#endif //
return\

llOlOlOlO\
OOl
;
}
#ifdef llOlOlOOlllO
void
Fre\
e
(
float
*
lOOlllOOOO\

)
{
fo\
r
(
int\

lOOOllOO\
O\
l
=
0
;
lOO\
OllOOOl
<
ll\
OlO\
lOOllll
.
lOOOlll\
O\
Ol
(
)
;
lOOOllOOO\
l
++
)
{
if
(
ll\
Ol\
Ol\
OO\
l\
lll
[
lOOOllO\
OOl
]
==
lOOll\
lOOOO
)
{
llOl\
OlO\
Ollll\

[
lO\
OO\
llOO\
O\
l
]
=
0
;
br\
eak
;
}
}
TA_\
AS\
SERT
(
lOO\
Ol\
lOOOl
!=
llOlOlOOlll\
l
.
lOOOlllO\
Ol
(
)
)
;
}
#endif //
vo\
id
Clear
(
)
{
lOlOOOlOOl
=
0
;
#ifdef llOlOlOOlllO
for
(
in\
t
lO\
OOl\
lOO\
Ol
=
0
;
lOO\
Oll\
O\
OOl
<
ll\
OlOlOOllll
.
lOOOl\
ll\
OOl
(
)
;
lOOO\
ll\
OOOl\

++
)
{
TA\
_A\
SSE\
RT
(
llOlOlOOlll\
l\

[
lOOOllOOO\
l\

]
==
0
)
;
}
llOlOlOOllll
.
Clear\

(
)
;
#endif //
}
private
:
int
lOl\
OOOlOlO
;
int
lOl\
OOOlOO\
l\

;
float
*
lOlOOlOll\
O
;
#ifdef llOlOlOOlllO
lOO\
OO\
lO\
llO
<
flo\
at\

*
>
llOlOl\
O\
O\
llll
;
#endif //
}
;
st\
ati\
c
in\
t
llOlO\
l\
O\
lOOl\
O
=
0
;
stati\
c\

llOl\
OlOOllOl\

*
ll\
OlOlOlOO\
l\
l
=
0
;
class\

llOlOlOlOlOO
{
pub\
lic
:
ll\
OlO\
lOlOlO\
O
(
)
{
lOlOOlOl\
lO
=
0
;
llO\
lOlOlOOlO
+=
6
*
6
;
}
~
llOlOl\
O\
l\
O\
lOO
(
)
{
Fi\
na\
l\
is\
e
(
)
;
}
voi\
d\

Ini\
t\
i\
a\
lis\
e
(
int
ll\
Ol\
Ol\
O\
lO\
lOl
,
int
llOlOl\
Ol\
OllO\

)
{
llOlOlOl\
Olll
=
llOlOlOl\
O\
lOl\

;
llOlOlOl\
lO\
O\
O
=
llOlOlOl\
OllO
;
TA\
_A\
SS\
ERT
(
llO\
lOlO\
lOlll
>=
1
)
;
TA_\
ASSE\
RT
(
llOlO\
l\
Ol\
lOOO
>=
1
)
;
TA\
_ASSERT\

(
llOlOlO\
lOlll\

<=
6
)
;
TA_\
ASSERT
(
llOl\
OlOllO\
O\
O\

<=
6
)
;
TA_ASSERT
(
lOlOOl\
OllO
==
0
)
;
TA_AS\
SE\
RT
(
llO\
lOlOlOOl\
l
)
;
lOl\
OO\
lOllO
=
llOlOl\
O\
lOOll\

->
ll\
Ol\
OlOlO\
OOO
(
llOlOlO\
lOl\
l\
l\

*
llOlOlOll\
OO\
O
)
;
lOOOOO\
Oll\
O
(
lOlOOl\
Ol\
lO\

,
ll\
O\
lOOll\
OlOl\

)
;
llO\
lOl\
Ol\
l\
OOl
=
fa\
ls\
e\

;
}
void\

Finalis\
e
(
)
{
#ifdef llOlOlOOlllO
if
(
lO\
l\
OO\
lOll\
O
)
{
TA_ASSERT\

(
ll\
OlOl\
OlOOll
)
;
llOlOlOl\
OOll
->
Free
(
lOlOO\
lO\
llO
)
;
}
#endif //
lOlOOl\
OllO
=
0
;
}
bool
lOO\
l\
OO\
lO\
Oll\

(
)
co\
nst
{
retur\
n
lOlOO\
lOl\
l\
O
!=
0
;
}
inl\
ine
flo\
at
&
operator
(
)
(
int
lOO\
O\
lOOlOOl\

,
int
lOO\
OlOOlOlO\

)
{
re\
t\
urn
lOlOOlOllO
[
lO\
O\
O\
l\
OOl\
OO\
l
*
llOlO\
l\
OllO\
O\
O\

+
lOOOl\
O\
Ol\
OlO
]
;
}
inli\
n\
e
float
operator
(
)
(
in\
t\

lO\
O\
O\
lOOl\
OO\
l
,
in\
t
lOOOlOOl\
OlO
)
co\
nst
{
re\
turn\

lO\
lOOlOl\
lO
[
lOOO\
lOOl\
OOl\

*
llOlOlOllO\
OO
+
lOO\
OlOOlOl\
O
]
;
}
int
llOlOlOllOlO
(
)
con\
st
{
retur\
n
llOl\
OlOlOlll
;
}
int\

llO\
lOlOllO\
ll
(
)
const
{
retur\
n
llOlO\
l\
OllO\
OO
;
}
void\

lOlOl\
l\
OO\
Ol\
O\

(
)
{
me\
mse\
t
(
lO\
lOO\
lOl\
lO
,
0
,
llO\
lO\
lOlOlll
*
llOlOlO\
l\
lOO\
O\

*
sizeof
(
floa\
t
)
)
;
llOlO\
lOll\
O\
Ol
=
false
;
}
void
llOlO\
lOl\
l\
lOO\

(
)
{
TA_ASSERT
(
ll\
OlO\
lOllO\
O\
O
==
llOl\
OlO\
l\
Ol\
ll
)
;
lOl\
O\
llOOOlO
(
)
;
for
(
int
lOOOllOOOl\

=
0
;
lOOO\
l\
lOOO\
l
<
llOl\
Ol\
Ol\
Olll
;
lOO\
O\
llO\
OOl
++
)
(
*
this\

)
(
lO\
OOllOOOl
,
lOOOllO\
OO\
l\

)
=
1.0f
;
ll\
O\
lOlOllO\
O\
l
=
true\

;
}
void\

llO\
lOl\
Oll\
lOl
(
)
{
llO\
l\
O\
lOl\
lOOl
=
false
;
}
bool
llO\
lOlOllllO
(
)
co\
ns\
t
{
re\
t\
urn
ll\
O\
lOl\
Ol\
lOOl
;
}
vo\
id
GetIn\
v\
er\
se\

(
llOlOl\
OlO\
lOO
&
lO\
lOO\
llOO\
lO\

,
llOl\
Ol\
OlOlOO
&
lOllO\
OOll\
lOl
)
{
TA\
_ASSERT
(
llO\
lOl\
Ol\
Ol\
ll
==
ll\
OlOlO\
llOOO
)
;
if
(
llOlO\
lO\
llll\
O\

(
)
)
{
lOlOO\
l\
lOOl\
O
.
llOlO\
lOll\
lO\
O
(
)
;
}
else
if
(
ll\
OlOl\
OlOlll
==
3
)
{
Mat3\
3
lOO\
O\
O\
O\
O\
O\
l\
l
(
(
*
th\
i\
s
)
(
0
,
0
)
,
(
*
this
)
(
0
,
1
)
,
(
*
this\

)
(
0
,
2
)
,
(
*
th\
is
)
(
1
,
0
)
,
(
*
th\
is
)
(
1
,
1
)
,
(
*
this\

)
(
1
,
2
)
,
(
*
this\

)
(
2
,
0
)
,
(
*
this\

)
(
2
,
1
)
,
(
*
thi\
s\

)
(
2
,
2
)
)
;
lOOOOOO\
Oll
.
Invert
(
)
;
lOlOO\
ll\
OOlO\

(
0
,
0
)
=
lOOOOOOOll
.
M11
(
)
;
lOlOOl\
l\
O\
O\
lO
(
0
,
1
)
=
lOOO\
O\
OOOl\
l\

.
M1\
2
(
)
;
lOlOOllO\
Ol\
O
(
0
,
2
)
=
lOOOO\
OO\
Ol\
l\

.
M13
(
)
;
lOlOOllO\
O\
lO\

(
1
,
0
)
=
lO\
OOOOOOll\

.
M2\
1
(
)
;
lOlOOllOOl\
O
(
1
,
1
)
=
lOOO\
OOOOll\

.
M22
(
)
;
lOl\
OOll\
OOlO
(
1
,
2
)
=
lO\
O\
OOO\
OOll
.
M23\

(
)
;
lO\
lOOllOOlO\

(
2
,
0
)
=
lOOOOOOO\
ll
.
M31
(
)
;
lO\
lOOll\
O\
Ol\
O\

(
2
,
1
)
=
lOOOOO\
O\
O\
ll\

.
M3\
2
(
)
;
lO\
lO\
Ol\
lOO\
lO
(
2
,
2
)
=
lOOOOO\
OOll\

.
M33\

(
)
;
}
else
{
TA\
_ASSE\
RT\

(
lOlO\
O\
llOOlO
.
llOlOl\
Oll\
O\
lO
(
)
==
llOlOlO\
llOlO
(
)
)
;
TA_ASSERT\

(
lO\
lOO\
llOOlO
.
llOlOl\
Oll\
Oll
(
)
==
ll\
OlO\
l\
O\
ll\
Ol\
l
(
)
)
;
TA_ASS\
ERT\

(
lO\
ll\
OOOlllOl\

.
llOl\
OlO\
ll\
OlO\

(
)
>=
ll\
O\
l\
OlOllOl\
O\

(
)
)
;
TA_\
A\
SS\
ERT
(
lO\
llOO\
Ol\
llO\
l\

.
llO\
l\
OlO\
l\
lO\
l\
l\

(
)
>=
llOl\
OlOllOll
(
)
)
;
TA_ASSER\
T\

(
lOl\
lOOOll\
lOl
.
llOlOlOll\
OlO
(
)
==
lO\
llOOO\
lllOl\

.
llO\
lOlO\
ll\
Oll
(
)
)
;
int
lOOO\
ll\
OOOl\

;
int\

lOO\
lOOlOl\
O
;
int\

lOOlO\
lOOOl
;
for
(
lOOOl\
lO\
OO\
l
=
0
;
lOOOl\
lOOOl\

<
lOl\
OO\
l\
lOOlO
.
ll\
OlOlOllOl\
l
(
)
;
lOOOllOOOl
++
)
{
for
(
lOO\
lOO\
lOlO
=
0
;
lOO\
lOOlO\
lO\

<
lOl\
O\
Ol\
lOOlO\

.
llOlOl\
O\
ll\
OlO
(
)
;
lOOlOOlOl\
O
++
)
lOllO\
O\
Oll\
lOl
(
lOOOllOOO\
l
,
lOO\
lOOlOlO\

)
=
(
*
thi\
s
)
(
lOOOllOOO\
l
,
lOOl\
OOlO\
lO
)
;
}
lO\
llOlOlO\
Oll
::
ll\
OlO\
lOlll\
l\
l
(
lO\
lO\
Oll\
OOlO\

.
llOl\
Ol\
Ol\
l\
OlO\

(
)
,
lO\
llOOOlllO\
l\

.
llO\
lOl\
OllOlO
(
)
,
&
lOl\
lOO\
O\
l\
llOl\

(
0
,
0
)
)
;
float
llOlO\
llOOOOO
;
for
(
int\

lOOOlOOlOlO
=
0
;
lOO\
Ol\
O\
OlO\
l\
O
<
lOlOOllOOlO
.
ll\
Ol\
OlO\
ll\
O\
ll
(
)
;
lO\
O\
Ol\
OOl\
O\
lO
++
)
{
for
(
lOOOllOO\
Ol
=
0
;
lOO\
Ol\
lOOO\
l
<
lOlOOllO\
OlO\

.
llOlOlOl\
lOl\
O\

(
)
;
lOOOll\
OOOl
++
)
{
if\

(
lOOOllOO\
O\
l
==
lOOOlOOlOlO\

)
lOlO\
O\
llOOlO\

(
lOOOl\
lOOOl
,
lOOOlOOlOlO
)
=
1.0f
;
else
lOlOOllOOlO
(
lO\
O\
O\
llOOO\
l\

,
lO\
OOlOOlOlO\

)
=
0.0f
;
llOlOl\
lO\
OOOO
=
lOlOOllOOl\
O
(
lOOOllO\
OOl
,
lOOOlOO\
lO\
lO\

)
;
for
(
lO\
Ol\
OlOOOl
=
0
;
lOOlO\
lOOO\
l
<
lO\
OOllOOOl
;
lOOlO\
l\
O\
OOl
++
)
llOl\
Oll\
OOOOO\

-=
lO\
llOO\
Ol\
llOl
(
lOOOl\
l\
OOOl
,
lOO\
l\
OlO\
O\
O\
l
)
*
lO\
l\
OO\
llOOlO
(
lOO\
lO\
l\
OOOl\

,
lOO\
O\
lOOlOl\
O\

)
;
lOl\
OOll\
OO\
lO\

(
lOOOl\
lOOO\
l
,
lO\
OO\
lOOlOlO
)
=
llO\
lOll\
O\
O\
O\
OO
;
}
for\

(
lOOOll\
OOO\
l
=
0
;
lO\
OOllOOOl\

<
lOlOOll\
OOlO\

.
ll\
OlOl\
Oll\
Ol\
O
(
)
;
lOOOllOOO\
l
++
)
lO\
lOOllOOlO
(
lOOOl\
lOOOl
,
lO\
O\
O\
lOOlO\
l\
O
)
/=
lO\
llOO\
O\
l\
llOl\

(
lOO\
Ol\
lOO\
O\
l
,
lOOOllOO\
Ol\

)
;
for
(
lOOOll\
O\
OOl
=
lOlOOllOOlO
.
llOlOlO\
llOl\
O
(
)
;
--
lOOOllOO\
Ol
>=
0
;
)
{
llOlOl\
lOOO\
O\
O\

=
lO\
lOO\
ll\
OO\
lO\

(
lOOOllOOOl
,
lOOOlOOlOl\
O
)
;
for\

(
lOO\
lOl\
O\
O\
O\
l
=
lOOOllOOOl
+
1
;
lOO\
l\
OlO\
OOl
<
lOlOO\
ll\
OO\
lO
.
ll\
Ol\
OlO\
l\
lOlO
(
)
;
lOOlOlOOOl
++
)
llOlOllOO\
OOO\

-=
lO\
ll\
O\
OOlll\
O\
l
(
lOOlO\
lOO\
O\
l
,
lOO\
O\
llOOOl
)
*
lOl\
OOllOOl\
O
(
lOOlOlO\
OOl
,
lOOOlOOlOlO\

)
;
lOlOO\
ll\
OOlO
(
lOO\
O\
llOOOl\

,
lOOOlOOl\
Ol\
O
)
=
llO\
lOllOO\
OOO
;
}
}
}
}
llOlOlOlO\
lOO
&
oper\
ato\
r\

=
(
const\

llOlOlOlOlO\
O
&
lOO\
lOOOOOOO
)
{
if
(
!
lOlOOl\
O\
l\
l\
O
)
{
Ini\
t\
iali\
se
(
lOO\
l\
O\
OOOO\
OO
.
llOlOlOllOlO
(
)
,
lOOlO\
O\
OO\
O\
O\
O\

.
llOlO\
lOl\
lOll
(
)
)
;
}
else\

{
TA_\
AS\
S\
ERT\

(
ll\
Ol\
Ol\
O\
llOl\
O
(
)
==
lOOlO\
OOOOOO\

.
llOlOlOllOlO
(
)
)
;
TA_A\
SSE\
R\
T
(
llOl\
Ol\
O\
llOll\

(
)
==
lOO\
lOOO\
O\
O\
OO
.
llO\
lOlOllOll
(
)
)
;
}
if
(
lOO\
lOOOOOOO
.
ll\
OlOlOlll\
l\
O
(
)
)
{
if
(
!
llO\
l\
OlO\
ll\
ll\
O
(
)
)
llO\
lOlOlll\
OO
(
)
;
re\
turn
*
this
;
}
for
(
int\

lO\
OOlOOlOO\
l
=
0
;
lOOO\
lO\
OlOOl
<
llOlOl\
OlOlll
;
lOOO\
lOOl\
O\
Ol\

++
)
{
for
(
int
lOO\
OlOOl\
Ol\
O
=
0
;
lOOOlOO\
lOlO
<
llOlOlOllOO\
O\

;
lO\
OOlOOlOlO
++
)
(
*
th\
i\
s
)
(
lOOOlOOlO\
O\
l
,
lO\
OOlOOlOlO
)
=
lO\
O\
lOOOOO\
OO
(
lOO\
OlO\
OlOOl
,
lOOOlOOlOlO\

)
;
}
ll\
OlO\
lOl\
llO\
l
(
)
;
retur\
n
*
this
;
}
priv\
a\
te
:
in\
t\

ll\
O\
lOlOlO\
ll\
l
;
int
llO\
l\
Ol\
O\
ll\
OOO
;
bo\
ol
llOl\
OlOl\
lOO\
l
;
float
*
lO\
lOO\
lO\
l\
l\
O
;
ll\
OlOlOlOl\
OO
(
const
llOlOlOl\
OlOO\

&
)
;
}
;
class
llO\
lOl\
lO\
O\
OOl
{
pu\
blic
:
llO\
l\
Ol\
lO\
OOOl
(
)
{
lOlOOl\
OllO
=
0
;
llOlOlOlOO\
l\
O\

+=
6
;
}
~
llOlOl\
lOO\
O\
Ol
(
)
{
Fi\
na\
li\
se
(
)
;
}
voi\
d
Initialise
(
in\
t
llOl\
Oll\
O\
OO\
lO
)
{
ll\
OlOllO\
OOl\
l
=
llOlO\
ll\
OOOlO
;
TA_A\
S\
S\
E\
RT
(
llOlOll\
OOOll
>=
1
)
;
TA_ASS\
ERT
(
llO\
lOllOOO\
ll\

<=
6
)
;
TA_ASSERT
(
lO\
l\
O\
Ol\
Ol\
lO
==
0
)
;
TA_ASSERT
(
ll\
Ol\
OlOlOOll
)
;
lOl\
OO\
lOllO\

=
llOlOlOlOOll
->
llOl\
O\
lOlO\
OO\
O\

(
llOlOl\
l\
OO\
OlO
)
;
lOOOOO\
OllO
(
lOlOOl\
O\
ll\
O
,
llOlOO\
llOlOl
)
;
llOlOll\
O\
OlOO
(
)
;
}
void
Final\
i\
se
(
)
{
#ifdef llOlOlOOlllO
if
(
lOlOO\
lOllO\

)
{
TA_\
AS\
SE\
RT
(
llO\
lOlOlOOl\
l\

)
;
llOl\
O\
lOlOOll
->
Fre\
e
(
lOlOOl\
Oll\
O\

)
;
}
#endif //
lO\
lOOlO\
l\
lO
=
0
;
}
bool
lOO\
lOO\
lOOll
(
)
const
{
ret\
urn
lOl\
OOl\
Ol\
lO
!=
0
;
}
int\

lOOO\
l\
ll\
O\
Ol
(
)
cons\
t
{
re\
tu\
rn
llO\
lOllOO\
Oll\

;
}
vo\
i\
d\

lOlOl\
lOOOlO
(
)
{
if
(
IsZero
(
)
)
return\

;
for
(
int
lOO\
OllOOO\
l
=
0
;
lO\
OOllO\
O\
Ol
<
llOlOllOOO\
l\
l
;
lOOOll\
O\
OOl\

++
)
lOlOOl\
Ol\
l\
O
[
lO\
OOllOOOl
]
=
0.0f
;
llOlOl\
lO\
OlOl
=
true
;
}
bool
IsZero\

(
)
cons\
t
{
#ifdef _DEBUG
if
(
llO\
l\
O\
llO\
O\
lOl
)
{
for\

(
int
lO\
OOllOO\
Ol
=
0
;
lOOOllOOOl\

<
lOOOll\
lOOl
(
)
;
lOO\
O\
ll\
OOO\
l
++
)
TA_A\
S\
SERT
(
(
*
th\
is
)
(
lOOO\
llOOOl
)
==
0.0f
)
;
}
#endif //
return
llO\
l\
OllOOlOl
;
}
void
llOlOllO\
Ol\
OO
(
)
{
llOlOl\
lOO\
lOl
=
fal\
se\

;
}
void
llO\
l\
OllOOllO\

(
)
{
llOlOllOOlO\
l\

=
true
;
}
inline
floa\
t\

&
ope\
rator
(
)
(
int\

llOlOllOOlll
)
{
retur\
n\

lOlOOlO\
llO\

[
llOl\
Ol\
l\
O\
O\
l\
ll\

]
;
}
inline\

float\

oper\
a\
tor\

(
)
(
int
ll\
O\
lOll\
O\
O\
l\
ll\

)
const
{
re\
turn
lOl\
OOlOl\
lO
[
ll\
Ol\
OllOOll\
l
]
;
}
llO\
lOll\
O\
OOO\
l
&
opera\
tor
=
(
co\
ns\
t
llO\
lOllOO\
OO\
l
&
lOOlO\
OOOOOO
)
{
if
(
!
lOl\
O\
Ol\
OllO
)
{
Init\
ial\
ise
(
lOOlO\
OO\
O\
OO\
O
.
lO\
OO\
ll\
lOOl
(
)
)
;
}
el\
se
{
TA_A\
SSER\
T\

(
lO\
OOll\
lOOl\

(
)
==
lOOl\
O\
OOO\
OOO
.
lOOOlll\
O\
Ol
(
)
)
;
}
if
(
lOOl\
O\
OOO\
O\
OO
.
IsZ\
ero
(
)
)
{
lO\
lOll\
OOO\
lO
(
)
;
retur\
n
*
this
;
}
for
(
in\
t
lOOOl\
l\
OOOl\

=
0
;
lOOOl\
lO\
OOl
<
llOlOllOO\
Ol\
l
;
lOOO\
llOOOl
++
)
(
*
th\
is
)
(
lOOOllOO\
Ol\

)
=
lOO\
lOOOO\
OOO
(
lOOOllOO\
O\
l\

)
;
llOlOllOO\
lOO\

(
)
;
re\
t\
urn
*
th\
is
;
}
private
:
in\
t
llOlOll\
O\
O\
O\
ll
;
boo\
l
ll\
OlOll\
OOl\
Ol
;
fl\
oat
*
lOlOOlOl\
lO\

;
llOlOl\
lOOOOl\

(
llO\
lOll\
OO\
OO\
l
&
)
;
}
;
}
us\
ing
name\
s\
p\
ace
llOlOlOOllOO
;
struct
lO\
llO\
lOlOOll
::
llOlOll\
Ol\
OOO
{
st\
ru\
ct
lO\
Oll\
OOOOO
{
floa\
t
llOlOl\
lOlOOl
[
6
]
;
lOO\
llOOO\
OO
*
llO\
lOllO\
l\
O\
lO
;
lO\
OllOOOOO
*
llOlO\
llOlOl\
l
;
int
lO\
OOl\
OOlOOl\

;
in\
t
lOOOl\
OOlOlO\

;
}
;
lO\
Oll\
OO\
OOO
*
*
ll\
OlOllO\
llOO
;
lOOllOO\
O\
OO
*
*
llO\
lO\
llO\
llOl
;
lOO\
llOOOOO
*
*
llOl\
OllOlllO
;
lOOllO\
O\
OOO
*
lOOlOOlO\
lll
;
int
lOO\
O\
l\
OlOOl
;
int\

llOOlOllOlll
;
in\
t
llOl\
O\
lOlOll\
l
;
ll\
O\
l\
Oll\
O\
lO\
O\
O
(
)
;
~
ll\
OlOllO\
lOOO\

(
)
{
Finali\
se
(
)
;
}
vo\
id
Init\
ialis\
e\

(
in\
t
llOOOllOO\
OO\
l
,
int\

llOlOllO\
l\
ll\
l
)
;
void
Fi\
nalis\
e
(
)
;
void
Cle\
ar
(
)
;
vo\
i\
d\

llO\
lOl\
l\
lOOOO
(
llO\
lOlllO\
OOl
*
llO\
lOlllOOlO
,
int\

llOlOll\
lO\
Oll
)
;
fl\
oat
llOlO\
l\
llO\
lO\
O\

(
int
lOOOlOOlOlO
,
flo\
a\
t
*
llO\
lOlll\
O\
lO\
l
)
;
voi\
d
llOlOll\
lO\
l\
l\
O
(
fl\
oat
*
llO\
lOlll\
Ol\
ll
,
fl\
o\
at\

*
ll\
OlOl\
lllOOO
,
int\

lOO\
lllO\
ll\
O
)
;
vo\
id\

llOlOlll\
lOOl\

(
floa\
t\

*
ll\
OlOlllOlll
,
float
*
llO\
l\
OllllOOO
,
int
lOOlllOllO\

)
;
}
;
struct
lOll\
OlO\
lOOll
::
llOlOll\
llOlO\

{
struct
lOOllOOOOO
{
llOlOlOlOl\
OO
llOl\
Ollll\
Oll
;
lOOllO\
OOOO
*
llOlOl\
lOlOl\
l
;
int
lOOO\
lOO\
l\
Ol\
O
;
int
lOOOlO\
O\
l\
OOl\

;
}
;
st\
ruct
llO\
lOllll\
lOO\

;
struct
llOl\
Oll\
ll\
lOl\

{
llOlO\
lll\
l\
lOl
*
ll\
OlOllllllO
;
llOlOll\
lllO\
O
*
llOlOlll\
l\
lll\

;
llOl\
O\
llll\
l\
OO
*
llOOOOOllO\
l
;
int
llOll\
O\
O\
O\
OO\
OO
;
}
;
st\
ruct
llOlO\
l\
llllOO
{
int\

lO\
lOll\
OOll\

;
int\

ll\
Oll\
OOOOOOl
;
in\
t
llOl\
OlOlOlOl
;
int
ll\
Ol\
l\
OOOOOO\
O\

;
lO\
OllO\
OOOO\

lllO\
OlllOO
;
lOOl\
lOO\
O\
OO
lllOlOOO\
OO\

;
ll\
OlOlll\
l\
lOO
*
ll\
OlOl\
lllll\
O
;
llOlO\
lllllO\
l
*
llOlO\
lllll\
ll\

;
llOlOll\
ll\
lO\
l
*
llO\
OOOOllOl\

;
vo\
i\
d
llO\
llOOOOOlO
(
int
lOOOlOOlOOl
,
const
Vec3
&
ll\
OOl\
llllO
,
cons\
t
Vec3
&
llO\
llOOO\
OOll
)
{
TA_ASSER\
T
(
lllOOlllOO
.
lOO\
OlOOlOlO
>=
0
)
;
TA_AS\
SERT\

(
lllOl\
OOOOO
.
lOOOl\
OO\
lOlO
==
-
1
)
;
TA_A\
SSE\
RT
(
lOOOlOOlOOl\

>=
0
)
;
TA_\
AS\
SER\
T
(
lOOOlOOlOO\
l\

<
lll\
OOlllOO
.
llO\
l\
O\
llllOll
.
ll\
OlO\
lOllO\
lO\

(
)
)
;
TA_ASSER\
T
(
lllOOlllOO
.
ll\
O\
lOl\
ll\
l\
O\
ll
.
llO\
lOlOllOll
(
)
==
6
)
;
lllOOl\
llOO
.
llOl\
Ol\
lllOll
(
lOO\
Ol\
OOl\
O\
O\
l
,
0
)
=
llOOll\
lllO
.
x
;
lllO\
O\
lll\
OO
.
llOl\
Olll\
lO\
ll
(
lOO\
O\
lOOl\
OOl
,
1
)
=
llOOllll\
lO
.
y
;
lll\
OOlll\
OO
.
ll\
OlOlll\
l\
Oll
(
lO\
OOlO\
OlOOl
,
2
)
=
llOOlllllO
.
z
;
lll\
OOll\
lOO
.
llOlOllllOll\

(
lOOOlOO\
lOOl
,
3
)
=
llOll\
OOOOOll\

.
x
;
lll\
OOll\
lOO
.
ll\
Ol\
Ol\
l\
l\
lOll
(
lOO\
O\
l\
OOlOOl
,
4
)
=
llOllO\
OOOO\
ll
.
y
;
lllOO\
lll\
OO\

.
llOlO\
ll\
llOll\

(
lO\
OOlO\
OlOO\
l\

,
5
)
=
llO\
l\
lOO\
OOOll
.
z
;
}
vo\
id
llOl\
lOO\
OO\
OlO
(
in\
t
lOOOl\
O\
Ol\
OOl
,
co\
n\
s\
t
Vec\
3
&
lll\
lOOOOll
,
con\
st
Ve\
c3
&
llOll\
O\
OOO\
lO\
O
,
co\
ns\
t
Vec3
&
lll\
lO\
OOl\
OO
,
con\
st
Vec3
&
ll\
OllO\
O\
OOlOl
)
{
TA_ASSERT
(
lllOOlllOO
.
lOOOlOOlO\
lO
>=
0
)
;
TA_ASSER\
T
(
ll\
lO\
l\
O\
O\
OO\
O
.
lOOOl\
O\
OlOlO
>=
0
)
;
TA_ASSERT
(
lOOOlOOlOOl
>=
0
)
;
TA_ASSERT\

(
lOOOlOOlOO\
l
<
lllOOl\
llO\
O\

.
ll\
OlOllllOll\

.
ll\
O\
lOlOll\
O\
lO
(
)
)
;
TA_A\
SS\
ERT
(
lll\
OOlllOO
.
ll\
OlO\
llllOll
.
llOlOl\
Oll\
Oll
(
)
==
6
)
;
TA_ASS\
ER\
T
(
lO\
OOl\
OO\
l\
OOl\

<
ll\
lOlOOOOO
.
llOlOl\
ll\
lOll
.
ll\
O\
lOlOl\
lO\
lO
(
)
)
;
TA_ASS\
E\
RT
(
lll\
OlOO\
OOO
.
llOlOll\
llOl\
l
.
ll\
O\
lOl\
OllOl\
l
(
)
==
6
)
;
lllOOlllOO
.
llO\
lO\
l\
lll\
Ol\
l
(
lO\
OOlOOlOOl\

,
0
)
=
llllOOOOll
.
x
;
ll\
lOOlllOO
.
llOlOl\
lllOll
(
lOO\
OlOOlOO\
l
,
1
)
=
llllOO\
OOll
.
y
;
lllOOl\
llOO
.
llOl\
OllllOll
(
lO\
OO\
l\
OOlOOl
,
2
)
=
llllO\
OOO\
ll
.
z
;
ll\
lO\
O\
lllOO
.
llO\
lOll\
llOll
(
lO\
OO\
lOOlOOl\

,
3
)
=
ll\
O\
llOO\
O\
OlOO
.
x
;
lllOOlll\
O\
O
.
llOlOlll\
l\
O\
ll\

(
lOOOl\
OOl\
OOl
,
4
)
=
ll\
O\
llOO\
OOl\
OO
.
y
;
ll\
lO\
OlllOO
.
llOlO\
l\
lllO\
ll\

(
lOOO\
l\
OOl\
O\
Ol\

,
5
)
=
ll\
O\
llO\
OO\
OlOO
.
z
;
lllOl\
OO\
OOO\

.
ll\
OlOll\
ll\
Ol\
l\

(
lO\
OOlO\
OlOOl
,
0
)
=
llllO\
OOlO\
O\

.
x
;
ll\
lOlOOOOO
.
llO\
lOl\
lllOll\

(
lOO\
OlOOlOO\
l
,
1
)
=
lll\
lOOOl\
OO\

.
y
;
lllOlOO\
OOO
.
llOlOllllO\
ll\

(
lOOOlOO\
lOO\
l
,
2
)
=
ll\
llOO\
OlO\
O
.
z
;
lllOlOOOOO
.
llOlOllllOll
(
lO\
OOlOOlOOl
,
3
)
=
llO\
llOO\
OOlOl\

.
x
;
lllOlOOOO\
O\

.
llOlOlll\
lOll\

(
lOOOlOOlOOl
,
4
)
=
llOll\
OOOOlOl
.
y
;
lllOlOOOOO
.
llOlO\
llll\
Oll
(
lO\
O\
OlO\
Ol\
OOl
,
5
)
=
llOllO\
O\
OOlOl
.
z
;
}
}
;
lOO\
l\
l\
O\
OOOO
*
*
llOlOllOllOl
;
lOOl\
lOOO\
OO
*
*
ll\
OlO\
llOll\
lO\

;
llOlOllllOl\
O
(
)
{
}
;
~
llO\
lOlll\
l\
Ol\
O
(
)
{
Final\
ise
(
)
;
}
void\

Init\
ialise
(
in\
t
ll\
O\
O\
Ol\
l\
O\
OOOl
,
int
llO\
lO\
l\
l\
O\
lll\
l
)
{
llO\
llOOOOll\
O\

=
0
;
llOllOOOOl\
ll
=
ll\
OOOll\
OOOOl
;
llOl\
lOO\
O\
lOOO
=
llOlO\
llOllll
;
llOOlOllOlll
=
llOlOllO\
ll\
l\
l
;
lO\
OOllllOO\

(
ll\
O\
lO\
llO\
llOl
,
lOO\
llOOOOO\

*
,
llO\
lO\
llO\
ll\
l\
l
)
;
lO\
OOllllO\
O
(
llO\
l\
O\
llOlllO
,
lOOllOO\
OOO
*
,
llOlOllO\
llll
)
;
lOOOl\
lll\
OO
(
llOllOOOlOO\
l
,
ll\
OlOl\
llllOO
,
llO\
OOll\
O\
OO\
O\
l
)
;
lOOO\
l\
lllOO
(
llOllOOO\
lOlO
,
llOlO\
ll\
lllOl\

,
ll\
OlOllO\
llll
)
;
memset
(
llOlOllOll\
Ol
,
0
,
ll\
Ol\
l\
O\
OOlO\
OO
*
sizeof\

(
lOOll\
O\
O\
O\
O\
O
*
)
)
;
me\
mset
(
llO\
lOllOlllO
,
0
,
ll\
O\
ll\
OOOlOOO\

*
siz\
eof
(
lO\
OllOO\
OOO
*
)
)
;
memset
(
llO\
llOOO\
lOl\
O
,
0
,
llOl\
lOOO\
lO\
O\
O
*
sizeo\
f
(
llOlO\
lllllOl\

)
)
;
}
void
Fi\
nalis\
e
(
)
{
llOllOOOOl\
lO
=
0
;
ll\
O\
l\
lOO\
OOl\
ll
=
0
;
llO\
l\
lOO\
OlOOO\

=
0
;
llOOlOllOll\
l
=
0
;
llOlOO\
llOl\
l\
O
(
llOlOllOll\
Ol
,
lOO\
ll\
OOOO\
O\

*
)
;
llOlOO\
l\
lO\
ll\
O
(
ll\
OlO\
llO\
lllO
,
lOO\
l\
lOOOO\
O
*
)
;
llO\
lOOll\
OllO
(
llO\
l\
lOO\
Ol\
O\
Ol
,
llO\
lOlllllOO
)
;
ll\
O\
l\
OO\
ll\
O\
llO
(
llO\
llOOO\
lOlO
,
ll\
OlOlllll\
Ol
)
;
}
void
Cl\
ear\

(
)
{
mems\
et
(
ll\
OlOll\
OllOl
,
0
,
llOOlOl\
l\
Oll\
l\

*
sizeof\

(
lOO\
llO\
OOOO\

*
)
)
;
mems\
e\
t
(
llOlOl\
lO\
lll\
O
,
0
,
llO\
OlOllO\
l\
ll
*
siz\
eof
(
lOOll\
OOO\
OO
*
)
)
;
me\
mse\
t\

(
llO\
llO\
OOlO\
lO
,
0
,
ll\
OOlOl\
l\
Olll
*
sizeof
(
llOlOlllllO\
l
)
)
;
for
(
int
llOO\
OO\
lO\
OOO\
O
=
0
;
llOOOO\
lO\
OO\
O\
O
<
llOllO\
O\
OOl\
lO
;
llOO\
O\
OlO\
OOOO
++
)
{
TA_ASS\
E\
RT
(
llOllOOOlO\
Ol
[
llO\
OOO\
lOOOOO
]
.
lllOOlllO\
O
.
lOO\
OlOO\
lOl\
O
>=
0
)
;
llO\
llOOOlOOl
[
llOOOOlO\
O\
OOO
]
.
ll\
lOOlll\
O\
O
.
ll\
Ol\
OllllOl\
l
.
Final\
i\
se
(
)
;
if
(
llO\
l\
l\
OOOlOOl
[
llO\
O\
OOlOOOOO
]
.
lll\
OlOOOO\
O
.
lO\
OOlOOlO\
l\
O
>=
0
)
llOl\
lOOOlO\
Ol
[
llOOOOl\
OO\
O\
OO\

]
.
lllOl\
O\
OOOO
.
llOl\
Ollll\
O\
ll
.
Finali\
se
(
)
;
}
ll\
Ol\
lOOO\
O\
ll\
O
=
0
;
llOOlOl\
lO\
lll\

=
0
;
}
int
ll\
Ol\
lOOOlOll
(
)
const
{
retu\
rn
llOllOOOO\
llO
;
}
int
lOllOllllO\
lO\

(
)
const\

{
ret\
u\
r\
n\

ll\
OO\
lO\
ll\
Olll
;
}
void
llO\
llOOOl\
lOO
(
)
{
llOOlO\
ll\
O\
lll\

++
;
TA_ASSE\
RT
(
llOOlO\
llOll\
l
<=
llOllOO\
Ol\
OOO\

)
;
}
llOlOlllllOO
*
llOl\
l\
O\
O\
OllOl\

(
in\
t
lOO\
O\
lO\
Ol\
ll
)
{
TA_\
ASSERT
(
lO\
O\
OlO\
Olll
>=
0
)
;
TA\
_\
ASSE\
RT
(
lOOOlO\
Oll\
l
<
llOllOOOOll\
O\

)
;
retur\
n\

&
ll\
Ol\
lOOOlOOl
[
lOOOl\
O\
Ol\
ll
]
;
}
ll\
OlOlllllOl
*
llOll\
O\
OOl\
llO
(
in\
t\

lOOOlOOlll\

)
{
TA_ASSERT
(
lO\
OOlOOl\
ll\

>=
0
)
;
TA_\
AS\
SERT
(
lOO\
OlO\
Ol\
ll\

<
ll\
OO\
lOll\
Olll
)
;
retu\
rn
&
llOl\
lOOO\
l\
OlO
[
lOOOlOOlll
]
;
}
in\
t
llOllOO\
Ol\
lll
(
int
llOl\
OlOl\
OlOl
,
int
llO\
l\
lO\
OlOO\
O\
O
,
in\
t
llOllOOlOO\
Ol\

,
u32
lOlOl\
l\
OOl\
l
)
{
TA_ASSERT
(
llOl\
OlOlOlOl
>
0
)
;
TA_ASSERT
(
llOllOOOOllO
>=
0
)
;
TA\
_A\
SSE\
RT
(
llOllOOOO\
lll
>=
0
)
;
TA_ASSER\
T\

(
llOll\
OO\
lOOOO
>=
0
)
;
TA_\
ASSERT
(
llOllOO\
lO\
O\
OO\

<
llOOlOl\
l\
O\
lll\

)
;
int\

ll\
Ol\
l\
OOl\
OOlO\

=
llOllOOOOllO
;
ll\
OlOlllllO\
O
&
ll\
Oll\
OOlOOll
=
llOl\
lO\
OO\
lOOl
[
llOllOOO\
OllO
++
]
;
llOll\
O\
Ol\
OO\
ll
.
lOlOll\
OOll\

=
lO\
lOllO\
Oll
;
llOll\
OO\
l\
O\
O\
ll\

.
llO\
lOlOl\
OlOl
=
llOl\
O\
lOlOlOl
;
ll\
Oll\
OOlOOll
.
llOll\
O\
O\
O\
OOOl
=
-
1
;
llOllOOlO\
O\
l\
l\

.
ll\
O\
llOO\
O\
O\
O\
OO
=
-
1
;
llO\
llO\
OlO\
Oll\

.
ll\
lO\
OlllOO\

.
lOOOlOO\
l\
OlO\

=
ll\
OllOOlO\
OOO\

;
ll\
OllOOl\
O\
O\
ll
.
ll\
lOOlll\
O\
O
.
lO\
OO\
l\
OOlO\
Ol
=
ll\
OllO\
OlOO\
l\
O
;
ll\
OllO\
O\
lOOll
.
lllOOlllO\
O\

.
llOlO\
l\
lllO\
ll\

.
Ini\
tiali\
s\
e
(
llOlOlOlOlO\
l
,
6
)
;
if
(
llOlOllOll\
lO
[
ll\
O\
ll\
OOlOOll
.
ll\
lO\
Olll\
OO
.
lOOO\
lOOlOl\
O
]
)
llO\
lOllOlllO
[
llOl\
l\
OOlOOll\

.
lllOOl\
llOO
.
lOOOlOOlO\
lO\

]
->
ll\
O\
lOllOlO\
ll
=
&
ll\
Ol\
lOOl\
O\
Oll
.
ll\
lOOll\
lO\
O
;
llOlOl\
lOll\
l\
O
[
llO\
ll\
O\
OlO\
O\
ll\

.
lllOO\
lllOO
.
lOO\
O\
lOOl\
OlO\

]
=
&
llOllO\
Ol\
O\
Ol\
l
.
ll\
l\
OOlllOO
;
if
(
!
llOlOllOl\
lOl
[
llOllOO\
l\
OOll
.
lllOOll\
l\
OO\

.
lOO\
OlOO\
lOlO
]
)
llOlOll\
OllO\
l
[
llOll\
OO\
lOOll
.
ll\
l\
OOll\
l\
O\
O
.
lOOOlO\
OlOlO
]
=
&
llOllO\
OlOOl\
l\

.
lll\
OOl\
llOO
;
ll\
Ol\
lOOlOO\
ll
.
ll\
lOOll\
lOO
.
ll\
OlO\
llOlOll
=
0
;
llOllOOlO\
Oll
.
ll\
OlO\
ll\
l\
lllO
=
0
;
llO\
llO\
O\
lOOl\
l
.
ll\
O\
lOlllllll
=
0
;
ll\
O\
l\
lOO\
lOOll
.
llOOOOOll\
Ol\

=
0
;
llOllO\
OlOOll\

.
lllOlOOOOO
.
lO\
OOlO\
OlOlO
=
ll\
O\
llOOlOOOl
;
llOllOOlOO\
ll
.
ll\
lOl\
O\
OOOO
.
lOO\
OlOO\
lO\
Ol
=
llOl\
lOOl\
O\
OlO\

;
if\

(
llOllOO\
lO\
OOl
>=
0
)
{
TA_ASSERT
(
llOllOO\
lO\
O\
Ol
<
llO\
O\
lOl\
l\
O\
ll\
l
)
;
llOll\
OOlOOll
.
lllO\
lOOOOO
.
llO\
l\
O\
llll\
O\
ll
.
Initialise
(
llOlOlOlO\
l\
Ol
,
6
)
;
if\

(
llOlOllO\
l\
l\
lO
[
llOllOOl\
OO\
l\
l
.
ll\
lO\
lOOOOO
.
lOOO\
l\
OOl\
OlO\

]
)
llO\
lOl\
lOl\
l\
lO
[
llO\
llOO\
lOOl\
l
.
lllOlOOOO\
O\

.
lOOOlOOlOl\
O
]
->
ll\
O\
lO\
l\
lOlOl\
l\

=
&
llOl\
lOOl\
OOl\
l
.
lll\
Ol\
OO\
OOO
;
llOlOllOlllO\

[
llOl\
lOOl\
OOl\
l
.
lll\
O\
lOOOOO
.
lOO\
O\
lOO\
lOlO
]
=
&
ll\
OllOOl\
OOll
.
lllOl\
OOOO\
O
;
if
(
!
llOl\
OllOllOl
[
llO\
l\
l\
OOlO\
Oll\

.
lllO\
lOOOOO
.
lOO\
OlOO\
lOlO\

]
)
llO\
l\
Oll\
OllOl\

[
ll\
OllO\
Ol\
O\
Oll
.
lllO\
lOOO\
OO\

.
lOO\
O\
lO\
Ol\
OlO
]
=
&
llOllOOlOOll
.
ll\
lOlO\
OO\
OO
;
llOl\
lOOlO\
Ol\
l
.
lllO\
l\
OO\
OOO
.
llOlO\
llOlO\
ll
=
0
;
llOl\
lO\
O\
lOOll\

.
llOlO\
lll\
ll\
lO
=
0
;
llOllO\
Ol\
OOll
.
llOlO\
l\
lll\
ll\
l
=
0
;
ll\
Ol\
lOOl\
OOl\
l
.
llOO\
OOO\
llO\
l
=
0
;
}
re\
t\
urn\

llOllOOlOOlO
;
}
voi\
d
lO\
OOl\
lOl\
Ol\

(
)
{
for
(
int
llO\
OOOl\
OOOO\
O
=
0
;
llOOOOlOOOOO
<
llOl\
lOOOOllO
;
llOOOOl\
OOOOO
++
)
llOl\
lOOl\
OlOO
(
llOOO\
Ol\
OOOO\
O
,
0
)
;
}
void
ll\
OllOOlO\
lOl
(
llOlOlllll\
O\
O
&
llOllO\
Ol\
OOll
)
{
llOllOOlOOll
.
lOlOllO\
Oll
&=
~
llO\
llOO\
l\
OllO
;
if
(
ll\
Ol\
l\
OO\
l\
OOll
.
llOO\
OOO\
llO\
l
)
{
llO\
llOOl\
OOl\
l\

.
ll\
OOOOOllOl\

->
llOlO\
llllll\
l
=
llOl\
lOOlO\
O\
ll\

.
llOlOll\
llllO
;
llOllOO\
lOOl\
l\

.
llOlOlllll\
lO
=
0
;
llO\
llO\
OlO\
Oll
.
llOOOOO\
l\
lOl
=
0
;
for
(
llOl\
Ollll\
l\
O\
l
*
llO\
O\
O\
OOlllO
=
llOll\
OOlOO\
ll
.
llO\
lOl\
llllll
;
llOOOOOlllO\

;
)
{
llOlOl\
ll\
l\
l\
Ol
*
lOO\
OOOlOOO\
l
=
llOO\
OOOll\
lO
->
llOlOl\
l\
l\
lllO
;
llOOOOOll\
lO
->
ll\
OlOl\
ll\
lll\
O\

=
0
;
ll\
OOO\
OOlllO
->
llOOO\
OOllOl
=
0
;
llO\
O\
O\
OOl\
l\
lO
=
lOOOO\
OlO\
OOl\

;
}
}
}
void\

ll\
OllOOlOlO\
O
(
in\
t
llO\
OOO\
lO\
OO\
OO\

,
llOlOlllllOl
*
ll\
OOOOOl\
lOl
)
{
TA\
_ASSE\
RT
(
llOO\
OOlOOOOO\

>=
0
)
;
TA\
_ASSERT\

(
llO\
OOO\
lOO\
OOO\

<
llOl\
lOOOO\
llO\

)
;
llOlOll\
lllOO
&
llOl\
lO\
O\
l\
OOl\
l\

=
llOl\
lOOOlO\
Ol
[
llO\
OOOlOO\
O\
OO
]
;
if\

(
llOl\
lO\
OlOO\
ll
.
lO\
lOllO\
Oll
&
ll\
O\
llOOlOlll
)
{
if
(
llO\
llOOl\
OOll
.
llOOOOOl\
lO\
l
)
{
TA\
_A\
SSERT
(
llO\
llOO\
lOO\
ll\

.
lOl\
Oll\
OOll
&
llOl\
lOOlO\
l\
lO
)
;
TA_A\
S\
SE\
RT
(
!
llOOOOOllOl
||
ll\
OOOOOllOl
->
ll\
OOOOO\
llOl
==
&
llOllOO\
l\
O\
Oll
)
;
}
ret\
urn
;
}
if
(
llOl\
lOOlOOll
.
lOl\
O\
llOOll\

&
llOOOOOllllO
)
llOll\
OO\
lOO\
ll
.
lOl\
Oll\
OOll
|=
llOll\
OOlOll\
O
;
else
ret\
ur\
n
;
TA_ASSE\
RT
(
llOllO\
O\
l\
OOll
.
llOOOOOl\
lOl
==
0
)
;
llO\
l\
l\
OO\
lOO\
ll\

.
ll\
OOOOOll\
Ol
=
ll\
OOOOOllOl\

;
ll\
OllOO\
lO\
Oll
.
lOlOl\
lOOll
|=
llOl\
lOOlOll\
l\

;
TA\
_\
A\
SSERT
(
llOl\
l\
OOlOO\
l\
l
.
lO\
lOllOO\
ll\

&
llO\
l\
lOOlO\
ll\
O
)
;
TA_A\
SS\
ERT
(
llOllOOl\
O\
Oll
.
llOlOllll\
llO
==
0
)
;
if
(
ll\
OOOOOllOl\

)
{
llO\
ll\
OOlOO\
ll\

.
llOlOllll\
l\
lO
=
llO\
O\
O\
OO\
llOl
->
llOlOl\
l\
lllll
;
llOOOOO\
l\
l\
O\
l
->
llOlO\
lllll\
l\
l\

=
&
llO\
ll\
OOlO\
Ol\
l\

;
}
llOlOlllllOl
&
lllOll\
OlllO
=
llOll\
OO\
OlOlO
[
llOllOOl\
OO\
ll
.
lllOOll\
l\
OO
.
lOOOl\
OOl\
O\
l\
O\

]
;
llO\
l\
O\
l\
l\
ll\
lOl\

&
lllOllOl\
lll\

=
llOl\
lOOO\
l\
OlO\

[
llO\
l\
lO\
Ol\
OOll\

.
lllOlOOOOO\

.
lOOOl\
OOlOl\
O
]
;
if\

(
llOOOOO\
ll\
Ol\

==
0
)
{
if
(
lll\
OllOll\
l\
O
.
llOOOO\
OllOl
||
lll\
Oll\
Ollll
.
llOOO\
OO\
ll\
Ol
)
{
llOl\
lOOlOl\
Ol
(
llO\
llOOl\
OO\
l\
l
)
;
retur\
n
;
}
lllOllOlllO\

.
ll\
OO\
O\
OOl\
lOl
=
&
ll\
OllOOl\
OO\
ll\

;
lllOllO\
l\
lll
.
llOOOOO\
llOl
=
&
llOllOOlOOl\
l
;
ll\
OllOO\
llOOO
(
llO\
ll\
OO\
lOOll
.
lllO\
O\
ll\
lOO
.
lOOO\
lOOlOlO
,
&
llOllOO\
lOOl\
l
)
;
llOllO\
Oll\
OOO
(
llOllOOl\
O\
O\
ll\

.
lll\
OlOOOOO
.
lOOOl\
OO\
l\
OlO
,
&
llOll\
OOlOO\
ll
)
;
}
else\

if
(
&
ll\
l\
OllO\
lllO
==
llOOO\
OOll\
O\
l
)
{
if
(
ll\
lO\
llOllll
.
llOOOOO\
llOl
)
{
llOllOOlOl\
Ol
(
llO\
llO\
OlOOll\

)
;
TA_ASS\
ERT\

(
ll\
Oll\
O\
OlOOl\
l
.
llO\
OO\
OOllOl
==
0
)
;
return
;
}
TA_A\
SSERT
(
lllO\
llO\
lll\
l
.
llOOO\
O\
O\
llOl
==
0
)
;
ll\
lOl\
l\
Olll\
l
.
ll\
OO\
O\
OOllO\
l
=
&
llOllOOlOOll
;
ll\
OllOOllO\
O\
O
(
llOll\
OOl\
O\
Oll
.
lllOlOOOO\
O
.
lOO\
Ol\
OOl\
OlO
,
&
llO\
llO\
Ol\
OOll
)
;
}
el\
se
if
(
&
lllOllOllll\

==
llOO\
O\
OOllOl
)
{
if
(
lllO\
l\
lOlllO
.
llOO\
OOOll\
Ol
)
{
ll\
OllOOlOl\
Ol\

(
llOllOO\
lOOll
)
;
TA_\
ASS\
ERT\

(
llOl\
lO\
O\
lOOll\

.
ll\
OO\
OO\
OllO\
l
==
0
)
;
return
;
}
TA_\
A\
SSERT
(
lllOllOlllO
.
llOOOOOllOl
==
0
)
;
lll\
OllO\
lllO
.
llOOOOOllO\
l
=
&
ll\
Oll\
OOl\
OOll
;
llO\
l\
lO\
Ol\
lOOO
(
llOllOO\
lOO\
ll
.
lllO\
O\
ll\
lOO
.
lOOOl\
OO\
l\
O\
lO
,
&
llOl\
lOOl\
OOll
)
;
}
el\
se
{
ll\
lOOl\
O\
O\
O\
l
(
0
)
;
}
}
vo\
id
llOllOOllOO\
O
(
int
llOO\
OOO\
l\
lOOl
,
ll\
Ol\
Ol\
l\
lll\
OO
*
llO\
O\
OOOll\
Ol\

)
{
ll\
OlOl\
llllOl
*
llOOO\
Oll\
OO\
O
=
&
llOllOOOl\
OlO
[
llOOO\
OOl\
lOO\
l
]
;
TA\
_A\
S\
S\
ER\
T
(
llO\
OO\
Oll\
OOO\

->
llOO\
OOOll\
Ol
!=
0
)
;
TA_ASS\
ER\
T
(
ll\
O\
OO\
Oll\
OOO
->
ll\
Ol\
Oll\
llllO\

==
0
)
;
if
(
llOOOOOllOl
)
{
ll\
OOOOl\
lOOO
->
ll\
O\
lOlll\
lllO
=
ll\
OO\
OOOllOl
->
llOl\
Ol\
llll\
l\
l
;
ll\
O\
OOOO\
llOl\

->
llO\
lOllll\
l\
l\
l
=
ll\
O\
OOO\
ll\
O\
O\
O\

;
}
for\

(
lO\
Ol\
lO\
O\
O\
OO\

*
lOOl\
llO\
O\
Ol
=
ll\
Ol\
OllOllOl
[
llO\
O\
O\
OO\
llOOl
]
;
lOO\
ll\
l\
OOO\
l
;
lOOl\
llO\
OOl\

=
lOOlll\
OOOl
->
llOlOllOlOll\

)
ll\
Ol\
lOO\
l\
OlOO
(
lOOlllO\
OOl
->
lO\
OOl\
OOlOOl
,
ll\
O\
OOO\
ll\
OO\
O\

)
;
}
privat\
e
:
llOlOlllllOO
*
llOllOOOlO\
Ol
;
llOlOlll\
l\
lOl
*
llOllOOOlOl\
O\

;
int\

llOll\
OOO\
O\
llO\

;
int\

llOllOOOOlll\

;
int
ll\
OOlO\
l\
lO\
lll
;
int
ll\
OllO\
OOlOOO\

;
}
;
stru\
ct
lOl\
lOlO\
lO\
O\
ll
::
ll\
OllOOl\
lOOl\

::
llOO\
OOOlOO\
O
{
bool\

llO\
ll\
O\
OllO\
lO
;
bool\

llO\
l\
lOOllOll
;
bo\
ol
llOllO\
Olll\
OO\

;
int\

lOOOlO\
Ol\
ll
;
llOlOl\
Ol\
OlOO
ll\
Oll\
O\
Ol\
l\
lOl\

;
llOlOlOlOlOO
llOllOOl\
lll\
O\

;
llOlO\
l\
OlOl\
OO\

llOl\
lOOll\
ll\
l
;
ll\
Ol\
Ol\
lOOOOl\

x
;
llOOOOOl\
OO\
O
*
llO\
l\
O\
llll\
lll
;
ll\
OO\
O\
OO\
lOO\
O
*
llOlOll\
l\
lllO
;
llOOOOOlOO\
O\

*
llO\
OOOOllOl\

;
}
;
struc\
t\

lOl\
lOlOlOO\
ll\

::
llOl\
lOlO\
OOO\
O
{
in\
t
lOOOlOOlOlO
;
llOlOlOlOlOO
llOlOllllOl\
l
;
}
;
lOll\
OlOlOO\
ll
::
llOlO\
l\
l\
Ol\
OOO
::
ll\
O\
lOllOlO\
OO
(
)
{
llOlOllOl\
lOO
=
0
;
ll\
OlOllOllOl
=
0
;
llOl\
O\
llOlllO
=
0
;
lOO\
l\
OO\
lOlll
=
0
;
lOOOl\
OlOOl
=
0
;
}
void
lOll\
OlO\
lO\
Oll
::
ll\
O\
lOl\
l\
Ol\
OOO
::
Ini\
t\
i\
alise
(
int
llOO\
Ol\
lOOOOl
,
int\

llO\
lOllOl\
lll
)
{
TA_A\
SS\
ERT
(
ll\
Ol\
OllOl\
l\
O\
O
==
0
)
;
lOOOllllOO
(
ll\
OlO\
llOllOO\

,
llOlOllOlO\
OO\

::
lOOllOO\
OOO
*
,
llO\
O\
O\
l\
lOO\
OOl
)
;
TA_\
ASSERT
(
ll\
O\
lOllOll\
Ol\

==
0
)
;
lOO\
Oll\
llOO\

(
ll\
OlOl\
lOllOl
,
llO\
l\
Ol\
lOlOOO\

::
lOOllOOO\
O\
O
*
,
llOlOl\
lO\
llll\

)
;
TA_ASSERT\

(
llOlOllO\
ll\
lO
==
0
)
;
lOO\
OllllO\
O
(
llOlOllOll\
lO
,
llOlOl\
lO\
lOOO
::
lOOllO\
OO\
OO
*
,
llOlO\
ll\
Ol\
lll\

)
;
memset\

(
llO\
lOllOl\
lOl
,
0
,
ll\
O\
lOllOll\
ll
*
si\
ze\
o\
f\

(
ll\
OlOllO\
l\
OOO
::
lOOllOO\
OOO
*
)
)
;
me\
m\
set
(
llOlOllOlllO
,
0
,
llOl\
O\
llO\
ll\
ll
*
sizeof
(
llOlOllOlOOO
::
lO\
OllO\
OO\
OO\

*
)
)
;
TA_\
AS\
SERT
(
lOOlOOlOlll
==
0
)
;
lO\
OOl\
lllOO\

(
lOO\
lO\
Ol\
Olll
,
lOOll\
OO\
OO\
O\

,
llOO\
Ol\
l\
OOOO\
l
*
2
)
;
lOO\
OlOlO\
Ol
=
0
;
llOOlOllOlll
=
0
;
llOlOl\
OlOlll\

=
0
;
}
voi\
d
lOllOlOlOO\
l\
l\

::
llO\
lOl\
lOlO\
OO
::
Fi\
n\
a\
l\
ise\

(
)
{
ll\
O\
lOOllOl\
l\
O
(
ll\
OlOllO\
llOO
,
lOOl\
lOO\
OOO
*
)
;
ll\
OlOOllOllO\

(
llOlOllOl\
lO\
l
,
lOO\
ll\
OOO\
O\
O
*
)
;
llO\
l\
OOllOllO
(
llOlOllO\
ll\
lO
,
lOO\
l\
lO\
OOO\
O
*
)
;
llOl\
OOllOllO
(
lOO\
lO\
O\
lOlll\

,
lO\
Ol\
lOO\
O\
OO\

)
;
lO\
OOlOlOOl\

=
0
;
ll\
O\
Ol\
OllOlll
=
0
;
llOl\
O\
lOlOl\
l\
l
=
0
;
}
vo\
id
lOllOl\
OlOOll
::
ll\
O\
l\
Oll\
Ol\
OOO
::
Cle\
ar\

(
)
{
TA_ASSE\
RT
(
llO\
lOl\
lO\
llOl
)
;
TA_AS\
SERT
(
llOlO\
llOlllO
)
;
lOO\
OlOlOO\
l
=
0
;
mems\
et
(
ll\
OlOllOl\
l\
O\
l
,
0
,
ll\
OOlO\
llOlll
*
si\
ze\
of\

(
llO\
l\
Ol\
l\
OlO\
OO
::
lO\
OllO\
OO\
OO
*
)
)
;
me\
mse\
t\

(
llO\
lOllOll\
lO
,
0
,
llOO\
lO\
llOll\
l
*
sizeo\
f
(
llOlOllOlOOO
::
lOOll\
O\
OO\
OO\

*
)
)
;
ll\
OOlOllOlll
=
0
;
ll\
O\
l\
OlOl\
O\
lll
=
0
;
}
void
lOll\
OlOl\
OO\
l\
l
::
llOlO\
llOlOOO
::
llO\
lOll\
l\
OO\
OO\

(
llOlOll\
lOO\
Ol
*
ll\
OlOl\
llOOlO
,
int\

ll\
OlOlllOOll\

)
{
llOO\
lO\
llO\
lll
=
llO\
l\
O\
lllO\
Ol\
l\

;
for\

(
int
lO\
OOl\
O\
O\
lOOl
=
0
;
lOOOlOO\
lOOl
<
ll\
Ol\
OlO\
lOl\
ll
;
lOOOlOOlO\
Ol
++
)
{
ll\
O\
l\
Oll\
Ol\
OOO
::
lOOl\
l\
O\
OOOO\

*
lO\
O\
ll\
lOO\
O\
l
=
llOlOllOl\
l\
O\
O
[
lOOOl\
OO\
l\
O\
O\
l
]
;
for
(
;
lOOl\
l\
lOOOl
;
lOOlllOO\
Ol
=
lOOl\
l\
lOOOl
->
llOlO\
llOl\
Ol\
O
)
{
con\
s\
t
llOlOl\
ll\
OOO\
l\

&
llOll\
OlOOO\
Ol
=
ll\
O\
l\
O\
lll\
O\
O\
lO
[
lOOl\
llOO\
Ol
->
lO\
OOl\
OOlOlO
]
;
lOOlllOO\
Ol
->
llOl\
O\
llOlOO\
l\

[
0
]
*=
llOll\
OlOO\
OO\
l
.
lO\
OO\
lll\
OlOlO
;
lO\
OlllOOOl\

->
llO\
l\
Ol\
lOlO\
Ol
[
1
]
*=
llO\
llO\
l\
O\
OOOl
.
lOOO\
l\
l\
lOlO\
l\
O\

;
lOOll\
lOOO\
l\

->
llOlOl\
lOlOOl
[
2
]
*=
llO\
ll\
OlOOO\
O\
l\

.
lO\
OOlll\
OlO\
l\
O
;
lOO\
lllOO\
O\
l\

->
llOlOllOlOO\
l
[
3
]
=
lOO\
lllOOO\
l
->
llOlO\
llOlOOl\

[
3
]
*
llOl\
lO\
lOOO\
Ol
.
llO\
ll\
Ol\
OOOl\
O
[
0
]
+
lO\
Ol\
llOOO\
l\

->
llOl\
Oll\
O\
lOOl
[
4
]
*
llOllOlOOOOl
.
llOllOlO\
OOll
[
0
]
+
lO\
Oll\
l\
OOOl\

->
llOlOll\
OlOOl
[
5
]
*
llO\
llO\
l\
OOOO\
l
.
llO\
llOl\
OOlO\
O
[
0
]
;
lOO\
lllOOOl
->
llO\
lO\
llOlOOl
[
4
]
=
lO\
O\
lllOO\
Ol
->
llOlO\
llO\
l\
OO\
l\

[
4
]
*
ll\
OllO\
l\
OOO\
O\
l
.
llOll\
Ol\
O\
OO\
ll
[
1
]
+
lO\
OlllOOO\
l
->
llO\
lOl\
l\
OlOO\
l\

[
5
]
*
llOllO\
lOOOOl
.
llOllOlOOlO\
O
[
1
]
;
lOOlllOO\
Ol
->
llOlOllOlOOl
[
5
]
=
lOO\
l\
ll\
OOO\
l\

->
llOlOl\
lOlOOl
[
5
]
*
llOl\
lOl\
OO\
OOl
.
ll\
OllO\
lOO\
lOO
[
2
]
;
}
}
}
float
lOllO\
l\
O\
lOOl\
l
::
llO\
lOl\
lOlO\
OO
::
llOlO\
lllO\
lO\
O
(
int
lOO\
OlO\
O\
lOOl\

,
floa\
t
*
ll\
O\
lO\
lllOlOl
)
{
TA\
_ASSERT
(
ll\
OlOl\
llOlO\
l
)
;
flo\
at
lOlOllllO\
lO
=
0.0f
;
lOOl\
l\
OOO\
OO
*
lO\
OlllOOOl\

=
llOl\
O\
llOl\
lOO\

[
lO\
OO\
lOOlOOl
]
;
for
(
;
lOOlllOOOl
;
lOOlllOO\
O\
l
=
lOOl\
l\
l\
O\
OOl\

->
ll\
OlOllO\
lOlO\

)
{
int
lOOO\
l\
OOl\
OlO
=
lOOlll\
OOOl
->
lOOO\
l\
O\
O\
lOlO
*
6
;
lO\
lOllllOlO
+=
llOlOlll\
OlOl
[
lOOOl\
OOlO\
l\
O
+
0
]
*
lOOl\
ll\
OO\
Ol
->
llOlOllO\
l\
OOl
[
0
]
;
lOlOllllO\
lO
+=
llOlO\
lllOlOl
[
lO\
OO\
lOOl\
OlO
+
1
]
*
lO\
O\
lll\
OOOl
->
llOl\
OllOl\
OO\
l
[
1
]
;
lOl\
O\
l\
lllOlO\

+=
llOlO\
ll\
lOl\
Ol\

[
lO\
O\
Ol\
O\
Ol\
OlO
+
2
]
*
lO\
OlllO\
OOl
->
ll\
OlOllO\
lOOl
[
2
]
;
lOlO\
l\
lllOlO
+=
llOl\
OlllOlOl\

[
lOO\
OlOOlOlO
+
3
]
*
lOO\
lllOOOl\

->
llOl\
O\
llO\
l\
OO\
l
[
3
]
;
lOlOllllOl\
O
+=
ll\
Ol\
Ol\
llO\
l\
Ol
[
lOOOl\
OOlOlO
+
4
]
*
lOOll\
lOOOl
->
ll\
O\
l\
O\
l\
lOlOOl\

[
4
]
;
lOlOllll\
OlO\

+=
llOl\
Oll\
lOl\
O\
l
[
lOOOlOOlOl\
O\

+
5
]
*
lOOll\
lOO\
Ol
->
ll\
OlO\
ll\
Ol\
O\
Ol
[
5
]
;
}
re\
t\
urn
lOlOllll\
O\
lO
;
}
lO\
l\
l\
OlOlOOll
::
ll\
OllO\
Ol\
lOO\
l\

::
ll\
OllOOllOO\
l
(
)
{
llO\
llOlOO\
lO\
l\

=
0
;
ll\
Oll\
Ol\
OOl\
l\
O
=
0
;
llOllOlOOlll
=
0
;
llOllOlO\
l\
OOO
=
0
;
llOllOlOl\
O\
Ol
=
0
;
llOl\
l\
OlO\
lOlO
=
0
;
llOllOl\
OlOll
=
0
;
ll\
OllOl\
O\
llOO
=
0
;
llOl\
l\
OlOl\
lOl
=
0
;
ll\
O\
ll\
OlOll\
lO
=
0
;
llOll\
OlOllll\

=
0
;
ll\
O\
llO\
l\
lOO\
OO
=
0
;
llO\
llO\
OOOl\
ll
=
0
;
llOllO\
OO\
O\
llO
=
0
;
ll\
Oll\
Ol\
lO\
OO\
l\

=
0
;
}
void\

lOl\
lOlOlOOl\
l
::
llOl\
lOOllO\
Ol\

::
Ini\
t\
i\
a\
li\
se
(
int
llOOO\
llOO\
OO\
l
,
in\
t
llOl\
O\
llOllll
)
{
llOl\
l\
OlO\
l\
OOl\

=
0
;
llOllOlO\
lOO\
O\

=
ll\
OOO\
llOO\
OOl
+
llOl\
OllOll\
ll\

*
6
;
lOOO\
llll\
OO
(
llO\
llO\
l\
O\
OlOl
,
fl\
o\
at\

,
llO\
llOlOlOOO
)
;
lO\
O\
OllllOO\

(
llOllOlOOllO\

,
float
,
llO\
llOlOlOO\
O
)
;
lOO\
OllllOO
(
ll\
Ol\
lOl\
O\
Olll\

,
floa\
t
,
llO\
ll\
O\
l\
O\
l\
OOO
)
;
llOllO\
lOlO\
lO
=
llOllO\
lOl\
OOO
;
lOO\
OllllOO\

(
ll\
O\
llOlOl\
O\
ll\

,
ll\
OOO\
OOlOOO
,
ll\
OllOlOl\
OlO
)
;
lOO\
O\
llllOO
(
llOllOlOl\
lOO\

,
llO\
O\
O\
OO\
lOO\
O
*
,
llOll\
OlO\
l\
OlO
)
;
lOO\
O\
l\
lllOO\

(
ll\
OllOlOl\
lOl
,
ll\
OOO\
OOl\
OO\
O
*
,
ll\
O\
llOlOlO\
lO\

)
;
lOOOOO\
ll\
OlO\

(
llO\
llOl\
Ollll
,
llOlO\
l\
lO\
OO\
Ol\

)
;
lOOO\
O\
O\
llOl\
O
(
llOllOllO\
OO\
O
,
llOlOl\
OlOlOO\

)
;
llOllOlOlll\
O
=
0
;
ll\
O\
llOOOOlll
=
ll\
OOOl\
lOO\
OO\
l\

;
ll\
OllOO\
OOllO
=
0
;
TA_\
A\
SS\
E\
RT
(
llO\
ll\
OllOOO\
l
==
0
)
;
lOOOllll\
OO
(
llOllOl\
lO\
OOl
,
llOllO\
lOOOO\
O
,
llOOOllO\
OOOl
*
2
)
;
}
vo\
id\

lOllOlOl\
O\
Oll
::
llO\
l\
l\
O\
OllOOl
::
Fina\
lise\

(
)
{
llOlOOllO\
ll\
O
(
ll\
Ol\
lOlOOlOl\

,
float
)
;
llOlO\
Ol\
l\
O\
l\
lO\

(
llO\
l\
l\
OlO\
Ol\
lO
,
float
)
;
llOl\
OOllOllO
(
llOl\
l\
Ol\
OOl\
ll
,
float
)
;
llOllOlOlOO\
O
=
0
;
llO\
l\
lOlOlOOl
=
0
;
llOllOlO\
lO\
lO
=
0
;
llOlO\
O\
llO\
l\
l\
O
(
llO\
llOl\
O\
l\
Oll
,
ll\
OOO\
O\
OlOOO
)
;
ll\
OlOOllOl\
lO
(
llO\
l\
l\
Ol\
OllO\
O\

,
llOOOO\
OlOOO\

*
)
;
llOlOOl\
l\
Ol\
l\
O
(
llOl\
lOl\
O\
llO\
l
,
llOOOOOlOO\
O
*
)
;
llO\
ll\
OlOll\
lO\

=
0
;
ll\
Ol\
OO\
llOlll\

(
llOll\
Ol\
O\
llll
,
ll\
O\
lOl\
l\
O\
OO\
Ol
)
;
llO\
lOO\
llOl\
ll
(
llOllOllOOOO
,
llOlOl\
OlOlO\
O\

)
;
llOllOOOOlll\

=
0
;
llOll\
OOOOl\
lO
=
0
;
ll\
O\
lOO\
ll\
OllO\

(
llO\
llOl\
lOOOl
,
ll\
Ol\
lOl\
OOO\
OO\

)
;
}
void
lOllO\
lO\
l\
OOll
::
ll\
Ol\
lO\
OllO\
Ol
::
Clear
(
)
{
ll\
Ol\
lO\
lOlOO\
l\

=
0
;
ll\
O\
llOllOOlO
=
0
;
llOOl\
Ol\
lOl\
ll
=
0
;
TA_AS\
SERT
(
llOlO\
lOl\
OOll
)
;
ll\
Ol\
lOlO\
l\
l\
ll
->
Fi\
n\
al\
is\
e
(
)
;
ll\
OllOllOO\
OO\

->
Fi\
na\
lis\
e
(
)
;
fo\
r
(
int\

llOO\
OO\
lOlOO
=
0
;
llOO\
OOl\
O\
lOO
<
llO\
llOlO\
lllO
;
llOOOOlOlOO
++
)
{
llO\
OOOOlO\
OO
&
llOOOO\
OO\
OlO
=
llOll\
OlOlOll\

[
ll\
OO\
OOlOlOO
]
;
llOOOOO\
OO\
lO\

.
llO\
llOOl\
llO\
l
.
Fina\
li\
se
(
)
;
llO\
OOOOOOl\
O
.
llOllOO\
ll\
ll\
O\

.
Fi\
nalise
(
)
;
llO\
OOOOOO\
lO
.
llO\
llOOlllll
.
Fina\
lise
(
)
;
llO\
OO\
OO\
OOl\
O
.
x
.
Finalis\
e
(
)
;
}
ll\
O\
ll\
OlO\
l\
llO
=
0
;
for
(
in\
t
llOllOl\
lOOll
=
0
;
llOllOl\
l\
OO\
ll
<
llOl\
lO\
OO\
O\
l\
lO\

*
2
;
llO\
ll\
Ol\
lOOll
++
)
llOl\
lO\
llO\
OOl\

[
ll\
Oll\
OllOOl\
l
]
.
llOlOllllOll
.
Finali\
se
(
)
;
llOl\
lOO\
OO\
ll\
O
=
0
;
llO\
l\
O\
l\
OlOOl\
l\

->
Clear\

(
)
;
}
void
lO\
llOlOlOOll
::
llOll\
OOl\
l\
OO\
l\

::
llOllOllOlOO
(
llOlOllllOlO
*
llOl\
lOl\
lOlOl
)
{
TA_ASSE\
RT
(
llO\
llOl\
O\
l\
OO\
l
>=
0
)
;
TA_\
ASSERT
(
llO\
llO\
lOlOOl
<
llOllOl\
O\
lOO\
O
)
;
llOllOlO\
lO\
Ol
=
ll\
O\
Ol\
Oll\
Olll
*
6
+
llOllOl\
lOOl\
O
;
memset
(
ll\
Ol\
l\
Ol\
OOlOl
,
0
,
llOllO\
lOlOOl\

*
size\
o\
f
(
float\

)
)
;
int\

llOO\
OO\
OllOOl
;
fo\
r\

(
llO\
OOO\
OllO\
Ol\

=
0
;
ll\
O\
O\
OO\
OllO\
Ol\

<
llOO\
l\
O\
llOlll
;
llOOOOO\
llOOl
++
)
{
TA_\
AS\
SERT
(
llOll\
OlOlllO
<
llOl\
lOlOlOOO\

)
;
llOOOOOlOOO
&
llOOOOOOOlO
=
llOl\
lOlOlOll
[
ll\
Oll\
OlOll\
lO\

++
]
;
ll\
O\
OO\
O\
OOOlO\

.
lO\
OOlOOl\
ll
=
llOllOlOlllO\

-
1
;
llOO\
OOOO\
O\
lO
.
llO\
llOOll\
Ol\
O
=
false
;
llO\
OOO\
OO\
O\
l\
O\

.
ll\
O\
llOOl\
lOll
=
false\

;
llO\
OO\
OOOOlO\

.
llOllOOll\
l\
OO\

=
fa\
l\
se\

;
llOOOOO\
OOl\
O
.
llOOOOO\
llOl
=
0
;
llOOOOO\
OO\
lO
.
llO\
lOlll\
llll
=
0
;
ll\
OOO\
O\
OOO\
l\
O
.
llOlOll\
l\
lllO
=
0
;
llOOOO\
O\
OOl\
O\

.
llOl\
lO\
Olll\
Ol\

.
Initialise
(
6
,
6
)
;
llOOOOOOOlO\

.
llOllOOllllO
.
Ini\
tialis\
e
(
6
,
6
)
;
llOOOOO\
O\
OlO
.
x
.
In\
it\
i\
ali\
se
(
6
)
;
}
int\

ll\
O\
llOllOl\
lO
;
for
(
llO\
l\
l\
OllOllO
=
0
;
llOllOllOllO
<
llO\
l\
l\
OOOOl\
lO
;
llOllOl\
l\
Oll\
O\

++
)
{
TA_\
ASSERT
(
llOllOlOll\
l\
O\

<
llOllOl\
OlOOO
)
;
llOl\
lOlOO\
OOO
*
llOllOllOlll
=
&
llOllOllOOO\
l
[
llOllO\
llOll\
O
*
2
]
;
in\
t
llOlOlO\
lOl\
O\
l
=
llOl\
lO\
llOl\
l\
l
->
llO\
lO\
llllO\
l\
l
.
ll\
O\
lOlOllOlO
(
)
;
llOO\
O\
OOl\
OO\
O
&
llOOO\
OOOO\
lO
=
llOll\
OlOlOll\

[
llOllO\
l\
OlllO
++
]
;
llOOOO\
OOOlO
.
lO\
O\
Ol\
OOll\
l
=
llOl\
lOlOl\
l\
lO
-
1
;
ll\
OOO\
OOOOlO
.
llOll\
OOllOlO\

=
tru\
e
;
llOOOOO\
O\
O\
l\
O\

.
ll\
OllO\
Ol\
lOll\

=
false
;
ll\
O\
OOOOOOlO
.
llOllOOlllO\
O\

=
false\

;
llO\
OOOOO\
OlO
.
ll\
OOOOOll\
Ol\

=
0
;
llO\
OO\
OOO\
Ol\
O
.
llO\
lO\
l\
l\
l\
llll
=
0
;
llOO\
O\
OOOO\
lO
.
llOlOl\
lll\
l\
lO
=
0
;
ll\
OOOOOOOl\
O
.
ll\
O\
llO\
Ol\
llOl
.
Initiali\
s\
e
(
ll\
O\
lO\
l\
OlOlO\
l
,
llOlOl\
Ol\
OlOl
)
;
ll\
OO\
O\
O\
OOOl\
O
.
ll\
Ol\
l\
OOll\
llO\

.
Initialis\
e
(
ll\
O\
lOlOl\
O\
l\
Ol\

,
ll\
OlOlOlOlOl\

)
;
llOOOOO\
O\
Ol\
O
.
x
.
Initi\
alis\
e
(
llO\
lOl\
OlOlOl\

)
;
}
ll\
Ol\
lOll\
OllO
=
0
;
int
llOO\
OO\
lOOOOO
;
for
(
llOOOOl\
OOOOO
=
0
;
ll\
O\
OOOlOOOO\
O
<
ll\
OllO\
llOlOl
->
ll\
OllO\
OOl\
Oll
(
)
;
llOOOOlOO\
OOO\

++
)
{
llOlOllll\
Ol\
O
::
llOlOlll\
ll\
OO\

&
llOllOO\
lOOll
=
*
llOllOllOlO\
l
->
ll\
O\
ll\
O\
O\
Ol\
lO\
l
(
llOOOOlOOOOO
)
;
if\

(
(
llOllOOlOOl\
l\

.
lOl\
Oll\
OOll
&
llOllOO\
lOllO
)
==
0
)
continue\

;
ll\
O\
llO\
OlOOll
.
llOllOOOO\
OOO
=
llOOlOllO\
ll\
l
+
llO\
l\
lOllOllO
;
TA_AS\
SERT
(
ll\
Ol\
lOllO\
ll\
O
<
ll\
OllOOOOllO
)
;
ll\
OllOl\
lOl\
l\
O
++
;
}
TA\
_\
ASSERT
(
llOl\
lOllOllO\

==
llOl\
lOOOOl\
lO
)
;
TA_\
A\
SS\
E\
RT
(
ll\
OllO\
llOlOl\

->
lO\
llO\
lll\
lO\
lO
(
)
==
llOOlOllO\
lll
)
;
for
(
llO\
OOO\
OllOOl
=
0
;
ll\
OOOO\
O\
llO\
O\
l
<
llOllOllOlOl
->
lOllOllll\
Ol\
O\

(
)
;
llO\
O\
OO\
OllOOl\

++
)
{
llOlO\
llll\
OlO
::
llOlOlllllOl
&
llOOOO\
OOO\
OO\

=
*
llOl\
lOl\
lO\
lOl
->
llO\
llO\
O\
Olll\
O\

(
llOOOOOllOOl
)
;
llOO\
OOOOOOO\

.
llOll\
OOO\
O\
OOO\

=
llOOOOO\
llO\
Ol\

;
}
fo\
r
(
ll\
OOOOlOOOOO\

=
0
;
ll\
OOOOlOOO\
OO\

<
llOllOllOl\
Ol\

->
llOllO\
OOl\
Oll
(
)
;
ll\
O\
OOOlOOO\
O\
O
++
)
{
llOlOllllOlO
::
llOlOlll\
l\
lO\
O
&
llOllO\
OlOOl\
l
=
*
llO\
llOllOlOl
->
ll\
OllO\
OOll\
Ol
(
llO\
OOOl\
O\
OOOO
)
;
if
(
(
llO\
l\
lO\
OlO\
Oll
.
lOlO\
l\
lOO\
ll\

&
llOl\
lO\
O\
lOllO
)
==
0
)
co\
ntinue\

;
ll\
OOO\
OOlOOO
&
ll\
OOOOO\
OOlO
=
llOllOlOlO\
l\
l
[
llOllOO\
lOOll
.
ll\
Ol\
lOOO\
OOOO
]
;
if
(
llOl\
lOOlOOll
.
llO\
O\
OOOll\
Ol\

)
llO\
O\
OO\
OO\
Ol\
O
.
llOOO\
O\
Oll\
Ol
=
&
llOl\
l\
OlOlO\
ll
[
llOll\
OOlO\
Oll
.
llOOOOOl\
lO\
l
->
llO\
llOOOOOOO\

]
;
if
(
ll\
Ol\
lOOlOOll
.
llOlOlll\
llll\

)
llOOOOOO\
OlO
.
ll\
OlOlll\
lll\
l\

=
&
llO\
llO\
lOl\
Oll
[
ll\
O\
llO\
Ol\
OOll
.
llOl\
Olllll\
ll
->
llO\
llOOOOOOO
]
;
if\

(
llOllOO\
lOOll\

.
llOl\
Ol\
l\
llllO
)
llOOOOOOOlO
.
llO\
lOllllllO
=
&
ll\
Ol\
l\
OlOlOll
[
ll\
Ol\
lOOl\
OOl\
l
.
ll\
Ol\
O\
llllllO
->
ll\
OllOOOOOO\
O
]
;
}
fo\
r
(
llO\
OO\
OOl\
lOOl\

=
0
;
llOOO\
OOllOOl
<
ll\
OllOll\
Ol\
Ol\

->
lO\
llOlll\
lOlO
(
)
;
llOOO\
OOllOOl
++
)
{
ll\
OlO\
ll\
llO\
lO\

::
llOlOlllllOl
&
ll\
OO\
OOOO\
OOO
=
*
ll\
O\
ll\
O\
llO\
lOl
->
llOllOOOlllO
(
ll\
OOOOOllOOl
)
;
llOO\
OOOlOO\
O\

&
llO\
OO\
OOOO\
lO\

=
ll\
OllOl\
OlOll\

[
llOOOOOOOOO
.
ll\
OllOOOOOOO
]
;
if
(
llO\
OOOOOO\
O\
O\

.
ll\
OO\
OOO\
l\
l\
Ol
)
llO\
O\
OO\
O\
OOlO\

.
llOO\
OOOllOl
=
&
ll\
Ol\
lO\
lOl\
Ol\
l\

[
llOOO\
OOOOO\
O
.
ll\
OOOOO\
llOl
->
llOl\
lOOOOOOO
]
;
if\

(
ll\
OOO\
OOOO\
O\
O
.
llO\
l\
Oll\
lllll
)
llO\
O\
OOO\
OOl\
O\

.
llOl\
O\
ll\
llll\
l
=
&
ll\
OllOlOl\
O\
ll
[
llOOOOO\
OOOO\

.
llOlO\
lllllll
->
llOllOOOO\
O\
OO
]
;
if
(
llOOO\
OOOOOO
.
ll\
OlOll\
ll\
llO\

)
llOOOOOOO\
l\
O
.
llOlOlll\
ll\
lO
=
&
llOllOlOlOll
[
llOO\
OOOOOOO
.
llOlOlll\
lll\
O
->
llOllOOOOO\
OO
]
;
}
}
vo\
id
lOllOl\
OlOOll
::
llOl\
lO\
O\
llOOl
::
llO\
ll\
O\
lllOOO
(
)
{
llOll\
O\
lOl\
OOl
=
llOOl\
Ol\
lOlll
*
6
+
llOllOll\
OOlO\

;
llOll\
O\
lOlll\
l
->
In\
itial\
ise\

(
6
)
;
llO\
llOl\
lOO\
OO
->
Initialise
(
6
,
6
)
;
int
llOOOO\
l\
OlOO\

;
llO\
llOlllOOl\

=
0
;
for
(
ll\
OO\
OO\
lOl\
OO
=
0
;
llOOOOlOlOO
<
ll\
O\
llO\
l\
OlllO
;
llOOOOlOlOO
++
)
{
llO\
OOOOlOOO\

&
llOO\
OO\
O\
OOlO
=
llOllOlOlOll
[
ll\
OOO\
OlOlOO
]
;
if
(
llO\
OOOO\
O\
O\
lO
.
llO\
OO\
OOll\
Ol\

==
0
)
llOll\
Oll\
lO\
lO
(
&
ll\
OO\
O\
OOOOlO\

)
;
}
llO\
ll\
OlllOll\

(
)
;
ll\
O\
l\
lOll\
ll\
O\
O
(
ll\
O\
llOlOO\
lOl
,
llOll\
OlO\
OllO\

)
;
}
void\

lO\
l\
lOlOlO\
Oll
::
llOllOOll\
OOl\

::
llOlOl\
ll\
OO\
OO
(
llOlOlll\
OO\
Ol\

*
ll\
Ol\
Ol\
llO\
OlO
,
int
llO\
lOlllO\
Oll
)
{
for\

(
int
lOOOlOOlO\
Ol
=
0
;
lOOO\
lOOlOOl
<
llOllOOO\
O\
l\
lO\

*
2
;
lOO\
O\
lOOlOOl
++
)
{
llOllOl\
OOO\
OO\

*
lOOlllO\
OOl
=
&
ll\
O\
llO\
llOO\
Ol
[
lOO\
O\
l\
OOlOOl
]
;
TA_\
A\
SSE\
RT
(
lOO\
lll\
OOO\
l\

->
lOOO\
lOOlOlO
>=
0
)
;
TA\
_AS\
SE\
R\
T
(
lOOlllOOO\
l
->
lO\
OOl\
O\
O\
lOlO
<
ll\
OlOl\
llOO\
ll\

)
;
co\
n\
st\

llOl\
OlllOOOl
&
llOl\
lOlO\
OOOl\

=
llOlO\
l\
ll\
O\
OlO
[
lO\
O\
lllO\
OOl\

->
lOOO\
lOOlO\
lO\

]
;
TA\
_ASSE\
RT
(
lOOlll\
OOOl
->
llOlOllllO\
l\
l
.
lOOlOO\
lOO\
l\
l
(
)
)
;
for
(
in\
t\

lO\
OO\
llOOOl
=
0
;
lO\
OO\
llOOOl
<
lOOl\
llOOO\
l
->
llO\
lOllll\
Oll\

.
llO\
lO\
lO\
llO\
lO
(
)
;
lOOOll\
OOOl
++
)
{
lOO\
l\
llOOOl
->
ll\
OlOllllOl\
l
(
lOOOllOOOl
,
0
)
*=
llO\
llO\
lOOO\
Ol
.
lOOO\
lllOlO\
lO
;
lO\
OlllO\
O\
O\
l\

->
llOlOllllOl\
l
(
lOOO\
ll\
O\
OOl
,
1
)
*=
llOl\
l\
Ol\
O\
OOO\
l
.
lO\
OOll\
lOl\
OlO\

;
lOOlll\
OOOl
->
ll\
OlOl\
lllO\
ll
(
lO\
O\
OllOOOl
,
2
)
*=
llOl\
lOlO\
OOO\
l
.
lO\
O\
Oll\
lOlOl\
O
;
lOOl\
llOOO\
l\

->
llOlO\
lll\
lOll\

(
lOOO\
llO\
OOl
,
3
)
=
lOO\
lllOO\
Ol
->
llO\
lO\
l\
l\
ll\
Ol\
l
(
lOOOllOOOl
,
3
)
*
llOllO\
lOOOOl
.
ll\
O\
llO\
lOOOlO\

[
0
]
+
lOO\
lllO\
OOl
->
llOlOllllOl\
l
(
lO\
OOll\
OOOl\

,
4
)
*
llO\
l\
l\
O\
lOOO\
Ol
.
ll\
OllO\
l\
O\
O\
O\
ll
[
0
]
+
lOOlllOOOl\

->
llOl\
OllllO\
ll
(
lOOOllOOOl
,
5
)
*
llOllOlOOOOl
.
ll\
O\
llOlOOlOO
[
0
]
;
lOOlllOO\
Ol
->
llOlOllllO\
ll
(
lOOOll\
OO\
Ol\

,
4
)
=
lOOll\
l\
OOOl
->
ll\
OlOllllO\
ll
(
lOO\
Ol\
lOO\
O\
l
,
4
)
*
llO\
ll\
OlOOO\
Ol\

.
llOl\
lO\
lOO\
O\
l\
l\

[
1
]
+
lOOl\
llOOOl
->
llOlOllllO\
l\
l
(
lOOOllOO\
Ol
,
5
)
*
llOl\
lO\
lOOOOl
.
llOllO\
lOOlOO
[
1
]
;
lO\
OlllOOOl
->
llOlO\
ll\
llOll
(
lO\
OOllOOOl\

,
5
)
=
lOO\
lll\
OOOl
->
llOl\
Ol\
lllOll\

(
lO\
O\
OllO\
O\
O\
l
,
5
)
*
ll\
Ol\
lOlOOOOl
.
ll\
Ol\
lOlO\
OlOO\

[
2
]
;
}
}
}
void
lOl\
lOlO\
lOO\
l\
l
::
llOllO\
Ol\
lO\
O\
l
::
llOll\
Ol\
ll\
O\
lO
(
llOO\
O\
OOlO\
O\
O
*
ll\
OOOOOl\
OOl\

)
{
for
(
llOO\
OOO\
l\
O\
OO
*
llOOO\
OOll\
lO
=
ll\
OOOOO\
lOOl
->
llOlOll\
lllll
;
llOOO\
OO\
ll\
lO\

;
llOO\
OOO\
lllO
=
llO\
OOO\
OlllO
->
ll\
OlOl\
lllllO
)
llO\
llO\
lllO\
lO
(
llOOOOOlllO\

)
;
ll\
OllOlO\
l\
lO\
O
[
llOllOlllO\
Ol\

]
=
llO\
OOOO\
lOO\
l
;
ll\
OllOl\
OllOl
[
llO\
llOlOlllO
-
llOllOlllOO\
l
-
1
]
=
llO\
OOOO\
lOOl
;
llOllOl\
l\
lO\
Ol
++
;
}
voi\
d
lO\
ll\
Ol\
O\
lOOll
::
llOll\
OOl\
lOOl\

::
ll\
OllOlll\
O\
ll
(
)
{
int\

ll\
OllO\
l\
ll\
lOl
;
for
(
llOll\
O\
ll\
l\
lOl
=
0
;
llOllOl\
lllO\
l\

<
llOllOlOlllO\

;
llOllO\
llllOl
++
)
{
ll\
OOOOOlOOO\

&
ll\
OO\
O\
O\
OOO\
l\
O
=
*
ll\
Oll\
OlOllO\
O
[
llOllO\
ll\
llOl
]
;
if
(
llOOOOOOOl\
O
.
llOll\
O\
OllOlO
)
llOOOO\
OOOlO\

.
llOl\
lOOl\
llO\
l
.
lOlOllOOOlO
(
)
;
els\
e
llO\
O\
OOOOOlO
.
llOl\
lO\
Oll\
lOl\

.
ll\
OlOlOll\
lOO\

(
)
;
if
(
llOOOOO\
OO\
l\
O
.
llO\
OOOO\
l\
lOl
)
{
int\

llO\
l\
lOll\
lll\
O
=
ll\
O\
O\
OOOOOlO
.
lOO\
OlOOl\
ll
;
int
llOllOllllll
=
llOO\
OO\
OOO\
l\
O
.
llO\
OOOOllOl
->
lOO\
OlOOlll
;
if
(
ll\
OOOOOOOlO
.
llO\
llOOl\
lO\
lO
)
llOlll\
O\
OOOOO\

(
llOOO\
OO\
O\
OlO
.
ll\
OllOOl\
l\
lll
,
ll\
OllOlllllO
-
llOO\
l\
OllOlll
,
llOllOl\
lllll
)
;
el\
se
llO\
lllOOOOO\
l\

(
llOOO\
OO\
OOl\
O
.
ll\
OllOOlllll
,
llOllOlll\
ll\
l
-
ll\
OO\
l\
Ol\
lOlll
,
llOllO\
l\
llll\
O
)
;
}
TA_ASSER\
T\

(
llOOO\
OO\
OO\
lO
.
llOll\
OOl\
llOl\

.
lO\
O\
lO\
Ol\
OOll
(
)
)
;
TA\
_ASSERT\

(
llOOOO\
OO\
OlO\

.
ll\
OllOOl\
ll\
lO
.
lOOlOOl\
OO\
ll\

(
)
)
;
if
(
llO\
OOOOOO\
lO
.
llOO\
O\
O\
OllOl
)
{
TA\
_A\
S\
S\
ERT
(
llOOOOOOOlO
.
llO\
l\
lOO\
ll\
l\
ll
.
lOOlO\
OlOO\
ll
(
)
)
;
}
}
#ifdef _DEBUG
for\

(
in\
t\

llOO\
OOlO\
l\
OO
=
0
;
llO\
OOOlOlOO
<
llOllO\
lOll\
l\
O\

;
llOO\
OO\
lO\
lOO
++
)
{
llO\
OOOOlOOO
&
llOOOOO\
OOlO\

=
ll\
OllO\
lO\
lO\
ll\

[
ll\
OOO\
OlOl\
OO
]
;
TA_\
ASS\
ERT
(
ll\
OO\
OOOOOlO
.
llOllOOlll\
Ol\

.
lOO\
lO\
OlO\
O\
ll
(
)
)
;
TA\
_AS\
SERT
(
llOO\
OOO\
OOlO
.
ll\
OllOOl\
ll\
lO
.
lOOlOOlOO\
l\
l\

(
)
)
;
if
(
llOOO\
OO\
O\
OlO\

.
llOOOO\
Ol\
lOl\

)
TA_A\
SSERT
(
llOOO\
O\
OOOlO
.
llOl\
lOOll\
lll
.
lOOl\
OOlOOl\
l
(
)
)
;
}
#endif //
for
(
ll\
OllOllllOl
=
0
;
llOl\
lO\
lll\
lOl\

<
llOl\
lOlOl\
llO\

;
llOllO\
lll\
lOl\

++
)
{
llOOOOOlOOO
&
llOOOOOOOlO\

=
*
llOllOlOllOO
[
llOllO\
ll\
l\
lO\
l
]
;
for
(
llO\
OOOOlOO\
O
*
llOOOOOlllO
=
llOOOOOOOlO
.
llOl\
O\
lllllll
;
llOOO\
OOlllO\

;
ll\
OOOOOll\
lO\

=
ll\
OOO\
OO\
lllO
->
llOlOllllll\
O
)
{
llOOO\
O\
OlOO\
O
&
lO\
lOlllOOl\
ll
=
*
llO\
OOOOlllO
;
llOl\
ll\
O\
OOO\
lO\

(
llOOOOO\
OOlO
.
llO\
llOOll\
lOl
,
lOl\
Oll\
lOO\
l\
ll
.
llOllOOlllOl
,
lO\
l\
O\
l\
llOOlll
.
llOllOOl\
llll
)
;
}
TA_A\
SSERT
(
llO\
llOllOOOO
)
;
llOOOOOO\
OlO
.
llO\
l\
lOOll\
l\
Ol\

.
Ge\
tIn\
v\
ers\
e\

(
llOOOOOOOlO
.
ll\
OllOOl\
lllO
,
*
ll\
O\
llOllOOOO
)
;
if
(
ll\
OOOOOOO\
lO
.
ll\
OOOOOllOl\

)
{
llOlllOOOO\
ll
(
llOOOOOOOlO
.
llOl\
lOOll\
lll
,
llO\
OOOOOOlO
.
llOll\
OOll\
llO
)
;
}
}
}
void
lO\
llOlOlOOll
::
llO\
l\
l\
OOllOOl
::
llOllOll\
ll\
OO
(
)
{
for
(
int
llO\
llO\
llllOl
=
0
;
llOl\
lOllllOl
<
ll\
OllOlOlllO
;
llOllOll\
l\
lOl
++
)
{
llO\
OO\
O\
OlOOO\

&
llOO\
OOOOOl\
O
=
*
llOl\
lOlO\
llO\
O
[
ll\
Ol\
lOllllOl
]
;
fo\
r\

(
llO\
O\
OOOlOOO
*
ll\
OOOOOlllO
=
llOO\
OO\
OOOlO
.
llOlOl\
ll\
llll
;
llOOOO\
OlllO
;
llO\
O\
OO\
Olll\
O
=
llOOO\
O\
O\
lllO
->
llOl\
O\
lll\
lll\
O
)
{
llOO\
OOOlO\
O\
O
&
lOlOlllOOl\
ll\

=
*
llOO\
OO\
O\
ll\
lO
;
llOlllOOOlOO
(
llO\
OOOOO\
O\
l\
O
.
x
,
lOlOl\
llOO\
lll
.
ll\
OllOO\
ll\
l\
l\
l
,
lOlOl\
llO\
Ol\
ll
.
x
)
;
}
}
for
(
in\
t
llO\
lll\
OOOlOl
=
0
;
llOlllO\
OOlO\
l
<
llOllOl\
OlllO\

;
llOlllOOOlOl
++
)
{
llOOOOOl\
OOO
&
ll\
O\
OOOOO\
O\
lO
=
*
llOllOlO\
ll\
Ol\

[
llOll\
lOOO\
l\
Ol\

]
;
llO\
lll\
OOOl\
lO
(
llOOOOOOO\
l\
O
.
x
,
ll\
OO\
OOO\
O\
O\
l\
O\

.
llOllOOl\
lll\
O\

,
llOOOOOO\
Ol\
O
.
x
)
;
if
(
llOOOO\
OO\
OlO
.
llOOOOOllOl
)
{
llOl\
llOO\
Oll\
l
(
ll\
OOO\
OOOOlO
.
x
,
llO\
OOOOO\
Ol\
O\

.
ll\
O\
llOOlllll
,
llOO\
OOOOOlO
.
llOOOOOllOl
->
x
)
;
}
}
}
vo\
id
lO\
llOl\
OlOO\
ll
::
llO\
ll\
OO\
llOO\
l
::
llOl\
llOOO\
OOO
(
ll\
OlOlOlOlOO\

&
llOl\
Ollll\
O\
ll\

,
int
lO\
OOlOOlOO\
l
,
int
lO\
OOlOO\
lOlO\

)
{
llO\
llO\
lOOOOO
*
ll\
Oll\
lO\
OlOO\
O
=
&
llOllOllO\
O\
Ol
[
lOOOlOOl\
OOl
*
2
]
;
if
(
llOl\
llOOl\
OOO
->
lOOO\
l\
OO\
l\
O\
lO
!=
lO\
O\
O\
lO\
O\
lO\
lO
)
llOll\
l\
O\
Ol\
OOO
=
&
llOllOllOOOl\

[
lOO\
O\
lOOl\
OOl
*
2
+
1
]
;
TA_A\
S\
SERT\

(
llOlllO\
O\
lO\
OO
->
lOOO\
lOO\
lOlO\

==
lOO\
OlO\
OlOlO
)
;
llO\
lOl\
lllO\
ll
.
Initial\
i\
s\
e
(
ll\
Ol\
l\
lO\
O\
lOOO
->
ll\
OlOl\
lllOl\
l
.
llO\
l\
OlO\
llOlO
(
)
,
llOlllOOl\
OOO
->
llOlOllllO\
ll
.
llOlOl\
O\
l\
lO\
ll
(
)
)
;
for
(
int
lOOOllOO\
Ol
=
0
;
lO\
O\
OllOO\
Ol
<
llOlOl\
lllOl\
l\

.
ll\
OlO\
lOl\
lOlO
(
)
;
lOOO\
ll\
O\
OOl
++
)
{
for
(
int
lOO\
lOOlOl\
O
=
0
;
lO\
Ol\
OOlOlO
<
ll\
OlOl\
lll\
O\
ll
.
llOlOlOll\
Ol\
l
(
)
;
lOOl\
OOlOl\
O
++
)
{
llOl\
O\
l\
ll\
lOll
(
lOOO\
llOOOl
,
lOOlOOlOl\
O
)
=
-
llOl\
ll\
OOlOOO
->
llO\
l\
OllllOll
(
lO\
OO\
llO\
OOl\

,
lO\
OlOOl\
Ol\
O
)
;
}
}
}
vo\
id\

lOllO\
lO\
lOOll\

::
llOllOOllOOl\

::
llO\
l\
llOO\
O\
OOl\

(
llOlOlO\
lOl\
OO\

&
llOlOllllOl\
l\

,
int
lOOOlO\
OlOO\
l
,
int
lO\
OOlO\
Ol\
OlO
)
{
llOll\
OlO\
OOOO\

*
llO\
l\
llO\
O\
lOOO
=
&
llO\
l\
l\
OllOOO\
l
[
lO\
OOlOO\
lOOl
*
2
]
;
if
(
llO\
lll\
O\
OlOOO
->
lOOOlOO\
lOlO
!=
lOOO\
l\
OOlOlO
)
llOll\
l\
OOl\
OOO
=
&
llO\
l\
lOll\
O\
OOl
[
lOOOlOOl\
OO\
l
*
2
+
1
]
;
TA_\
ASS\
ERT
(
ll\
OlllO\
Ol\
O\
OO
->
lO\
OOlOOlOlO\

==
lOO\
OlO\
OlOl\
O
)
;
llOl\
Olll\
lOll\

.
In\
it\
ial\
ise
(
llOlllOOlOOO
->
ll\
OlOl\
lllO\
ll
.
llOlOl\
OllO\
ll
(
)
,
llOlllOOlOOO
->
llOlOllllOl\
l
.
llO\
lOlO\
l\
l\
O\
l\
O\

(
)
)
;
fo\
r
(
int
lOO\
Ol\
lOO\
O\
l
=
0
;
lO\
OOllOO\
Ol
<
llOlOllllOl\
l
.
ll\
O\
lOl\
OllOlO\

(
)
;
lOOOl\
lOO\
Ol\

++
)
{
for
(
int\

lOO\
lOO\
lO\
l\
O
=
0
;
lO\
O\
lOOl\
OlO
<
llOlOllllO\
ll\

.
llOlOlO\
l\
lOll\

(
)
;
lOOl\
OOl\
OlO
++
)
{
ll\
OlO\
llllOl\
l\

(
lOO\
O\
llOOO\
l\

,
lO\
Ol\
O\
Ol\
Ol\
O
)
=
-
ll\
Olll\
OOlOOO\

->
ll\
OlOllllOll
(
lOOlOOlO\
lO\

,
lOOOll\
OOOl
)
;
}
}
}
vo\
id\

lOllO\
lOlO\
Oll
::
llOllO\
Ol\
lOOl
::
llOlll\
OOOO\
lO
(
llOlOl\
OlOlO\
O\

&
lO\
lOOllOOlO
,
const
ll\
O\
lOlOlO\
lOO
&
llOll\
l\
OOl\
O\
Ol
,
const
llOlOl\
O\
l\
OlOO
&
lOO\
lO\
OlOl\
O
)
{
TA\
_AS\
SERT
(
lOlOO\
llOOlO\

.
lOOlOOlOOl\
l
(
)
)
;
TA_\
ASSERT
(
ll\
OlllO\
O\
lOOl
.
lOO\
lOOl\
OOll\

(
)
)
;
TA_A\
SSERT
(
lO\
OlOO\
lOlO\

.
lOO\
l\
O\
O\
lO\
Oll
(
)
)
;
TA\
_ASSERT
(
lO\
OlOOlOlO
.
llOlOlOl\
l\
Ol\
O\

(
)
==
llOlllOOlO\
Ol
.
ll\
O\
l\
OlOll\
O\
lO
(
)
)
;
TA_\
ASSERT
(
lOOlOO\
lO\
lO
.
llO\
lOl\
OllOlO
(
)
==
llOll\
l\
OOlOOl
.
ll\
OlO\
lOllO\
ll
(
)
)
;
TA_A\
SSERT
(
lOlOOllOOlO\

.
llOlOlOllO\
lO
(
)
==
lOO\
lOOlO\
lO\

.
ll\
OlO\
l\
Oll\
O\
ll
(
)
)
;
TA\
_A\
SS\
ERT\

(
lOlO\
Ol\
l\
OOlO\

.
llOlOlOllOll
(
)
==
lOOlO\
OlOlO
.
llOlOlOllOl\
l\

(
)
)
;
fo\
r
(
int\

llOl\
l\
lOOlO\
l\
O
=
0
;
llOlllOOlOlO
<
lOOlOOl\
OlO
.
llO\
lOlOllO\
ll
(
)
;
llOlllOO\
lOl\
O
++
)
{
for
(
in\
t
ll\
OlllOOl\
Ol\
l\

=
0
;
llOlllOOl\
Oll
<
llOl\
llO\
OlO\
O\
l
.
ll\
Ol\
OlOll\
OlO\

(
)
;
llOll\
l\
OO\
lOll\

++
)
{
flo\
at
ll\
OlO\
llOO\
O\
OO
=
0.0f
;
fo\
r
(
int
llOlll\
O\
OllOO
=
0
;
llOll\
lOOllOO\

<
llOlllOO\
lO\
Ol
.
ll\
O\
lOlOllOl\
l
(
)
;
llOlll\
OOllOO\

++
)
{
co\
nst
in\
t
llOll\
lOOllOl
=
llO\
l\
llOO\
llOO
;
llO\
lOllOOOOO
+=
llOll\
lOO\
lOO\
l
(
llOll\
lOOlOll
,
llO\
lllOOll\
OO
)
*
lOOlOO\
lO\
lO\

(
llOlllOOl\
lOl
,
llOlll\
OOl\
O\
lO
)
;
}
int
llO\
lllOO\
lllO
=
llOlllOOlOll\

;
for
(
in\
t
llO\
lllO\
Ol\
ll\
l\

=
0
;
llOll\
lOOllll
<
lO\
OlO\
OlO\
l\
O
.
ll\
O\
l\
O\
lOllOl\
l
(
)
;
ll\
OlllO\
Ollll
++
)
lOlO\
Oll\
OOlO\

(
llOlllOOlll\
l
,
llO\
lllO\
OlOl\
O
)
-=
llO\
l\
Oll\
O\
OOOO
*
lO\
Ol\
OOlOl\
O
(
ll\
Oll\
lOOll\
l\
O\

,
llOlllOOllll\

)
;
}
}
lOl\
OOl\
l\
O\
OlO
.
llO\
lOlOl\
llOl
(
)
;
}
voi\
d
lOllOlOlOOll
::
llO\
l\
lOOl\
lO\
Ol
::
ll\
OlllOOOOll
(
ll\
O\
lOlO\
lOlOO
&
ll\
lOOll\
lO\
O
,
cons\
t
ll\
O\
lOlOl\
O\
l\
OO
&
lllOlO\
OO\
OO
)
{
TA_\
A\
S\
SERT
(
lllO\
O\
lllOO
.
lOOl\
OOlO\
Oll\

(
)
)
;
TA_ASSERT
(
lllOlOOOOO\

.
lOO\
lOOlO\
Oll
(
)
)
;
TA_\
A\
S\
S\
E\
RT\

(
lllOlOOOOO
.
ll\
O\
l\
OlOllOll
(
)
==
lll\
O\
Oll\
lOO
.
llO\
lOl\
OllOlO\

(
)
)
;
TA_\
AS\
SERT
(
lllO\
Oll\
l\
O\
O\

.
llOlO\
lOllOlO\

(
)
==
lllOlOOOOO\

.
llO\
l\
Ol\
Oll\
OlO
(
)
)
;
TA\
_A\
S\
SERT
(
llO\
l\
l\
OlOl\
lll
)
;
TA_ASSERT\

(
llOl\
l\
OlOl\
lll
->
lOOOl\
l\
lOOl
(
)
>=
ll\
lO\
O\
ll\
lOO
.
ll\
Ol\
O\
l\
O\
llO\
ll
(
)
)
;
for
(
int\

lOOOlOOl\
OlO
=
0
;
lO\
OOlOOlOlO
<
lllO\
Ol\
l\
lOO\

.
llOlOlO\
llOll\

(
)
;
lO\
OOl\
OOl\
OlO
++
)
{
int
lOOOlOOlO\
O\
l\

;
fo\
r
(
lO\
OOlO\
Ol\
OOl\

=
0
;
lO\
OOl\
OOl\
O\
Ol\

<
lll\
OOl\
ll\
O\
O
.
llOlO\
lO\
llO\
lO
(
)
;
lO\
O\
OlOOlO\
O\
l
++
)
{
float
lll\
OO\
l\
lOOl\

=
0.0f
;
fo\
r
(
int
lOOOl\
lOOOl
=
0
;
lO\
OOl\
lO\
OOl
<
lllOlO\
O\
O\
OO
.
llO\
lO\
l\
O\
llOll
(
)
;
lOO\
O\
llOO\
Ol
++
)
ll\
lOOllO\
Ol
+=
lllOlOOOOO
(
lO\
OOlOOlO\
O\
l
,
lOO\
O\
llO\
O\
O\
l
)
*
ll\
lOOl\
llOO
(
lOOOll\
OOO\
l
,
lO\
OOlOOlOlO
)
;
(
*
llOllOlOl\
lll
)
(
lOOOlOOlOOl
)
=
lllO\
Oll\
OO\
l
;
}
for
(
lOOOlOO\
l\
O\
Ol
=
0
;
lO\
OO\
lOOlOO\
l
<
lll\
OOll\
lOO
.
ll\
OlOlOllOlO
(
)
;
lOOOlO\
Ol\
OO\
l
++
)
lll\
O\
O\
l\
llO\
O
(
lOOOlO\
OlOOl
,
lO\
OOlOOlOlO
)
=
(
*
ll\
OllO\
lOllll\

)
(
lOO\
Ol\
OO\
l\
OOl\

)
;
}
lllO\
Oll\
lOO
.
llOl\
O\
l\
O\
l\
l\
lOl\

(
)
;
}
vo\
id
lO\
ll\
OlO\
l\
OO\
l\
l
::
llO\
llOOllOOl\

::
llOll\
lOOOl\
l\
O
(
llO\
lOl\
lOOOO\
l
&
lOlOOll\
OO\
l\
O\

,
con\
s\
t
ll\
O\
l\
O\
lOlOlOO
&
llOlllO\
lOOOO
,
co\
nst\

llOlOllOOOOl
&
llOl\
llO\
lOOOl
)
{
lO\
OlOl\
lllOl
(
llOlOlO\
O\
OO\
OO
)
;
TA_\
ASSER\
T
(
lOlOOl\
lOOlO
.
lOOlOOlOOll
(
)
)
;
TA_ASSERT
(
llOl\
llOlOO\
O\
O
.
lOOl\
OOlOOll
(
)
)
;
TA_AS\
SERT\

(
llOlll\
Ol\
OO\
Ol
.
lO\
OlOO\
lOOl\
l
(
)
)
;
TA\
_A\
SS\
ERT
(
llOlllO\
l\
OO\
OO
.
ll\
O\
lOlOll\
Oll
(
)
==
llO\
lll\
Ol\
OO\
O\
l
.
lOOOlll\
OOl
(
)
)
;
TA\
_AS\
SE\
RT\

(
lOlOOllOOlO
.
lOOOlllOOl
(
)
==
ll\
Ol\
llOl\
OOOl
.
lOO\
O\
l\
ll\
OOl
(
)
)
;
TA_ASS\
ERT
(
llO\
l\
lOlOllll\

->
lOOO\
lll\
OOl
(
)
>=
llOl\
llOlOO\
Ol
.
lOOO\
lll\
OOl
(
)
)
;
if
(
ll\
OlllOlO\
OOl\

.
IsZ\
er\
o
(
)
)
{
lOlOOll\
OO\
lO\

.
lO\
l\
O\
ll\
OO\
Ol\
O
(
)
;
re\
turn\

;
}
if\

(
llOl\
llOlOO\
OO
.
ll\
O\
lOlO\
lll\
lO
(
)
)
{
lOl\
OOllOOlO
=
llOll\
l\
O\
lOOOl
;
retu\
r\
n
;
}
int
lOO\
OlOO\
l\
OOl\

;
fo\
r
(
lOOOl\
OOlO\
Ol\

=
0
;
lO\
OOlO\
OlOOl
<
ll\
OlllOl\
OO\
O\
O
.
llOlOlOl\
lOlO
(
)
;
lOOOlOOlOOl\

++
)
{
fl\
oat
ll\
OlO\
llOO\
O\
OO
=
0.0f
;
for
(
int
lOOOlOOl\
O\
l\
O
=
0
;
lOOO\
lO\
Ol\
OlO
<
llO\
lllOlOO\
OO\

.
llOlOl\
OllOl\
l
(
)
;
lOOOlO\
O\
l\
Ol\
O\

++
)
llO\
l\
Oll\
OOOOO\

+=
llO\
lllOlO\
O\
OO
(
lOOO\
lOOlOO\
l
,
lOOOl\
O\
O\
lOlO\

)
*
llOlllOlOOOl
(
lOOOlOOlOl\
O\

)
;
(
*
ll\
OllO\
l\
Ol\
lll
)
(
lO\
OOlOOlOOl
)
=
llOlOl\
lOOOOO
;
}
for\

(
lOOOl\
OOl\
OOl
=
0
;
lOOOlO\
OlO\
Ol
<
ll\
OlllOlOOOO
.
ll\
OlOl\
OllOlO
(
)
;
lOOOlOOlOO\
l\

++
)
lOl\
OOll\
OOl\
O
(
lOOOlOOlOOl
)
=
(
*
llOllO\
l\
O\
llll
)
(
lOO\
O\
lO\
O\
l\
OOl
)
;
lO\
lO\
OllOOlO
.
llOlOl\
lOOl\
OO
(
)
;
}
void
lO\
ll\
O\
lOl\
OO\
ll\

::
llOllOOllO\
O\
l\

::
llOlllOO\
OlO\
O
(
ll\
O\
l\
OllOOOO\
l\

&
lOlOOllOOlO
,
co\
nst\

llOlOlOlOlO\
O
&
llOlllOlOO\
OO\

,
co\
n\
st\

ll\
O\
lOl\
lOOO\
O\
l
&
llOl\
l\
l\
OlOOOl
)
{
TA_\
AS\
SERT
(
lOl\
O\
OllO\
O\
l\
O
.
lOOl\
OO\
lOOll
(
)
)
;
TA_ASSERT
(
llOll\
lOlOO\
O\
O
.
lOOlOO\
lOO\
ll
(
)
)
;
TA_AS\
S\
ERT
(
ll\
O\
ll\
l\
O\
lOOOl
.
lO\
OlO\
Ol\
OOll
(
)
)
;
TA\
_A\
S\
SERT
(
ll\
OlllO\
l\
OO\
OO\

.
llOlO\
lOllO\
lO
(
)
==
llOll\
l\
OlOOOl
.
lOOO\
l\
l\
lOOl
(
)
)
;
TA_ASSERT
(
lOlO\
O\
llOOlO
.
lOOOl\
llOOl\

(
)
==
llOlllOl\
O\
O\
O\
O
.
llOl\
Ol\
Oll\
Ol\
l
(
)
)
;
if
(
llO\
l\
llOlOOOl
.
IsZe\
ro\

(
)
)
retur\
n
;
if
(
llO\
ll\
lOl\
O\
OOO
.
llOlOl\
O\
lll\
lO\

(
)
)
{
lOl\
OOll\
OO\
lO
=
llOlll\
OlOOOl
;
retu\
rn
;
}
for
(
int
lO\
OOlOOlOOl\

=
0
;
lOOO\
lOOlOO\
l
<
llOll\
lO\
lOOO\
O\

.
llOlOlOllOll
(
)
;
lOOOlOOlOOl
++
)
{
float
llOlOl\
lO\
OOO\
O
=
0.0f
;
fo\
r
(
int
lOOOl\
O\
Ol\
OlO
=
0
;
lOOOlOOlOl\
O\

<
llOll\
lOlOOOO
.
llO\
lOlO\
llO\
l\
O
(
)
;
lOO\
OlOOlOl\
O
++
)
llOl\
O\
llOOOOO
+=
ll\
Oll\
lO\
lO\
O\
O\
O
(
lO\
O\
OlOOl\
Ol\
O\

,
lO\
O\
O\
l\
OOlOOl
)
*
llOlll\
O\
l\
O\
OOl
(
lOO\
OlOOlOl\
O
)
;
lOlOOllO\
OlO
(
lOO\
OlOOl\
OO\
l\

)
-=
llOl\
Ol\
lOO\
OO\
O
;
}
lOl\
O\
Ol\
lO\
OlO
.
llOlOl\
lO\
OlOO\

(
)
;
}
void
lOllO\
lOlOOll\

::
llO\
l\
l\
O\
O\
l\
lO\
Ol
::
llOlllO\
OOlll
(
llOlO\
ll\
OO\
O\
Ol
&
lO\
lOO\
llO\
O\
lO
,
con\
st
llOl\
Ol\
Ol\
OlO\
O
&
llOl\
llOl\
O\
OOO
,
const\

llO\
lO\
ll\
O\
O\
O\
O\
l
&
llOlllOl\
OOOl
)
{
TA_ASSERT
(
lOlOOllO\
OlO
.
lO\
Ol\
OOl\
OOll
(
)
)
;
TA_ASS\
ER\
T
(
llO\
lllOlO\
OOO
.
lOOlOOlOO\
ll
(
)
)
;
TA_\
ASSERT
(
llOlllOlOOOl\

.
lOOlOOlO\
Oll
(
)
)
;
TA\
_ASS\
E\
RT
(
llO\
lllOlOOOO
.
llOl\
Ol\
O\
l\
lOll
(
)
==
llOl\
llOlOOOl\

.
lO\
OOll\
lOOl
(
)
)
;
TA_ASSE\
RT\

(
lOl\
O\
OllOOlO\

.
lOOOlllOOl
(
)
==
llO\
l\
llOlOOO\
O\

.
llOl\
Ol\
Ol\
lOlO
(
)
)
;
if\

(
llO\
lllO\
lOOO\
l\

.
IsZ\
ero
(
)
)
retur\
n\

;
if
(
llO\
ll\
lOlOO\
OO
.
llOlOlOlll\
lO
(
)
)
{
lO\
l\
O\
OllOOlO
=
llOl\
l\
lOlO\
OOl
;
re\
t\
urn
;
}
for
(
in\
t
lO\
OOlOOlOOl
=
0
;
lOOOl\
OO\
l\
O\
O\
l
<
ll\
OlllOlOOOO
.
llO\
lOl\
OllO\
lO
(
)
;
lOOOlOOl\
O\
O\
l
++
)
{
flo\
a\
t
llOlOllOOOOO
=
0.0f
;
fo\
r
(
in\
t
lO\
OOlOOlOlO
=
0
;
lO\
OOl\
O\
OlOlO
<
ll\
O\
lll\
OlOO\
OO
.
llO\
lOlO\
ll\
O\
l\
l
(
)
;
lO\
OOlOO\
lOl\
O
++
)
llO\
l\
Ol\
lOO\
OO\
O
+=
ll\
OlllOlOOOO
(
lOO\
OlOOl\
OO\
l
,
lOOOl\
OO\
lO\
lO
)
*
llO\
ll\
lO\
lO\
OOl
(
lOO\
OlOO\
lO\
lO
)
;
lOlOO\
llOOlO
(
lOO\
O\
lO\
O\
lOOl
)
-=
llOl\
OllOO\
OOO
;
}
lO\
lOO\
llOO\
l\
O
.
llOlOllOOlOO\

(
)
;
}
voi\
d
lOllO\
l\
OlOO\
ll
::
ll\
O\
llO\
Oll\
O\
Ol
::
llOllOll\
l\
l\
OO\

(
const
float
*
llOl\
ll\
O\
lO\
O\
l\
O
,
float
*
llOlll\
OlOOll
)
{
int\

lOOOllO\
OOl
;
int
lOOl\
OO\
l\
Ol\
O
=
0
;
for
(
lOOOl\
lO\
OOl
=
0
;
lOOOll\
OOO\
l
<
llOllOlOl\
l\
lO\

;
lOOOl\
lOO\
Ol
++
)
{
llOOOO\
OlOOO
&
llOOOOOOOl\
O
=
llOllOlO\
lO\
ll
[
lOOOl\
lO\
OO\
l\

]
;
int
llOlllOlO\
lO\
O
=
0
;
for
(
int
lOOl\
OlOOO\
l
=
0
;
lOOlO\
l\
OOOl\

<
llOOOOOOOlO
.
x
.
lOO\
O\
l\
llO\
Ol
(
)
;
lO\
OlOl\
OOO\
l
++
)
{
llOOOO\
OOOl\
O\

.
x
(
lOO\
lO\
l\
OOOl
)
=
llO\
ll\
l\
OlOOlO
[
lOOlO\
Ol\
OlO
++
]
;
if\

(
llO\
OOOO\
OOl\
O
.
x
(
lOOlO\
lO\
OOl
)
==
0.0f
)
llOll\
lOlOl\
OO
++
;
}
if\

(
llO\
ll\
lOlOlOO\

==
llOO\
OOOOO\
lO
.
x
.
lO\
OOl\
llOOl
(
)
)
llOO\
OOOOOlO
.
x
.
ll\
OlO\
llOOl\
lO
(
)
;
el\
s\
e\

llOO\
OO\
OOOlO
.
x
.
ll\
Ol\
OllOOlO\
O
(
)
;
}
llO\
llOl\
ll\
lOO
(
)
;
lOOlOOlO\
lO
=
0
;
for
(
lOOOll\
O\
OOl
=
0
;
lOOOll\
OOOl\

<
llO\
llO\
lOll\
l\
O
;
lOO\
O\
llOO\
Ol\

++
)
{
ll\
O\
O\
O\
OO\
lO\
OO\

&
ll\
OOO\
OOOOlO
=
llOll\
OlO\
lO\
ll
[
lOOOll\
OOOl
]
;
for\

(
int
lOOl\
OlOOOl
=
0
;
lOOlOl\
OOOl
<
ll\
OOOOOO\
OlO
.
x
.
lOOOll\
l\
OOl
(
)
;
lOOlO\
lO\
OOl
++
)
llO\
lllOlO\
Ol\
l
[
lO\
OlOOlOlO
++
]
=
llOOO\
OOOOlO
.
x
(
lO\
OlO\
l\
OOOl\

)
;
}
}
void
lOllOlOlOO\
ll
::
llOl\
lO\
OllOOl
::
ll\
OlllOlOlOl
(
float
*
ll\
Ol\
llOlO\
ll\
O
,
flo\
at\

*
ll\
O\
lllOl\
Ol\
l\
l
,
ll\
O\
lOl\
lOl\
OO\
O
*
llOlll\
Oll\
OOO
,
int
lOO\
O\
lOOlOl\
O
)
{
TA\
_A\
SSERT\

(
ll\
OlllOl\
O\
llO\

)
;
TA_AS\
SERT\

(
ll\
OlllOl\
Olll\

)
;
TA\
_ASSER\
T
(
llOlllOllOOO\

)
;
int
lOOOll\
OOO\
l
;
in\
t
lOOl\
OOlO\
lO\

=
0
;
for
(
lOO\
OllOOOl\

=
0
;
lOO\
OllOOOl
<
llOllOlO\
ll\
lO\

;
lO\
OOll\
O\
OOl
++
)
{
llOOO\
OOlO\
OO
&
llO\
OOOO\
OOl\
O
=
llOll\
Ol\
OlOl\
l
[
lOOOllOOOl
]
;
llOO\
OOOOOl\
O
.
x
.
lOlOllO\
OOlO\

(
)
;
}
ll\
O\
lO\
llO\
lOO\
O
::
lOOllOOOOO\

*
lO\
Oll\
lOOOl
=
ll\
Ol\
llOll\
O\
OO\

->
llOl\
Ol\
lOl\
lO\
O
[
lOOO\
lOO\
l\
OlO
]
;
for
(
;
lOOlllOOOl
;
lOOlllOOO\
l
=
lOOll\
lOOOl\

->
llO\
lOllOlOl\
O
)
{
ll\
OOOOO\
lOOO
&
ll\
OOOOOOOlO\

=
llOl\
l\
O\
l\
O\
l\
Oll\

[
lOOl\
llOOO\
l\

->
lOO\
O\
lOOlOlO\

]
;
llOOOO\
OOOlO
.
x
(
0
)
=
lOOlllOOO\
l\

->
llOlOllO\
lOOl\

[
0
]
;
ll\
O\
OO\
OOO\
OlO
.
x
(
1
)
=
lOOl\
llOOOl
->
llOlOllOlOOl
[
1
]
;
ll\
OO\
OO\
OOOlO
.
x
(
2
)
=
lOOl\
ll\
O\
O\
Ol
->
llOlO\
llOlO\
Ol
[
2
]
;
llOOO\
O\
OO\
Ol\
O
.
x
(
3
)
=
lOO\
lllOO\
O\
l
->
llO\
lO\
l\
lO\
lO\
Ol
[
3
]
;
llOOOOOOOlO\

.
x
(
4
)
=
lO\
Olll\
OOOl
->
llO\
l\
OllOl\
OOl
[
4
]
;
llOOOO\
OO\
O\
l\
O
.
x
(
5
)
=
lOOl\
l\
lOOOl
->
ll\
OlO\
llO\
l\
O\
Ol\

[
5
]
;
llOOOO\
OOOlO\

.
x
.
llOl\
OllOOlOO\

(
)
;
}
ll\
O\
llOll\
llOO
(
)
;
lOOlOOlOlO\

=
0
;
for\

(
lOOO\
ll\
OOOl\

=
0
;
lOOO\
llOOO\
l
<
llO\
l\
lO\
lOlllO
;
lO\
OOllO\
OO\
l\

++
)
{
llOOOOOlOOO
&
llO\
OOOOOOlO
=
llOll\
O\
lOl\
Oll
[
lOOO\
llOOOl
]
;
for
(
int
lOOlOlOOOl\

=
0
;
lOOlOlOOOl
<
llOO\
OOOOOlO
.
x
.
lOO\
OlllOOl
(
)
;
lO\
O\
lO\
lOOO\
l
++
)
llOlllOl\
OllO
[
lO\
O\
lO\
OlOl\
O\

++
]
=
llOO\
O\
O\
O\
O\
OlO
.
x
(
lO\
OlO\
l\
OOOl
)
;
}
}
floa\
t
lOllO\
lOl\
OO\
ll\

::
llOllO\
Ol\
l\
OOl
::
ll\
O\
ll\
l\
OllO\
Ol
(
llOlOllO\
lO\
O\
O\

*
llO\
ll\
lOl\
lOO\
O
,
int\

lOO\
OlOOl\
OOl\

)
{
retur\
n
llOl\
llOllOO\
O\

->
ll\
OlOlllO\
lO\
O
(
lO\
O\
OlOOlO\
Ol
,
ll\
O\
ll\
Ol\
OO\
ll\
O
)
;
}
voi\
d\

lOll\
O\
lOl\
OOll
::
ll\
O\
llOOllOOl
::
llOll\
l\
OllOlO
(
llOlOllOlOOO
*
llOl\
llOll\
OO\
O
,
flo\
a\
t
*
ll\
OlllOllOll
)
{
float
llOl\
ll\
Ol\
Olll
[
1024
]
;
int
lO\
OO\
lOOlOOl
;
TA_AS\
SE\
RT
(
llO\
llOlO\
lOOl\

<
1024
)
;
memse\
t
(
llOlll\
OlOll\
l
,
0
,
ll\
OllOl\
OlOOl
*
si\
ze\
o\
f
(
float
)
)
;
for\

(
lO\
OO\
l\
O\
OlOO\
l
=
0
;
lOOOlOOlO\
Ol
<
llO\
lllO\
l\
lOOO
->
llOlO\
lO\
lOlll
;
lOOO\
lOO\
l\
OOl
++
)
{
flo\
at
ll\
Ol\
l\
lO\
lll\
OO\

=
llOl\
ll\
OllOll
[
lOOOlO\
OlOOl
]
;
llOlOll\
Ol\
OOO
::
lOOllOO\
OOO
*
lOO\
l\
ll\
OOOl
=
llOlllOl\
lO\
OO
->
llO\
lOllO\
l\
l\
OO
[
lOOOl\
OOlOO\
l
]
;
for\

(
;
lO\
OlllOOOl\

;
lOO\
l\
llO\
OOl
=
lOO\
lll\
OOOl
->
ll\
OlOllO\
lOlO
)
{
int
llOlllOlllOl
=
lOOlllOOOl
->
lOOOlO\
O\
lOl\
O\

*
6
;
llO\
lll\
Ol\
Olll
[
llOlllO\
ll\
lOl
+
0
]
+=
lOO\
lllOOOl
->
llO\
l\
OllOlOOl
[
0
]
*
llOlll\
OlllOO
;
llOll\
lOl\
Ol\
ll\

[
llOl\
llOlllOl
+
1
]
+=
lOO\
lllO\
OO\
l
->
llOlOllO\
lOO\
l\

[
1
]
*
llOlllOl\
llOO\

;
llO\
l\
llOlOll\
l
[
llOlllO\
lllOl
+
2
]
+=
lOO\
lllOOO\
l
->
ll\
OlOllO\
l\
OO\
l
[
2
]
*
llO\
ll\
lOlllOO
;
llOlllOlOll\
l
[
ll\
Oll\
lO\
lllO\
l
+
3
]
+=
lOOlllOO\
Ol\

->
llOlOllOl\
OO\
l
[
3
]
*
llOl\
l\
lO\
lll\
OO
;
llO\
lllOlOl\
ll\

[
llOlllOl\
ll\
Ol
+
4
]
+=
lOOlllOO\
Ol
->
llO\
l\
OllO\
lOOl
[
4
]
*
llOlllOlll\
O\
O
;
llOlllOlOlll\

[
llOl\
ll\
Oll\
l\
O\
l\

+
5
]
+=
lOOll\
lO\
OOl\

->
ll\
Ol\
O\
llOlOOl
[
5
]
*
llO\
l\
l\
lO\
l\
llOO
;
}
}
for
(
lOOOlOOlO\
O\
l
=
0
;
lOOOl\
OOlOOl
<
llOl\
lO\
lOlOOl
;
lO\
OOlO\
OlO\
O\
l
++
)
llOll\
lOl\
Olll
[
lOOO\
lOOlOOl
]
+=
llOllOl\
OOl\
Ol
[
lOOOlO\
O\
lOOl
]
;
llO\
llO\
l\
lllOO\

(
llOlllOlOlll
,
llOll\
Ol\
OO\
ll\
l
)
;
}
lO\
llOlOlOOll
::
lOllOl\
OlOOll\

(
)
{
lOlOOOlOlO
=
0
;
lO\
lOOOlO\
O\
l
=
0
;
llOllOOOlOOO
=
0
;
llOOlOll\
O\
lll\

=
0
;
ll\
OlllOllllO
=
0
;
ll\
OlllO\
llll\
l
=
0
;
llO\
llOlOOlOl
=
0
;
llOl\
l\
Ol\
OOll\
l
=
0
;
llOl\
l\
llOOOOO
=
0
;
llOllllO\
O\
O\
Ol
=
0
;
llOl\
lll\
O\
O\
OlO
=
0
;
llO\
llllOOOl\
l
=
0
;
llOlll\
lO\
OlO\
O
=
0
;
llOllll\
OOlO\
l\

=
0
;
llOlll\
lO\
Ol\
lO
=
0
;
llO\
ll\
l\
l\
OOlll
=
0
;
ll\
Oll\
l\
lO\
lO\
OO
=
0
;
ll\
O\
lll\
l\
OlO\
Ol\

=
0
;
llO\
l\
ll\
lOlO\
lO
=
0
;
llOllllOlOl\
l\

=
0
;
llO\
ll\
llOllOO
=
0
;
llOllllOllOl
=
0
;
llOll\
l\
lOlllO\

=
0
;
llOllll\
Ollll
=
0
;
ll\
Olllll\
OOOO
=
0
;
llOlll\
llOOO\
l
=
0
;
}
lO\
llOlOlOO\
l\
l\

::
~
lOllO\
lOl\
OO\
ll
(
)
{
Fin\
ali\
se
(
)
;
}
voi\
d
lOllO\
lOlO\
Ol\
l
::
Init\
ialise\

(
in\
t\

ll\
O\
OOllOO\
O\
O\
l
,
in\
t
llOlO\
ll\
Ol\
lll\

)
{
TA_ASS\
E\
RT
(
llOlOlOl\
OOl\
l
==
0
)
;
llO\
lOlOl\
O\
OlO
=
0
;
lO\
l\
OO\
O\
lOlO\

=
ll\
OOO\
l\
lOOO\
Ol
;
lOlOOOlOO\
l\

=
0
;
llO\
llO\
OO\
lOO\
O
=
llOl\
Oll\
Ollll\

;
ll\
OOl\
Oll\
Oll\
l
=
0
;
lOOOlll\
lOO
(
ll\
Ol\
ll\
OllllO
,
float
,
lOl\
OOO\
lOlO
)
;
lOOOlll\
l\
O\
O
(
ll\
Ol\
llOlll\
l\
l
,
fl\
oat\

,
lO\
lOOOl\
O\
l\
O
)
;
lOOOlll\
lOO
(
llOl\
lO\
lOOlOl\

,
float
,
lO\
l\
OOOlO\
lO\

)
;
lOOO\
lll\
lOO
(
llOl\
lO\
l\
O\
Olll
,
float\

,
lO\
l\
O\
OO\
lOlO
)
;
lOOOl\
l\
llOO
(
ll\
O\
llllO\
OO\
OO
,
floa\
t
,
lOl\
OOOlOl\
O
)
;
lOOOllllOO
(
llOllll\
O\
OOO\
l
,
int
,
lOlOOOlOl\
O
)
;
lO\
OOll\
llO\
O
(
ll\
OllllO\
O\
OlO
,
int
,
lOl\
OOO\
lOlO\

)
;
lOOOllllO\
O\

(
llOll\
l\
l\
OO\
O\
l\
l
,
flo\
at
,
lOlOO\
OlOl\
O
*
lOlOOOl\
OlO
)
;
lOO\
Olll\
lOO\

(
llOl\
l\
llOOlOO
,
flo\
at
,
lO\
lOOOl\
O\
lO\

*
lO\
lOO\
O\
lOlO
)
;
lOOOllllOO
(
llOll\
l\
l\
OOlOl
,
in\
t
,
lOlOO\
OlOl\
O
)
;
lO\
OOlll\
lOO
(
ll\
OllllOOllO\

,
in\
t
,
lO\
l\
OOOlOlO\

)
;
lOOO\
llll\
OO\

(
llOll\
llOOlll
,
llOlOl\
l\
lOOOl
,
llOllO\
OOlO\
OO
)
;
ll\
Ol\
lllOlOll
=
0
;
lO\
OOl\
ll\
lOO
(
llOl\
l\
llOllOO
,
int\

,
lOlOO\
Ol\
OlO
)
;
ll\
Oll\
ll\
Oll\
Ol\

=
0
;
lO\
OOlll\
lOO
(
llOllllOl\
l\
lO\

,
int\

,
lOlOOO\
lOl\
O
)
;
int
llO\
ll\
l\
llO\
OlO
=
llOl\
lO\
OOlOOO
*
6
+
lO\
lOOOlOl\
O
;
lOOO\
llllOO
(
llOlll\
lO\
lll\
l
,
float
,
llO\
lllllOOl\
O\

)
;
lOO\
Olll\
lOO
(
llOl\
ll\
llOOOO\

,
float
,
llOlll\
l\
lO\
OlO\

)
;
llO\
llll\
lOO\
Ol
=
0
;
lOOOOO\
l\
lOl\
O
(
llO\
l\
l\
llO\
lOOO
,
ll\
OlOl\
l\
OlOO\
O
)
;
ll\
OllllOlOOO
->
Ini\
t\
iali\
s\
e
(
lO\
lOO\
OlO\
lO
,
llO\
llO\
OOlOO\
O
)
;
lOOO\
OO\
l\
l\
O\
lO
(
llOlll\
lOlOOl\

,
llOlO\
ll\
l\
lOl\
O\

)
;
ll\
Oll\
l\
lO\
l\
O\
Ol
->
In\
it\
ialise
(
lO\
l\
O\
O\
O\
lOlO
,
llOll\
OO\
O\
lO\
OO\

)
;
lOOOOOl\
lO\
lO\

(
llO\
l\
lllO\
lOlO
,
llO\
l\
lOOllOOl\

)
;
llOlll\
lOlOlO\

->
Initialise\

(
lOl\
OOOlOlO
,
ll\
OllOOOlOOO
)
;
lOOOO\
OllOlO
(
(
llOlO\
lOOOO\
l\
O
*
&
)
lO\
lOOlO\
l\
lO\

,
llOl\
O\
lOO\
OO\
lO
)
;
if
(
!
llOl\
OlOlO\
O\
ll
)
{
lOOOOOllOlO
(
ll\
OlOl\
OlOOl\
l
,
llOlOlOO\
l\
lOl
)
;
TA\
_ASSERT
(
ll\
OlOl\
OlOOlO
>
0
)
;
llOl\
OlO\
lOO\
ll
->
Initial\
ise\

(
llOlOlOlOOlO
)
;
}
#ifdef _DEBUG
ll\
Oll\
ll\
lO\
O\
ll
(
)
;
#endif //
}
voi\
d
lOll\
Ol\
O\
lO\
O\
ll
::
Finali\
s\
e
(
)
{
Cle\
ar
(
)
;
lOl\
OOOlOlO
=
0
;
lOlO\
O\
O\
lOOl\

=
0
;
llO\
llOOO\
l\
OOO\

=
0
;
llO\
OlOl\
lOlll
=
0
;
llOlO\
OllO\
llO\

(
llOlllOl\
l\
llO
,
fl\
oa\
t\

)
;
llO\
l\
O\
OllO\
ll\
O\

(
llOlllOlll\
ll
,
float
)
;
llOl\
OOl\
lOllO
(
ll\
Ol\
lOl\
OOl\
O\
l
,
float\

)
;
ll\
OlOOll\
OllO
(
llOll\
O\
lOOlll
,
float\

)
;
ll\
OlOOllO\
llO\

(
llOl\
lllO\
OOOO
,
float\

)
;
llOlOOl\
lOl\
lO
(
ll\
OllllOOO\
Ol\

,
int\

)
;
llOlOOllOl\
lO
(
llOll\
llOOO\
l\
O
,
int
)
;
llOlOOllOllO
(
ll\
Ol\
lllOO\
Oll
,
flo\
at
)
;
llOlOO\
llO\
llO
(
ll\
O\
ll\
l\
lOOlOO
,
flo\
at
)
;
llOlOOll\
Oll\
O\

(
llOl\
l\
l\
l\
OOl\
Ol
,
int
)
;
ll\
O\
lOOll\
O\
llO
(
llOllllO\
O\
llO
,
int
)
;
llOl\
OOll\
OllO
(
ll\
OllllOOll\
l\

,
llOlOl\
llO\
OO\
l
)
;
llOlOOllOlll
(
ll\
O\
llll\
OlOOO
,
llOlOll\
OlOOO
)
;
llOlOOllO\
ll\
l\

(
llOlll\
lOlOlO
,
llO\
llO\
Oll\
OO\
l\

)
;
llOlOOllOlll\

(
llOll\
ll\
OlOOl
,
ll\
Ol\
Ol\
l\
llOl\
O\

)
;
ll\
Olll\
lOlOll
=
0
;
llOl\
OOllOll\
O\

(
llOllllOll\
OO
,
int
)
;
llOllllOllOl
=
0
;
ll\
OlO\
Oll\
O\
l\
lO
(
ll\
O\
l\
l\
llOl\
ll\
O\

,
in\
t
)
;
llOlOOllO\
ll\
O
(
ll\
OllllOll\
ll
,
flo\
at\

)
;
llO\
l\
OOll\
OllO
(
ll\
O\
lllllOOOO
,
float
)
;
llOl\
OOllOl\
ll
(
ll\
O\
l\
OlOlOO\
ll
,
llOlO\
lOO\
llOl
)
;
ll\
Ol\
OlO\
O\
O\
Ol\
O
*
lOO\
lllOOOO
=
(
llOlOlOO\
OOlO
*
)
lOlOOlO\
llO\

;
llOlO\
Oll\
Ol\
ll
(
lOOll\
l\
OOOO
,
llOlOlOOOOlO
)
;
lO\
l\
O\
OlOllO
=
0
;
}
vo\
i\
d\

lOl\
lOlOlOOll
::
Clear\

(
)
{
TA_AS\
SER\
T
(
ll\
Ollll\
Ol\
OOO\

)
;
llOl\
l\
ll\
OlOO\
O
->
Clear
(
)
;
llOlll\
l\
OlOOl
->
Clea\
r
(
)
;
ll\
O\
llllOlOl\
O
->
Cl\
ea\
r\

(
)
;
ll\
OOlOllOlll\

=
0
;
lOlOO\
O\
lOO\
l
=
0
;
}
void
lOll\
OlOlOOl\
l
::
llOOOOlOOll\
O\

(
int\

ll\
OO\
OOl\
OOO\
O\
O\

,
int\

lO\
OOlO\
O\
l\
O\
O\
l
,
float
lOOOO\
Ol\
ll\
O
)
{
TA_ASSERT
(
llOOOOlO\
OOO\
O
>=
0
)
;
TA\
_ASSERT
(
llOOOOl\
OOOO\
O
<
ll\
OllllO\
lOOl
->
ll\
Oll\
OOOlO\
ll
(
)
)
;
llOlOl\
lllOlO
::
ll\
OlOll\
l\
llOO\

&
llOllOOlOOll
=
*
ll\
Ollll\
Ol\
OO\
l\

->
llOll\
OOO\
l\
lO\
l
(
llOOOO\
lO\
O\
OOO
)
;
TA\
_A\
SS\
ERT
(
lOOO\
l\
OO\
lOO\
l\

>=
0
)
;
TA_\
ASS\
ERT
(
lOO\
O\
lOO\
lOOl\

<
ll\
Oll\
O\
O\
lOOll
.
ll\
OlOl\
OlOlOl
)
;
if
(
ll\
Ol\
lOOl\
OO\
ll\

.
lO\
l\
OllOOll\

&
ll\
O\
ll\
O\
O\
l\
Ol\
lO\

)
{
TA\
_ASSERT\

(
llOlll\
lOlOlO\

)
;
int
lO\
OO\
lOOll\
l
=
ll\
O\
llOOlOO\
l\
l
.
llO\
llOO\
O\
OOOl\

+
lOOOlOO\
lOOl
;
lO\
OOl\
OOll\
l
+=
llOOlO\
llOlll
*
6
;
TA_ASS\
ER\
T
(
lOO\
O\
lOOl\
ll\

<
llOll\
llOlOl\
O
->
llOllO\
lOl\
OOO
)
;
llOl\
lllOl\
OlO
->
llOllOlO\
OlOl
[
lOOOlO\
Olll\

]
=
lO\
OOOOll\
lO\

;
}
els\
e
{
TA_ASSER\
T
(
llOllO\
OlO\
O\
ll
.
ll\
Oll\
OOOOOOl
>=
0
)
;
int
lOO\
OlOOlll\

=
ll\
Ol\
l\
OO\
lOOll
.
llO\
ll\
OOO\
OOOl
+
lOO\
OlO\
OlOO\
l
;
TA_ASS\
ER\
T\

(
lOOOlOOlll\

>=
0
)
;
TA_A\
SSERT
(
lOOOl\
OOll\
l
<
lOlO\
OOlOOl
)
;
llOl\
l\
O\
lOO\
l\
Ol
[
lOOOl\
OOlll\

]
=
lOOOO\
O\
l\
l\
lO\

;
}
}
float
lOll\
OlOlO\
Oll
::
GetImpu\
lse
(
int
llOO\
OOlO\
OO\
O\
O\

,
int
lOOOlOOlOOl
)
{
TA\
_A\
SS\
E\
RT
(
llOOO\
OlOOOO\
O
>=
0
)
;
TA_ASS\
E\
R\
T
(
llOO\
OOlO\
OOOO
<
llOl\
ll\
lOlOO\
l
->
ll\
OllOO\
OlO\
l\
l\

(
)
)
;
llOl\
O\
ll\
llOl\
O
::
ll\
OlO\
l\
l\
l\
llOO
&
ll\
OllO\
OlOOl\
l
=
*
llO\
llllOl\
OO\
l\

->
ll\
OllO\
OOll\
O\
l
(
llOOOOlOOO\
OO
)
;
TA_A\
SSE\
RT
(
lO\
O\
OlO\
OlOOl\

>=
0
)
;
TA_ASSERT
(
lOO\
OlOO\
lOOl
<
llOl\
lO\
Ol\
OOll
.
llOlOl\
OlO\
lOl
)
;
if
(
llOllO\
OlOOl\
l
.
lOlOllOOl\
l
&
llOl\
lOOlOllO
)
{
TA_ASSERT
(
ll\
OllllOlOlO\

)
;
int\

lOO\
O\
lOO\
lll
=
llOl\
lOOlOOl\
l
.
llOl\
lOOO\
OOO\
l\

+
lOO\
O\
l\
OOlOOl
;
lOOOlOOlll
+=
llOOlOllOlll
*
6
;
TA_\
ASSERT
(
lOOOlO\
Olll
<
ll\
Ollll\
O\
lO\
lO
->
llO\
llO\
lOlOOO
)
;
return\

llOllllOlO\
l\
O
->
llOllO\
lOOlll
[
lOOO\
lOOl\
ll\

]
;
}
els\
e\

{
TA_A\
S\
S\
E\
R\
T
(
llOl\
lOOlOO\
ll
.
llOl\
lO\
OOOO\
Ol
>=
0
)
;
int
lOOOlOO\
l\
ll
=
llO\
llOO\
l\
OOll
.
llO\
llO\
OO\
OO\
Ol
+
lOO\
O\
lOOlOOl
;
TA_AS\
S\
E\
R\
T
(
lOOO\
lOO\
ll\
l
>=
0
)
;
TA\
_A\
SS\
ER\
T
(
lOOOl\
OOlll
<
lO\
lOOO\
lOOl
)
;
return\

llO\
llOlOOlll
[
lOOOlO\
Ol\
l\
l
]
;
}
}
vo\
id
lOllOlOl\
OOll\

::
llOOOO\
Ol\
lOlO\

(
float
llOll\
lll\
OlOO\

,
const
Mat3\
3\

&
ll\
O\
lllll\
Ol\
Ol
)
{
TA_ASSE\
RT
(
llO\
OlOll\
Olll
<
ll\
Ol\
lOOOlOOO
)
;
TA_ASS\
ERT
(
llOll\
l\
l\
OOl\
ll
)
;
llOlOlll\
OOOl
&
llOl\
lO\
lOOOO\
l
=
llOllll\
OOll\
l
[
ll\
OO\
lOllOlll\

++
]
;
TA_\
ASS\
ERT\

(
llOll\
llOl\
O\
lO
)
;
llOl\
ll\
l\
Ol\
OlO\

->
llOO\
lOllOlll
++
;
ll\
O\
llll\
OlOOl\

->
llO\
llOOOllOO\

(
)
;
ll\
Oll\
OlOO\
O\
Ol
.
lOO\
OlllOl\
OlO
=
Sq\
rt
(
llOlllllOlOO\

)
;
cons\
t
Ma\
t33
&
lllOllOOllO\

=
llOl\
ll\
l\
lOlOl\

;
llO\
l\
lOlOOOOl
.
llOllO\
l\
OOO\
lO
[
0
]
=
Sqr\
t\

(
lllOll\
O\
Ol\
lO
.
M11
(
)
)
;
TA\
_\
ASSERT
(
ll\
OllOlOO\
OOl
.
llOl\
lOlOOOlO
[
0
]
>
0.0f
)
;
llO\
ll\
Ol\
O\
OO\
Ol\

.
llO\
ll\
OlOOO\
ll
[
0
]
=
lllOll\
OOllO
.
M21
(
)
/
llOllO\
lOOO\
Ol
.
llOll\
O\
lOO\
O\
lO\

[
0
]
;
llOllOlO\
OOOl
.
llO\
llOlOOlOO
[
0
]
=
lllOl\
lOO\
l\
lO
.
M31
(
)
/
ll\
OllO\
l\
OOOO\
l\

.
llOllOlOOOlO
[
0
]
;
fl\
oat
llO\
lOllOO\
OO\
O\

=
ll\
lOllOOll\
O\

.
M2\
2
(
)
;
llOlO\
ll\
O\
OOOO
-=
llOllOlOOOOl
.
llOllOlOOOll\

[
0
]
*
llOll\
O\
lO\
OO\
O\
l
.
llOll\
OlOO\
Oll
[
0
]
;
TA_\
ASSE\
RT
(
llO\
lOll\
O\
OOOO
>
0.0f
)
;
llOllO\
lOOOOl
.
llO\
l\
lOlOOOl\
l\

[
1
]
=
Sqrt\

(
ll\
OlO\
llOO\
OO\
O\

)
;
llOlO\
ll\
O\
OOOO
=
lll\
Ol\
lOOllO
.
M3\
2
(
)
;
ll\
Ol\
OllOOOO\
O
-=
llOl\
lO\
l\
OOO\
Ol
.
llOl\
lOlOO\
Ol\
l
[
0
]
*
llOllO\
lOOO\
Ol
.
llOllO\
lOO\
lOO
[
0
]
;
ll\
O\
llOl\
O\
OOOl
.
llOll\
OlOOlOO\

[
1
]
=
ll\
OlOllOO\
OO\
O
/
llO\
llO\
lO\
O\
OOl\

.
llO\
ll\
Ol\
OOOl\
l
[
1
]
;
llOlO\
ll\
OOOOO
=
lllO\
ll\
OOllO
.
M33
(
)
;
llOlOllO\
OOOO\

-=
ll\
Ol\
l\
OlO\
OOO\
l
.
llO\
l\
lOlO\
OlOO
[
0
]
*
llOllOl\
OOOO\
l
.
ll\
Oll\
OlOOlOO
[
0
]
;
llOlOll\
OOOOO\

-=
llOllOlOO\
OOl
.
llO\
llOl\
OO\
lOO
[
1
]
*
llO\
llOlOO\
OO\
l
.
llO\
llO\
lO\
OlO\
O
[
1
]
;
TA_A\
SSE\
RT
(
llOlOll\
OO\
O\
OO\

>
0.0f
)
;
llO\
llOlO\
O\
OO\
l
.
ll\
Oll\
OlO\
OlOO
[
2
]
=
Sqrt\

(
llO\
l\
Oll\
OOOOO
)
;
#ifdef llOlllllOllO
Ma\
t33
llOl\
ll\
l\
lOlll
;
ll\
Olllll\
Olll
.
SetT\
oId\
e\
nti\
t\
y
(
)
;
llOllll\
lOll\
l
.
llO\
lllll\
l\
OOO\

=
llO\
llOlOOOOl
.
ll\
OllOl\
OOOl\
O
[
0
]
*
llOllOlOOOO\
l
.
llOllOl\
O\
OOlO\

[
0
]
;
llOlllllOlll
.
lO\
OO\
O\
l\
OOOlll\

=
llOll\
OlOOOOl\

.
llOllOlOO\
O\
ll
[
0
]
*
llOllOlOOO\
Ol
.
llOllO\
lOOOlO
[
0
]
;
llOll\
lllOll\
l
.
lOOOOlOOlOO\
O
=
llO\
llOl\
OO\
OOl\

.
llOllOl\
OOOll
[
0
]
*
llO\
llO\
lOOO\
Ol
.
llOllOlOOOlO
[
1
]
+
llO\
l\
lOl\
O\
OOOl
.
llO\
ll\
OlOO\
Oll
[
1
]
*
ll\
OllOlO\
O\
OOl
.
ll\
OllOlOO\
Oll
[
1
]
;
ll\
OlllllOlll
.
lOOOOlOOlOlO
=
ll\
Oll\
O\
lOOOOl\

.
llO\
ll\
Ol\
O\
OlOO
[
0
]
*
llOllOlO\
O\
OOl\

.
llO\
l\
lOlOOOlO\

[
0
]
;
llO\
lllllOl\
ll
.
lOO\
O\
O\
lOOl\
Oll\

=
llOllO\
lOOOO\
l
.
llOllOlOOl\
OO
[
0
]
*
ll\
O\
llOlOOOOl\

.
llOllOlOOOl\
O\

[
1
]
+
llOll\
OlOOOOl\

.
ll\
Ol\
l\
Ol\
OOlOO
[
1
]
*
ll\
OllOl\
O\
OOOl
.
ll\
OllOlO\
O\
Ol\
l\

[
1
]
;
ll\
O\
lllllOlll\

.
lOOOO\
O\
OO\
ll\

=
llOl\
lOlOOOO\
l\

.
ll\
O\
llO\
lOO\
lOO
[
0
]
*
ll\
Ol\
lOl\
OOO\
Ol
.
ll\
Oll\
Ol\
OOO\
lO
[
2
]
+
llOllO\
lOOOOl
.
llOllOl\
O\
OlOO
[
1
]
*
ll\
O\
l\
lOlOOOOl
.
ll\
OllOlOOOll
[
2
]
+
ll\
OllO\
lOOOOl
.
llO\
l\
lOlO\
O\
lO\
O\

[
2
]
*
llOllOlO\
OO\
Ol
.
ll\
O\
llOlOOlOO\

[
2
]
;
fo\
r
(
int
lOOOl\
lOO\
Ol
=
0
;
lOOO\
llOO\
Ol
<
3
;
lO\
OOl\
lOOOl
++
)
{
for
(
in\
t\

lOOlOO\
lOl\
O\

=
0
;
lOO\
lOOl\
OlO
<=
lOOOllOOOl\

;
lOO\
lOOlOlO
++
)
{
float
lOOOOO\
lllO
=
llOllll\
lOlll\

.
llOlllOlO\
O\
OO\

[
lOOOllOOOl
]
[
lOOl\
OO\
lO\
l\
O\

]
-
ll\
l\
OllOOllO
[
lOO\
OllO\
OOl
]
[
lOOl\
OOlOl\
O
]
;
}
}
#endif
}
int
lOllOlOlOOll
::
llOOO\
O\
l\
OOOO\
l
(
int
llOlOl\
OlOlOl
,
in\
t
llOllOOl\
OOOO
,
int\

llOllOOlOOOl\

,
u32\

lOl\
Oll\
O\
Oll
)
{
int
llOllllllOO\
l
=
llOllllO\
lO\
Ol
->
llOll\
OOOll\
ll
(
llOlOlOl\
OlO\
l
,
llO\
l\
l\
O\
O\
lOOO\
O
,
ll\
Ol\
l\
O\
O\
lOOOl
,
lO\
l\
Ol\
lOOll
)
;
re\
t\
urn
ll\
OllllllOOl
;
}
vo\
id
lO\
l\
lOl\
OlO\
Oll
::
llO\
O\
OO\
lOOO\
l\
O
(
int
llOOOOlOO\
OOO
,
int
lOOOlOO\
lOOl
,
const
Vec\
3
&
llOOll\
lllO\

,
const
Vec3
&
llOl\
l\
OOOOOll
)
{
llO\
lOllllO\
lO
::
llOlO\
lll\
llOO
*
llO\
llllll\
OlO
=
llOllllOlOO\
l
->
llOllO\
OOl\
lOl
(
llOOOO\
lOOOO\
O\

)
;
llOllll\
llO\
lO
->
llOllOOOO\
OlO
(
lOO\
Ol\
OO\
lOOl
,
llO\
Olll\
llO
,
ll\
Oll\
OOOOO\
ll
)
;
}
void
lO\
ll\
Ol\
Ol\
OO\
l\
l
::
ll\
OO\
O\
OlOO\
Ol\
O
(
in\
t
llO\
OO\
OlOOOOO
,
in\
t
lOOOlOOl\
OOl
,
con\
st
Ve\
c3
&
llll\
OOOO\
l\
l\

,
const
Vec3
&
llOllOOO\
OlOO
,
co\
ns\
t
Ve\
c3
&
ll\
l\
lOO\
O\
lO\
O
,
co\
n\
st
Vec\
3
&
ll\
OllOOOO\
l\
Ol\

)
{
llO\
l\
OllllO\
l\
O
::
ll\
OlO\
l\
llllOO
*
llO\
llllllOlO
=
llOll\
llO\
l\
OO\
l
->
ll\
O\
ll\
O\
OOll\
Ol
(
ll\
OO\
OOlO\
OO\
OO
)
;
llOlll\
l\
ll\
OlO
->
llO\
ll\
O\
OOOOlO
(
lOOOl\
OOlO\
Ol
,
llll\
OOOOll
,
llOllO\
OOO\
l\
O\
O\

,
llllOOOlOO
,
ll\
OllOOOO\
lOl\

)
;
}
vo\
id
lOllOl\
O\
lOOll\

::
llOOO\
OlOO\
O\
ll\

(
)
{
TA_\
ASSERT\

(
ll\
Olll\
lO\
lOOl
->
ll\
Oll\
OOOl\
O\
l\
l\

(
)
+
1
>=
llO\
ll\
llOlOOl
->
lOll\
Oll\
llO\
lO
(
)
)
;
llOlll\
ll\
lOl\
l
(
)
;
}
bool
lO\
llOl\
OlOOll
::
llOO\
OO\
lOll\
O\
O
(
)
{
ll\
Ol\
llllOOO\
l
=
0
;
lOO\
lOlllO\
O\
l\

(
llOl\
O\
Ollllll
)
;
{
TA\
_AS\
SERT\

(
llO\
llll\
OlOOO\

)
;
TA_ASS\
ERT
(
llOllllOO\
ll\
l
)
;
TA\
_\
A\
S\
SERT
(
llO\
l\
l\
llO\
l\
OlO
)
;
llOllllOlOl\
O
->
llOlOlll\
OOOO\

(
llO\
llllOO\
lll
,
llOOlOl\
lOlll\

)
;
llOll\
llOlOlO
->
llO\
l\
lOlll\
OOO\

(
)
;
llOlll\
lO\
lO\
O\
O\

->
llO\
lOlllO\
O\
O\
O
(
llOll\
l\
lO\
O\
lll\

,
llOO\
lOll\
Olll
)
;
{
TA\
_A\
SS\
ER\
T
(
lOlO\
OOl\
OOl
<
1024
)
;
flo\
a\
t
llOlllO\
lOllO
[
1024
]
;
float
ll\
OlllOlOlll
[
1024
]
;
for
(
in\
t
lOO\
OlOOlO\
lO
=
0
;
lO\
O\
OlOOl\
O\
l\
O
<
lO\
l\
O\
OOlOO\
l
;
lOOO\
lO\
O\
lO\
lO
++
)
{
llOllll\
OlOlO
->
llOll\
lOl\
OlO\
l
(
llOlllO\
lOllO
,
llOlllOl\
O\
lll
,
llOllllOlOO\
O\

,
lOO\
O\
lOOlO\
lO
)
;
for\

(
int
lOO\
OlOOlOOl
=
0
;
lOOOlOOlOOl\

<
lOlOOO\
lO\
Ol
;
lOO\
O\
lOOl\
O\
Ol\

++
)
{
ll\
O\
llllOOOll
[
lOOOlO\
OlOO\
l\

*
lOl\
OOOlOOl
+
lO\
O\
OlOOlOlO
]
=
ll\
Olll\
lOlOO\
O
->
llOlOl\
llO\
l\
OO
(
lOOO\
l\
OOlOOl
,
ll\
O\
lllO\
lOllO\

)
;
}
}
}
}
lOO\
lOll\
lO\
ll
(
llOlOOlllll\
l\

)
;
in\
t
lOOOllOOO\
l
;
for
(
lOOO\
llOOOl\

=
0
;
lOOOll\
OO\
Ol
<
lO\
lOOOl\
OOl
;
lOOOl\
l\
OOOl
++
)
{
llOl\
l\
O\
lOOlll
[
lO\
OO\
l\
l\
OOO\
l
]
=
0
;
llOll\
O\
lOOlOl
[
lOOOllOO\
Ol\

]
+=
llO\
l\
ll\
l\
O\
l\
Ol\
O
->
llOll\
lOl\
lOOl
(
ll\
Olll\
l\
O\
lOO\
O
,
lOOO\
llOO\
Ol\

)
;
}
ll\
Oll\
llOlOll
=
0
;
llO\
llllOll\
Ol
=
0
;
#ifdef _DEBUG
static
s64
llO\
lllll\
l\
lO\
O
=
0
;
static
s64
ll\
OlllllllOl\

=
0
;
llOl\
ll\
llll\
O\
l
++
;
#endif //
for\

(
int
llOl\
l\
llllll\
O
=
0
;
llOllll\
ll\
llO
<
lOlOOOlO\
Ol
;
llOlll\
ll\
ll\
lO
++
)
{
if\

(
!
ll\
Ollllll\
ll\
l
(
llOllllllll\
O\

)
)
re\
turn\

false
;
}
for\

(
lOOOllOOO\
l
=
0
;
lOO\
OllOOOl
<
lOlOOO\
lO\
Ol
;
lOO\
Oll\
O\
OOl
++
)
{
}
ll\
Ol\
lllOlOlO
->
llOll\
l\
Ol\
lOlO
(
llOl\
lllOlOOO
,
llOllOlOOlll\

)
;
#ifdef _DEBUG
llOlll\
llll\
O\
O
++
;
ll\
O\
lOlO\
OOOOl
=
(
floa\
t\

)
ll\
O\
l\
l\
lllll\
O\
O
/
(
fl\
oat\

)
llO\
ll\
lll\
llO\
l
;
#endif //
re\
t\
urn\

tru\
e
;
}
voi\
d
lOllO\
lOlO\
Oll
::
llOO\
OOlOl\
l\
lO
(
)
{
int
lOOOllOOOl\

;
for
(
lOOOll\
OOOl
=
0
;
lOOOllO\
OOl
<
lO\
lOOO\
l\
OOl
;
lOOOl\
l\
O\
OOl\

++
)
{
ll\
OllOl\
OO\
lll\

[
lOOO\
llOOO\
l
]
=
0.0f
;
llOl\
lOlOOlOl
[
lOOO\
llOOOl
]
+=
ll\
Olll\
lOlOl\
O
->
llOl\
l\
lOll\
OO\
l\

(
llOl\
lllOlOOO
,
lOOOll\
O\
O\
Ol\

)
;
}
for
(
lOO\
Oll\
O\
OO\
l
=
0
;
lOOOllO\
OOl
<
llOllllOlOl\
l
;
lOOOllOOOl
++
)
llOllllOlll\
l
[
lOOOl\
lOOOl\

]
=
ll\
OllOlO\
OlO\
l
[
llOllllO\
l\
lOO
[
lOOOllOOOl
]
]
;
lllO\
OOOOOO\
OO
(
llOl\
lllOlOll
,
lOlOO\
O\
lOOl
,
llOlll\
l\
OOlO\
O
,
ll\
Oll\
llOll\
ll\

,
ll\
Oll\
lll\
O\
OOO\

)
;
fo\
r
(
lOOO\
l\
lOOO\
l
=
0
;
lOOOl\
lOOO\
l\

<
llOllll\
OlOl\
l
;
lOOOll\
OOOl\

++
)
{
TA_AS\
SERT
(
Floa\
t\
Is\
OK
(
llO\
llll\
lOOOO
[
lO\
OO\
llOO\
O\
l
]
)
)
;
llOllOlOO\
l\
ll\

[
llOll\
llOOlOl
[
lOO\
Ol\
lOOOl
]
]
=
-
llOl\
l\
ll\
lOO\
OO\

[
lO\
OOl\
l\
O\
OOl\

]
;
}
llO\
ll\
llOl\
OlO\

->
llOlllOll\
OlO
(
llOl\
l\
l\
lOlOOO\

,
ll\
OllOlOO\
lll
)
;
}
voi\
d
lOllOlOlOOll
::
llOllll\
llO\
ll
(
)
{
llO\
lll\
lOlOOl
->
lOOO\
l\
lOlOl
(
)
;
fo\
r\

(
int
llO\
OOOlOOOO\
O\

=
0
;
llO\
OOO\
lOOOOO
<
llOllllO\
l\
O\
Ol
->
llOl\
l\
O\
OOlO\
ll
(
)
;
ll\
O\
OO\
Ol\
OOOOO
++
)
{
llOlOlll\
lO\
lO\

::
llO\
lOlll\
ll\
O\
O
&
ll\
O\
llOO\
lOOll
=
*
llO\
llllOl\
OOl
->
llOllO\
OOllOl
(
ll\
O\
O\
OOlOOOOO
)
;
if
(
ll\
Ol\
lO\
OlOOll
.
lO\
l\
Ol\
l\
OOl\
l
&
llOl\
lOOlOl\
lO\

)
{
TA_\
A\
SSERT
(
llOl\
lllOlOlO
)
;
llOllOlOO\
O\
O\
O
&
lllOOO\
O\
OO\
OO\
l
=
llOll\
llOlOlO
->
llOllOl\
lOOOl
[
ll\
O\
llllOl\
O\
lO
->
llOll\
OOOO\
ll\
O
*
2
+
0
]
;
llOllOlOOOOO
&
lllOO\
OO\
OOOlO\

=
llOllllOl\
O\
lO
->
ll\
OllOl\
lOO\
Ol
[
llOllllOlOlO
->
llOllOOO\
Oll\
O
*
2
+
1
]
;
llO\
ll\
ll\
O\
lOlO
->
llOllOOOO\
l\
lO
++
;
llO\
llO\
O\
lO\
Oll
.
ll\
OllOOOO\
OOl
=
ll\
Oll\
llOl\
O\
lO\

->
ll\
O\
l\
lOll\
OOl\
O
;
ll\
OllllOlOlO
->
llOl\
lOllOOlO
+=
llOl\
lO\
Ol\
OOll
.
ll\
OlOl\
O\
l\
O\
l\
Ol
;
lllO\
OOOOO\
OOl
.
llOlOllllOl\
l\

=
ll\
OllO\
OlO\
Oll
.
lllOOlll\
OO\

.
llOlOl\
lll\
Ol\
l
;
lll\
OOOOOOO\
Ol
.
lOOOlO\
O\
lO\
lO
=
llOllOOlOOll
.
lllOOlllO\
O
.
lOOOl\
OOlOl\
O
;
TA_A\
SSERT
(
ll\
lOOOOOOO\
Ol
.
lO\
OOl\
O\
O\
l\
OlO
>=
0
)
;
lllOOOOOOO\
lO
.
ll\
Ol\
Ollll\
Oll
=
llO\
l\
lO\
OlOOll
.
lll\
OlOO\
OOO\

.
llOl\
O\
ll\
llOl\
l\

;
lllOOOO\
OOO\
lO
.
lO\
O\
O\
lOOlO\
l\
O
=
ll\
OllOOlO\
O\
ll\

.
lllOlOOOO\
O
.
lOO\
OlOOlOlO
;
TA\
_A\
SSE\
RT
(
lllOOOOOO\
O\
lO\

.
lOO\
O\
l\
O\
OlOl\
O\

>=
0
)
;
}
else
{
ll\
Ol\
Ol\
lOl\
OO\
O\

*
llOll\
l\
OllOO\
O
=
llOlll\
lOl\
OO\
O
;
llOllO\
O\
lOOl\
l\

.
ll\
Ol\
l\
OOOOOOl\

=
llOlllO\
llOO\
O\

->
ll\
O\
lOlOl\
O\
ll\
l
;
for
(
int
lll\
OOOO\
OOOll
=
0
;
lllO\
OO\
OO\
OO\
ll
<
llO\
llOOlOOll
.
llOlOlOlOlO\
l
;
ll\
l\
OOO\
OOOOll
++
)
{
TA\
_ASSERT
(
lOl\
OOO\
lOOl\

<
lOlOOO\
lOlO
)
;
TA_A\
S\
SE\
RT
(
lOlOO\
OlOO\
l\

>=
0
)
;
ll\
Ol\
lll\
OO\
O\
O\
l\

[
lOlO\
O\
O\
lOOl
]
=
llOll\
OOlO\
O\
l\
l\

.
lOlOl\
lO\
Oll\

;
int
lOOOlOOlOOl
=
llOl\
l\
lO\
ll\
OO\
O
->
llOlO\
lOlOl\
ll
;
ll\
Ol\
llOl\
l\
OOO
->
llOlO\
lOlOl\
ll
++
;
lOlOOO\
l\
O\
Ol
++
;
TA\
_ASSERT
(
llO\
l\
ll\
Oll\
O\
OO
->
ll\
OlOl\
Ol\
Olll
==
lOlOO\
OlOO\
l
)
;
TA_ASSER\
T
(
llOl\
llOl\
lOOO
->
llO\
l\
O\
llOl\
lOO
)
;
TA_ASSERT
(
llO\
ll\
l\
Oll\
OOO
->
llOlOll\
OllOl
)
;
TA_A\
S\
SER\
T
(
llO\
ll\
lOllO\
OO\

->
llOl\
Oll\
OlllO
)
;
TA_A\
SSERT
(
llOlll\
OllOOO
->
lO\
OO\
lO\
lO\
O\
l
<
lO\
lO\
OOlOlO
*
2
)
;
ll\
Ol\
Oll\
OlOO\
O
::
lOOl\
lOO\
OOO
*
lllO\
OOO\
OOlOO\

=
&
llOlll\
OllOO\
O
->
lO\
OlOOlOlll\

[
ll\
Ol\
llOll\
OO\
O
->
lO\
OOlOlO\
O\
l
++
]
;
if
(
ll\
O\
l\
l\
l\
Ol\
lOOO
->
llOlOl\
lOlllO
[
llOl\
lOOlOO\
ll
.
lllOO\
l\
llOO
.
lO\
OO\
lOOlOlO\

]
)
llOlllOllOOO\

->
llOlOl\
lOlllO
[
llOl\
l\
OOl\
OOl\
l\

.
lllO\
OlllO\
O
.
lOOOlOOlOlO
]
->
llOlO\
llOlOll
=
lllOOOOOOl\
OO\

;
ll\
Oll\
lO\
llOO\
O\

->
llOlOllOlllO
[
ll\
OllOOlOOll
.
lllOOl\
llOO
.
lOOOlOOlO\
l\
O
]
=
lll\
OO\
OOOOl\
OO
;
lll\
OOOO\
OOlOO
->
ll\
OlO\
llOl\
O\
ll
=
0
;
lllOOO\
OOO\
l\
O\
O
->
ll\
OlOl\
lOl\
OOl\

[
0
]
=
llO\
llOOl\
OOl\
l
.
ll\
l\
O\
Ol\
l\
lOO
.
llOl\
Ol\
ll\
l\
O\
ll
(
lllOOO\
OO\
OOl\
l\

,
0
)
;
ll\
lO\
OOOOOl\
O\
O
->
llOl\
OllOl\
OO\
l
[
1
]
=
llOllOO\
lOOll
.
ll\
l\
OO\
lllOO
.
llO\
lOlll\
lOll
(
lll\
O\
OOOOOOll
,
1
)
;
lll\
OOO\
OOOlOO\

->
ll\
OlO\
l\
lOl\
OOl
[
2
]
=
llOl\
lOOl\
OOll
.
ll\
lOOlllOO
.
ll\
OlOl\
lllO\
ll
(
ll\
lOOOOO\
OO\
ll
,
2
)
;
ll\
lO\
OOO\
OOlOO
->
llOlOl\
l\
Ol\
OO\
l
[
3
]
=
llOll\
OOlO\
Oll
.
lll\
OOlllO\
O\

.
ll\
O\
lO\
llll\
Oll
(
ll\
lOOOO\
OOO\
l\
l\

,
3
)
;
lllOOOOO\
Ol\
OO
->
llOlOll\
O\
lOOl
[
4
]
=
llOll\
OOlOOl\
l
.
lllOO\
ll\
lOO
.
ll\
Ol\
O\
llllOll
(
lllOO\
OOO\
OO\
ll
,
4
)
;
lllOO\
OOO\
OlOO
->
llOlO\
llOlOOl
[
5
]
=
llOllO\
O\
lOOll\

.
lllOO\
lllOO
.
ll\
OlOll\
l\
lOll
(
lllOO\
OO\
O\
O\
O\
ll
,
5
)
;
lllOOOOO\
O\
lO\
O
->
lOOOl\
OO\
l\
OOl\

=
lOOOlO\
O\
lOO\
l
;
lllOO\
OOO\
OlOO\

->
lO\
O\
Ol\
OOlOlO
=
llOl\
lOOlOOll
.
lllOOll\
l\
OO\

.
lOO\
Ol\
OOl\
O\
lO
;
if\

(
!
llOll\
lOllO\
OO
->
llO\
l\
OllOl\
lOl
[
llOllOOlOOll
.
ll\
lO\
OlllO\
O
.
lOOOlOOlOlO
]
)
llO\
l\
llOllOOO\

->
llOl\
Oll\
OllOl
[
llO\
l\
lOOl\
O\
O\
ll
.
lllOOlllOO
.
lOOOlOO\
lOlO
]
=
lllOO\
O\
OOOlOO
;
if\

(
llOllO\
O\
l\
OOll
.
lllO\
lOO\
OOO\

.
lOO\
O\
l\
O\
O\
lOlO
>=
0
)
{
TA_\
ASSERT
(
llOlllOll\
OOO
->
lOOOlOl\
OOl
<
lOlOOOl\
Ol\
O\

*
2
)
;
llOlOllOl\
OOO\

::
lOO\
llO\
OO\
O\
O
*
ll\
lOO\
OO\
OOl\
O\
l\

=
&
llOlllOllO\
OO
->
lOOlO\
OlOlll
[
ll\
O\
lllOllO\
O\
O
->
lOOO\
lOlO\
Ol
++
]
;
if
(
ll\
O\
lllO\
llOO\
O
->
ll\
OlO\
l\
lOll\
lO\

[
llOllO\
OlOOl\
l
.
lllOlO\
OOO\
O
.
lO\
OO\
l\
OO\
lOlO
]
)
ll\
O\
l\
llO\
l\
lOO\
O
->
ll\
OlOllOlll\
O
[
llOllOOlO\
Oll
.
lll\
OlOOO\
OO
.
lOO\
O\
lOOlO\
l\
O
]
->
llOlOl\
lOlO\
ll
=
lllO\
OOOOOlOl
;
llO\
lllOllOO\
O
->
llO\
lO\
llO\
lllO
[
llOl\
lOOlOOl\
l
.
lll\
OlOOOOO
.
lOOOlOOlOlO
]
=
lll\
OOOOOOlOl
;
lll\
OOOOO\
Ol\
Ol\

->
ll\
O\
lOllOlOll
=
0
;
lllOO\
O\
OO\
OlOl\

->
llO\
lOllOlO\
Ol
[
0
]
=
llO\
ll\
OOlOOll
.
lll\
OlOO\
OO\
O\

.
ll\
OlOl\
l\
l\
lOll\

(
lllOOOOO\
OOll\

,
0
)
;
ll\
lOOOO\
OOl\
Ol
->
llOl\
Ol\
lOl\
O\
Ol
[
1
]
=
llOllO\
OlO\
Oll
.
lllOlOOO\
OO
.
llOlOl\
lll\
Oll
(
lllOOOO\
OOOll
,
1
)
;
ll\
lOOOO\
OOlOl
->
llO\
lOllOl\
O\
O\
l\

[
2
]
=
ll\
Ol\
lOOl\
OOll
.
lllO\
lOOOOO
.
llOl\
Ol\
lllOll
(
lllOOOO\
O\
OOl\
l\

,
2
)
;
lll\
OOOOOOl\
Ol
->
llOlOl\
lO\
lOOl
[
3
]
=
llOllOO\
lOOll\

.
ll\
l\
O\
l\
O\
OOOO
.
ll\
OlO\
llllOll
(
lllO\
OO\
OO\
O\
Oll
,
3
)
;
ll\
lO\
OO\
OO\
O\
lOl
->
llOl\
Oll\
OlOOl
[
4
]
=
llOll\
OOlOOll
.
lllOlO\
O\
OOO
.
llOl\
Ol\
lll\
Oll
(
lll\
OOO\
OO\
OOll\

,
4
)
;
lllOOOOOOlOl
->
ll\
O\
lO\
llOlOOl\

[
5
]
=
llO\
llOOlOO\
ll
.
lllOlO\
OO\
OO
.
ll\
O\
lOlll\
lO\
ll
(
lllOOOOO\
OO\
ll
,
5
)
;
lllOOOOOOlOl
->
lOOOlOO\
lOOl\

=
lOOOl\
OOl\
OOl
;
lllOOOOOOl\
Ol\

->
lOOOl\
OOl\
Ol\
O
=
ll\
Oll\
O\
OlOO\
ll
.
lllOl\
OOO\
OO\

.
lOOOlOOlOlO
;
if
(
!
llOl\
llOllOOO
->
llO\
lO\
l\
lOllOl
[
ll\
OllOOlOOl\
l\

.
lll\
OlOOOOO
.
lOOO\
lOO\
l\
O\
lO\

]
)
llOl\
ll\
OllO\
OO
->
llOlO\
llOllOl\

[
llOllO\
OlO\
Oll\

.
lllO\
lOOOO\
O\

.
lOO\
OlO\
OlO\
l\
O
]
=
lllO\
OOO\
OO\
lO\
l\

;
if
(
llO\
llOOlO\
Oll
.
lll\
OO\
lllO\
O
.
lOOO\
l\
O\
OlOlO
<
llOllOOlOOll
.
lll\
OlO\
OO\
OO
.
lOOOlOO\
lOlO
)
{
llOlll\
Ol\
lO\
OO
->
llO\
lO\
l\
l\
OllO\
O\

[
lO\
O\
OlOOlO\
Ol\

]
=
ll\
lOOOOOOlOO\

;
lll\
OOO\
OO\
O\
lOO
->
ll\
OlO\
llOlOlO\

=
ll\
lOOOOOOlOl
;
lllOOOOOOlOl
->
ll\
OlOl\
lO\
lO\
lO
=
0
;
}
el\
s\
e\

{
llO\
ll\
lOll\
OOO
->
llO\
lOl\
lOl\
lOO
[
lO\
OO\
l\
OOlOOl
]
=
lll\
OOO\
OO\
Ol\
Ol
;
ll\
lOO\
O\
OOOlOl
->
llOl\
Ol\
lOlOlO
=
lllO\
OOO\
OO\
lO\
O
;
lllO\
OOOOOl\
OO\

->
llOl\
Ol\
lOlOlO
=
0
;
}
}
else
{
ll\
OlllOl\
lOOO
->
ll\
O\
l\
O\
l\
lOllOO
[
lO\
O\
OlOOlOOl
]
=
ll\
lOOOOOO\
lOO
;
ll\
lOO\
OOO\
Ol\
O\
O
->
llOlOl\
lO\
lO\
lO\

=
0
;
}
}
}
}
llOl\
lllOlOl\
O
->
llOll\
O\
ll\
OlOO\

(
llOlll\
lO\
lOOl
)
;
}
bo\
ol\

lOl\
lOlOlO\
Oll\

::
llO\
ll\
lllll\
ll
(
in\
t\

llO\
llllllllO
)
{
lOOlOll\
llO\
l
(
ll\
OlOOl\
llOOl
)
;
in\
t
lll\
OOO\
OOOll\
O
=
0
;
lO\
OlOlllOOl
(
llOlOO\
ll\
lllO
)
;
{
float
lllOO\
l\
lO\
Ol\

=
0.0f
;
for
(
in\
t\

lOOlO\
O\
lO\
lO\

=
0
;
lOOl\
OOlOlO
<=
ll\
O\
l\
lllllllO
;
lOOlOOlO\
lO
++
)
lllOOllOO\
l\

+=
ll\
OllllOOO\
ll\

[
llOlll\
l\
llllO
*
lO\
lO\
OOl\
OOl
+
lOO\
lOOlO\
l\
O
]
*
llO\
llO\
lOOlll\

[
lOO\
l\
OOl\
OlO
]
;
llOl\
llO\
lll\
l\
O\

[
llOll\
ll\
llllO\

]
=
lllO\
OllO\
Ol
+
llOllO\
lOO\
lOl\

[
llO\
ll\
l\
ll\
ll\
lO
]
;
lOO\
OOO\
Ol\
lO
(
Float\
IsO\
K
(
llOlll\
OllllO
[
llOll\
lll\
l\
llO
]
)
,
llOlO\
OllOl\
Ol
)
;
}
lOOl\
OlllO\
l\
l\

(
ll\
OlOOl\
l\
lllO\

)
;
fo\
r
(
int
lO\
OO\
ll\
OOOl
=
0
;
lOOO\
llOOOl
<
llOllllOlO\
l\
l
;
lO\
OOll\
OOOl\

++
)
{
if
(
(
llOllll\
O\
O\
OO\
l
[
ll\
Ol\
l\
llO\
llO\
O
[
lOOOllOOOl\

]
]
&
llO\
OOOOlllO\
l
)
==
0
)
{
if
(
llOl\
llOllllO
[
llOl\
lllO\
llOO
[
lOOOl\
lO\
O\
Ol\

]
]
<
-
0.1f
)
retur\
n
fa\
lse
;
if
(
llOll\
OlO\
Ol\
ll
[
ll\
Ol\
l\
ll\
O\
llOO
[
lO\
O\
O\
ll\
OO\
Ol
]
]
<
-
2.0f
)
retu\
rn
fa\
lse
;
}
els\
e
{
if
(
Fab\
s
(
llOll\
l\
O\
ll\
l\
lO\

[
llOl\
lllOl\
lO\
O
[
lOOOllOOOl
]
]
)
>
1.0f
)
ret\
u\
rn
false\

;
}
}
fo\
r\

(
;
;
)
{
ll\
O\
l\
llllOO\
Ol\

++
;
lllO\
O\
OOO\
O\
llO
++
;
if\

(
ll\
lOOOOO\
OllO\

>
(
llO\
l\
lllllllO
+
1
)
*
2
)
{
lOOO\
OOOll\
O
(
0
,
"PhysicsSolver is Looping: Giving up Now")
;
re\
tur\
n
fa\
lse
;
}
int\

lOO\
O\
llOO\
Ol\

;
if\

(
ll\
O\
ll\
llO\
O\
OOl
[
llO\
lllll\
l\
llO\

]
&
llOOOOOl\
l\
lOl
)
{
}
els\
e\

{
const
fl\
o\
at
lll\
OO\
OOOO\
l\
ll
=
0.01f
;
if
(
llOll\
lO\
llllO\

[
llOl\
ll\
l\
l\
ll\
lO
]
>
-
ll\
lOOO\
OOO\
ll\
l
)
{
lO\
O\
O\
OOOl\
lO\

(
llOlll\
lOllOl
<
llOllllllllO
+
1
,
ll\
OlOO\
llOl\
Ol
)
;
llOll\
l\
lOlllO\

[
llO\
l\
l\
llOl\
lOl\

++
]
=
llOllllll\
llO\

;
re\
tur\
n
true
;
}
}
ll\
l\
OOO\
OOlOO\
O
(
ll\
O\
ll\
l\
llll\
lO
)
;
lOO\
l\
O\
lllOOl
(
llOlO\
O\
lllllO
)
;
if\

(
0
)
{
floa\
t
ll\
lOOllO\
O\
l
=
0.0f
;
memset\

(
llO\
l\
ll\
lO\
llll
,
0
,
llOlll\
l\
O\
l\
O\
lO
->
llO\
llO\
l\
OlOOl
*
size\
of
(
fl\
oat
)
)
;
for
(
lOO\
O\
l\
lOOOl\

=
0
;
lOOOllOOOl
<=
llO\
l\
l\
l\
lllllO
;
lOOOl\
lOO\
Ol
++
)
{
co\
nst
int\

lO\
OO\
lOOlOlO\

=
lO\
OO\
l\
lOOOl
;
float\

llOlO\
l\
lOO\
OO
=
llOllllOOOO\
O
[
lO\
O\
OlO\
OlOl\
O
]
;
if
(
llOlOllO\
OO\
O
==
0.0f
)
cont\
inu\
e\

;
llOl\
Oll\
OlOOO
::
lOOllO\
OO\
OO
*
lOOl\
l\
l\
OO\
O\
l
=
ll\
Oll\
l\
l\
OlO\
OO
->
llOl\
O\
llOl\
lOO
[
lOOOllOOO\
l\

]
;
fo\
r
(
;
lO\
OlllOOOl
;
lOO\
lllOOOl
=
lO\
O\
lllOO\
Ol\

->
llOlOll\
O\
lOlO
)
{
int
lOOOlO\
OlOlO
=
lOO\
l\
l\
lOOOl
->
lOO\
OlO\
OlOlO
*
6
;
ll\
O\
l\
ll\
l\
Ol\
lll\

[
lOO\
Ol\
O\
OlOlO
+
0
]
+=
lOOl\
ll\
OOOl
->
ll\
Ol\
Oll\
Ol\
OOl
[
0
]
*
llOl\
OllOOO\
O
,
llOllllOllll
[
lO\
OO\
l\
OOlO\
lO
+
1
]
+=
lO\
Ol\
llOOO\
l
->
llOlO\
llOlO\
Ol
[
1
]
*
llOlOllOOOO
,
llOllllOll\
ll\

[
lOOOlO\
Ol\
OlO\

+
2
]
+=
lOOlllOO\
Ol\

->
llOl\
OllOl\
OOl
[
2
]
*
llOl\
Ol\
lO\
OOO\

,
ll\
Oll\
llO\
l\
lll
[
lO\
OO\
lOOl\
OlO
+
3
]
+=
lO\
OlllOOOl\

->
ll\
OlOllOlO\
Ol
[
3
]
*
llO\
l\
OllO\
OO\
O
,
llOl\
ll\
l\
Ollll
[
lO\
O\
OlOO\
lOl\
O
+
4
]
+=
lOOlll\
O\
O\
Ol
->
ll\
OlOllO\
lOOl\

[
4
]
*
ll\
OlOllOOOO
,
llOl\
ll\
l\
Ollll
[
lOOOlOOlOlO
+
5
]
+=
lOOlll\
OO\
Ol\

->
ll\
OlOllOl\
OOl
[
5
]
*
llOl\
OllOOOO
;
}
}
llOllllOlOl\
O
->
llO\
l\
l\
Olll\
lOO\

(
llO\
l\
l\
ll\
O\
llll
,
llOlll\
l\
lOOOO
)
;
for\

(
lOOOl\
lO\
OOl\

=
0
;
lOOOll\
OOOl\

<=
llOllll\
llll\
O
;
lOOOl\
lOOOl
++
)
{
ll\
OlO\
llOlOOO\

::
lO\
OllO\
O\
O\
OO
*
lOOl\
ll\
OOOl
=
llOl\
lllOlOOO
->
ll\
O\
l\
O\
llOl\
l\
O\
O
[
lOOO\
ll\
OOO\
l\

]
;
if
(
lOOlllOOO\
l
->
lO\
O\
OlOOlOO\
l
!=
llOlllll\
lllO
&&
(
llO\
lll\
lO\
OOOl\

[
lO\
Ol\
l\
lOO\
Ol\

->
lOO\
OlOOlO\
Ol
]
&
(
ll\
OOOOOlllOl
|
lllOO\
O\
O\
OlO\
Ol
)
)
)
continue
;
flo\
at
ll\
lOOllOOl
=
0.0f
;
fo\
r
(
;
lO\
OlllO\
OO\
l
;
lOOll\
l\
OOOl\

=
lOOlll\
OOOl\

->
llOl\
OllOlO\
lO
)
{
in\
t
lOOOlO\
OlOlO\

=
lOOlll\
OOOl
->
lO\
OOlOO\
lOlO
*
6
;
lllOOllOOl
+=
lOOl\
l\
lOOOl
->
llOlOl\
lOlOOl
[
0
]
*
llOll\
l\
llO\
OO\
O
[
lO\
OOlO\
OlOlO
]
+
lOOlllOOOl\

->
llOlO\
ll\
O\
lOOl\

[
1
]
*
llOl\
llllO\
OOO\

[
lOOO\
lOO\
lOlO
+
1
]
;
lll\
O\
Oll\
O\
Ol
+=
lOOll\
lOOOl
->
llO\
lOllOl\
OO\
l
[
2
]
*
ll\
Ol\
l\
l\
llOOOO\

[
lOOOlOOlO\
lO\

+
2
]
+
lO\
Oll\
lOOOl
->
ll\
OlOllOlOOl
[
3
]
*
llOlllllOOOO\

[
lOO\
OlOOl\
O\
l\
O
+
3
]
;
ll\
lO\
Ol\
l\
OOl
+=
lOOl\
llOOOl
->
llOlO\
l\
l\
Ol\
OOl\

[
4
]
*
llO\
lll\
l\
lOOOO
[
lOOOlOOl\
O\
lO
+
4
]
+
lOOlllOOOl
->
llO\
lO\
l\
lOlOOl
[
5
]
*
ll\
Oll\
lllO\
O\
O\
O
[
lOO\
OlOOl\
O\
lO
+
5
]
;
}
llOll\
l\
Oll\
lll
[
lOOO\
l\
lO\
O\
O\
l
]
=
lllOOll\
OO\
l
;
}
}
else\

if\

(
1
)
{
int
lllOO\
O\
OOl\
O\
l\
O
=
0
;
for
(
lOO\
OllO\
OOl
=
0
;
lO\
OOllOOOl
<=
llO\
l\
lll\
llllO
;
lO\
OO\
l\
lOOOl\

++
)
{
if
(
llO\
llll\
OO\
OO\
O
[
lOOOllOOO\
l
]
!=
0.0f
)
llOl\
l\
l\
lOOl\
lO
[
lllOOOOOlOl\
O
++
]
=
lOOOllOOO\
l
;
}
{
float
lllOO\
ll\
O\
Ol
=
0.0f
;
int
lOOlOO\
lO\
lO\

;
for\

(
lOO\
O\
llOOOl
=
0
;
lO\
OO\
ll\
OOO\
l
<=
llOlllll\
lllO
;
lOOO\
ll\
OOOl\

++
)
{
if\

(
lOOOl\
lO\
OOl
!=
ll\
O\
llll\
llllO
&&
(
llOllll\
OOOOl\

[
lOO\
OllOOOl\

]
&
(
llO\
OOO\
O\
lllOl
|
lll\
OOO\
O\
OlO\
O\
l
)
)
)
co\
ntinue
;
lllOO\
llOO\
l
=
0.0
;
for\

(
int\

lOOOlO\
O\
l\
ll
=
0
;
lO\
OOlO\
O\
lll\

<
lllOOOOOl\
OlO
;
lO\
OOlOO\
l\
l\
l\

++
)
{
lO\
OlOOlOlO
=
llOlll\
l\
OO\
llO
[
lOOOlOOlll
]
;
ll\
lOOllOO\
l
+=
llO\
ll\
l\
lO\
OOll
[
lO\
OO\
l\
lOOOl
*
lOlOOO\
l\
OOl\

+
lOO\
lOOlOlO
]
*
ll\
Ol\
l\
llOO\
OOO
[
lO\
Ol\
O\
O\
lOl\
O
]
;
}
llO\
lllOll\
lll
[
lOO\
OllOOOl\

]
=
lllO\
Ol\
l\
OO\
l
;
}
}
}
lOO\
l\
O\
l\
llO\
ll\

(
llOlOOl\
llllO
)
;
float
lOOOOllOOOl
;
int\

llOllOllOOll
;
lllOOOOOlO\
l\
l
(
llO\
lllllll\
lO
,
lOOOOl\
lO\
OOl
,
llOllOllOOll\

)
;
if
(
ll\
OllOl\
lOOll
==
-
1
)
{
TA\
_\
ASSERT
(
llOll\
l\
lOllOl\

<
llOllll\
ll\
l\
lO
+
1
)
;
llOllllOlllO
[
llOl\
lllO\
llOl
++
]
=
llOl\
l\
ll\
llllO\

;
return
true
;
}
for\

(
lOOO\
llOO\
O\
l
=
0
;
lOOOllO\
O\
O\
l\

<=
llOll\
l\
llll\
lO\

;
lOOOl\
lOOOl
++
)
{
lO\
OOOOOl\
lO
(
FloatI\
sOK\

(
llOllOlOOlll
[
lOOO\
l\
lOO\
Ol
]
)
,
ll\
OlOO\
llO\
lOl
)
;
lOOO\
OO\
OllO
(
FloatIs\
OK
(
ll\
Ol\
llO\
ll\
llO
[
lOO\
O\
ll\
OOOl
]
)
,
ll\
OlOOllOl\
Ol
)
;
ll\
Ol\
lOl\
O\
Oll\
l
[
lOO\
Ol\
l\
OOOl
]
+=
lOOOOll\
OOOl\

*
llO\
llllOOOOO
[
lOOOl\
lOO\
Ol\

]
;
llO\
l\
l\
lO\
ll\
ll\
O
[
lOOO\
llO\
OOl
]
+=
lOOOO\
l\
l\
O\
OOl
*
llO\
lllO\
lll\
ll
[
lOOOllOOOl
]
;
TA_\
ASS\
ERT
(
lOOOllO\
O\
O\
l
<=
llOll\
ll\
ll\
l\
lO
||
ll\
O\
l\
lOl\
OOl\
l\
l
[
lOOOllOOOl\

]
==
0
)
;
lO\
OOOOOllO
(
Fl\
oatIs\
OK
(
llOl\
lO\
lOO\
lll\

[
lO\
OOllO\
OOl
]
)
,
ll\
OlO\
OllOl\
Ol\

)
;
lOOOO\
OO\
l\
l\
O
(
Flo\
a\
tI\
sOK\

(
ll\
Ol\
llOll\
l\
lO
[
lOOOllOOO\
l\

]
)
,
llOlO\
OllO\
lOl
)
;
}
lOOlO\
lll\
OOl
(
llOl\
OOlllOlO
)
;
for\

(
lO\
OOllOOOl
=
0
;
lO\
OOllOOOl
<
llOllllOl\
Ol\
l
;
lOOOllOOOl\

++
)
{
if
(
ll\
Ol\
lllOllOO
[
lOOOl\
lOO\
Ol
]
==
llO\
llOl\
lOOll
)
br\
ea\
k
;
}
if\

(
lOOOllOOO\
l\

!=
llOl\
lllOlO\
ll
)
{
TA_\
AS\
SERT
(
llOll\
llOl\
Oll
>
0
)
;
lllOOOOOll\
OO
(
llO\
lll\
lOlOl\
l
,
lO\
lOOOlOOl
,
llOllllO\
OlOO
,
lOOOl\
lO\
OO\
l
)
;
llOllll\
OlOll
--
;
for\

(
;
lOOOl\
lOOO\
l
<
llOllllOlO\
ll
;
lO\
O\
OllOO\
Ol\

++
)
llOl\
lllOllOO\

[
lO\
O\
OllOOO\
l
]
=
llO\
llll\
OllO\
O
[
lOOOllOOOl
+
1
]
;
TA_\
A\
SSERT
(
ll\
OllllOllOl
<
llOllllll\
llO\

+
1
)
;
ll\
Ol\
lllOlllO
[
llOllllOll\
O\
l\

++
]
=
llO\
l\
l\
OllOO\
l\
l\

;
#ifdef _DEBUG
for
(
lOOOl\
lOO\
Ol
=
0
;
lOOOll\
OOOl
<
llO\
l\
lllOlOll\

;
lOO\
Ol\
lO\
O\
Ol
++
)
TA_A\
S\
SERT
(
llOl\
l\
l\
lOl\
l\
OO
[
lOOOl\
lO\
OO\
l
]
==
ll\
O\
llllOOlO\
l
[
lO\
O\
Oll\
O\
OOl
]
)
;
#endif //
}
els\
e
{
fo\
r
(
lOOO\
ll\
OO\
O\
l
=
0
;
lO\
O\
OllOO\
Ol
<
llO\
llllOllO\
l
;
lOOO\
llO\
OOl
++
)
{
if\

(
llOllllOl\
llO\

[
lO\
OOll\
OOOl
]
==
llOll\
Ol\
lO\
O\
ll
)
break
;
}
if
(
lO\
O\
OllOO\
Ol
!=
llOllllOl\
lOl\

)
{
TA_\
ASSERT\

(
llOlll\
lOllOl
>
0
)
;
if
(
lllOOOO\
Oll\
O\
l
(
llO\
ll\
llOl\
Oll
,
lO\
lO\
OOlOOl\

,
llO\
lll\
l\
OOlO\
O
,
llOllll\
O\
OO\
ll
,
llO\
llO\
l\
lOOll
)
)
{
ll\
O\
llll\
O\
ll\
O\
l
--
;
for
(
;
lOOO\
llO\
OO\
l\

<
llOllllO\
llO\
l
;
lOOO\
llOOOl
++
)
ll\
O\
llllOlllO\

[
lOOOl\
lO\
OOl
]
=
llOll\
llOll\
lO
[
lO\
OOl\
lO\
OOl
+
1
]
;
TA\
_\
A\
SSERT
(
llOl\
ll\
lOl\
Oll
<
llOllllllllO\

+
1
)
;
llOl\
ll\
lOllOO
[
llOllllOlOl\
l\

++
]
=
llO\
ll\
Ol\
l\
OO\
l\
l
;
}
else
{
llOllllO\
OOOl
[
llOll\
O\
l\
lOOl\
l\

]
|=
ll\
lOOOOOlO\
Ol
;
}
#ifdef _DEBUG
for\

(
lOO\
OllOOO\
l
=
0
;
lOOOllOOO\
l
<
llOllllOlOl\
l
;
lOOOllOO\
Ol
++
)
TA\
_AS\
SE\
R\
T\

(
llOllllOll\
OO
[
lOOO\
llOOOl\

]
==
ll\
Oll\
llOOlOl\

[
lOOOll\
OO\
Ol
]
)
;
#endif //
}
el\
se\

{
if
(
lllOO\
OOOllO\
l
(
llOll\
llOl\
Oll\

,
lOlOOO\
lOOl\

,
llOllllO\
OlO\
O
,
ll\
Oll\
llOO\
Oll
,
llOllO\
ll\
OOll
)
)
{
TA_AS\
SERT\

(
llOlll\
lOlO\
ll\

<
llOlll\
lll\
llO
+
1
)
;
ll\
OllllO\
llOO\

[
ll\
O\
ll\
llO\
l\
O\
ll
++
]
=
llOllOllOO\
l\
l
;
}
else
{
TA_A\
SSERT\

(
llOl\
ll\
lOllOl
<
ll\
Ol\
lllll\
llO
+
1
)
;
llOllllOlll\
O\

[
llOllllOllOl\

++
]
=
llO\
l\
l\
OllOOl\
l
;
llOllllOOOOl
[
llO\
l\
lOllOOll\

]
|=
ll\
l\
O\
OO\
OO\
l\
OOl
;
}
#ifdef _DEBUG
fo\
r\

(
lOOOllOOO\
l\

=
0
;
lOOOl\
lO\
OOl
<
llOl\
ll\
lO\
lOll
;
lOO\
OllOOOl
++
)
TA_\
A\
S\
S\
ERT
(
llOllll\
Oll\
OO
[
lOO\
O\
ll\
OO\
Ol
]
==
ll\
Ollll\
OOl\
O\
l
[
lOOOllOOOl
]
)
;
#endif //
lOOlOl\
l\
lOll
(
ll\
O\
lOOl\
llOlO
)
;
return\

tr\
ue
;
}
}
lOO\
l\
Olll\
Oll
(
llO\
lOOlllOlO
)
;
}
return
true\

;
}
void\

lO\
llOlOlOOll
::
lllOOO\
OOlOOO\

(
int
llOll\
llll\
llO
)
{
lO\
Ol\
Oll\
llOl
(
llO\
lO\
OllllO\
l
)
;
int
lOO\
Oll\
OO\
Ol\

;
in\
t
lllOOOOOll\
lO\

=
lO\
lOOO\
l\
OO\
l
;
for
(
lOOOllO\
OOl
=
0
;
lOOOll\
OOOl\

<
llOllll\
OlOll
;
lO\
OOl\
lOO\
O\
l
++
)
llO\
ll\
llOl\
l\
ll
[
lOOOl\
lOO\
Ol
]
=
-
lllO\
OOOOllll\

(
ll\
OllllOl\
lOO
[
lOOOllOO\
Ol
]
,
llOllllllllO
)
;
lll\
OOOOOO\
O\
OO
(
llO\
llllOlOl\
l
,
lllO\
OOOOll\
lO
,
llOl\
lll\
OO\
lOO
,
llOllllO\
llll\

,
llO\
ll\
lll\
OOOO\

)
;
for
(
lO\
OO\
llOOOl
=
0
;
lOOOl\
lOO\
O\
l
<
lOl\
OOOlOO\
l\

;
lOOOll\
OOOl\

++
)
ll\
O\
llllOOO\
OO\

[
lOOOl\
lO\
OO\
l
]
=
0.0f
;
llOll\
llOO\
OOO
[
llOll\
l\
llll\
lO
]
=
1.0f
;
fo\
r
(
lO\
OO\
llO\
OO\
l\

=
0
;
lOOOll\
O\
OOl
<
llOl\
ll\
lOlOll
;
lO\
OOllO\
OOl\

++
)
{
lO\
OOOOOll\
O
(
Fl\
o\
a\
tI\
sOK
(
llOl\
llllOOOO
[
lO\
OOllOO\
Ol
]
)
,
ll\
OlO\
OllOlOl
)
;
ll\
Oll\
l\
l\
OO\
OOO
[
ll\
OllllO\
OlOl\

[
lOOOl\
lOO\
Ol
]
]
=
ll\
Ollll\
lOOOO
[
lO\
OO\
llO\
OOl
]
;
}
}
void
lO\
ll\
OlO\
lOOl\
l\

::
lllO\
OOOl\
OOOO\

(
int
lllOO\
OOlOO\
Ol
,
in\
t
lllOO\
OOlO\
OlO
,
con\
s\
t\

fl\
oat
*
lOOOll\
llOOl
,
co\
ns\
t
float
*
ll\
OlOll\
lOlOl
,
float\

*
lllOO\
O\
O\
lOOll
)
{
lOOl\
Ol\
lllO\
l\

(
llO\
lOOl\
llllO
)
;
for\

(
in\
t
lOOOll\
O\
OOl\

=
0
;
lOOOl\
lOO\
O\
l
<
lll\
OO\
O\
OlO\
OOl
;
lOOOllOOOl
++
)
{
flo\
at\

lllOOllO\
O\
l\

=
0.0f
;
fo\
r\

(
int
lOOlOO\
l\
OlO
=
0
;
lOO\
lOO\
lOlO
<
ll\
lOOOOlOOOl
;
lOOl\
OO\
lOlO\

++
)
lll\
OO\
ll\
OOl\

+=
lO\
OO\
ll\
l\
lOOl\

[
lOO\
Ol\
lO\
OOl
*
lllOO\
OO\
lOOlO
+
lOOlO\
OlOlO\

]
*
ll\
O\
lOl\
llO\
lO\
l
[
lO\
Ol\
OO\
lOl\
O
]
;
lll\
OOO\
O\
lOOl\
l\

[
lOOOl\
lOO\
Ol
]
=
ll\
lOOllOO\
l\

;
}
}
void\

lOllOlOlOOl\
l
::
ll\
lO\
OOOOlOll
(
in\
t
ll\
Olllll\
l\
ll\
O\

,
float
&
lOO\
OOl\
lOOOl
,
int
&
llO\
ll\
Oll\
O\
Oll
)
{
lO\
O\
lOll\
l\
lOl\

(
ll\
OlOOllllO\
O
)
;
const
flo\
at
lllOO\
O\
OlO\
lOO\

=
0.1f
;
lOOOO\
llOO\
Ol
=
k_fMax\
F\
lo\
a\
t
;
llOllOl\
lO\
O\
ll
=
-
1
;
if
(
llO\
lllOlll\
ll
[
llOllll\
ll\
llO
]
<
lll\
O\
OOOl\
OlOO
*
0.05f
)
{
llOl\
lll\
O\
OOO\
l\

[
llOllllll\
llO
]
|=
lllOOOOO\
lOOl
;
llOll\
OllOO\
ll
=
-
1
;
lOO\
OOllO\
O\
O\
l
=
0.0f
;
ret\
urn
;
}
if\

(
llO\
ll\
ll\
O\
OOOl
[
ll\
Olll\
l\
l\
lllO\

]
&
ll\
OOO\
OOl\
ll\
Ol
)
{
if
(
Fab\
s
(
llOlllOll\
llO
[
llOlll\
llll\
lO
]
)
>
lllOOO\
OlO\
lOO\

*
5.0f
&&
ll\
Ol\
llOl\
ll\
ll
[
llOll\
ll\
llllO\

]
>
lllOO\
OOlOl\
OO
*
0.5f
)
{
llOllO\
ll\
OO\
ll
=
llOl\
lllll\
llO
;
lOOOOllOOOl\

=
-
llOlllOlll\
lO
[
llOllll\
l\
lllO
]
/
ll\
Ol\
ll\
Olll\
ll
[
llOl\
l\
ll\
l\
ll\
lO
]
;
}
else
{
ll\
O\
ll\
ll\
OOOOl
[
llOllll\
ll\
llO
]
|=
lllOOO\
O\
O\
lOOl\

;
llOl\
l\
O\
llOOl\
l\

=
-
1
;
lOOOOll\
OOOl
=
0.0f
;
retur\
n
;
}
}
else
{
if\

(
llO\
lll\
Oll\
llO\

[
llO\
ll\
llll\
ll\
O\

]
<
-
lllO\
O\
O\
OlOlOO\

*
0.1f
&&
llOlllOll\
l\
l\
l
[
llOl\
lll\
llllO\

]
>
lll\
OOO\
OlOlOO
*
0.01f
)
{
llOll\
O\
llO\
O\
ll
=
llOll\
llllllO
;
lO\
OOOll\
OOOl
=
-
llOlll\
O\
llllO
[
llOllll\
l\
ll\
lO\

]
/
llOl\
llOl\
l\
lll
[
ll\
Ollll\
lll\
lO
]
;
}
else
{
llOllOl\
lOOl\
l
=
-
1
;
lOOOOl\
lOOOl
=
0.0f
;
retur\
n
;
}
}
fl\
oat
lO\
O\
OOOllll
=
Sign\

(
lOOOOl\
lOOOl\

)
;
if
(
lOO\
OOOl\
lll
==
0.0f
)
lOOO\
OOllll\

=
1.0f
;
int
lOOOllO\
OOl
;
bool
lllOOOO\
lOlO\
l
=
false
;
for
(
lOOOllOOO\
l
=
0
;
lO\
O\
OllOOOl\

<
llOll\
l\
l\
OlOll
;
lOOOllOOOl
++
)
{
int\

lO\
OlO\
O\
lO\
lO
=
llOllll\
O\
l\
lOO
[
lOOOllOOOl
]
;
if\

(
llOllllO\
O\
OOl
[
lO\
OlOOlO\
lO
]
&
lll\
OOO\
OOlOO\
l
)
co\
nt\
in\
ue
;
if
(
llOl\
l\
llOO\
OOl\

[
lOO\
lOOlOlO
]
&
llOO\
O\
OOll\
lOl\

)
{
if\

(
Fabs\

(
llO\
llOl\
O\
Olll
[
lO\
OlOOlOlO
]
+
lOOOO\
l\
l\
OOOl\

*
llOl\
l\
l\
l\
OOOO\
O
[
lOOl\
OOlOlO\

]
)
<
Fa\
bs
(
llO\
llOl\
OOlll
[
lOOl\
OOl\
Ol\
O\

]
)
*
0.001f
)
{
lllOOOOlO\
lOl
=
true
;
lOO\
OOllOO\
Ol\

=
0.0f
;
llOllO\
llOOll
=
lO\
OlOOl\
OlO\

;
llO\
ll\
llOO\
OOl\

[
lOOl\
OO\
lOlO\

]
|=
ll\
lOOOOO\
lOOl\

;
}
}
el\
se\

if
(
llOllll\
OO\
OOO
[
lO\
OlOO\
lOl\
O\

]
*
lOOOOO\
l\
l\
ll\

<
0.0f
&&
Fab\
s
(
llOll\
l\
lOO\
O\
O\
O
[
lO\
OlOO\
lOlO
]
)
>
Fa\
bs\

(
ll\
Oll\
O\
lO\
Ol\
ll\

[
lOO\
lOOlO\
l\
O\

]
*
0.001f
)
)
{
fl\
o\
at
lllOO\
OOlOllO\

=
-
llOllOl\
OOlll
[
lO\
OlOOl\
O\
lO
]
/
llOl\
lllOOO\
OO\

[
lOO\
lOOlO\
lO
]
;
if
(
ll\
lOOOOl\
O\
llO
<
lOO\
OOllOO\
Ol
*
lO\
OO\
OOllll\

)
{
lllOOO\
OlOl\
Ol
=
true
;
lOOO\
Ol\
l\
OOOl
=
lllOOOO\
l\
OllO\

;
ll\
OllOll\
OOll
=
lOOlOOlOl\
O
;
}
}
}
for
(
lOOO\
llO\
OOl\

=
0
;
lOOO\
llOOOl
<
llO\
ll\
l\
lOll\
Ol
;
lOOOllO\
O\
Ol
++
)
{
int
lOO\
lOO\
lOlO
=
ll\
OllllO\
ll\
lO
[
lOOOl\
l\
O\
O\
Ol\

]
;
if
(
llOl\
l\
ll\
O\
O\
O\
Ol
[
lO\
O\
lO\
OlOlO\

]
&
lllOO\
OO\
OlO\
Ol
)
co\
ntinue
;
if
(
llOl\
l\
ll\
OO\
O\
Ol\

[
lOOl\
O\
OlOl\
O\

]
&
llOOOOOlllOl
)
{
}
el\
se
if\

(
llO\
lllO\
llll\
l\

[
lO\
O\
l\
OO\
lOl\
O
]
*
lOOOOOllll
<
-
lllOOOOlOlOO
)
{
fl\
o\
at
lllOOOO\
lOllO
=
-
llOl\
llOllll\
O\

[
lOO\
l\
OOlOlO
]
/
llOll\
lOll\
lll
[
lOOl\
OO\
lOl\
O
]
;
if
(
llOllOl\
lOOll
==
ll\
Ol\
lllllllO
)
{
if
(
lllO\
O\
O\
O\
l\
OllO
<
lOO\
OOllOOOl
*
lOO\
OOOll\
ll\

-
lllOOOO\
lOlOO
)
{
ll\
lO\
O\
OOlOl\
Ol\

=
false\

;
lOOOO\
l\
l\
O\
O\
Ol
=
lllOOOOlOllO\

;
llO\
l\
lOll\
OOll
=
lOOlOOlO\
lO
;
}
}
els\
e
{
if
(
lllOO\
OOlOl\
lO\

<
lO\
OOOl\
l\
OO\
O\
l
*
lOOOOOllll
)
{
ll\
l\
OOO\
OlOlOl
=
false
;
lOOOO\
l\
lO\
O\
Ol
=
lllO\
O\
OOlOllO
;
llO\
llOl\
l\
O\
Ol\
l\

=
lOOlOO\
lOlO
;
}
}
}
}
TA_A\
S\
SER\
T
(
ll\
O\
llOll\
OOll
!=
-
1
)
;
if
(
ll\
lOOOO\
lOlO\
l
&&
Fab\
s
(
ll\
OllOlOO\
lll
[
ll\
OllOllO\
Oll
]
<
0.0f
)
)
{
TA_ASSE\
RT
(
llOllO\
l\
l\
OO\
ll
!=
-
1
)
;
if
(
!
(
llOll\
llOOOOl
[
llO\
llOll\
OOll\

]
&
llOO\
O\
O\
Ol\
llOl
)
)
ll\
Olll\
lOOO\
Ol
[
llO\
ll\
OllOOll
]
|=
lll\
OO\
OOOl\
OOl
;
}
}
void
lOllOlOl\
OOll
::
ll\
lOOOO\
lOlll\

(
int\

lOOlllOl\
lO\

,
float
*
lOOOllllO\
Ol
,
float
*
llOll\
l\
O\
l\
OO\
lO\

,
fl\
oat
*
llOlllOlOOll
)
{
int\

lOOOllOO\
Ol\

,
lO\
OlOOlOlO
,
lO\
OlOlOOOl
,
llOl\
OOlllO
;
fl\
oat
ll\
lOOllOOl
;
for
(
lOO\
OllO\
OOl
=
0
;
lOOOllOOOl
<
lOO\
l\
llOll\
O
-
1
;
lOOO\
llOO\
O\
l\

++
)
{
ll\
OlOOlllO\

=
lO\
OO\
ll\
OOO\
l\

;
for
(
lOOlO\
OlOl\
O
=
lO\
OOll\
O\
O\
Ol
;
lO\
OlO\
OlO\
lO
<
lOOll\
lO\
llO
;
lO\
Ol\
OOl\
Ol\
O
++
)
{
if\

(
Fa\
bs
(
lOOOl\
l\
llOO\
l
[
lOOlOO\
lO\
l\
O
*
lO\
OlllOllO\

+
lOOO\
ll\
OOOl\

]
)
>
Fabs
(
lOOO\
lll\
l\
OOl
[
llOlOOlllO
*
lO\
Olll\
Ol\
lO
+
lOO\
OllO\
O\
Ol
]
)
)
ll\
OlO\
O\
l\
ll\
O
=
lO\
OlOOlOlO\

;
}
for
(
lO\
Ol\
OlO\
OOl
=
lOOOllOOOl
;
lOOlOlOOOl
<
lOOll\
lOll\
O
;
lOOlOlO\
OOl
++
)
{
lllOO\
l\
l\
OOl\

=
lOOOllllO\
O\
l\

[
lOO\
Ol\
l\
O\
OOl
*
lO\
O\
l\
llO\
llO
+
lOO\
l\
OlOOOl\

]
;
lOO\
O\
llll\
OOl
[
lOOOll\
O\
O\
Ol
*
lOOlllO\
llO
+
lO\
OlOlOOOl
]
=
lO\
O\
OllllOO\
l
[
ll\
O\
lO\
OlllO\

*
lOOlllOllO
+
lOOlOlOOOl
]
;
lOOO\
llllOOl
[
ll\
Ol\
O\
O\
lllO\

*
lOO\
lllOllO
+
lO\
OlOlOO\
Ol
]
=
ll\
lOOllO\
Ol
;
}
lllO\
OllOOl
=
llOlll\
O\
lOOlO
[
lOOO\
l\
lOO\
Ol\

]
;
llO\
lllOlO\
Ol\
O
[
lO\
OOllOO\
Ol
]
=
llOll\
lO\
lOOlO\

[
llOlOO\
ll\
lO
]
;
llOlllOlOO\
lO
[
llOlOOlll\
O
]
=
lllOO\
l\
lOOl
;
for
(
lOOlOO\
lOlO
=
lOO\
O\
l\
lOOOl
+
1
;
lO\
O\
lOOlOl\
O
<
lOOlllOl\
lO\

;
lOO\
lOOlOlO\

++
)
{
floa\
t\

ll\
Ol\
ll\
Ol\
l\
lO\
O\

=
lOOO\
llllOO\
l
[
lOOlOOlOlO
*
lOOll\
lO\
l\
lO
+
lO\
OOl\
l\
OO\
Ol\

]
/
lO\
OO\
llll\
O\
Ol
[
lOOOl\
lOOOl\

*
lO\
Olll\
Ol\
l\
O
+
lOOOllOOO\
l\

]
;
lOOO\
O\
OO\
llO
(
Fab\
s
(
lOOOll\
llOO\
l
[
lOO\
OllOOOl
*
lO\
Ol\
llOllO
+
lO\
O\
OllOO\
O\
l\

]
)
>
0.0001f
,
llO\
lOO\
llOl\
Ol\

)
;
lO\
OOOOOllO\

(
Floa\
t\
IsOK
(
ll\
Oll\
lO\
lllOO
)
,
llOlOOl\
lO\
lO\
l\

)
;
llO\
lll\
O\
lO\
OlO
[
lOOlOOlOlO\

]
-=
llO\
l\
ll\
OlO\
Ol\
O
[
lOO\
OllO\
OOl
]
*
llO\
lllO\
ll\
l\
O\
O\

;
for
(
lO\
OlOlOOOl
=
lOOlll\
O\
llO
-
1
;
lOOl\
Ol\
OO\
Ol
>=
lOOO\
ll\
OOOl\

;
lOO\
lOlO\
OOl
--
)
lOOO\
ll\
l\
lOO\
l
[
lOOlO\
O\
l\
Ol\
O
*
lOOll\
lOll\
O\

+
lO\
OlOlOOO\
l
]
-=
lOOOll\
llOOl\

[
lO\
OO\
llOOO\
l
*
lO\
OlllOl\
l\
O
+
lOO\
lO\
l\
OOO\
l
]
*
llOll\
lOlllOO
;
}
}
fo\
r
(
lO\
OlOOlOlO
=
lO\
Olll\
Oll\
O\

-
1
;
lOO\
l\
OOlO\
lO
>=
0
;
lO\
OlOOlOlO
--
)
{
flo\
at
llOl\
llO\
ll\
lOO
=
lO\
OOlll\
lOO\
l
[
lO\
Ol\
OO\
lOlO
*
lOOll\
l\
Oll\
O
+
lOOlOOlOl\
O\

]
;
llOl\
llOlllOO
=
1.0f
/
llOlll\
Oll\
l\
OO
;
lllO\
Ol\
l\
OO\
l
=
0.0f
;
for
(
lOOl\
OlO\
OOl
=
lOOlOOlOlO
+
1
;
lOO\
l\
OlOOOl\

<
lOOl\
llO\
l\
lO
;
lOOl\
O\
l\
OOOl
++
)
lllOOllOOl
+=
lO\
OOllllOO\
l\

[
lOOlOOlOlO
*
lOO\
l\
l\
lOllO
+
lO\
O\
lO\
lOOOl
]
*
ll\
OlllOl\
O\
Oll\

[
lOOlOlOOOl
]
;
ll\
Oll\
l\
OlO\
O\
ll\

[
lO\
OlO\
OlOlO
]
=
(
llOlll\
O\
lOOlO\

[
lOOlOOl\
O\
lO
]
-
lllOOllOOl
)
*
llOlllOlllOO
;
lO\
O\
OO\
O\
OllO
(
Flo\
atI\
sOK\

(
llOl\
ll\
OlOOll
[
lOOlOO\
l\
OlO
]
)
,
llOl\
OOllO\
lOl\

)
;
}
}
void\

lOllOlOlOOll\

::
lllO\
OOOl\
lOOO
(
in\
t
lOOl\
llOllO
,
float
*
lOOOllllOOl
,
floa\
t
*
llOlllO\
lOOlO
,
fl\
o\
at
*
llOlll\
OlOOll
)
{
int\

lOOOllO\
O\
Ol
;
int
lOOlOO\
lO\
lO
;
in\
t
lOO\
lOlOOOl
;
float
ll\
O\
l\
OllOOO\
O\
O
;
for
(
lOO\
lOOlOl\
O
=
0
;
lOOl\
OOl\
Ol\
O
<
lOO\
lllOllO
;
lOO\
l\
OOlO\
lO
++
)
{
fo\
r\

(
lOOOl\
l\
OOO\
l
=
lOOl\
OO\
lOlO
;
lO\
OO\
l\
l\
OOOl
<
lO\
O\
lllOllO
;
lOOOllOOOl
++
)
{
ll\
OlOllO\
OOOO
=
lO\
OOl\
lllO\
Ol
[
lOOO\
llOOOl\

*
lO\
O\
lllOllO\

+
lOO\
lOOlOlO
]
;
for
(
lO\
OlOlOOOl
=
0
;
lOOl\
OlOOOl
<
lOOlOOlOlO
;
lOOlOlOOOl
++
)
llOlOll\
OOOOO
-=
lO\
OO\
lll\
lOOl
[
lOO\
O\
ll\
OOOl
*
lO\
OlllOll\
O
+
lOO\
l\
O\
l\
OO\
Ol
]
*
lOOOllll\
OO\
l
[
lO\
O\
lO\
O\
lOlO
*
lOOl\
llOl\
lO
+
lOOlO\
lOOOl
]
;
if
(
lOOOl\
lO\
OOl\

==
lOO\
lOO\
lOl\
O
)
{
if
(
ll\
OlOllOOOOO
<
0.0f
)
{
TA_A\
S\
SERT
(
0
)
;
llOlOllOOOO\
O\

=
0.0f
;
}
lOOOlll\
l\
OO\
l\

[
lO\
OO\
llO\
OOl
*
lOOll\
lOllO
+
lOOlOOl\
O\
lO
]
=
Sqr\
t
(
llOlOllO\
OOOO
)
;
}
else
{
TA_\
ASS\
ERT
(
Fabs
(
lOOOllllOOl\

[
lOOlOO\
lOl\
O
*
lOOl\
llOll\
O\

+
lOOlOOlOlO
]
)
>
0.0f
)
;
lOOOl\
lll\
OOl
[
lO\
OO\
llOOOl
*
lOOlllO\
ll\
O
+
lOO\
lO\
OlOlO
]
=
llOlOll\
O\
OOOO
/
lOOOll\
l\
lOOl
[
lO\
Ol\
OOlOl\
O
*
lOOl\
l\
lOllO\

+
lOOlO\
Ol\
Ol\
O
]
;
}
}
}
for
(
lOO\
OllO\
OO\
l
=
0
;
lOOO\
llOOOl
<
lOOlllO\
ll\
O
;
lOOOl\
lOOOl
++
)
llOlll\
OlOOll
[
lOOOl\
l\
OOOl
]
=
ll\
O\
l\
llOlOO\
lO
[
lOOO\
ll\
OOOl
]
;
for
(
lOOO\
llOOOl
=
0
;
lOO\
OllOOO\
l
<
lOOlllOl\
lO\

;
lOOOll\
OOOl
++
)
{
llOlOllO\
O\
O\
OO
=
llOlll\
OlO\
O\
ll
[
lOOOllOOO\
l
]
;
fo\
r
(
lOO\
lOlOOOl
=
lOOOllOO\
O\
l\

-
1
;
lOO\
l\
OlOOO\
l
>=
0
;
lOO\
lOlOOOl
--
)
ll\
O\
l\
OllOOOO\
O\

-=
lOOOlll\
lO\
O\
l
[
lO\
O\
OllOOOl
*
lOOlllOllO\

+
lOOlOlOOOl\

]
*
llOlllOlOOll
[
lOOlOl\
OOOl
]
;
llOl\
llO\
lO\
Oll
[
lOOOllOOOl\

]
=
ll\
OlOl\
l\
OOOOO
/
lO\
O\
OllllOOl
[
lOOOl\
l\
OOOl
*
lOO\
lllOllO\

+
lOO\
OllOO\
O\
l
]
;
}
fo\
r\

(
lO\
OOllOOO\
l\

=
lOOlllO\
llO\

;
--
lOOOll\
OOO\
l
>=
0
;
)
{
ll\
OlOll\
O\
O\
O\
OO
=
llOl\
llOlOO\
ll\

[
lOOO\
ll\
O\
OOl\

]
;
for
(
lOO\
lOl\
OOO\
l
=
lOOOllOOOl
+
1
;
lO\
O\
lO\
lOOOl
<
lOOll\
l\
OllO
;
lOO\
lOlOOOl
++
)
llOl\
Ol\
lOO\
O\
OO
-=
lOOOll\
llOOl
[
lOO\
lOlOOOl
*
lOOl\
l\
lOllO\

+
lOOOl\
lOOOl
]
*
llOlllOlOOll
[
lOOlOlOO\
Ol
]
;
ll\
OlllOlOOll\

[
lOOOll\
O\
OOl
]
=
llOlOllOO\
OOO
/
lOOO\
llllO\
Ol
[
lOOO\
llOO\
Ol
*
lOOlll\
OllO
+
lOOOllOOOl
]
;
}
}
void
lOll\
OlOlO\
Oll
::
llOlO\
lO\
llll\
l
(
in\
t
lOO\
l\
llOllO
,
int
llOOO\
llOO\
OOl
,
float\

*
lOO\
Oll\
ll\
OOl\

,
flo\
at
*
llOl\
ll\
OlOO\
l\
O\

,
flo\
at
*
llOlll\
O\
lOOll
)
{
llOlOlO\
lllll
(
lOOlllOll\
O
,
llOOOllOOOOl
,
lOO\
O\
llllOOl
)
;
lllOOOOOOOOO
(
lOO\
l\
llOllO
,
llOO\
OllOOOO\
l
,
lOO\
O\
llllOO\
l\

,
llOlllO\
lOO\
lO
,
llOll\
lO\
l\
OOll
)
;
}
vo\
id\

lO\
llOlO\
lOOll
::
llOlOlOl\
llll
(
in\
t
lOO\
lllOllO
,
int
ll\
OOOllOO\
OOl
,
float\

*
lOOOllllO\
O\
l
)
{
lOOlOl\
lllO\
l
(
llO\
l\
OOlllOOO\

)
;
int
lOOOllO\
OO\
l
;
int
lOOlO\
O\
lOlO
;
int
lOOlOlOOOl\

;
fl\
o\
at\

llOlOllOOO\
OO
;
fo\
r
(
lO\
OlOOlO\
lO\

=
0
;
lO\
O\
l\
OO\
lO\
l\
O
<
lO\
OlllOll\
O
;
lOO\
l\
O\
OlOl\
O
++
)
{
fo\
r\

(
lO\
OOll\
OOOl
=
lO\
OlOO\
lOlO
;
lOOOll\
OOO\
l
<
lOOl\
llOllO
;
lOOOllO\
OOl
++
)
{
ll\
OlOllOO\
OO\
O\

=
lOO\
Ollll\
O\
O\
l\

[
lOOOllOOO\
l\

*
llO\
O\
Oll\
OO\
O\
Ol
+
lOOlOOlOlO
]
;
for
(
lO\
OlOlOOOl\

=
0
;
lOO\
lO\
lOOO\
l\

<
lOOlOO\
l\
Ol\
O\

;
lOOlOlO\
OOl
++
)
{
llO\
lO\
llOO\
OOO
-=
lOOOllllOOl
[
lOOOl\
lOOOl\

*
ll\
OO\
O\
llO\
O\
OOl
+
lO\
OlO\
lOOOl\

]
*
lOOOll\
llOOl\

[
lOO\
lO\
O\
lO\
lO
*
llOOOllOO\
O\
O\
l
+
lOOlOl\
OOOl
]
*
lO\
OOl\
l\
l\
l\
O\
Ol
[
lOOlOlOO\
Ol
*
llOOO\
llO\
OOO\
l
+
lOOl\
OlOO\
Ol\

]
;
}
if
(
lO\
O\
O\
llOOOl
==
lO\
OlOO\
lO\
l\
O
)
{
{
}
lO\
O\
O\
llllOOl\

[
lOOOll\
O\
OO\
l
*
llOOOl\
lOOO\
Ol
+
lO\
OlO\
Ol\
OlO
]
=
llOlOllOOOOO
;
}
else\

{
TA\
_ASSE\
R\
T
(
Fab\
s\

(
lOOOllllOO\
l\

[
lO\
Ol\
O\
O\
lO\
lO
*
llOO\
OllOO\
O\
Ol
+
lO\
OlO\
OlOlO
]
)
>
0.0f
)
;
lO\
OO\
llllOOl
[
lOO\
OllOOO\
l\

*
llOO\
Oll\
OOOOl\

+
lO\
OlO\
O\
l\
Ol\
O
]
=
llOlOll\
O\
O\
OOO
/
lOOO\
lll\
lOO\
l
[
lOOl\
OOlOlO\

*
llO\
OOllOOOOl
+
lOOl\
OO\
lOlO
]
;
}
}
}
}
vo\
id
lOll\
Ol\
OlO\
Oll
::
lll\
OO\
OOOOOOO
(
int
lOOlllOllO
,
in\
t\

llO\
O\
Ol\
lO\
OOO\
l
,
floa\
t
*
lOOO\
l\
lllO\
O\
l
,
floa\
t\

*
ll\
O\
lllO\
lOOl\
O
,
float
*
llOl\
l\
lOlOOll
)
{
lOOlOl\
l\
llOl\

(
llOlOOlllO\
OO
)
;
int
lOOOllOO\
Ol
;
int
lO\
OlOlOOOl
;
float
llOlO\
ll\
OOOO\
O
;
for\

(
lOOO\
llOOO\
l\

=
0
;
lOOO\
l\
l\
OOO\
l
<
lOO\
lllOllO
;
lOO\
O\
llOOOl
++
)
llOl\
llOl\
O\
O\
ll\

[
lO\
O\
OllO\
OOl\

]
=
llOlll\
OlOOlO
[
lOOOl\
lOO\
O\
l\

]
;
for
(
lO\
OO\
llOO\
Ol\

=
0
;
lOO\
OllOOOl
<
lOO\
lllO\
llO
;
lO\
O\
O\
ll\
OOO\
l
++
)
{
llO\
lO\
ll\
OOO\
OO\

=
llOl\
ll\
OlO\
Ol\
l
[
lOO\
O\
ll\
OO\
Ol\

]
;
for
(
lOOl\
OlO\
OOl
=
0
;
lO\
OlOl\
OO\
O\
l
<
lOOO\
llO\
OOl
;
lO\
OlO\
lOOO\
l
++
)
llOlO\
ll\
OOO\
OO
-=
lO\
OO\
llllOOl
[
lOO\
Oll\
OOO\
l\

*
ll\
OOOl\
l\
O\
OO\
Ol
+
lOOl\
O\
l\
OOOl
]
*
llOl\
l\
lOlO\
Ol\
l
[
lOOlOlOOO\
l\

]
;
llOlllOlOO\
ll
[
lOOOll\
OOOl\

]
=
llO\
lOl\
lO\
OOOO\

;
}
for
(
lOOOllO\
O\
Ol
=
0
;
lO\
OOl\
lOOOl
<
lOOlll\
OllO
;
lO\
O\
OllO\
OO\
l\

++
)
llOlllO\
l\
OOll
[
lOOO\
llO\
O\
O\
l
]
/=
lO\
OOllllO\
Ol
[
lOOOl\
l\
OOOl
*
llOOOllOOOO\
l
+
lOO\
OllOOOl
]
;
fo\
r
(
lO\
OOllOOO\
l
=
lOOlllOllO\

;
--
lOOOll\
O\
OO\
l
>=
0
;
)
{
llOlOllOOO\
OO
=
llOlll\
Ol\
OOll\

[
lOOOllOOOl
]
;
fo\
r
(
lOOlOlOOOl
=
lOO\
Ol\
l\
O\
OOl
+
1
;
lOOl\
O\
lO\
OOl\

<
lOO\
l\
llOllO
;
lOOlOlOO\
Ol\

++
)
llO\
lOllOOOOO
-=
lOOOl\
lllOOl
[
lO\
OlO\
lOO\
Ol
*
llO\
OO\
llO\
OOO\
l
+
lOO\
OllO\
OOl
]
*
llOlllOlOO\
ll
[
lO\
OlOlOO\
Ol
]
;
llOlllO\
lOO\
ll
[
lOOOll\
OOOl\

]
=
ll\
O\
lOllOOOOO
;
}
}
voi\
d
lO\
ll\
OlOl\
O\
Oll
::
lllOOOOllO\
Ol
(
int
lOO\
lllO\
l\
lO
,
int
llOOOllOOO\
Ol
,
float
*
lllOOO\
Ol\
lO\
lO
,
float\

*
ll\
lOOOOllOll\

)
{
TA_ASSE\
RT
(
0
)
;
}
void
lOllOlOlO\
O\
l\
l
::
lllO\
OOOOllOO
(
int
lOOlllO\
l\
l\
O
,
int
ll\
OOOll\
OOO\
O\
l
,
floa\
t
*
lO\
OO\
ll\
llO\
O\
l
,
int
lll\
OOO\
OlllOO\

)
{
lO\
O\
l\
Oll\
ll\
Ol
(
ll\
Ol\
O\
Oll\
lOOO
)
;
int
lOOOll\
OOOl
;
int
lO\
O\
lOOlOl\
O\

;
#define llOlllOlOOOl(lOOOllOOOl) lOOOllllOOl[(lOOOllOOOl) * llOOOllOOOOl + lllOOOOlllOO]
#define lllOOOOlllOl(lOOOllOOOl, lOOlOOlOlO) lOOOllllOOl[(lOOOllOOOl) * llOOOllOOOOl + (lOOlOOlOlO)]
float
ll\
Oll\
lOOOl
=
Sqrt
(
llOlllOlO\
O\
Ol
(
lllOOOOlllOO
)
)
;
for\

(
lOO\
lOOlOlO\

=
lllOOOOlllO\
O
+
1
;
lO\
O\
lOOlOl\
O
<
lOOlllOl\
lO
;
lO\
OlOOlOlO
++
)
llO\
ll\
lOl\
OOO\
l
(
lOO\
lOO\
lO\
lO
)
*=
llOlllOO\
Ol
;
fl\
o\
at
lllOOOOl\
ll\
lO
=
1.0f
;
for
(
lO\
OlO\
Ol\
OlO
=
ll\
l\
OO\
OOll\
lOO
+
1
;
lOOl\
O\
OlOlO\

<
lO\
Olll\
O\
llO
;
lOOl\
O\
Ol\
OlO
++
)
{
flo\
at
lllO\
OO\
O\
ll\
lll
=
llOlll\
OlOOOl
(
lOOlOOlOl\
O
)
;
floa\
t
lOllllll\
O\
O
=
lll\
OOOOll\
llO
+
ll\
lO\
OO\
Olll\
ll
*
lllO\
O\
O\
Olll\
ll
/
lllOOOO\
lllO\
l
(
lOOlOOlOlO\

,
lOOlOOl\
OlO
)
;
float
lllO\
OO\
lO\
OOOO
=
ll\
lOOOOll\
lll
/
(
lll\
OOOO\
l\
llOl
(
lOOlOOl\
O\
lO
,
lOOl\
OO\
lOlO\

)
*
lOllllllO\
O
)
;
lOO\
O\
OO\
O\
llO\

(
lll\
OOOOl\
ll\
lO\

>
0.0f
,
ll\
O\
lOO\
llOlOl\

)
;
lllOOOO\
ll\
lOl
(
lOOlOOlOlO\

,
lO\
Ol\
OOlOl\
O
)
=
lllOOOOl\
llOl
(
lOOlOOlOlO
,
lOO\
l\
OOlOlO
)
*
lOll\
l\
ll\
lOO\

/
ll\
lO\
O\
OOll\
l\
lO
;
lO\
O\
OOOOllO\

(
ll\
l\
OOO\
OlllOl\

(
lOOlOOlO\
lO
,
lO\
Ol\
OO\
lOl\
O
)
>
0.0f
,
llO\
lOO\
llOlO\
l
)
;
for
(
lOOO\
llOO\
Ol
=
lOOl\
OOlOl\
O
+
1
;
lOOOllOOOl\

<
lOOl\
llOllO\

;
lO\
OOllO\
OOl
++
)
{
llOlllOlOOO\
l
(
lOOOl\
lO\
OOl
)
=
llOlllOlOO\
Ol
(
lOOOll\
O\
OO\
l
)
-
lllOO\
O\
Ol\
llll
*
ll\
lOOOOlllOl
(
lOOO\
llOOO\
l
,
lOOlOOlOl\
O
)
;
lll\
O\
O\
OOlllOl
(
lOO\
O\
l\
lOO\
O\
l
,
lOOlO\
OlOl\
O
)
=
lll\
OOOO\
lllOl
(
lOOOll\
OOOl
,
lOOlOOlOlO\

)
+
lllOOOlOOOOO\

*
llOl\
l\
lOlOOOl\

(
lO\
OOl\
lOOOl\

)
;
}
lll\
OOOO\
llll\
O
=
lOlll\
ll\
lOO
;
}
#undef llOlllOlOOOl
#undef lllOOOOlllOl
for\

(
lO\
OlOOl\
OlO
=
ll\
lOOOOl\
llOO
;
lO\
Ol\
OOl\
O\
lO
<
lO\
Olll\
O\
llO
-
1
;
lOO\
lO\
O\
lOlO
++
)
{
ll\
Ol\
lllOOlOl
[
lOOlOO\
lOlO\

]
=
llO\
lll\
l\
O\
O\
lOl
[
lOOlOOlOl\
O\

+
1
]
;
fo\
r
(
lOOOllO\
O\
O\
l
=
lO\
OlO\
OlOl\
O\

;
lOOOllOOOl
<
lOOlllOll\
O
-
1
;
lOOO\
llOOOl\

++
)
lOOOllllOOl
[
lO\
OOll\
OOOl
*
ll\
OO\
O\
l\
lOOOOl
+
lOO\
lOOlO\
lO
]
=
lOOOlll\
lOOl
[
(
lO\
OOl\
l\
O\
OOl
+
1
)
*
llOOOll\
O\
OOOl
+
lO\
OlO\
O\
lO\
lO
+
1
]
;
}
fo\
r
(
lOOlOOl\
OlO
=
0
;
lOOlOOlOlO
<
lllOOOOlllOO\

;
lOOl\
OOlO\
lO
++
)
for
(
lOOOllO\
OOl
=
ll\
lO\
OOOlllOO
;
lOO\
OllOOOl
<
lOOlllOl\
lO
-
1
;
lOOOllOO\
Ol
++
)
lOOOl\
l\
ll\
OO\
l
[
lOOOll\
O\
O\
Ol
*
ll\
OO\
Ol\
lOOOOl
+
lO\
OlO\
Ol\
OlO
]
=
lO\
OOll\
llO\
Ol
[
(
lOOO\
llOO\
O\
l
+
1
)
*
llOO\
OllOOOOl
+
lOOl\
O\
OlOlO\

]
;
}
boo\
l
lO\
llO\
l\
OlO\
Oll
::
lllOOOOOllOl
(
in\
t\

lOOll\
lO\
llO
,
int
llO\
OOll\
OO\
OOl\

,
float
*
lllOO\
Ol\
OOOOl
,
const\

float
*
lllOOO\
lOOOlO
,
int
lll\
OO\
OlOO\
Oll
)
{
lOOlO\
llllOl
(
llO\
lOOll\
lOOO
)
;
TA_\
ASSERT
(
lOOlll\
OllO
<
llO\
OOl\
lOOOO\
l
)
;
llOllllOOlOl
[
lO\
Olll\
OllO
]
=
lllOOOl\
OOOll\

;
in\
t
lOOOllOOOl
;
in\
t
lOOl\
OOlOlO
;
int
lOOlOlOO\
Ol
;
float
llOlOll\
OOO\
OO
;
for
(
lO\
O\
lO\
O\
lOlO
=
0
;
lO\
O\
lO\
Ol\
OlO
<
lOOlll\
Ol\
lO\

+
1
;
lOO\
lO\
Ol\
O\
lO
++
)
{
lOO\
OllO\
OO\
l
=
lOO\
l\
ll\
OllO
;
{
llO\
l\
OllOOOO\
O\

=
ll\
lOO\
OlOOOlO\

[
lll\
O\
OOlO\
O\
O\
l\
l\

*
ll\
OOO\
ll\
O\
OO\
O\
l
+
llOlll\
lOOlOl
[
lO\
Ol\
O\
Ol\
O\
l\
O
]
]
;
for\

(
lO\
Ol\
OlOOOl
=
0
;
lOO\
l\
Ol\
OOO\
l
<
lOO\
lOOlOlO
;
lOO\
l\
OlOO\
O\
l
++
)
{
llOl\
O\
llO\
OO\
OO
-=
ll\
lO\
OOlOO\
O\
O\
l\

[
lOOOllOOOl
*
llOOO\
l\
lOOOOl
+
lOO\
lO\
l\
OO\
O\
l
]
*
lll\
OO\
OlOOOOl
[
lO\
OlOOlOlO\

*
llOOOllOOOO\
l
+
lOOl\
O\
lO\
O\
O\
l
]
*
lll\
OO\
OlOOO\
O\
l
[
lOOlOlOOOl
*
llO\
OOll\
OOOO\
l\

+
lO\
O\
lOl\
OOO\
l
]
;
}
if
(
lO\
O\
Oll\
OOOl
==
lO\
OlOO\
lOlO
)
{
if
(
llO\
lOllOOO\
OO
<=
0.005f
)
{
llOlOllO\
OO\
O\
O
=
0.005f
;
re\
turn
fa\
lse\

;
}
lll\
OO\
Ol\
OOOOl
[
lOOOllO\
O\
O\
l
*
llOOOllOO\
OOl
+
lOOl\
OOlOl\
O
]
=
llOlOll\
OOOO\
O\

;
}
el\
s\
e
{
TA_AS\
S\
ERT
(
Fabs
(
lllOO\
O\
lOOO\
Ol
[
lOOlOOlOlO\

*
llOOOllOOOOl
+
lOOlO\
OlOlO
]
)
>
0.0f
)
;
lll\
O\
OOlOO\
O\
Ol
[
lOOOllOOO\
l
*
ll\
O\
O\
Ol\
lOOOO\
l
+
lOOl\
OO\
lO\
l\
O
]
=
llOl\
OllOOO\
OO\

/
lll\
O\
O\
OlOO\
OOl\

[
lOOl\
OOlOlO
*
llOOOllOOOO\
l\

+
lO\
OlO\
O\
lOlO
]
;
}
}
}
return
true
;
}
#ifdef _DEBUG
vo\
i\
d
lOl\
lOlO\
lOOl\
l
::
ll\
Oll\
lll\
OOll\

(
)
{
#define lllOOOlOOlOO(lOOOllOOOl, lOOlOOlOlO) llOllllOOOll[(lOOOllOOOl) * lOlOOOlOlO + (lOOlOOlOlO)]
#define lllOOOlOOlOl(lOOOllOOOl, lOOlOOlOlO) llOllllOOlOO[(lOOOllOOOl) * lOlOOOlOlO + (lOOlOOlOlO)]
ll\
lO\
OOlOOlOO
(
0
,
0
)
=
13.0f
;
ll\
lO\
OOl\
OOlOO
(
0
,
1
)
=
12.0f
;
lll\
OOOlO\
O\
lOO\

(
0
,
2
)
=
11.0f
;
lll\
OOO\
lOOlOO\

(
1
,
0
)
=
12.0f
;
lllOOOlOOlO\
O
(
1
,
1
)
=
14.0f
;
lll\
OO\
OlOO\
lOO
(
1
,
2
)
=
10.0f
;
lllOOO\
lO\
Ol\
OO
(
2
,
0
)
=
11.0f
;
lllO\
O\
OlOOlOO
(
2
,
1
)
=
10.0f
;
ll\
lOOOlO\
O\
lOO\

(
2
,
2
)
=
15.0f
;
int\

lOO\
lllOllO\

=
3
;
mem\
se\
t\

(
llOllll\
O\
llll
,
0
,
siz\
eo\
f
(
floa\
t
)
*
lO\
lOOO\
lO\
lO
)
;
mems\
et\

(
llOlllllOOOO
,
0
,
sizeof
(
fl\
o\
at
)
*
lO\
l\
OOOl\
O\
lO
)
;
llOl\
O\
lO\
lll\
l\
l\

(
lO\
OlllOl\
lO
,
lOlOOO\
l\
OlO
,
ll\
Ol\
ll\
lOOOl\
l
,
llOlll\
lOllll
,
llOlllllOOOO
)
;
lllOOOlOOlOl
(
0
,
0
)
=
14.0f
;
lllO\
OOlOOl\
Ol
(
0
,
1
)
=
10.0f
;
lllOOOl\
O\
Ol\
Ol
(
1
,
0
)
=
10.0f
;
lllO\
OOlO\
O\
l\
Ol
(
1
,
1
)
=
15.0f
;
memse\
t
(
llO\
lll\
lOll\
ll
,
0
,
sizeof
(
fl\
oa\
t
)
*
lOl\
O\
OOlOl\
O
)
;
mems\
et
(
llO\
l\
ll\
ll\
OOO\
O
,
0
,
siz\
eof\

(
float
)
*
lO\
lOOOlOlO
)
;
llOlO\
lO\
ll\
lll
(
lO\
OlllO\
ll\
O
-
1
,
lOlOOO\
l\
OlO
,
ll\
Ollll\
OOl\
O\
O\

,
llOllllOl\
lll
,
ll\
Ol\
llll\
O\
OOO\

)
;
lllOO\
OOOll\
OO\

(
lO\
O\
lllOllO
,
lOl\
O\
OOlOlO
,
llO\
l\
lll\
OO\
Oll
,
0
)
;
lOOl\
l\
lOllO\

--
;
{
for
(
in\
t
lOOl\
OO\
lOlO\

=
0
;
lOOlO\
OlOl\
O
<
lO\
OlllO\
ll\
O
;
lOOlO\
OlOlO
++
)
{
fo\
r
(
in\
t
lOOOl\
lOO\
O\
l
=
lOO\
lOOlO\
lO
;
lOOOl\
lOOOl
<
lO\
OlllOll\
O
;
lOOOllOOO\
l
++
)
{
fl\
oat\

lO\
OOOO\
lll\
O
=
llO\
lll\
lOOOll
[
lOOOll\
OO\
Ol
*
lOlO\
OO\
lO\
lO
+
lOOlOOlO\
lO
]
-
ll\
Oll\
l\
lOOlOO\

[
lOO\
OllOOOl
*
lOl\
OOOlO\
l\
O\

+
lOOl\
OOl\
OlO
]
;
TA_\
ASSE\
R\
T\

(
Fl\
oatIsOK
(
lOOOOOlllO
)
)
;
TA_\
ASS\
ERT
(
Fa\
b\
s
(
lOO\
OOO\
lllO
)
<
0.0001f
)
;
}
}
}
lll\
OOOlOOlOO
(
0
,
0
)
=
13.0f
;
lllOO\
OlOO\
lOO
(
0
,
1
)
=
12.0f
;
ll\
l\
OOOlO\
O\
l\
OO
(
0
,
2
)
=
11.0f
;
ll\
lOOOlOOl\
OO
(
1
,
0
)
=
12.0f
;
lllOOOlOOlOO
(
1
,
1
)
=
14.0f
;
ll\
lOOO\
lOOlOO
(
1
,
2
)
=
10.0f
;
lllO\
O\
OlOO\
lO\
O
(
2
,
0
)
=
11.0f
;
lllOOO\
l\
OOl\
O\
O
(
2
,
1
)
=
10.0f
;
lll\
OOOlO\
OlO\
O
(
2
,
2
)
=
15.0f
;
lOOlll\
Oll\
O
=
3
;
memset
(
llOl\
l\
ll\
Ollll
,
0
,
si\
zeof
(
float
)
*
lOlOOO\
lOlO
)
;
memset\

(
llOlllllOOOO\

,
0
,
siz\
eof
(
float
)
*
lO\
l\
OO\
OlOlO
)
;
llOl\
OlOll\
ll\
l
(
lOOlll\
O\
llO
,
lO\
lOOOlO\
l\
O
,
llOll\
ll\
OO\
Oll\

,
llOl\
lllO\
l\
l\
l\
l
,
llOll\
l\
ll\
OOOO
)
;
ll\
l\
O\
OOlO\
Ol\
Ol
(
0
,
0
)
=
13.0f
;
lllO\
OO\
lOOl\
O\
l
(
0
,
1
)
=
11.0f
;
lllO\
O\
Ol\
OOlO\
l
(
1
,
0
)
=
11.0f
;
ll\
lOOOlOO\
l\
Ol
(
1
,
1
)
=
15.0f
;
me\
mset
(
llOllllOl\
l\
l\
l
,
0
,
sizeof
(
float\

)
*
lO\
lOOOlOl\
O
)
;
mem\
set
(
ll\
Olll\
llOOOO
,
0
,
si\
z\
eof
(
fl\
oat\

)
*
lO\
l\
OOOlOlO
)
;
llOlO\
lOl\
llll\

(
lOOl\
llOl\
lO\

-
1
,
lOlOO\
OlO\
lO
,
llOll\
llOO\
lO\
O\

,
llOll\
llO\
lll\
l
,
llOll\
ll\
lOOO\
O
)
;
ll\
l\
OOOOOllOO
(
lOOl\
llOllO\

,
lOl\
O\
O\
OlOlO\

,
llO\
lll\
l\
OOOll
,
1
)
;
lOOlll\
O\
l\
lO
--
;
{
fo\
r
(
in\
t
lOOlOO\
lOlO\

=
0
;
lOO\
lOOlO\
lO\

<
lOOl\
llO\
llO\

;
lOOlO\
OlOlO
++
)
{
for\

(
in\
t
lO\
OOllOO\
Ol
=
lOOlOOlOlO
;
lOOOl\
lOOO\
l
<
lOOlllOllO
;
lOOOllOOOl
++
)
{
floa\
t
lO\
OOOO\
lllO
=
llOll\
llOO\
Oll
[
lOOOl\
lOOOl
*
lOlOOOl\
O\
lO
+
lO\
O\
l\
OO\
lO\
lO\

]
-
llOlll\
l\
OOl\
OO\

[
lOO\
Ol\
lOO\
Ol
*
lOl\
OO\
OlOlO
+
lOOlOOlOlO\

]
;
TA\
_ASSE\
R\
T\

(
Fl\
oat\
IsO\
K
(
lOOO\
O\
O\
l\
l\
lO
)
)
;
TA\
_ASSERT\

(
Fabs
(
lOOOO\
OlllO
)
<
0.0001f
)
;
}
}
}
lllOOOlOOl\
O\
O
(
0
,
0
)
=
13.0f
;
lll\
OOOlOO\
lOO\

(
0
,
1
)
=
12.0f
;
ll\
lO\
OO\
lOOl\
O\
O\

(
0
,
2
)
=
11.0f
;
lllOOOl\
OO\
lOO
(
1
,
0
)
=
12.0f
;
ll\
lO\
O\
OlOOlOO
(
1
,
1
)
=
14.0f
;
ll\
lOO\
OlOOlOO
(
1
,
2
)
=
10.0f
;
ll\
lOOOl\
OOlOO\

(
2
,
0
)
=
11.0f
;
lll\
O\
OOlOOl\
OO
(
2
,
1
)
=
10.0f
;
lll\
OOOl\
OOl\
OO
(
2
,
2
)
=
15.0f
;
lOO\
lllOll\
O\

=
3
;
memset\

(
ll\
Ol\
lllOlll\
l
,
0
,
sizeof
(
flo\
a\
t
)
*
lOl\
O\
OOlOlO
)
;
mems\
e\
t
(
llO\
lll\
llOO\
O\
O\

,
0
,
si\
z\
e\
o\
f
(
float
)
*
lOlOOO\
l\
Ol\
O
)
;
llOlOlOlllll
(
lO\
Ol\
llO\
l\
l\
O
,
lOlOOOlOlO
,
llO\
lll\
lOO\
Ol\
l
,
ll\
Ollll\
O\
l\
lll
,
llOll\
l\
l\
l\
OOOO
)
;
lllOOOlOOlOl
(
0
,
0
)
=
13.0f
;
lllOOOlOOlOl
(
0
,
1
)
=
12.0f
;
lllO\
OO\
l\
O\
OlO\
l
(
1
,
0
)
=
12.0f
;
lllOO\
OlOOlOl
(
1
,
1
)
=
14.0f
;
memse\
t
(
llOl\
lllOll\
l\
l
,
0
,
sizeo\
f
(
floa\
t
)
*
lO\
lO\
OOlOlO
)
;
memset
(
llOlll\
llOOOO
,
0
,
size\
of
(
float
)
*
lOlO\
OOlO\
l\
O
)
;
ll\
OlOl\
Oll\
ll\
l
(
lOOll\
lO\
l\
lO
-
1
,
lOl\
OOOl\
OlO
,
ll\
OllllOOlOO\

,
llOll\
llOllll
,
llOlllllOO\
OO
)
;
ll\
lOOOO\
OllOO
(
lOOlll\
Oll\
O
,
lO\
lOOOlOlO
,
llOllllOOOll
,
2
)
;
lOOlllOllO
--
;
{
fo\
r
(
int
lOO\
lOO\
lOlO
=
0
;
lOOlO\
O\
lOlO
<
lOO\
lllOllO
;
lOO\
lO\
Ol\
OlO\

++
)
{
for
(
in\
t
lOOOl\
lO\
O\
Ol
=
lO\
OlOO\
lO\
lO
;
lOOOll\
OOOl
<
lOO\
lll\
OllO
;
lOOO\
llOO\
Ol
++
)
{
float
lOOO\
OO\
ll\
lO
=
ll\
Ollll\
OOOll
[
lOO\
Ol\
l\
OOOl
*
lOlOOOl\
Ol\
O\

+
lOO\
l\
OOlOlO\

]
-
ll\
O\
lll\
lO\
Ol\
OO
[
lOOOl\
lOOOl\

*
lOlO\
O\
OlOl\
O
+
lOOlOOlOlO\

]
;
TA_\
ASS\
ERT
(
FloatIsOK
(
lOOOOOlll\
O
)
)
;
TA_ASS\
ERT
(
Fabs
(
lOOOOOlllO
)
<
0.0001f
)
;
}
}
}
lll\
OOOlOO\
lOO
(
0
,
0
)
=
13.0f
;
lllO\
OOlOOl\
OO
(
0
,
1
)
=
12.0f
;
ll\
lO\
OOlOOl\
OO
(
0
,
2
)
=
11.0f
;
lll\
OOO\
lOO\
lOO
(
1
,
0
)
=
12.0f
;
ll\
lOOOl\
O\
O\
lOO
(
1
,
1
)
=
14.0f
;
lll\
OOOlOOlOO
(
1
,
2
)
=
10.0f
;
lllOO\
OlOO\
l\
OO
(
2
,
0
)
=
11.0f
;
ll\
l\
O\
O\
OlO\
O\
lOO
(
2
,
1
)
=
10.0f
;
lllOOO\
lOOl\
OO\

(
2
,
2
)
=
15.0f
;
lOOll\
lOl\
lO
=
3
;
{
for
(
in\
t
lOOlOOlOlO
=
0
;
lOOlOO\
l\
Ol\
O\

<
lOOl\
llOl\
lO
;
lOOlOOl\
OlO
++
)
for
(
int
lO\
OOllO\
OOl
=
0
;
lOO\
Oll\
OOOl
<
lOOlllOllO
;
lO\
OOllO\
O\
Ol\

++
)
llOllllOOlO\
O
[
lOOOll\
OOOl
*
lOlOOOlOlO
+
lOOlOOlOlO
]
=
ll\
Ol\
ll\
lOO\
Oll
[
lOO\
O\
llOOOl\

*
lOlOOOl\
OlO\

+
lO\
Ol\
OOlO\
l\
O
]
;
}
llOl\
O\
lO\
llll\
l
(
lOOll\
l\
O\
llO\

,
lOl\
OOOlOl\
O\

,
llO\
lll\
lOO\
O\
ll
,
llO\
ll\
llOll\
ll
,
llOlllll\
O\
O\
O\
O
)
;
lll\
OOOOOllOl
(
0
,
lOlO\
OOlO\
lO\

,
llOllllOOl\
OO\

,
llOllllOOlOO
,
0
)
;
ll\
lOOOO\
OllO\
l\

(
1
,
lOlOOOlOlO\

,
ll\
O\
l\
lllOOlOO
,
llOllllOOl\
OO
,
1
)
;
lll\
O\
OO\
OOllO\
l\

(
2
,
lO\
lOOOlO\
l\
O
,
llOllllOOlOO
,
ll\
Ollll\
OOlOO\

,
2
)
;
lllO\
OOOOO\
OOO
(
lOOlllOl\
lO
,
lOlOOO\
l\
O\
lO
,
ll\
O\
lll\
lOOlOO
,
ll\
OllllO\
llll
,
ll\
Ol\
lll\
l\
OO\
O\
O
)
;
{
fo\
r\

(
int
lOOl\
O\
Ol\
OlO
=
0
;
lOOl\
O\
O\
lOlO
<
lOOlllOllO
;
lOOlOOlOlO
++
)
{
for
(
int
lOOOllOOOl
=
lO\
Ol\
O\
O\
lO\
lO\

;
lOO\
Ol\
lOOO\
l
<
lOO\
ll\
l\
OllO
;
lOOOll\
O\
O\
O\
l
++
)
{
float\

lO\
OO\
OO\
lllO\

=
llO\
ll\
ll\
OOOll
[
lOOOllOOOl
*
lOlO\
OOlOlO
+
lOOl\
OOlO\
lO
]
-
llOllllO\
OlOO
[
lO\
OO\
llO\
OO\
l
*
lOlO\
OO\
l\
OlO
+
lO\
Ol\
OO\
l\
OlO
]
;
TA_ASSERT
(
Floa\
tIsOK\

(
lOOOOOlllO
)
)
;
TA\
_AS\
S\
ERT
(
Fabs\

(
lO\
OOO\
Olll\
O\

)
<
0.0001f
)
;
}
}
}
}
#endif
}
#endif //

//---------------------------------------------------------------------------------
// File Name: zpta025.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#include "PhysicsJoint.h"
#ifndef TA_DYNAMICOBJECT_H
#include "DynamicObject.h"
#endif //
names\
pace
TA
{
Phys\
icsJoi\
nt
::
PhysicsJoi\
nt
(
)
{
lllOllOOO\
O
=
ll\
OOllllO\
llO
;
llOOllllOlll
.
Clea\
r
(
)
;
llOOlllllOO\
O
.
Cl\
ear
(
)
;
llOOl\
llllOO\
l
=
0
;
llOOl\
ll\
llOlO\

=
0
;
llO\
O\
lllllOll
.
Cl\
ear
(
)
;
llOOll\
llllOO
.
Cle\
ar\

(
)
;
llOOl\
l\
llllOl
=
0.0f
;
llOOlllll\
l\
l\
O
.
SetToIdent\
it\
y
(
)
;
llOOllll\
ll\
ll
.
Set\
ToI\
denti\
t\
y
(
)
;
llOlOOO\
OOOO\
O
.
Cl\
ea\
r
(
)
;
ll\
OlOO\
OO\
O\
O\
Ol
.
Clear
(
)
;
llOl\
OOOO\
OOlO
.
Cle\
ar
(
)
;
ll\
OlOO\
O\
OOOll
=
0
;
lOOllOl\
lOOll\

=
0
;
}
PhysicsJoint
::
~
Ph\
ysicsJoint
(
)
{
Finalise
(
)
;
}
void
Phys\
icsJoin\
t
::
Initi\
alis\
e\
E\
u\
lerConstraint
(
con\
st\

Ve\
c3
&
lOOO\
O\
llll\
l\

,
const
Mat\
3\
3\

&
ll\
OlOO\
OOOlO\
O\

,
co\
nst\

Euler\
An\
gle\
s\

&
lO\
Ol\
llll\
O\
l\
Ol
,
const\

Eul\
erA\
ngles
&
lOOlll\
llOllO\

)
{
TA_A\
SSERT
(
llOOll\
lllOOl
)
;
if
(
llO\
OlllllOlO
)
{
Init\
i\
alis\
e\
E\
ule\
r\
Con\
strain\
tE\
x\

(
lO\
O\
OO\
l\
l\
ll\
l
/
llOO\
lllll\
OOl
->
Ge\
t\
Fra\
me\

(
)
,
lOOOOl\
llll
/
llOOlllllOlO
->
Ge\
tFram\
e\

(
)
,
llOlO\
OOOOlOO
,
llOO\
llll\
lOOl
->
GetFr\
ame
(
)
.
m33Ro\
tatio\
n
,
ll\
OOl\
ll\
l\
l\
OlO
->
Ge\
t\
Frame\

(
)
.
m33Rota\
tion
,
lO\
OlllllOlO\
l
,
lOOlll\
llO\
llO
)
;
}
else\

{
InitialiseEulerC\
o\
ns\
tr\
aintEx
(
lOOO\
Ol\
lll\
l
/
llO\
OlllllOO\
l\

->
GetFra\
me
(
)
,
lO\
OOOlll\
ll
,
llOl\
OO\
OOO\
lOO
,
llOOlllllOOl
->
Get\
Fram\
e
(
)
.
m33Ro\
tat\
ion
,
k_m33\
Identity
,
lOOllll\
l\
O\
l\
Ol
,
lOOl\
lll\
lOll\
O\

)
;
}
}
voi\
d
Phys\
icsJoint
::
Initial\
iseEulerCo\
nstra\
int\
Ex\

(
con\
st
Ve\
c\
3
&
llO\
lO\
OOOOlOl
,
co\
nst
Vec\
3
&
ll\
O\
l\
OOOOOllO
,
co\
nst\

Mat33
&
llOlOO\
O\
OOl\
OO
,
const
Mat\
33
&
llOlOOOOOl\
ll\

,
const
Mat33
&
ll\
OlO\
OOOlOO\
O
,
co\
n\
s\
t
Euler\
A\
n\
gles\

&
lO\
OlllllOlO\
l
,
co\
n\
st
Eu\
l\
e\
r\
An\
gl\
es
&
lOOlllllOl\
lO
)
{
llOl\
OOOOlOOl
=
TY\
PE_\
EU\
L\
ER_ANGL\
E_CONS\
T\
RAINT
;
lll\
O\
llOOOO
=
0
;
llO\
O\
ll\
l\
lOlll\

=
llOl\
O\
O\
OO\
O\
l\
O\
l
;
llOOlllll\
OO\
O\

=
llOlOO\
OOOllO
;
ll\
OO\
lll\
ll\
l\
lO\

=
llOlO\
OOOOl\
O\
O
/
llOlOOOOOlll
;
llOOl\
llllll\
l
=
ll\
OlOOO\
O\
O\
lOO
/
llO\
lOO\
OOlOOO
;
llO\
lOOOOO\
OOO
=
lOOl\
llllOl\
O\
l\

;
llO\
lOOOOOOOl
=
lO\
Ollll\
lO\
ll\
O
;
llO\
lO\
OO\
O\
OOl\
O
.
Clear
(
)
;
lO\
Olll\
OO\
OO\
Ol
(
)
;
}
void
PhysicsJo\
i\
nt
::
Ini\
ti\
ali\
seHinge
(
con\
s\
t
Vec3
&
lOOOO\
ll\
ll\
l
,
con\
st
Ve\
c3
&
ll\
O\
l\
OO\
O\
Ol\
Ol\
O
,
floa\
t
lO\
O\
ll\
l\
lllOOl
,
float
lO\
Olll\
l\
llOlO
)
{
lOOOOOOllO
(
ll\
OlO\
OOOlOlO
.
IsN\
o\
r\
mal\
ised\

(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeAxis isn't normalised.")
;
TA\

::
Mat33
llO\
lOOOOlOll\

;
ll\
Ol\
OOOOlO\
l\
l
.
v3Y\

=
ll\
Ol\
OO\
O\
OlO\
lO
;
in\
t
lOOO\
lOOOll\
O
[
3
]
;
ll\
OlO\
OOOlOlO
.
Ge\
tAxisOrd\
er
(
lOO\
Ol\
OOOl\
lO
)
;
Vec3
lOO\
Ol\
O\
OOlll\

=
Vec3
::
GetU\
nitVe\
c\
to\
r
(
lO\
OOlO\
OOll\
O\

[
2
]
)
;
ll\
OlOOOOlOll\

.
v3X\

=
ll\
OlOOOO\
lOlO
.
Cro\
s\
s
(
lOOOlOO\
Ol\
ll
)
;
ll\
OlO\
OOOl\
Ol\
l\

.
v3X
.
Norm\
alis\
e
(
)
;
llOl\
O\
OO\
OlOll
.
v3Z\

=
llOlO\
OO\
Ol\
Oll
.
v3X
.
Cro\
ss\

(
llOlOOO\
OlOl\
l
.
v3Y
)
;
Ini\
tialise\
E\
u\
ler\
Cons\
tr\
ai\
nt
(
lOOOOlllll
,
llOlOO\
OO\
l\
Oll
,
Eu\
le\
rA\
n\
gles
(
0.0f
,
lOO\
l\
lllll\
OOl
,
0.0f
)
,
Eul\
er\
Ang\
les
(
0.0f
,
lOOl\
lll\
llO\
lO\

,
0.0f
)
)
;
}
void
Phys\
i\
csJoint
::
Initialis\
e\
Hing\
eEx
(
const
Vec3
&
llOlOO\
OO\
O\
lO\
l
,
const\

Vec3
&
llOl\
OOOOOllO
,
const
Ve\
c3
&
llOlO\
OOOlOlO\

,
const
Vec3
&
llOl\
OOOOllOO
,
const\

Mat3\
3
&
ll\
OlOOOOOlll
,
co\
nst\

Mat\
33
&
ll\
OlOOOOl\
OO\
O\

,
floa\
t
lOOllllllO\
Ol
,
float\

lOOl\
l\
llllO\
lO
)
{
lOOO\
OO\
O\
l\
l\
O
(
llOlOOOO\
l\
OlO
.
Is\
N\
or\
m\
alised
(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeAxis isn't normalised.")
;
lOOOO\
OOllO
(
llO\
lOOOO\
llO\
O
.
IsNormalised\

(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeCenterDirection isn't normalised.")
;
TA
::
Mat\
33
llO\
lOO\
OOlO\
ll
;
llOl\
O\
OOOlOll
.
SetT\
o\
LookAt
(
ll\
OlOOO\
OllOO
,
llOlOOO\
Ol\
O\
lO
)
;
In\
itiali\
seEule\
rConstr\
aint\
Ex
(
llOlOOO\
OOlOl
,
llOl\
O\
OOOO\
llO
,
llO\
lOO\
OO\
lOl\
l
,
llOlOOOOO\
lll
,
llOlOOOOlOOO
,
TA
::
EulerAn\
gl\
es\

(
0.0f
,
lO\
O\
l\
lllllOOl\

,
0.0f
)
,
TA\

::
Eule\
rAngles
(
0.0f
,
lOOlllll\
lOlO
,
0.0f
)
)
;
lOOlllOOOOOl
(
)
;
}
void
Phy\
si\
csJo\
int\

::
In\
itiali\
se\
B\
allAndSo\
c\
k\
et
(
con\
st
Vec\
3
&
lO\
OOOl\
ll\
ll\

,
const
Vec3
&
llOl\
OOO\
Ol\
lOl
,
float\

lOO\
ll\
l\
l\
llOlO
)
{
TA\
_A\
SSE\
RT
(
ll\
OOlllllOOl
)
;
if\

(
llOO\
l\
l\
ll\
lOlO
)
{
InitialiseB\
allAndS\
ocketE\
x
(
lOOO\
O\
llll\
l
/
ll\
O\
Ollll\
l\
OOl
->
Ge\
tFram\
e
(
)
,
lOO\
OOl\
l\
lll\

/
llOOlllllOlO\

->
GetF\
rame
(
)
,
llOlO\
OOOllOl
/
llO\
OlllllOOl
->
GetFrame
(
)
.
m3\
3Rota\
t\
i\
on
,
-
llOlOOO\
Oll\
O\
l
/
ll\
O\
O\
l\
llllOlO\

->
GetFram\
e
(
)
.
m33Rota\
tion
,
lOOllll\
l\
l\
O\
lO\

)
;
}
el\
se
{
Initial\
iseBal\
lAnd\
Sock\
e\
tEx\

(
lOO\
O\
Ol\
ll\
ll\

/
ll\
O\
Ollll\
lO\
Ol
->
Ge\
tFrame
(
)
,
lOO\
OOll\
lll
,
llO\
lO\
OOO\
ll\
Ol\

/
llOOl\
ll\
l\
lOO\
l
->
Get\
F\
r\
ame
(
)
.
m33R\
otat\
i\
on
,
-
ll\
O\
l\
O\
OOO\
llOl
,
lOOl\
lllll\
OlO
)
;
}
}
vo\
id
Physi\
c\
sJoint
::
Initi\
alise\
BallAn\
d\
S\
oc\
k\
e\
tEx
(
const
Vec3
&
ll\
OlOOOOOlOl
,
cons\
t\

Ve\
c3\

&
ll\
Ol\
OOOOO\
ll\
O
,
cons\
t
Vec3
&
llOlO\
OOOl\
ll\
O
,
co\
n\
st
Vec\
3
&
llOlOOOOlll\
l
,
float
lOOl\
lll\
llOl\
O\

)
{
TA\
_ASSERT
(
llOO\
l\
l\
l\
llOO\
l\

)
;
llOlOOOOlOOl
=
TYPE\
_\
BALL_AND_SO\
C\
KET
;
ll\
l\
Oll\
OOOO
=
0
;
llOOllllOlll
=
llO\
l\
OOOOOlOl\

;
llO\
Olll\
llO\
OO
=
llOl\
OOO\
OOllO
;
llOOll\
l\
ll\
Oll\

=
ll\
O\
lOOOOll\
lO
;
TA_A\
SSERT
(
llO\
Olllll\
O\
ll\

.
Is\
Normali\
s\
e\
d
(
)
)
;
ll\
O\
Ollll\
ll\
OO\

=
ll\
OlOOOO\
ll\
ll
;
TA_\
A\
SSERT
(
ll\
OOllllllO\
O
.
IsNo\
rmalise\
d
(
)
)
;
llOO\
l\
ll\
lll\
O\
l\

=
lOOlllll\
lOlO
;
llOlO\
OOOOOlO\

.
Cl\
ear\

(
)
;
lOOll\
l\
OOOOOl\

(
)
;
}
void\

PhysicsJ\
oint\

::
In\
it\
i\
ali\
seLimited\
BallAndSo\
ck\
e\
t
(
cons\
t
Ve\
c3
&
lOOOOll\
lll
,
cons\
t\

Mat33
&
llOlOOOOOl\
O\
O
,
flo\
at
lOOll\
l\
l\
lllOl\

,
float\

lO\
Ollll\
llll\
O
)
{
TA_A\
SSERT
(
ll\
OOllll\
l\
O\
Ol
)
;
if
(
llOO\
l\
llllOlO
)
{
InitialiseL\
imi\
t\
edBa\
l\
l\
AndS\
ocke\
tEx
(
lOOOOlllll
/
llOOl\
lll\
lO\
Ol\

->
Ge\
tF\
rame
(
)
,
lO\
OOOllll\
l
/
ll\
OO\
lllllOlO
->
Ge\
tFra\
me\

(
)
,
llOlO\
OO\
OOlO\
O
,
llOOlllll\
OO\
l
->
GetF\
rame\

(
)
.
m3\
3\
Rotation
,
llOOll\
lllOlO
->
GetFrame
(
)
.
m3\
3Rotation
,
lOOll\
lllll\
Ol
,
lO\
Ol\
lllllllO
)
;
}
els\
e\

{
Initialise\
Limite\
d\
BallAndSoc\
ket\
Ex
(
lOOOOll\
lll
/
llOOll\
l\
llOOl
->
GetFrame\

(
)
,
lOO\
OOllll\
l
,
ll\
OlOOOOOlO\
O\

,
ll\
OO\
lllll\
OOl
->
Get\
Fr\
ame
(
)
.
m33Rot\
a\
t\
ion
,
k_\
m\
33I\
dentity
,
lO\
Oll\
l\
l\
l\
llOl
,
lOO\
lll\
l\
l\
lll\
O\

)
;
}
}
voi\
d
Phys\
i\
cs\
Joi\
nt\

::
Init\
ial\
iseLimi\
tedBa\
llAndSocke\
tE\
x
(
const
Ve\
c3
&
ll\
OlO\
OO\
O\
O\
lO\
l
,
const
Vec3
&
llOl\
OOOOOllO\

,
const
Mat33
&
llOlOO\
OO\
Ol\
OO\

,
con\
st
Ma\
t\
33\

&
llOlOOO\
OOl\
ll
,
const
Ma\
t33\

&
llOlOO\
OOlO\
O\
O\

,
float
lO\
Olll\
llll\
Ol\

,
flo\
at
lOO\
lllll\
lll\
O
)
{
llOlO\
OOOl\
O\
Ol
=
TYPE_LIMI\
TED_\
BALL_AN\
D_S\
OCKET
;
lllOll\
OOO\
O
=
0
;
llOOllllOl\
ll
=
llO\
lOOO\
OOlO\
l
;
llOOl\
l\
l\
ll\
OOO
=
llO\
l\
O\
OOOOll\
O
;
llOO\
ll\
ll\
lllO\

=
llOlOO\
OOOl\
OO
/
llOlOOOOOlll
;
llOOllllll\
ll
=
ll\
OlOO\
OOO\
l\
OO
/
ll\
OlOOO\
OlOOO
;
llO\
lOO\
O\
O\
O\
O\
OO
.
Cl\
ear
(
)
;
llO\
lO\
OOOOOOO\

.
x
=
-
lO\
Olllll\
l\
l\
lO
;
llOlOOOOOOOO\

.
y
=
-
lOOlllll\
ll\
Ol
;
llOlOOOOO\
OO\
l\

.
Clea\
r
(
)
;
ll\
OlO\
OOOO\
OOl\

.
x
=
lOO\
llllll\
ll\
O
;
ll\
OlOO\
O\
O\
OO\
OO
.
y
=
lO\
Olllll\
ll\
Ol
;
llOlO\
OOO\
OOlO
.
Cle\
ar
(
)
;
lOO\
l\
ll\
O\
O\
OOO\
l\

(
)
;
}
voi\
d
Physics\
Jo\
int\

::
InitialiseSq\
ua\
re\
S\
o\
cket
(
co\
n\
st\

Ve\
c3
&
lOO\
OO\
lllll
,
const
Mat33
&
llOlO\
O\
OOOlOO\

,
fl\
oat\

lOOllllll\
l\
ll
,
floa\
t
lOl\
OO\
O\
OOOOOO\

,
float\

lOl\
O\
OOOOOOOl
,
flo\
at
lOlOO\
O\
OO\
OOlO
,
fl\
oat\

lOl\
OO\
OO\
O\
OOll\

,
floa\
t\

lOlOOOOOO\
lOO
)
{
TA\
_ASSERT
(
llOOlllllOOl\

)
;
if\

(
llOOllll\
lO\
l\
O
)
{
Initi\
ali\
se\
Sq\
u\
are\
So\
cke\
t\
Ex
(
lO\
OOO\
lllll
/
llO\
OlllllOOl\

->
GetFr\
am\
e
(
)
,
lOOOOll\
lll
/
ll\
OO\
lllllOlO\

->
GetFr\
ame
(
)
,
llOl\
OO\
OO\
OlOO
,
llO\
Ol\
llllOO\
l
->
GetF\
ra\
m\
e
(
)
.
m33Rotation
,
llOOllll\
lOlO\

->
GetFrame
(
)
.
m3\
3Rotation
,
lOOll\
l\
l\
ll\
l\
l\
l\

,
lOl\
OOOOO\
OOOO\

,
lOlOOOO\
O\
OOO\
l
,
lOlOOOOOOOlO
,
lO\
lOOOOO\
OOll
,
lOlO\
O\
OO\
OOlOO
)
;
}
else\

{
Initia\
l\
iseSquareS\
ocke\
tEx
(
lOOO\
O\
lll\
ll\

/
llOO\
lll\
llOOl\

->
GetFrame
(
)
,
lOO\
OOlllll
,
ll\
Ol\
OOOOOl\
O\
O
,
llOO\
lllll\
OOl
->
GetF\
ra\
m\
e
(
)
.
m33Ro\
ta\
tio\
n\

,
k_m3\
3I\
d\
ent\
ity
,
lO\
Olllll\
llll
,
lOlOO\
OO\
OOOOO
,
lO\
lO\
OO\
OO\
OOOl
,
lOlOO\
OOOOOl\
O\

,
lOl\
OOOOOOOll\

,
lOl\
OOO\
O\
OOlOO
)
;
}
}
void\

PhysicsJoi\
nt\

::
In\
it\
i\
a\
l\
is\
eS\
q\
u\
a\
r\
eSo\
cket\
Ex
(
const
Ve\
c3
&
llOlOOOOOlOl
,
const
Ve\
c3
&
llO\
l\
OOOOOllO
,
const\

Mat3\
3
&
ll\
O\
l\
OOOOOlOO\

,
co\
nst
Mat3\
3\

&
llOlOOOO\
O\
ll\
l
,
const
Ma\
t33
&
ll\
Ol\
OOOO\
lOOO
,
floa\
t\

lOO\
lll\
llllll\

,
flo\
a\
t
lOl\
OO\
O\
O\
OOO\
OO
,
float\

lOlOOOOO\
OOOl
,
fl\
oat
lOlOOOOOO\
OlO
,
float
lO\
lO\
O\
OOO\
O\
O\
l\
l\

,
float
lOlOOOOO\
OlO\
O\

)
{
ll\
O\
lOOO\
OlO\
Ol
=
TYPE_SQUA\
RE\
_S\
OCK\
ET
;
lllO\
llOOO\
O\

=
0
;
ll\
OOlll\
l\
Oll\
l
=
llOl\
OOOOOlO\
l
;
llOO\
lllllOOO
=
llOlOOOOOllO
;
llOOl\
lll\
ll\
lO
=
llO\
l\
OOOOO\
lOO\

/
llOlOOO\
OOlll
;
ll\
O\
Oll\
lllll\
l
=
llOlO\
OOO\
OlOO
/
llOl\
O\
OO\
O\
lOO\
O
;
llO\
lOOO\
O\
OOOO
.
Ini\
ti\
alise
(
lOO\
lllllll\
ll
,
lOlO\
O\
O\
O\
OOOOl\

,
lOlOOOOOOO\
ll
)
;
ll\
O\
lOOO\
O\
OO\
O\
l\

.
Initia\
lise\

(
lO\
lOO\
O\
OOOOO\
O\

,
lO\
lOOOOOOOl\
O
,
lOlOO\
OOOO\
lOO
)
;
con\
st
floa\
t
llOlO\
OOl\
OOO\
O
=
0.01f
;
if
(
llOl\
O\
OOOO\
OOO\

.
x
>
-
llOlOOO\
l\
OOOO
)
llOlOOOOO\
OOO\

.
x
=
-
ll\
OlOOOlO\
OOO\

;
if
(
ll\
O\
l\
O\
OOOOOOl\

.
x
<
llOlOO\
Ol\
OOOO\

)
llOlOOOO\
OOOl
.
x
=
llO\
lOOO\
lOOO\
O\

;
if
(
llO\
lOOOOOO\
OO
.
y
>
-
llOl\
OOOlOOO\
O
)
llOlOOOOOOO\
O
.
y
=
-
llO\
lOOOl\
OOO\
O
;
if
(
llOlOO\
OO\
OOOl
.
y
<
ll\
O\
lO\
OO\
lOOOO\

)
llOlOO\
OO\
OOOl
.
y
=
llOlO\
O\
OlOO\
O\
O
;
if
(
llOl\
O\
O\
O\
OOO\
OO
.
z
>
-
ll\
O\
lOOO\
lOOOO
)
llOlOOOOOOO\
O
.
z
=
-
llO\
l\
O\
OOlO\
OOO
;
if
(
llOlOOOOOOOl
.
z
<
llOlOOOlOOOO\

)
llO\
lO\
OOOOO\
Ol
.
z
=
llOlO\
OOl\
OOOO\

;
ll\
OlOOO\
O\
O\
OlO
.
Cle\
ar\

(
)
;
lOO\
l\
ll\
OO\
OOO\
l
(
)
;
}
voi\
d\

Phy\
sicsJoint\

::
Initialise\
S\
lider
(
co\
ns\
t\

Vec3\

&
lll\
O\
OOlO\
O\
l\
l
,
const\

Ve\
c3
&
llOlOOOlOO\
Ol\

,
co\
nst
Vec3
&
llOlOOOlOOlO
)
{
TA\
_\
ASSERT
(
llOOl\
l\
lllOOl
)
;
if\

(
llOOll\
lllOl\
O\

)
{
In\
itia\
lise\
Sli\
derEx\

(
ll\
lO\
OOl\
OO\
l\
l
/
llOOlllllOOl\

->
Ge\
tFram\
e\

(
)
,
llO\
lOOO\
lOOOl\

/
llOO\
l\
ll\
llOlO
->
Get\
Frame
(
)
,
llO\
l\
OO\
OlOOlO
/
llOO\
l\
ll\
llOlO
->
Ge\
tFram\
e
(
)
)
;
}
else
{
Ini\
tialis\
eS\
liderEx
(
lllOOOl\
OOl\
l
/
ll\
O\
Oll\
l\
llOO\
l
->
GetFra\
me\

(
)
,
llO\
lOOOl\
OOO\
l
,
llO\
lOO\
O\
lO\
OlO
)
;
}
}
vo\
id
Physic\
s\
Jo\
int
::
Initiali\
s\
eS\
l\
iderE\
x
(
const
Vec3
&
llOlOOOOO\
lOl
,
cons\
t\

Vec3
&
llOlOOOlOO\
l\
l
,
co\
ns\
t
Ve\
c\
3
&
llOl\
OO\
Ol\
O\
l\
O\
O
)
{
llOlOOOOl\
O\
Ol
=
TYP\
E\
_L\
IN\
EAR_SLIDER\

;
lllO\
ll\
O\
OOO\

=
0
;
llOOll\
l\
l\
O\
lll
=
ll\
OlOO\
O\
OOlOl
;
llOOlllllOOO
=
llOlOOOlO\
Oll
;
ll\
OOlll\
llOll
=
llOlOO\
OlOlOO
;
lO\
Ol\
l\
lO\
OOOOl\

(
)
;
}
vo\
id\

Ph\
ys\
i\
csJoint\

::
Ini\
ti\
al\
is\
eRotati\
onC\
onstraint
(
cons\
t
Mat33
&
llOlOOOOOlOO
,
con\
s\
t
EulerAngle\
s
&
lO\
O\
lll\
llOlO\
l
,
co\
n\
st\

Eule\
rAngl\
es
&
lOOl\
llllOllO
)
{
TA_AS\
SERT
(
ll\
OOlllllOOl
)
;
if\

(
llOOl\
llllOlO
)
{
Initialise\
Rotati\
o\
nConst\
rain\
t\
E\
x
(
llOlOOOO\
OlOO
,
llOO\
lllllOO\
l
->
GetF\
ra\
me
(
)
.
m3\
3R\
otat\
i\
on
,
llOOllll\
l\
OlO
->
Ge\
tF\
ram\
e\

(
)
.
m33Ro\
ta\
ti\
on
,
lO\
Oll\
lllOlOl\

,
lOOl\
llllOl\
lO\

)
;
}
else
{
Initia\
liseRo\
tati\
onCo\
n\
st\
r\
aintE\
x
(
llO\
lO\
O\
OOO\
l\
OO\

,
llOOlllllOOl
->
Get\
Fr\
a\
m\
e\

(
)
.
m33Rot\
a\
tion
,
k_m33Identity
,
lO\
Ol\
lll\
l\
OlOl
,
lOOlllll\
OllO\

)
;
}
}
void\

Physi\
csJo\
i\
n\
t
::
Initi\
al\
i\
s\
eRota\
t\
i\
on\
Constrai\
n\
tEx
(
cons\
t
Ma\
t\
33
&
llOl\
OOOOOlOO
,
const\

Ma\
t33
&
llOlOO\
OOO\
lll
,
const\

Mat\
33
&
llOlO\
OOOlOOO
,
const
Euler\
Angles
&
lOO\
l\
llllOlOl
,
co\
ns\
t\

Eule\
rAn\
g\
les
&
lOOlllllO\
llO\

)
{
llOlOOOO\
l\
OOl\

=
TYPE_ROTAT\
IO\
N_C\
O\
NSTRA\
IN\
T
;
ll\
lOllOOOO
=
0
;
llOOllll\
Olll
.
Cl\
e\
ar
(
)
;
llOOl\
lll\
lO\
OO
.
Cle\
a\
r\

(
)
;
llOO\
ll\
lllllO
=
llOlOOOO\
OlOO
/
llO\
l\
OOOO\
Olll
;
ll\
OOllll\
lll\
l
=
ll\
OlOOOOOlOO
/
llOlO\
OO\
Ol\
OO\
O\

;
llOlOOOOOOOO
=
lOO\
lllll\
OlO\
l\

;
llOlOO\
OOO\
OOl
=
lOO\
llll\
lO\
llO
;
ll\
O\
lOOOO\
OOlO
.
Cle\
ar
(
)
;
lO\
Olll\
O\
O\
O\
OOl\

(
)
;
}
void
PhysicsJoin\
t
::
Ini\
tialise\
Ve\
cto\
rConstrai\
nt\

(
const
Vec\
3
&
llO\
l\
O\
OO\
Oll\
Ol
,
float
lOOl\
lllll\
Ol\
O\

)
{
TA_\
A\
SSERT
(
llO\
Ollll\
lOOl
)
;
if
(
llOO\
llll\
lO\
lO\

)
{
In\
i\
tia\
liseVec\
tor\
C\
o\
nstra\
intEx\

(
ll\
OlOOOOllOl
/
ll\
O\
Olllll\
OOl
->
GetFr\
am\
e
(
)
.
m3\
3Rota\
tion
,
llOlOO\
OOllOl
/
llO\
O\
ll\
lllOlO
->
GetFrame\

(
)
.
m33Rotation
,
lO\
Oll\
llllO\
lO
)
;
}
else
{
Initiali\
seVe\
ct\
o\
rConst\
raintEx
(
llOlOO\
OOllOl
/
llOOlllllOOl
->
GetFr\
ame
(
)
.
m33Ro\
tation
,
ll\
OlOOO\
Oll\
Ol
,
lO\
Oll\
llllOl\
O
)
;
}
}
void
PhysicsJ\
oint\

::
In\
itialiseV\
e\
c\
t\
o\
r\
C\
o\
nstrai\
ntEx
(
co\
ns\
t
Ve\
c\
3
&
llOlOOOOlllO\

,
con\
st
Vec3\

&
llOlOOOO\
ll\
ll\

,
float
lOO\
lll\
ll\
lOlO
)
{
llOl\
O\
OOO\
l\
OOl
=
TYP\
E\
_VECTOR_CONST\
R\
AINT\

;
ll\
lOllOOOO
=
0
;
llOOllll\
O\
l\
ll
.
Clear
(
)
;
llOOlllll\
OOO
.
Cl\
ear
(
)
;
llO\
Ollll\
lOll
=
llOlOOOOll\
l\
O\

;
TA_AS\
SE\
RT
(
llOOl\
llllO\
ll
.
Is\
Norma\
lise\
d
(
)
)
;
ll\
OOllllll\
OO
=
ll\
Ol\
OOOOll\
ll
;
TA_\
A\
SSE\
RT
(
llOOl\
ll\
ll\
lOO\

.
IsN\
o\
rma\
lised
(
)
)
;
llOOll\
l\
lllO\
l
=
lO\
Ol\
lll\
llOlO
;
llO\
lOOOO\
OOl\
O\

.
Clear
(
)
;
lOOl\
l\
l\
OOO\
O\
O\
l
(
)
;
}
vo\
id\

Physics\
Join\
t
::
Reset
(
const
Vec\
3
&
ll\
lOOOlOO\
ll
,
const
Vec\
3
&
lllOOO\
lO\
Ol\
O
,
cons\
t
Ma\
t33\

&
llOl\
OOO\
lOlO\
l
,
co\
ns\
t
EulerAngle\
s\

&
lOOlll\
llOlOl
,
const
EulerAngles
&
lO\
Ol\
l\
l\
llOllO\

)
{
llOlOO\
OO\
lOOl\

=
TYPE_\
E\
U\
LE\
R_ANGLE_\
C\
ONSTR\
AIN\
T
;
lllOll\
OOO\
O
=
0
;
llOOlll\
l\
Olll\

=
lllOO\
O\
lOOll
;
llOOlll\
llOOO
=
lllOO\
OlOOlO
;
llOOlllllll\
O
=
llOlOOO\
l\
Ol\
O\
l\

;
llO\
Ollllllll
=
llOl\
OOOlOlO\
l\

;
llO\
lO\
OOOOO\
OO
=
lO\
Ol\
lll\
l\
OlOl
;
llO\
lOOOO\
OOOl
=
lO\
O\
lllllO\
llO
;
llO\
l\
O\
OOOOOlO\

.
Cl\
ear
(
)
;
lOO\
lll\
OOOO\
O\
l
(
)
;
}
voi\
d
Phy\
s\
icsJoint
::
Res\
et\
AsT\
ypeHinge
(
const\

Vec3
&
lllO\
O\
OlOOll
,
const
Ve\
c\
3
&
lllOOO\
l\
O\
O\
lO
,
con\
s\
t
Vec3
&
llOlOOOlOllO
,
cons\
t
Ve\
c3
&
llOlOO\
O\
lOlll
,
floa\
t
lOOllllll\
OO\
l
,
float
lOOl\
l\
llll\
OlO
)
{
lO\
OOOOOllO\

(
llOlO\
OO\
lOllO\

.
Is\
Norma\
lis\
e\
d
(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeAxis isn't normalised.")
;
lO\
OOO\
OO\
l\
l\
O\

(
llOlOOOlOlll
.
IsNormalis\
e\
d
(
)
,
"PhysicsJoint::ResetAsTypeHinge. v3HingeNormal isn't normalised.")
;
TA\

::
Mat33
ll\
Ol\
OO\
OOl\
O\
ll
;
llOlOOOO\
lOll
.
SetToL\
oo\
kAt\

(
llOlOOO\
lOl\
ll
,
llO\
lO\
O\
OlOllO
)
;
Rese\
t
(
lllOOOl\
O\
O\
l\
l\

,
ll\
lOO\
O\
lOO\
lO\

,
llOlOO\
O\
Ol\
O\
ll
,
TA
::
Euler\
Ang\
les\

(
0.0f
,
lOOllllllOO\
l\

,
0.0f
)
,
TA
::
Eu\
lerAn\
gl\
es\

(
0.0f
,
lOO\
llllllOlO
,
0.0f
)
)
;
lOOll\
lO\
OOOOl
(
)
;
}
void
PhysicsJ\
oint
::
Reset\
A\
sT\
y\
p\
eSocket
(
co\
n\
st
Vec\
3\

&
lllO\
OOlOO\
ll
,
const
Ve\
c3
&
lllOOOlOOlO
,
const
Vec3
&
llOlO\
OOllOOO\

,
co\
ns\
t
Vec3\

&
llOl\
O\
OOllOOl
,
fl\
o\
at
lOOllllllO\
lO
)
{
llOlOOOOlOOl
=
TYPE_\
BALL\
_AND\
_\
SOC\
KET
;
ll\
lO\
llO\
OOO
=
0
;
ll\
OO\
l\
lllO\
lll
=
lllOO\
O\
l\
OO\
l\
l
;
llOOlll\
llO\
OO
=
lllOOO\
lO\
O\
lO
;
llOOllll\
lOl\
l
=
ll\
O\
lOOO\
llO\
O\
O
;
TA_A\
SS\
ERT
(
llOOl\
lll\
lOl\
l
.
IsN\
or\
malised
(
)
)
;
llOOll\
l\
l\
ll\
OO
=
ll\
OlO\
O\
Ol\
l\
OOl
;
TA_ASS\
ERT\

(
llO\
O\
ll\
l\
lllOO
.
Is\
N\
ormalis\
e\
d\

(
)
)
;
llOOlllll\
lOl
=
lOOllll\
l\
lOlO\

;
llOlOOOO\
O\
OlO
.
Clea\
r
(
)
;
lOOlllOOO\
OOl\

(
)
;
}
void
Physi\
csJoint
::
Res\
e\
tA\
sT\
yp\
e\
L\
imited\
S\
oc\
ket\

(
co\
nst
Ve\
c\
3\

&
ll\
lOOO\
lO\
Oll\

,
co\
nst\

Vec3
&
lllOO\
Ol\
O\
O\
l\
O\

,
co\
nst
Mat3\
3
&
llOl\
OO\
OlOl\
O\
l
,
fl\
oat
lOOl\
llllllO\
l
,
float
lOO\
ll\
ll\
llllO
)
{
ll\
Ol\
OO\
OOlO\
O\
l
=
TYPE_LIM\
ITED_\
B\
ALL_\
AN\
D\
_SO\
CK\
E\
T
;
ll\
lO\
llO\
O\
OO
=
0
;
ll\
OOllll\
O\
lll
=
lll\
OOOlO\
Oll
;
llOOl\
llll\
OO\
O
=
ll\
lOOO\
lOOlO
;
ll\
OOlll\
lll\
lO
=
llOl\
OOOlOl\
O\
l
;
llOOl\
llll\
ll\
l
=
llO\
lOO\
Ol\
OlOl
;
llO\
lOO\
OOOOOO
.
Clea\
r\

(
)
;
llO\
lOOOO\
OO\
OO\

.
x
=
-
lOOlll\
ll\
ll\
l\
O\

;
llOlOO\
OOOOOO\

.
y
=
-
lOOll\
ll\
lllOl\

;
ll\
Ol\
OOO\
OOO\
O\
l\

.
Cl\
ear\

(
)
;
llOlOO\
OOOOOl
.
x
=
lOOl\
ll\
ll\
lll\
O
;
llOl\
OO\
OOO\
OO\
O
.
y
=
lOO\
ll\
lll\
llOl
;
llO\
lOOOOOOlO
.
Cle\
a\
r\

(
)
;
lOO\
lllO\
OOOOl
(
)
;
}
void\

Phy\
s\
i\
cs\
Join\
t\

::
Res\
et\
AsT\
y\
p\
e\
Squa\
reSoc\
ket
(
const
Vec3
&
ll\
l\
OOOl\
OOll
,
const
Vec3
&
lllOOOl\
O\
OlO
,
const
Mat33
&
ll\
Ol\
OOOlOlO\
l
,
flo\
a\
t
lOOll\
llll\
ll\
l
,
float
lO\
lOO\
OO\
OOOOO
,
flo\
at
lOlOOO\
OOOO\
Ol
,
floa\
t
lOlO\
O\
OO\
OOO\
lO\

,
flo\
at
lOlOOOOOOOll
,
floa\
t
lO\
lOOOOO\
OlOO\

)
{
ll\
O\
lOOOOlO\
O\
l
=
TYPE_SQUARE\
_\
SOCKE\
T
;
lll\
OllO\
OO\
O
=
0
;
llOOllllO\
ll\
l
=
lllOOO\
lOOll
;
llOO\
lll\
l\
lOOO\

=
lllOOOlOOlO
;
llO\
Olll\
llllO
=
llOlOOOlO\
lOl
;
llOO\
lllllll\
l
=
ll\
OlOOOlOlOl\

;
llOlOOOOOOOO
.
Initi\
ali\
se
(
lOOll\
ll\
ll\
lll\

,
lOlO\
OO\
OOOOOl
,
lO\
lOOOOOO\
Ol\
l
)
;
llOlO\
OOOOOO\
l
.
Ini\
tia\
lise
(
lO\
l\
OOO\
OOOOOO\

,
lO\
lOOOOO\
O\
OlO\

,
lO\
lOOOOOOlOO
)
;
co\
n\
st
fl\
oat
ll\
Ol\
OOOlOOOO
=
0.01f
;
if
(
llOl\
OOOOOOOO
.
x
>
-
llOlOOOlOOOO
)
ll\
OlOOO\
OO\
OOO
.
x
=
-
llOl\
O\
OOl\
OOO\
O
;
if\

(
llOlOOOOO\
OOl
.
x
<
ll\
OlOOO\
l\
OOOO\

)
llOlO\
OO\
OOO\
O\
l
.
x
=
llOlOOOl\
OOOO
;
if
(
ll\
O\
lOOOOO\
OOO
.
y
>
-
llOlO\
OOl\
OO\
OO
)
ll\
OlOO\
O\
O\
OOO\
O
.
y
=
-
llO\
l\
OO\
OlOOO\
O
;
if
(
llOlOO\
OO\
OOOl
.
y
<
llO\
lOOO\
lOO\
OO
)
llOlO\
OOOOOOl
.
y
=
ll\
O\
lOOOlOOOO
;
if
(
ll\
O\
lOOOOOOO\
O
.
z
>
-
ll\
OlO\
OOl\
OOOO
)
llO\
lOOOOOO\
OO
.
z
=
-
ll\
OlOOOlOOOO
;
if
(
llOlO\
O\
O\
OO\
OOl\

.
z
<
llOl\
O\
OO\
l\
O\
OOO
)
ll\
O\
lOOOOO\
O\
Ol\

.
z
=
llOlOO\
Ol\
OOOO\

;
ll\
OlOOOO\
OOl\
O
.
Cle\
a\
r
(
)
;
lOOll\
l\
OOOO\
Ol\

(
)
;
}
voi\
d\

Phys\
ic\
sJoi\
n\
t
::
Re\
se\
tAsType\
Slider
(
cons\
t
Vec\
3\

&
lllO\
OOlO\
Oll\

,
const
Vec3\

&
llOlOOOl\
OOOl\

,
cons\
t\

Vec3
&
ll\
OlOOO\
lO\
OlO\

)
{
ll\
OlOOOOlOOl
=
TYPE_LINEA\
R_\
S\
LIDE\
R
;
lllOl\
l\
OOO\
O
=
0
;
ll\
OOllllOlll\

=
lllOOO\
lO\
O\
ll
;
ll\
O\
Olll\
ll\
OOO
=
llOl\
OOO\
lOOOl
;
llOO\
l\
ll\
llOll
=
ll\
O\
lO\
OOlO\
O\
lO\

;
lOOll\
lOOOOOl
(
)
;
}
vo\
id
Ph\
ysic\
s\
J\
oint
::
Reset\
As\
Typ\
eRot\
ationC\
o\
ns\
t\
rai\
n\
t
(
const\

Mat33\

&
llO\
lOOOlO\
lOl
,
co\
ns\
t
Euler\
An\
gles
&
lOOlllllOlOl\

,
cons\
t
Eul\
erAngles
&
lOOlllllOl\
lO
)
{
ll\
Ol\
OOOOl\
OOl
=
TY\
P\
E\
_ROTATION_CONSTRAINT
;
lllOllO\
OOO
=
0
;
ll\
O\
Ollll\
Olll
.
Clea\
r
(
)
;
ll\
OOlllllOOO
.
Clear\

(
)
;
llOOlllllllO
=
llO\
lOOOl\
Ol\
Ol
;
llOOl\
llll\
ll\
l
=
ll\
OlOOOl\
O\
lOl
;
ll\
OlOOO\
O\
OOOO
=
lOO\
lll\
llO\
lOl\

;
llO\
lOOOOOOOl
=
lOOl\
llllOllO
;
llOlOO\
OOOOlO
.
Clea\
r
(
)
;
lOO\
lllOOOOOl\

(
)
;
}
void
Phys\
icsJoint
::
Re\
setAs\
Type\
Vector\
Cons\
tra\
int
(
const
Vec\
3
&
llOl\
O\
OOl\
lOOO\

,
con\
st
Ve\
c3
&
llOlO\
OOllO\
Ol\

,
floa\
t
lOO\
ll\
llll\
O\
lO
)
{
llO\
lOO\
O\
Ol\
OO\
l
=
TY\
PE_\
V\
EC\
TOR\
_C\
ONSTRAIN\
T
;
lllOl\
lOOOO\

=
0
;
llO\
Ollll\
Oll\
l
.
Cl\
e\
ar
(
)
;
llOOl\
llll\
OOO
.
Clear
(
)
;
llOOlll\
ll\
Ol\
l
=
ll\
OlOOOll\
OOO
;
TA_ASSE\
RT\

(
llOO\
ll\
l\
llOll\

.
IsNorm\
alis\
ed
(
)
)
;
ll\
OOllll\
llOO
=
llO\
lOOOllOO\
l
;
TA\
_\
ASSERT
(
llOO\
llllllOO
.
IsNo\
rma\
lised
(
)
)
;
llOO\
llll\
llO\
l\

=
lOOllll\
llOl\
O
;
llOlO\
OOO\
OOl\
O
.
Cle\
a\
r
(
)
;
lOOlllOO\
OOO\
l
(
)
;
}
fl\
oat\

Ph\
ysicsJ\
o\
int
::
llO\
l\
OOOll\
OlO
(
Vec3
&
ll\
OlOOOllOll
,
Vec3\

*
lO\
lOl\
lllllll
)
{
floa\
t
lOOOOllOOl\
l
;
floa\
t
lOOOO\
l\
l\
OlOO
;
SinAn\
dC\
os
(
GetMinAngles
(
)
.
x
,
lO\
OOO\
ll\
OOll
,
lOO\
OOllOlO\
O
)
;
Vec3
lO\
lll\
ll\
lllll\

(
0.0f
,
lOOO\
OllO\
lOO
,
lOOO\
O\
l\
lO\
O\
ll
)
;
Si\
n\
An\
d\
Cos
(
Get\
MaxAn\
gle\
s
(
)
.
x
,
lO\
OOOll\
O\
Oll
,
lOOOOllOl\
OO
)
;
Vec3
llO\
OOO\
OOO\
O\
OO
(
0.0f
,
lOOO\
Ol\
lOlOO
,
lOOOOllO\
O\
ll
)
;
Sin\
A\
nd\
C\
os
(
Ge\
t\
Mi\
nAngl\
es
(
)
.
z
,
lOOOOl\
lOOll
,
lOOO\
OllOlOO
)
;
Vec3
llO\
OOOOOOOOl
(
lOOOOllO\
Ol\
l
,
lOOOO\
llOlOO\

,
0.0f
)
;
SinAnd\
Cos
(
GetMaxAng\
les
(
)
.
z
,
lOOOO\
l\
lOOl\
l
,
lOOO\
OllOlOO
)
;
Vec3\

llOOO\
OOOOOl\
O
(
lOOOO\
llOOll
,
lOOO\
OllOl\
OO
,
0.0f
)
;
Vec\
3
lOOOlOO\
OlOl
=
llO\
lOOOl\
l\
Oll
;
Vec3
llOlOOO\
ll\
l\
OO\

[
4
]
;
llOl\
OOOl\
l\
lOO
[
0
]
=
llO\
O\
OOO\
OO\
OOO
.
Cross
(
llOOOOO\
OOOlO
)
;
llOlO\
OOlll\
OO
[
1
]
=
llO\
OOOOOOO\
lO
.
Cross\

(
lOlll\
ll\
llll\
l
)
;
llOlOOO\
l\
l\
lOO\

[
2
]
=
lO\
llllllllll
.
Cros\
s
(
llO\
OO\
O\
OOOOOl
)
;
llOl\
OO\
Ol\
llOO
[
3
]
=
llOOOO\
OOOO\
Ol
.
Cros\
s
(
llOOOO\
OOOO\
OO
)
;
const
float
llOlOOO\
lllO\
l
=
0.01f
;
flo\
a\
t
llO\
lOOOllll\
O
=
lOO\
OlOOOl\
O\
l\

.
Dot
(
llO\
lOOO\
ll\
l\
OO
[
0
]
)
;
float\

llO\
lOOOllll\
l\

=
lO\
OOlOOOlO\
l
.
Dot\

(
llOlOOOlll\
OO
[
1
]
)
;
float
llO\
lOO\
l\
OOOOO\

=
lOOO\
lO\
OOl\
Ol
.
Dot
(
ll\
O\
l\
OOO\
lllO\
O
[
2
]
)
;
float
llOlOOlOOOOl
=
lOOOlOOOlOl
.
Do\
t
(
llOl\
OO\
Ol\
l\
lOO
[
3
]
)
;
int
ll\
OlOO\
lOOOl\
O
=
0
;
int
llOlO\
OlOOOll\

=
-
1
;
float
lOO\
O\
l\
l\
OOlll\
O
=
llOl\
OOO\
l\
l\
l\
l\
O
;
float
lOOOllOO\
ll\
ll
=
k_f\
Ma\
xFloat
;
if
(
lOOOllOOlllO
>
llOlOOOlllll
)
{
ll\
O\
lOOlOOOll
=
llOlOOl\
OO\
OlO
;
ll\
OlO\
OlO\
OOl\
O
=
1
;
lOOO\
l\
lO\
Oll\
ll
=
lOOO\
l\
lOOlllO
;
lOO\
OllOOll\
l\
O
=
ll\
OlOOOlllll
;
}
else
if
(
lOO\
O\
ll\
OOllll
>
ll\
Ol\
OO\
Olllll
)
{
llOl\
OOlO\
OOll
=
1
;
lOOOllOOlll\
l
=
llO\
lOOOll\
lll
;
}
if
(
lOOO\
llOOlllO
>
llO\
lO\
OlOOOOO
)
{
llOlOOlOO\
Ol\
l\

=
ll\
OlOOlOO\
O\
l\
O\

;
llOlOOlOOOl\
O
=
2
;
lO\
O\
OllOOl\
lll
=
lOOO\
ll\
O\
O\
lll\
O\

;
lOOOl\
lOO\
lllO
=
ll\
Ol\
OOlOOOOO
;
}
else
if
(
lO\
OO\
ll\
O\
Ol\
lll\

>
llOlOOl\
OOOOO
)
{
llOl\
OOlOO\
Oll
=
2
;
lOOOllOOl\
lll
=
llOlO\
OlOOOO\
O\

;
}
if\

(
lOOOllOOlllO
>
llOlOOl\
OOOOl\

)
{
ll\
OlO\
OlOOOll
=
llO\
l\
OOlOOOlO\

;
llOlOOlOOO\
l\
O\

=
3
;
lOO\
OllOOll\
ll\

=
lOO\
O\
llOOlllO\

;
lO\
OOl\
lOOlllO
=
llO\
lO\
Ol\
O\
OO\
Ol
;
}
els\
e\

if
(
lOOOllO\
Ollll
>
llOlOO\
l\
O\
OOO\
l\

)
{
ll\
Ol\
O\
O\
lO\
OOll
=
3
;
lOOO\
l\
l\
OO\
ll\
ll\

=
llO\
lO\
O\
l\
OOO\
Ol
;
}
TA_ASS\
ER\
T
(
ll\
OlOO\
lOOOll\

!=
-
1
)
;
if
(
lOO\
OllOOll\
l\
O
<
-
0.01f
)
{
lOOOlO\
OOl\
O\
l
-=
llOlOOOll\
l\
OO
[
llOlOOlOOO\
l\
O\

]
*
lO\
OO\
llOOll\
lO
;
if
(
lOOOl\
lOO\
llll
>
0
)
{
}
el\
se
{
switc\
h\

(
llO\
lOO\
lOOOlO
)
{
cas\
e
0
:
if
(
llOl\
OOlOO\
Oll
==
3
)
lOOO\
lO\
OO\
lOl
=
llO\
O\
O\
O\
OOOOO\
O\

;
el\
se
if
(
ll\
O\
lOOlOOO\
ll
==
1
)
lO\
OOl\
OOO\
lOl\

=
llO\
OOO\
OOOOlO\

;
br\
eak
;
ca\
s\
e
1
:
if
(
llOlOOlO\
O\
Ol\
l\

==
0
)
lOOO\
l\
O\
OO\
lOl\

=
llOOOO\
OOOOlO
;
else\

if
(
llO\
l\
OO\
lO\
OOl\
l
==
2
)
lOOOlOOOlOl
=
lOllllll\
llll
;
break\

;
case\

2
:
if
(
llOl\
OOl\
OOOl\
l
==
1
)
lOOOlOOOlOl\

=
lOllllllllll
;
else
if
(
llOlO\
O\
l\
OOOll
==
3
)
lO\
OO\
lOO\
OlOl
=
llOOO\
O\
OOOOOl
;
bre\
ak
;
case
3
:
if\

(
llOlOOl\
O\
OO\
l\
l
==
2
)
lOO\
OlO\
OO\
lOl
=
llOO\
OOO\
O\
O\
OOl\

;
els\
e
if\

(
ll\
O\
lOO\
l\
O\
O\
Oll
==
0
)
lOOOlOO\
O\
lOl
=
llOOO\
OOOOOOO
;
break
;
default
:
lllOO\
lOOOO
;
}
}
if
(
lOlO\
lllllll\
l\

)
{
Vec3
lOOOlOOOOO
=
llOlOO\
Ol\
l\
Oll
.
Cross
(
lOO\
O\
lOOOlOl
.
Cross
(
llO\
lOOO\
ll\
Oll
)
)
;
fl\
oat
lO\
llll\
OlOl
=
lOO\
O\
l\
OOOO\
O\

.
Ge\
t\
M\
agnit\
ude
(
)
;
if\

(
lO\
l\
l\
llO\
l\
Ol
>
0.0000001f
)
*
lOlO\
ll\
ll\
llll
=
lOO\
O\
lOOOOO
/
lO\
llllOlOl\

;
el\
se
*
lOlO\
ll\
llll\
ll\

=
llOlO\
O\
O\
ll\
lOO
[
llOlOO\
lOO\
OlO
]
;
llOl\
OOOllll\
O
=
lOl\
lllOl\
Ol
;
}
}
els\
e
{
if
(
lO\
lOlllllll\
l
)
{
Ve\
c3
lOOOlOOOOO
=
llOlOO\
OllOll
.
Cro\
ss
(
lO\
OO\
l\
OOO\
lOl\

.
Cross
(
llO\
lOOOl\
l\
O\
ll
)
)
;
float
lOll\
llOl\
O\
l
=
lOO\
OlO\
O\
OOO
.
GetM\
agnitud\
e\

(
)
;
if
(
lOllllOlOl
>
0.0000001f
)
*
lO\
lOll\
ll\
l\
lll
=
lO\
OOl\
OOOO\
O\

/
lO\
lll\
l\
O\
l\
O\
l
;
else\

*
lOlOll\
llllll
=
llOlOO\
Oll\
lO\
O\

[
llOlOOlO\
O\
Ol\
O\

]
;
}
}
llOlOO\
O\
llOll
=
lOOO\
lOOO\
lOl
;
retur\
n\

llO\
l\
OOO\
llllO\

;
}
void\

Ph\
ysi\
csJ\
oint
::
Ini\
ti\
ali\
se
(
Dy\
n\
amic\
Objec\
t
*
lOlOOOOOll\
O\
l
,
Dynam\
icObj\
ect
*
lOlOO\
OO\
OlllO
)
{
TA_\
ASS\
ERT\

(
llO\
O\
ll\
lll\
OOl\

==
0
)
;
TA_\
ASS\
ER\
T\

(
llOOlll\
llOlO\

==
0
)
;
llO\
Ol\
l\
l\
l\
lOOl
=
lOlO\
O\
O\
O\
O\
l\
lOl
;
llOOlllll\
OlO\

=
lOl\
OOOOOlllO
;
#ifdef llOlOOlOOlOO
llOOlllllOOl\

->
Add\
Ref
(
)
;
if\

(
llOOl\
l\
lllO\
lO
)
llO\
Ol\
llll\
OlO
->
Ad\
dRef
(
)
;
#endif //
}
void
Physics\
Joint
::
Fin\
al\
ise
(
)
{
llOOlll\
lOlll
.
Clear
(
)
;
llOOllll\
lOO\
O
.
Clear
(
)
;
if
(
llOO\
l\
llll\
OOl
)
{
#ifdef llOlOOlOOlOO
llOOl\
l\
lllOO\
l\

->
Releas\
e\

(
)
;
#endif //
llOOlll\
llOOl
=
0
;
}
if
(
llO\
O\
llll\
l\
Ol\
O\

)
{
#ifdef llOlOOlOOlOO
llOOlllllOlO\

->
Rele\
ase
(
)
;
#endif //
llOOl\
lll\
lOlO
=
0
;
}
llO\
lOOOOOO\
lO
.
Clea\
r\

(
)
;
}
void
Physi\
csJo\
int
::
lOOl\
llOO\
OOOl
(
)
{
if
(
llOO\
ll\
ll\
l\
OOl\

)
llOO\
lllll\
OOl
->
lOO\
l\
llOOOOO\
l\

(
)
;
if
(
llO\
Ol\
l\
l\
l\
l\
O\
lO
)
llOOll\
lllOlO
->
lOOlllO\
OO\
O\
Ol
(
)
;
}
}

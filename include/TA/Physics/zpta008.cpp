//---------------------------------------------------------------------------------
// File Name: zpta008.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define llOllOlOOll
#define lOllOllOOlO
#include "CollisionObjectCapsule.h"
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef llOllOOlOOO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_COLLISIONOBJECTSPHERE_H
#include "CollisionObjectSphere.h"
#endif //
#ifndef TA_COLLISIONOBJECTLINELIST_H
#include "CollisionObjectLineList.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
#ifndef TA_COLLISION_H
#include "Collision.h"
#endif //
#ifndef lllOOOllOOO
#include "../Physics/zpta007.h"
#endif //
nam\
es\
pace
TA
{
void\

Col\
lisio\
n\
ObjectC\
a\
p\
sule
::
Ini\
ti\
al\
ise
(
co\
nst
Ve\
c3
&
lllOlOlOOOO
,
co\
ns\
t
Vec3
&
lllO\
l\
OlO\
OOl\

,
flo\
at
llll\
l\
O\
O\
OOl
)
{
lll\
OlOlOOl\
O
=
lll\
O\
lOlO\
OOO
;
ll\
lOlO\
lOO\
ll
=
ll\
lO\
l\
Ol\
OOOl
;
lOlOlOOlOlO
=
lll\
llOO\
OOl
;
lOOOOOOl\
lO\

(
ll\
l\
l\
l\
OOOOl
>=
0.0f
,
"CollisionObjectCapsule::Initialise. fRadius is < 0.")
;
lO\
OO\
O\
OO\
llO\

(
(
lllOl\
OlOOll\

-
lll\
OlOlO\
Ol\
O
)
.
Get\
Mag\
nit\
u\
de\

(
)
>
k_fMi\
n\
Flo\
at\

,
"CollisionObjectCapsule::Initialise. The capsule length is equal to zero")
;
}
void\

Coll\
i\
si\
onOb\
j\
ec\
tC\
ap\
sule\

::
Fi\
n\
alise
(
)
{
lllOlO\
lOOl\
O
.
Clear
(
)
;
lllOlOlOOll
.
Cle\
a\
r
(
)
;
lO\
lO\
lOOlOlO\

=
0.0f
;
}
voi\
d
Coll\
isionObjectCap\
s\
ule
::
Seriali\
s\
e
(
Ser\
ia\
lise\
r
&
lOOO\
lO\
llOl
,
co\
nst
Ve\
rsion
&
lllOl\
OOlO\
O\

)
{
lOOOOOOll\
O
(
lllOlOO\
lOO
<=
llOllOOll\
OO
,
"CollisionObjectCapsule::Serialise. The version number is too new.")
;
lOOOl\
OllOl
.
Se\
ria\
lise
(
lllOl\
Ol\
O\
OlO
)
;
lOOOlO\
llO\
l
.
Se\
ri\
al\
ise
(
ll\
l\
OlOlOO\
l\
l\

)
;
lOOO\
lOllOl
.
Serial\
ise\

(
lOl\
OlO\
Ol\
O\
lO
)
;
}
void
CollisionO\
bjec\
t\
Ca\
psule
::
Ren\
de\
r
(
cons\
t\

MFram\
e\

&
lOOOOOO\
OOl\

)
{
const
in\
t\

lllO\
lOlOl\
OO
=
6
;
const
int
ll\
l\
O\
lOlOlO\
l
=
4
;
Ma\
t33
ll\
l\
OlOlOllO
;
ll\
lOlOlOllO
.
SetToLookDown\
Ve\
ct\
or
(
(
lllOl\
OlOOll
-
lllOlOlOOlO
)
.
GetNormal
(
)
)
;
for
(
int\

lll\
O\
lOlO\
lll
=
0
;
lll\
OlOlOll\
l\

<
ll\
lO\
lOlOl\
OO\

;
lllOlOlOl\
ll\

++
)
{
float\

lOOOOl\
lO\
Oll
;
fl\
oat
lO\
OOO\
llO\
l\
O\
O
;
SinA\
ndCos
(
(
flo\
at
)
lll\
Ol\
OlO\
lll
/
(
float
)
lllOlO\
lO\
lOO
*
(
k_fPi
*
2.0f
)
,
lOO\
OOllO\
Ol\
l
,
lOOOOllOl\
O\
O
)
;
Vec3\

lllOl\
OllO\
OO
=
(
lllO\
lOlOl\
l\
O
.
v3X\

*
lO\
OOOllOlOO
+
lll\
O\
l\
OlOllO
.
v3Y
*
lO\
OO\
OllOO\
ll
)
;
SinAn\
dC\
os\

(
(
flo\
at
)
(
lllOlOl\
O\
lll
+
1
)
/
(
float
)
lll\
OlOl\
OlOO\

*
(
k_\
f\
Pi
*
2.0f
)
,
lOOOO\
llOOll
,
lOOOO\
l\
l\
OlO\
O\

)
;
Vec3
lllOlOl\
lOO\
l
=
(
lll\
Ol\
OlOllO
.
v3\
X\

*
lOOO\
OllOlOO
+
lllOlOlO\
llO
.
v3Y
*
lOO\
O\
OllO\
Ol\
l
)
;
{
co\
n\
st\

Vec3
lllO\
l\
OllO\
lO
[
4
]
=
{
(
ll\
lOlOl\
O\
O\
lO
+
lllO\
l\
O\
l\
l\
OO\
O
*
lO\
l\
O\
lOO\
lO\
lO
)
*
lOOO\
OO\
OO\
Ol\

,
(
lllOlOlO\
O\
lO
+
ll\
lOl\
OllOO\
l
*
lOlO\
lOO\
lO\
lO
)
*
lOOOO\
OOO\
Ol\

,
(
lll\
OlO\
lO\
Oll\

+
ll\
lO\
lOllOO\
l
*
lOl\
O\
lOOlOlO
)
*
lOO\
OOOOOOl
,
(
lllO\
lO\
lOOll
+
lllOlOl\
lOOO\

*
lO\
lOlO\
OlO\
lO
)
*
lOOOOOOOO\
l
,
}
;
const\

Vec3\

ll\
lOlOllOll\

[
4
]
=
{
lllO\
lOllO\
OO
*
lOOO\
OO\
OOOl
.
m3\
3Rotation
,
lllOlOllO\
Ol
*
lO\
OOOO\
OOO\
l
.
m33Rot\
at\
i\
o\
n\

,
lllOlOllOOl\

*
lO\
O\
OOOOO\
Ol
.
m33R\
otatio\
n
,
ll\
lOlOllOOO
*
lOOOOOO\
OOl
.
m33R\
ot\
at\
io\
n
,
}
;
Physic\
s\
Render\

::
Rende\
r\
P\
ol\
ygon\

(
4
,
lllO\
lO\
llOlO
,
ll\
lOl\
Ol\
lOll
)
;
}
for
(
int
lllOlOlll\
OO
=
0
;
lllOl\
O\
lll\
O\
O
<
lllOlOlOl\
O\
l
;
lllO\
l\
Ol\
ll\
OO\

++
)
{
SinAnd\
Cos
(
(
flo\
at
)
lllOlOlllOO\

/
(
flo\
a\
t
)
lllOlOl\
O\
lOl
*
(
k_f\
Pi
)
,
lO\
OOOllOOll
,
lOOOOl\
lOlO\
O
)
;
Vec\
3
lllOlOlllOl\

=
lllOlOl\
l\
OOO
*
lOO\
OOllO\
lO\
O\

+
lllO\
lOlOl\
lO\

.
v3\
Z
*
lOOOO\
llOOll
;
Vec3
ll\
lOlOllll\
O\

=
lllO\
lOll\
OO\
l\

*
lOO\
OOl\
lO\
lOO
+
ll\
lOl\
OlOl\
lO
.
v3\
Z
*
lOOOOllOOll
;
SinAndCos
(
(
floa\
t
)
(
lllO\
lOlllO\
O\

+
1
)
/
(
float
)
lllOlOlO\
lOl
*
(
k_f\
P\
i\

)
,
lOOOOllO\
O\
ll\

,
lO\
O\
OOll\
OlO\
O
)
;
Vec3\

ll\
l\
OlOlllll
=
lllOlOllOOO\

*
lO\
O\
OO\
l\
lO\
lOO
+
lllOlO\
lOll\
O
.
v3Z
*
lOOOOll\
OO\
ll
;
Vec3\

lllOllOOO\
OO
=
lll\
Ol\
O\
llO\
Ol\

*
lOO\
O\
O\
ll\
O\
l\
OO\

+
lllOl\
Ol\
OllO\

.
v3Z
*
lO\
OOOl\
l\
O\
Ol\
l
;
{
const
Ve\
c\
3
lllOlO\
llO\
l\
O
[
4
]
=
{
(
lllOl\
Ol\
OOlO
-
ll\
l\
O\
lO\
lllO\
l
*
lOl\
O\
l\
OOlOl\
O
)
*
lOOOOO\
OOOl
,
(
lllOlOlOOlO
-
lllOl\
Ollll\
l
*
lOlO\
l\
OOl\
O\
lO
)
*
lOO\
OOOOOOl
,
(
lllOlOlOOlO
-
lllOll\
OO\
OOO
*
lOlOlOOlOl\
O\

)
*
lO\
OOO\
OOOOl
,
(
lll\
O\
l\
O\
l\
O\
OlO\

-
lll\
OlO\
l\
lllO
*
lOl\
OlOOlOlO
)
*
lOOOOOO\
O\
Ol
,
}
;
const
Vec3
ll\
lOlOll\
Oll
[
4
]
=
{
-
lllOlO\
ll\
l\
Ol
*
lOO\
OO\
OO\
O\
Ol
.
m33Ro\
tat\
io\
n\

,
-
lllOl\
O\
lllll
*
lOOOOOOOOl
.
m33\
R\
otation
,
-
lllOllOOO\
OO
*
lOO\
OOOO\
O\
Ol
.
m3\
3R\
otation
,
-
ll\
lOl\
OllllO
*
lOO\
OOOO\
OOl
.
m33Ro\
tati\
on
,
}
;
Phy\
s\
ic\
sRend\
er
::
Re\
nderPolygon\

(
4
,
lllOlOll\
OlO
,
lllOlOll\
Ol\
l
)
;
}
{
const
Ve\
c3
lllOlOl\
lOl\
O
[
4
]
=
{
(
lllOlOlO\
Ol\
l
+
lllOlOlllOl
*
lO\
l\
Ol\
O\
O\
lOlO
)
*
lOOOOOOOOl
,
(
ll\
lOlOlO\
Oll
+
lllOl\
Ol\
l\
lll
*
lOlO\
lOOlOlO\

)
*
lOOOOOOOOl
,
(
lllOlOlOO\
ll
+
ll\
lOll\
OOO\
OO
*
lO\
lO\
l\
OO\
lO\
l\
O
)
*
lO\
OO\
OOO\
OO\
l
,
(
lllOlO\
lOOll\

+
lllOlOl\
lllO
*
lOlOlOO\
lOlO
)
*
lOOO\
OOOOO\
l\

,
}
;
cons\
t
Vec3\

lll\
Ol\
Ol\
lOll\

[
4
]
=
{
lll\
OlO\
lllOl
*
lOOOOOO\
O\
O\
l
.
m33Ro\
tatio\
n
,
ll\
lOlOl\
llll
*
lO\
OOOO\
OOOl
.
m3\
3Ro\
t\
a\
tion\

,
lllOllOO\
OOO
*
lOO\
OO\
OOOOl
.
m33\
Rotati\
o\
n\

,
lll\
Ol\
Olll\
lO
*
lOOOOOOO\
Ol
.
m33\
Rotat\
io\
n
,
}
;
Physics\
Render
::
Ren\
derPolygo\
n
(
4
,
lll\
Ol\
OllOl\
O
,
lll\
O\
l\
O\
l\
lOll
)
;
}
}
}
}
AABB
Co\
llis\
ionObj\
e\
c\
tCapsule
::
Calc\
ul\
a\
teB\
oun\
din\
gB\
o\
x
(
)
const\

{
AABB
lOOO\
OOOl\
l\
l
;
lOOOOOO\
lll
.
In\
it\
ialis\
e\
ToFit2Po\
i\
n\
t\
s
(
ll\
lOl\
Ol\
OOlO
,
lllO\
lOlOOll\

)
;
lO\
O\
O\
O\
OO\
ll\
l
.
v3Ext\
ent\

.
x
+=
lOl\
O\
lO\
OlO\
lO\

;
lOOO\
O\
O\
Olll
.
v3\
Exten\
t
.
y
+=
lOlOlO\
OlOl\
O
;
lOOO\
OO\
Ol\
l\
l
.
v3E\
xten\
t
.
z
+=
lOlOlOO\
lOlO
;
return
lOO\
OO\
OOl\
l\
l
;
}
voi\
d
Col\
lision\
Ob\
j\
ectC\
a\
p\
s\
ule
::
Cal\
c\
ul\
ateMas\
s
(
flo\
at\

lllOllOO\
OOl
,
float
&
lOllO\
O\
OOll\
O
,
Vec3\

&
lllOllOOOl\
O
,
Mat33\

&
ll\
lOllOO\
Ol\
l
)
const
{
fl\
oa\
t
lOOl\
Ol\
l\
OOO
=
(
lllOlOl\
OOl\
O
-
lllOlOl\
OO\
ll\

)
.
Get\
M\
ag\
nit\
ude
(
)
;
flo\
at\

lllOl\
lOOl\
OO
=
lOOlOllOOO
*
k_fPi
*
lOlOlO\
OlOl\
O\

*
lOlO\
lOOl\
OlO
*
ll\
lOllO\
OOOl\

;
float
lll\
OllOOlO\
l
=
(
k_f\
Pi
*
4.0f
/
3.0f
)
*
lO\
l\
OlOO\
l\
OlO
*
lOlO\
lOOlO\
lO
*
lOlOlO\
OlO\
lO
*
ll\
lO\
llOOOOl
;
lOllOOOO\
ll\
O
=
lllOll\
O\
OlOl
+
lllOllOO\
lOO\

;
ll\
lO\
ll\
OO\
Oll\

.
SetToIde\
ntity
(
)
;
lllOllOOOll\

.
M11
(
)
=
ll\
l\
OllOOlOO
*
(
0.25f
*
lOlO\
lOOlOlO
*
lO\
lOl\
OOlOlO
+
(
1.0f
/
12.0f
)
*
lOOlOll\
OOO
*
lOOlOllO\
OO
)
;
lllOl\
lOOOl\
l
.
M22
(
)
=
ll\
l\
O\
llOO\
Oll
.
M11
(
)
;
ll\
lOllOOOll
.
M33
(
)
=
(
lll\
O\
l\
lOOlOO
*
0.5f
+
lllOl\
lO\
O\
lOl\

*
0.4f
)
*
lOlOl\
O\
OlOlO
*
lOl\
O\
lO\
O\
lOlO
;
Mat33
lllO\
lO\
lOllO
;
lll\
OlOlOl\
lO
.
Se\
t\
ToLoo\
k\
Down\
Vector
(
(
lllOlO\
lOOl\
l
-
ll\
l\
O\
lOlO\
O\
lO
)
/
lOOlOllOOO
)
;
Ma\
t33
ll\
lOl\
lO\
O\
llO\

;
lll\
OllOOOll
=
ll\
lO\
lOl\
OllO
.
GetTransposeAsInver\
se\

(
)
*
ll\
lOllOOO\
ll
*
ll\
lOlO\
lOll\
O
;
lllO\
llO\
O\
Ol\
O\

=
(
lllOlO\
lOOl\
O\

+
lllOlOlOOll
)
*
0.5f
;
}
boo\
l
Collisi\
onO\
bjectC\
ap\
sule\

::
Tes\
tLin\
eF\
o\
rColl\
is\
ion
(
con\
st
Vec\
3
&
lOOlO\
lO\
lll\

,
cons\
t
Vec3
&
lOOOlOO\
OOO
,
float
lOOlOllO\
OO
,
Collisi\
on
&
llOllll\
Olll\

)
con\
s\
t\

{
Vec3\

lOOlOllOOl
=
lOOl\
OlOlll\

+
lO\
OOl\
OO\
O\
OO\

*
lO\
O\
lO\
llOOO\

;
fl\
oat
llll\
OlOOll
;
Vec3
lOlll\
l\
OOl\
l
;
Vec3\

lOll\
l\
l\
Ol\
OO
;
bo\
o\
l
lllOl\
lOO\
lll\

=
fa\
lse
;
if
(
Ge\
ometry
::
TestP\
o\
intMo\
v\
ement\
A\
gainst\
Sph\
e\
r\
e
(
lOOlOl\
Olll
,
lOO\
lO\
llO\
Ol
,
lllOlOl\
O\
OlO
,
lOlOlO\
OlO\
lO
,
llllOlOOll\

,
lOllllOOll
,
lOllll\
O\
lO\
O
)
)
{
if
(
lOll\
ll\
OlOO
.
Dot
(
lllOlOl\
OOll\

-
ll\
lOlOlOOlO
)
<
0.001f
)
{
floa\
t
lOlOlllOOl
=
lOOOlOO\
O\
OO
.
Dot
(
lOlll\
lOOll\

-
lOOl\
Ol\
Olll
)
;
if
(
lOl\
Olll\
OOl
<
llOl\
ll\
lO\
ll\
l\

.
lO\
llO\
O\
lO\
Oll
)
{
Vec3
lllOllO\
l\
OOO
=
lOOlOlOll\
l
+
lOlOll\
lOO\
l
*
lOOOlOOOO\
O
;
llOllllO\
l\
ll
.
In\
itiali\
se
(
0
,
0
,
lOlOlll\
OOl
/
lOO\
lO\
llOOO\

,
lOl\
Oll\
lOOl\

,
lOllllO\
Oll\

,
lO\
llllOl\
OO\

)
;
llOllll\
Oll\
l
.
SetCo\
llision\
Ob\
je\
ctA
(
const_\
cast
<
Coll\
isionObject\
C\
a\
psule
*
>
(
thi\
s\

)
)
;
lllOllO\
Ol\
ll\

=
tr\
u\
e
;
}
}
}
if
(
Geome\
try\

::
TestP\
ointMovementAgainstSphere
(
lOO\
lOlO\
lll\

,
lOOlO\
l\
lOOl
,
ll\
lO\
lOlOO\
ll
,
lOlOlOOl\
OlO\

,
llllOlO\
O\
ll
,
lOl\
lll\
OO\
ll\

,
lOl\
lllO\
lOO
)
)
{
if\

(
lOl\
ll\
lOlOO
.
Do\
t
(
ll\
lOl\
O\
lOOlO\

-
ll\
lOlOlO\
Oll
)
<
0.001f
)
{
float
lO\
lOlllOOl\

=
lO\
O\
OlOOOO\
O
.
Dot
(
lOllll\
OOl\
l\

-
lOOlOl\
Ol\
ll
)
;
if\

(
lOlOlllO\
Ol
<
llOllll\
Olll
.
lOl\
lOOlO\
Ol\
l
)
{
Vec3
ll\
lOllOlOOO
=
lOOl\
OlOlll
+
lOlOll\
l\
OOl
*
lO\
OOlOO\
OOO
;
llOllllOl\
l\
l
.
Ini\
t\
ia\
l\
ise
(
0
,
0
,
lO\
lOll\
l\
O\
Ol
/
lO\
O\
lOll\
OO\
O\

,
lOlOll\
lOOl
,
lO\
lll\
lOO\
ll\

,
lOl\
l\
llOlOO
)
;
llOl\
l\
l\
l\
Ol\
ll
.
Se\
tCollisi\
onObjec\
tA
(
cons\
t_cast
<
Colli\
s\
i\
onObje\
c\
tCa\
psule\

*
>
(
th\
i\
s
)
)
;
ll\
lO\
llOOl\
ll
=
true
;
}
}
}
if\

(
Geometry
::
Te\
stSph\
ereMove\
mentAgainstL\
i\
n\
e
(
lO\
OlO\
lO\
ll\
l\

,
lO\
OlO\
l\
l\
O\
Ol
,
ll\
lO\
lOlOO\
lO\

,
lllOlOl\
OO\
ll\

,
lOlOlOOlOlO
,
llllOlOOll
,
lO\
lll\
lOO\
ll
,
lOl\
ll\
lOlO\
O
)
)
{
lOll\
llOOll
+=
lOl\
lllOlOO
*
lOlO\
lOOlOl\
O
;
float\

lOlOlllOOl
=
lOOOlOO\
OOO
.
Dot
(
lOll\
ll\
O\
Oll
-
lOOlOlOlll
)
;
if
(
lOlOll\
l\
OOl
<
llOl\
l\
l\
lO\
l\
l\
l\

.
lO\
llOOlOOll
)
{
llOll\
llOl\
l\
l
.
Initialis\
e
(
0
,
0
,
lO\
lOll\
l\
OO\
l
/
lOOlOllOOO
,
lOl\
O\
lllOO\
l\

,
lO\
l\
lllOOll
,
lOll\
l\
lOlOO\

)
;
llOll\
llO\
lll\

.
SetColli\
sionOb\
je\
ctA\

(
const_cast
<
Co\
llis\
i\
onObje\
ct\
C\
ap\
sule
*
>
(
this\

)
)
;
lllOllOOl\
ll\

=
true
;
}
}
return\

lllO\
l\
lOOlll
;
}
Coll\
i\
s\
i\
onOb\
jec\
tCapsu\
le
*
TA\
C_CAL\
L
Coll\
i\
sion\
O\
bj\
e\
c\
tC\
apsul\
e
::
CreateN\
ew
(
)
{
Coll\
ision\
Obj\
ect\
Cap\
sule
*
lOlO\
ll\
O\
lOO\
l
;
lOOOOO\
llOlO
(
lO\
l\
OllO\
lOO\
l
,
Collis\
io\
nObject\
Capsu\
l\
e
)
;
retu\
rn
lOlOll\
O\
l\
OO\
l
;
}
Collis\
io\
nO\
bjectCap\
sule
::
Collis\
i\
o\
n\
O\
bjec\
tCa\
psu\
l\
e
(
)
:
CollisionObject\
S\
im\
ple
(
Colli\
sio\
nObject
::
TY\
PE_CAPSULE
)
{
lllO\
lOlO\
OlO
.
Clear\

(
)
;
lllO\
lO\
lO\
Ol\
l\

.
Cle\
ar
(
)
;
lOl\
Ol\
OO\
lO\
lO
=
0.0f
;
}
Co\
llisi\
o\
nOb\
jectCap\
sule
::
~
Co\
l\
lision\
Ob\
jec\
tCa\
p\
sule
(
)
{
Final\
ise
(
)
;
}
static
inli\
ne
bool
TAC_CA\
LL\

ll\
lO\
ll\
O\
lOOl\

(
con\
st
Vec3
&
lllOlOl\
OOOO
,
co\
nst
Ve\
c3\

&
ll\
lOlOl\
OOOl
,
co\
nst
Vec\
3
&
lll\
OllOlO\
lO
,
co\
nst
Ve\
c3
&
ll\
l\
Ol\
lOl\
Oll
,
lOllOl\
lOl\
lO
lllOOOOlOOl
,
void
*
lllO\
l\
lOl\
lOO
)
{
return
false\

;
}
#ifndef DOXYGEN
vo\
id
TA\
C_CA\
LL
lllOllOl\
lOl
(
const
MF\
rame
&
lO\
lllOOOOOl\

,
co\
ns\
t
MFrame\

&
lOlll\
OO\
OOlO
,
lO\
l\
lO\
ll\
lOOO
*
lO\
lllO\
OOOl\
l
)
{
TA_\
A\
SS\
E\
RT
(
lOlllOOO\
Ol\
l\

->
lOllO\
OOllll\

->
GetCo\
llisi\
onObjectTyp\
e
(
)
==
Col\
lisio\
n\
Object
::
TYP\
E_CAPS\
ULE
)
;
co\
ns\
t
Col\
li\
sion\
Objec\
tCapsu\
l\
e\

&
lllOll\
O\
ll\
lO
=
*
(
cons\
t
Colli\
s\
i\
onObje\
ctCapsul\
e
*
)
lOlll\
OOOO\
ll
->
lOl\
lOOOl\
lll
;
TA\
_A\
S\
SE\
RT\

(
lOlllOO\
OOl\
l
->
lOllOOlOOOO\

->
GetColl\
isi\
onObject\
Type
(
)
==
Co\
llis\
ionO\
b\
j\
e\
ct
::
TY\
PE\
_CA\
PSULE\

)
;
co\
nst
Colli\
s\
ionOb\
je\
ct\
Cap\
s\
ule\

&
ll\
lO\
llOllll
=
*
(
const\

Co\
lli\
si\
onO\
bjectCapsule
*
)
lOll\
lOOOOll
->
lOl\
lOOlOOOO
;
const\

floa\
t\

lOllOlO\
lll
=
0.0001f
;
Vec3
lllOlll\
O\
OOO
=
lllOll\
Ol\
l\
lO
.
lllOlOlOOl\
O\

*
lOlllOO\
OOOl
;
Vec3
lll\
Oll\
lOOOl\

=
ll\
lOllOlllO
.
lllOlOlOOll\

*
lOll\
lOOOOOl
;
Vec\
3\

lllOlllOOlO
=
ll\
lOllOlllO\

.
lll\
OlOlOOlO\

*
lOl\
llO\
OO\
Ol\
O\

;
Vec3
lllO\
ll\
lOO\
ll
=
ll\
l\
Ol\
lOlllO
.
lllOlOl\
OOll
*
lOl\
llO\
OOO\
lO
;
flo\
at
lllOll\
l\
O\
lOO
=
ll\
lOl\
lOlll\
O\

.
lOlOl\
OOlOlO\

+
lllOl\
lOllll
.
lO\
l\
OlOOlOlO\

;
bo\
o\
l
lllO\
lllOlOl
=
false
;
if
(
lllOlllO\
lOl
)
return\

;
Ve\
c\
3\

lllOl\
llOllO
;
Vec3
lllOlllOll\
l
;
Geometr\
y\

::
Fi\
n\
dC\
l\
osestPoin\
tOn\
LineT\
o\
Line
(
lllOlllO\
O\
OO\

,
lll\
OlllOOOl
,
lllOllOl\
lll\

.
lllO\
lOlOOl\
O
,
lllO\
llOllll
.
lll\
Ol\
OlOOll\

,
lllOll\
lOllO
,
lllOlllO\
lll
)
;
Vec3
lOOO\
l\
O\
O\
OOO
=
lll\
O\
l\
l\
lOllO
-
lllO\
lllOlll\

;
float\

lllOO\
l\
Olll
=
lO\
O\
OlOOOO\
O
.
GetMagn\
itu\
de\
Sq\
rd\

(
)
;
if
(
lllOOlO\
ll\
l\

<
lllOl\
llO\
lOO
*
lllOlll\
OlOO\

&&
lllOOl\
Olll
>
lOll\
Ol\
Olll
)
{
fl\
oa\
t
lOll\
ll\
O\
lOl
=
Sqr\
t\

(
ll\
lOO\
lOlll
)
;
lOO\
OlOOO\
OO
/=
lOll\
ll\
O\
l\
O\
l
;
Collisio\
n
lOll\
OllOlll
;
lOllOll\
Ol\
ll
.
Initial\
ise
(
Colli\
si\
on
::
lOllOlOOOO\
O
,
0.0f
,
lllOlllOl\
OO
-
lOllll\
O\
l\
Ol
,
(
lllOlllO\
ll\
O
+
lllOlllOl\
l\
l
)
*
0.5f
,
lOOOl\
OOOOO
)
;
if
(
!
lll\
O\
l\
l\
llOOO
(
lOl\
lO\
llOlll\

,
lOl\
llOOOOll\

)
)
return\

;
}
else
if
(
lOlll\
O\
OO\
Ol\
l
->
lOllOl\
l\
lOl\
l
)
{
float
ll\
llOlO\
Oll
;
Ve\
c3
lOlll\
lOOll
;
Vec\
3
lO\
lll\
l\
Ol\
OO
;
if
(
Geometry
::
TestL\
i\
neMovement\
Agai\
nstCa\
psule
(
lll\
O\
lllO\
OO\
O
,
lll\
Ol\
ll\
OOOl
,
lllOll\
lOOl\
l
,
lllOllOlll\
O\

.
lll\
OlOl\
OOl\
l
*
lOl\
ll\
OO\
OOlO
,
lllO\
llOl\
lll
.
lll\
Ol\
O\
lOOlO
,
lllO\
ll\
O\
l\
l\
ll
.
ll\
lOl\
OlOOll
,
lllO\
l\
llOlO\
O
,
ll\
llOlOOll
,
lO\
llllOOll\

,
lO\
l\
lll\
Ol\
OO
)
)
{
Colli\
sio\
n
lOllOllOlll
;
lOl\
lOllO\
lll
.
In\
itiali\
se
(
Collisi\
on\

::
lOl\
lO\
lOOOO\
O
,
ll\
l\
l\
OlOOl\
l
,
0.0f
,
lOllllOOll
,
-
lOllll\
OlO\
O
)
;
if\

(
!
lllOll\
l\
lOOO
(
lOllOllOll\
l
,
lOlllOOOO\
ll
)
)
re\
t\
u\
r\
n
;
}
}
}
voi\
d
TAC_CALL
lllOllll\
OOl\

(
const
MFr\
a\
me
&
lOl\
llOOOOOl
,
const
MF\
ram\
e
&
lOlllOOOO\
lO
,
lO\
llO\
l\
l\
lOOO
*
lOll\
lOOO\
Oll
)
{
TA_\
A\
SSERT
(
lOll\
l\
O\
OOOl\
l\

->
lOllOOOllll
->
GetColl\
i\
si\
onO\
bjectType
(
)
==
Co\
lli\
sionObject
::
TYPE_SP\
HER\
E
)
;
con\
st\

Col\
lis\
ionObject\
Sphere
&
lll\
Ol\
lllOl\
O
=
*
(
const\

Colli\
sionObject\
Sphere\

*
)
lOl\
llO\
OOOll
->
lO\
llO\
OOl\
l\
ll
;
TA_ASSERT
(
lOl\
llOOOOll
->
lO\
llO\
OlOO\
O\
O\

->
GetC\
ollisio\
n\
ObjectTy\
pe
(
)
==
Coll\
isi\
on\
Ob\
j\
e\
c\
t
::
TYPE_C\
AP\
SULE\

)
;
co\
n\
st
Col\
lisionObject\
Ca\
psule\

&
lOl\
l\
lO\
l\
OOl\
O
=
*
(
con\
st
Colli\
s\
i\
onO\
bjectC\
a\
ps\
ule
*
)
lO\
lll\
OOOOll
->
lOl\
lOOlOOO\
O
;
cons\
t
float
lO\
llOl\
Oll\
l
=
0.0001f
;
Vec3\

ll\
l\
Ol\
lllO\
ll
=
lllO\
l\
l\
ll\
Ol\
O
.
ll\
l\
OO\
OOll\
OO
*
lOlll\
OO\
OOOl
;
fl\
oa\
t\

lllO\
lllOlO\
O
=
lOlllO\
lO\
OlO
.
lOl\
O\
lOOlO\
l\
O\

+
ll\
l\
Olll\
l\
OlO
.
lOl\
OlO\
OlOlO
;
Vec3
lOl\
lllOO\
ll
=
Geo\
me\
try\

::
Fi\
nd\
C\
l\
osestP\
ointOnL\
i\
ne
(
lll\
O\
l\
lllO\
ll
,
lOlllOlOOl\
O
.
lllOlO\
lOOlO\

,
lO\
l\
llOl\
OOlO\

.
lllOlOl\
OOll
)
;
Ve\
c3
lO\
OOlOO\
OOO
=
lll\
OllllOll\

-
lOl\
lllOOl\
l
;
floa\
t\

lll\
OOl\
Ol\
ll
=
lO\
OOl\
O\
OOOO\

.
GetMa\
g\
n\
i\
tude\
Sqrd\

(
)
;
if
(
lll\
OOl\
O\
lll\

<
lllO\
lllOlO\
O
*
lllOl\
l\
l\
OlOO
&&
ll\
lOOlO\
lll\

>
lOl\
lOlO\
l\
ll
)
{
lOOOl\
O\
OOOO\

/=
Sqrt
(
lllOOl\
Olll
)
;
Col\
l\
is\
ion\

lOllO\
llO\
l\
ll\

;
lOllOllOl\
ll\

.
Init\
i\
a\
li\
se
(
Co\
lli\
si\
on
::
lOllOlO\
O\
OO\
O\

,
0.0f
,
lllO\
l\
llO\
l\
OO
-
Sqr\
t
(
lllO\
OlO\
l\
ll
)
,
(
lOl\
l\
llOOl\
l
+
lllOllllOll\

)
*
0.5f
,
lO\
O\
O\
lOOOOO
)
;
lll\
OllllO\
OO\

(
lOl\
l\
OllOl\
ll
,
lOl\
llO\
OOO\
ll
)
;
retu\
rn
;
}
Vec3
lllOlll\
llOO
=
lll\
O\
lll\
l\
OlO
.
ll\
l\
OO\
OOllOO\

*
lOll\
lO\
OOOl\
O
;
float
lll\
lOl\
OO\
ll
=
0.0f
;
if
(
!
lO\
ll\
lOOO\
Oll
->
lOllOlllOll\

)
return
;
if\

(
Geo\
metry
::
TestPointM\
ov\
e\
ment\
Aga\
in\
s\
tS\
p\
h\
ere
(
lllOllll\
Ol\
l
,
lllOlllllOO
,
lOlllOlOOlO
.
lllOlO\
lOOlO
,
ll\
lOlllOlOO
,
llllO\
lO\
Ol\
l
,
lOl\
lllO\
Oll\

,
lOOOlOOOO\
O
)
)
{
if\

(
lO\
OOlOOOOO\

.
Dot
(
lOlllOlOOlO\

.
lllOlOlOOlO
-
lOl\
ll\
OlOOlO\

.
lllOl\
OlO\
Oll
)
>
0.0f
)
{
lO\
llll\
OOll
+=
lO\
OOl\
OOOOO
*
lOlllO\
lOOlO
.
lOlOl\
O\
O\
lOlO
;
Collis\
io\
n
lOll\
Ol\
lOlll
;
lOllO\
llOl\
ll
.
Initialise
(
Collis\
io\
n
::
lO\
llOlOOOOO
,
llllO\
lO\
Oll\

,
0.0f
,
lOll\
ll\
OOll
,
lOO\
O\
l\
OOOOO
)
;
ll\
lOll\
llOOO
(
lOllOl\
lOlll
,
lOll\
lOOOO\
ll
)
;
return
;
}
}
if\

(
Geo\
metry
::
Te\
stPoi\
nt\
Movemen\
t\
AgainstS\
p\
he\
re
(
lllOl\
lllOl\
l
,
ll\
lOlllll\
OO
,
lOlllOlOOlO
.
lllOlO\
lOOl\
l
,
lll\
Oll\
lOlOO
,
llllOlOOl\
l
,
lOllllO\
Oll\

,
lOOOl\
OOOOO
)
)
{
if\

(
lO\
OOl\
OOOO\
O
.
Do\
t
(
lOlllOlOOl\
O
.
lllOlOlO\
O\
ll
-
lOlllOlOOl\
O\

.
lllOlOlOOl\
O
)
>
0.0f
)
{
lOl\
ll\
lOOll
+=
lOOOl\
OOOO\
O
*
lO\
l\
llO\
lOOl\
O
.
lOl\
OlOO\
l\
Ol\
O\

;
Collisi\
on\

lO\
llOll\
Olll
;
lOllO\
llO\
lll\

.
Init\
ia\
li\
se
(
Co\
l\
lision\

::
lOll\
OlOOOO\
O
,
ll\
l\
lOlOOll
,
0.0f
,
lOll\
llOOll
,
lOO\
O\
l\
OOOO\
O
)
;
lll\
Ol\
lllOO\
O
(
lOllOl\
lOlll
,
lO\
lllOO\
O\
O\
ll
)
;
ret\
u\
r\
n
;
}
}
if
(
Geome\
tr\
y
::
Te\
s\
tSph\
ereMo\
v\
ementA\
gain\
stLine
(
ll\
lOll\
l\
lOll
,
ll\
lO\
ll\
lll\
O\
O
,
lO\
ll\
l\
O\
l\
OO\
lO
.
lllOlOlO\
Ol\
O\

,
lOlll\
Ol\
OOlO
.
ll\
lOlOlO\
O\
ll
,
lllOlll\
O\
l\
OO
,
llll\
O\
l\
O\
Ol\
l
,
lOllllOOll\

,
lOOO\
lOO\
O\
O\
O\

)
)
{
lOl\
l\
llOOll\

+=
lO\
OOlOOOOO\

*
lOlll\
Ol\
OOl\
O
.
lOlOlO\
OlOlO
;
Coll\
ision
lOll\
O\
l\
l\
O\
lll
;
lOll\
Oll\
Olll
.
Initiali\
se
(
Collision
::
lO\
llOlO\
O\
OOO
,
llllOl\
O\
Ol\
l\

,
0.0f
,
lOllll\
OOll\

,
lOOO\
lO\
O\
OOO
)
;
lllOlll\
lOOO
(
lOll\
O\
l\
lOll\
l\

,
lOlllOO\
OOll
)
;
return
;
}
}
void
TAC_CA\
LL\

lllOlll\
ll\
O\
l
(
co\
nst
MF\
rame
&
lOlllOOOOO\
l\

,
con\
st
MFra\
m\
e
&
lOlllOO\
OOlO
,
lOll\
Ol\
llOOO
*
lOlll\
OO\
OOll
)
{
lllO\
O\
ll\
O\
OlO\

(
)
;
TA_ASSERT
(
lOlllOO\
OO\
l\
l\

->
lOllOOO\
llll
->
Ge\
tCo\
lli\
sionO\
bj\
e\
ctT\
y\
p\
e\

(
)
==
Co\
l\
lis\
i\
on\
O\
b\
jec\
t
::
TYPE_CA\
P\
S\
ULE\

)
;
co\
nst
Coll\
isi\
onO\
bj\
ectCapsul\
e
&
lO\
lll\
OlOO\
l\
O
=
*
(
const\

Collisi\
onO\
bje\
ctCap\
su\
le
*
)
lOll\
lOOOOll
->
lOll\
O\
OOlll\
l
;
TA\
_ASSERT
(
lOl\
llOO\
OOll
->
lO\
llOO\
lO\
O\
OO
->
Get\
Co\
ll\
i\
sion\
Objec\
tType
(
)
==
Coll\
isionObje\
ct\

::
TYPE_CA\
CHED\
_P\
O\
LY_\
DATA
)
;
const\

Col\
lisi\
onObjectC\
ache\
dPolyDa\
t\
a
&
llOll\
lllO\
O\
l
=
*
(
const
Collisi\
onObject\
Ca\
c\
hedP\
olyD\
a\
ta
*
)
lOl\
ll\
OOO\
Oll\

->
lOl\
lOOlOOO\
O
;
Vec3
lOlll\
OlOOOO
[
2
]
;
lO\
l\
llOlOO\
OO
[
0
]
=
lOlllOlOOl\
O
.
lll\
Ol\
O\
lO\
OlO
*
lOlllO\
OOOOl\

;
lO\
lllOlOOOO
[
1
]
=
lOlllOlOOl\
O
.
lllOlOlO\
Oll
*
lOl\
llO\
O\
OOOl
;
Ve\
c\
3
lOll\
ll\
O\
OOll\

[
2
]
;
lOlll\
lOOOl\
l
[
0
]
=
lOl\
llOlOOlO
.
lll\
OlOlOOlO
*
lO\
ll\
lO\
OOO\
lO
;
lOll\
llOOOll
[
1
]
=
lOlllOlOO\
lO
.
ll\
l\
Ol\
O\
l\
OO\
ll
*
lO\
l\
llOOOOlO
;
for\

(
int
lllOllllllO
=
0
;
lllOllllllO
<
llO\
l\
l\
lllO\
Ol\

.
ll\
lOlOO\
lOlO
(
)
;
)
{
const
Colli\
sion\
Obje\
ctCac\
he\
d\
PolyD\
a\
ta
::
Polygon
*
llOOO\
l\
Ol\
OO
=
(
const
CollisionOb\
jectCac\
he\
dPol\
yData
::
Po\
lygo\
n
*
)
llOll\
ll\
lOO\
l
.
lllO\
l\
OOlOOl
(
lllOl\
lll\
l\
lO\

)
;
lllOll\
llllO
+=
llOl\
llll\
OOl
.
lllOO\
llOO\
Ol
(
llOOOlOlO\
O
->
lOllO\
lll\
Ol
)
;
#define lOlllOlOlOl(lOOOllOOOl) llOOOlOlOO->llOllllOlO[lOOOllOOOl].lOOOOlllll
#define lOllllOOOlO(lllOlllllO, lllOlllllll, llOOOlOlOO, lOOOOlllll, lOOOlOOOOO)								\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lOllOllOlll.lOllOOlOOlO = llOOOlOlOO->llOlllOlOOO;														\
	lllOOllOlll(lOllOllOlll, lOlllOOOOll);							\
}
#define lOlllOlllOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOlO) \
	lllOlOOOllO(lllOlllllO, lllOlllllll, llOOOlOlOO->llOlllOlOOO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOlO)
#define lOllllOOOOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lOlllOlOOl, lllOOlllOll, lllOOOlllOO, lOOOOlllll, lOOOlOOOOO) \
	lllOOlllOlO(lllOlllllO, lllOlllllll, llOOOlOlOO, lOlllOlOOl, lllOOlllOll, lllOOOlllOO, lOOOOlllll, lOOOlOOOOO)
#define lOlllOllOll(lllllllll, lOOOOOOOOO, lOllOlOlOlO) \
	lllOlOOOlll(lllllllll, lOOOOOOOOO, lOllOlOlOlO)
#define lOllllOOOOO(lllOOOlllOO) \
	lllOlOOOOOO(lllOOOlllOO, lllOlOOOOOl)
#define lOlllOlOOOl(llOOlllllO) (llOOOlOlOO->lOOOlOOOOO.Dot((llOOlllllO) - llOOOlOlOO->llOllllOlO[0].lOOOOlllll))
co\
nst
bo\
ol
lOlll\
l\
O\
lOOl
=
false
;
#include "../Physics/zpta002.inl"
#undef lOlllOlOlOl
#undef lOllllOOOlO
#undef lOlllOlOOOl
#undef lOlllOlllOl
#undef lOllllOOOOl
#undef lOlllOllOll
#undef lOllllOOOOO
}
lllOOllOOll\

(
lO\
l\
llOOOOll
)
;
}
void
TAC\
_\
CALL
llll\
OOOOOOO\

(
cons\
t
MFrame\

&
lOlllOOOO\
Ol
,
const
MFrame\

&
lOll\
lOOOO\
l\
O
,
lOllOlll\
OOO
*
lOlllOOOOll
)
{
TA_A\
SSER\
T
(
lOl\
llOOOOl\
l
->
lO\
ll\
OO\
O\
llll
->
Get\
C\
olli\
si\
onO\
bjectTy\
pe\

(
)
==
Coll\
isi\
on\
Obj\
e\
ct
::
TYPE_C\
A\
P\
SULE
)
;
TA_ASSERT
(
lOl\
llOOO\
Oll
->
lO\
ll\
O\
Ol\
OOOO\

->
Ge\
tCollision\
Obj\
ec\
t\
T\
ype
(
)
==
Collis\
ion\
Obj\
e\
c\
t\

::
TY\
PE\
_\
LINE_\
LI\
ST
)
;
cons\
t\

Col\
lis\
ionO\
b\
je\
c\
t\
C\
aps\
ule
&
lOl\
l\
lOlOOlO\

=
*
(
Colli\
sionO\
bje\
ctCap\
s\
ule
*
)
lOlllO\
O\
OOll
->
lO\
llOOO\
llll
;
const
Colli\
sionObj\
ect\
Li\
n\
eList
&
llllOO\
O\
O\
O\
Ol
=
*
(
Coll\
isionO\
bj\
ect\
L\
i\
neList
*
)
lO\
l\
llOOOO\
l\
l
->
lOl\
lOOlOOOO
;
const
fl\
oat\

lO\
llOlOlll
=
0.0001f
;
Ve\
c\
3\

llllllll\
l\

=
lOll\
l\
OlOOlO
.
lllO\
lOlOO\
l\
O\

*
lO\
ll\
l\
O\
OOOOl
;
Vec\
3
lOOOOOO\
OOO\

=
lOlllOlO\
Ol\
O
.
lllOlO\
l\
O\
Oll
*
lOll\
lOO\
OOOl\

;
Vec\
3
lll\
lOO\
O\
O\
OlO\

=
lOOOOOOOOO
-
ll\
llllll\
l
;
for
(
int\

lll\
OOO\
OlOO\

=
0
;
lllO\
OOO\
lO\
O
<
llll\
OOOOOO\
l
.
llllOO\
O\
OOll
.
lO\
OOl\
llOOl
(
)
;
lllO\
OOOlO\
O
++
)
{
float\

llllOl\
O\
Oll\

;
Vec3
lOll\
l\
l\
OOll\

;
Ve\
c3
lOlll\
l\
OlOO
;
const
Vec\
3
&
lOOl\
Ol\
Olll
=
llllOOOOOOl
.
llll\
OO\
OOOll
[
lllOOOOlO\
O
]
.
lO\
OlOl\
Olll\

;
con\
st
Vec3\

&
lOO\
lOllO\
Ol
=
lll\
lOOOOOOl\

.
llllOOOOOll\

[
lllOOOOlOO\

]
.
lO\
OlOllO\
Ol
;
if\

(
Geom\
et\
r\
y
::
Tes\
tP\
oi\
ntM\
ovement\
AgainstS\
pher\
e
(
lOO\
lOl\
O\
l\
ll
,
lOO\
lO\
l\
l\
OOl
,
ll\
ll\
l\
llll
,
lOlllO\
lOOlO
.
lOlOl\
OOl\
O\
lO
,
ll\
llOlOOll
,
lOll\
l\
l\
OOll
,
lO\
llllOlOO\

)
)
{
if
(
lOllllO\
lOO
.
Do\
t
(
lOOOO\
O\
OO\
OO
-
ll\
lll\
l\
lll
)
<
0.0f
)
{
Co\
lli\
sion
lOllO\
ll\
Olll
;
lOllOll\
Olll
.
In\
i\
tialis\
e
(
Co\
llision\

::
lOl\
lO\
lOOlOO\

,
0.0f
,
llllOlOOl\
l
,
lOllllO\
Oll
,
lOl\
ll\
lOlOO
)
;
lOl\
lOllOl\
ll
.
lOllOO\
lOO\
Ol\

=
lllO\
OO\
Ol\
OO
;
if\

(
!
lOll\
lOOOO\
ll\

->
lOl\
lOl\
ll\
lOO
)
lOllOll\
O\
ll\
l\

.
lOll\
OOlOOlO\

=
0
;
el\
se
lOllO\
llO\
ll\
l
.
lO\
ll\
OOl\
OOl\
O
=
1
;
if
(
!
lll\
OllllO\
OO
(
lOl\
lOllOlll
,
lOlllOOOO\
ll
)
)
return
;
continu\
e
;
}
}
if
(
Geome\
tr\
y
::
Tes\
tPointMovem\
entA\
gains\
t\
S\
pher\
e
(
lOOl\
OlOll\
l
,
lOOlO\
llOOl
,
lOOOOOOOO\
O
,
lO\
lllO\
lO\
OlO
.
lOlOlO\
OlO\
l\
O
,
llll\
O\
lOO\
ll
,
lOlll\
l\
OO\
l\
l
,
lOll\
llOlOO
)
)
{
if
(
lOl\
lllOl\
OO
.
Dot
(
lllll\
lll\
l
-
lOOOOOOOOO
)
<
0.0f
)
{
Coll\
isi\
on
lOllO\
l\
l\
Oll\
l\

;
lOllOll\
Ol\
ll\

.
Initialise
(
Collis\
ion
::
lOllOl\
O\
O\
lO\
O\

,
0.0f
,
llll\
OlOOl\
l
,
lOllll\
OO\
ll
,
lOll\
l\
lOl\
OO
)
;
lOll\
O\
llOl\
ll
.
lOl\
lOOlOOOl
=
lllOOOOl\
O\
O\

;
if
(
!
lOl\
llO\
OOOll\

->
lOllOl\
lllOO
)
lOl\
lOll\
Olll\

.
lOllO\
Ol\
O\
OlO
=
0
;
else
lO\
llO\
l\
l\
Ol\
ll
.
lO\
ll\
O\
Ol\
O\
O\
l\
O\

=
1
;
if
(
!
lllOllllOOO\

(
lO\
ll\
OllOl\
ll\

,
lO\
lllOOOOl\
l
)
)
re\
turn
;
continu\
e
;
}
}
if\

(
Geometr\
y
::
Test\
Sp\
hereM\
ovem\
en\
tAgainstLine
(
lOOlOlO\
lll\

,
lOO\
lOll\
OOl
,
ll\
l\
llll\
ll
,
lOO\
O\
O\
O\
OOOO
,
lOlllO\
l\
OO\
lO\

.
lO\
lOlOOl\
O\
lO\

,
lll\
lOlOOll
,
lOll\
l\
lO\
Oll
,
lOl\
ll\
lO\
l\
OO
)
)
{
lOlll\
lOOll\

+=
lOllllO\
lOO
*
lOlll\
O\
lOOlO
.
lO\
l\
OlOOlOlO
;
Co\
l\
li\
si\
on
lOllOl\
lOlll
;
lOllOll\
Oll\
l\

.
In\
itialise
(
Co\
llis\
ion
::
lOll\
OlO\
OlO\
O
,
0.0f
,
llllO\
lOOll\

,
lOllllO\
Oll
,
lOlll\
l\
O\
lOO
)
;
lO\
ll\
OllOlll
.
lOllOOlOOOl\

=
lll\
OOOO\
l\
OO
;
if\

(
!
lOlllOOOO\
ll
->
lOl\
l\
Ol\
lllOO\

)
lOllOll\
Ol\
l\
l
.
lOl\
lOOlO\
OlO
=
0
;
else
lOllO\
ll\
Olll
.
lO\
ll\
O\
OlOOlO
=
1
;
if
(
!
ll\
lOll\
llOO\
O
(
lOll\
OllOl\
ll
,
lOlllOO\
OOll
)
)
return
;
co\
nti\
nue
;
}
}
}
#endif //
}

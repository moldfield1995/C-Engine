//---------------------------------------------------------------------------------
// File Name: zpta016.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include "../Physics/zpta005.h"
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
#include <memory.h>
nam\
e\
spac\
e
TA
{
co\
nst
flo\
at\

lO\
OOl\
O\
OOll
=
0.001f
;
sta\
t\
ic\

in\
t
lOOO\
l\
llllllO
=
0
;
#ifdef _DEBUG
#define lOOOllllllll(llOOOOOlOOl)											\
if (lOOlOOOllO)																				\
{																								\
	TA_ASSERT(lOOlOOOOOOOO.lOlOOOOllO((u32*)(llOOOOOlOOl)));										\
	TA_ASSERT((u32*)(llOOOOOlOOl)- &lOOlOOOOOOOO[0] < lOOlOOOOOOOl);									\
}
#define lOOlOOOOOOlO(llOOOOOlOOl)											\
if (lOOlOOOllO)																				\
{																								\
	TA_ASSERT(lOOlOOOOOOOO.lOlOOOOllO((u32*)(llOOOOOlOOl)));										\
	TA_ASSERT((u32*)(llOOOOOlOOl) - &lOOlOOOOOOOO[0] >= lOOlOOOOOOOO.lOOOlllOOl() - lOOlOOOOOOll);		\
}
#define lOOlOOOOOlOO(llOOOOOlOOl) lOOlOOOOOlOl(llOOOOOlOOl, true)
#define lOOlOOOOOllO(llOOOOOlOOl) lOOlOOOOOlOl(llOOOOOlOOl, false)
#define lOOlOOOOOlll(llOOOOOlOOl) lOOlOOOOlOOO(llOOOOOlOOl)
#define lOOlOOOOlOOl(llOOOOOlOOl, lOOlOOOOlOlO) TA_ASSERT(lOOlOOOOlOll(llOOOOOlOOl, lOOlOOOOlOlO))
#define lOOlOOOOllOO(llOOOOOlOOl, lOOlOOOOlOlO) lOOlOOOOllOl(llOOOOOlOOl, lOOlOOOOlOlO)
#else
#define lOOlOOOOOlOO(llOOOOOlOOl)
#define lOOlOOOOOllO(llOOOOOlOOl)
#define lOOOllllllll(llOOOOOlOOl)
#define lOOlOOOOOOlO(llOOOOOlOOl)
#define lOOlOOOOOlll(llOOOOOlOOl)
#define lOOlOOOOlOOl(llOOOOOlOOl, lOOlOOOOlOlO)
#define lOOlOOOOllOO(llOOOOOlOOl, lOOlOOOOlOlO)
#endif
#define lOOlOOOOlllO()						\
lOOlOOOOllll(lOOlOOOlOOOO, lOOlOOOlOOOl, lOOlOOOlOOlO, -, -, -)		\
lOOlOOOOllll(lOOlOOOlOOOO, lOOlOOOlOOOl, lOOlOOOlOOll, -, -, +)		\
lOOlOOOOllll(lOOlOOOlOOOO, lOOlOOOlOlOO, lOOlOOOlOOlO, -, +, -)		\
lOOlOOOOllll(lOOlOOOlOOOO, lOOlOOOlOlOO, lOOlOOOlOOll, -, +, +)		\
lOOlOOOOllll(lOOlOOOlOlOl, lOOlOOOlOOOl, lOOlOOOlOOlO, +, -, -)		\
lOOlOOOOllll(lOOlOOOlOlOl, lOOlOOOlOOOl, lOOlOOOlOOll, +, -, +)		\
lOOlOOOOllll(lOOlOOOlOlOl, lOOlOOOlOlOO, lOOlOOOlOOlO, +, +, -)		\
lOOlOOOOllll(lOOlOOOlOlOl, lOOlOOOlOlOO, lOOlOOOlOOll, +, +, +)
lO\
Ol\
OO\
OlOllO
::
llO\
OOOOlOOO
::
llOOOOOlO\
OO\

(
)
{
llOOOOl\
Ol\
lO
=
0
;
llOO\
OO\
OllOl
=
0
;
llO\
O\
OOlOl\
OO\

=
0
;
lOlOl\
lOOl\
l
=
0
;
ll\
OOOOl\
OOl\
l
[
0
]
=
0
;
llO\
OOO\
lOOl\
l
[
1
]
=
0
;
llOO\
O\
O\
lO\
O\
ll
[
2
]
=
0
;
llO\
OO\
O\
lOOl\
l\

[
3
]
=
0
;
llOO\
O\
Ol\
OOll
[
4
]
=
0
;
llOOOOl\
OOl\
l
[
5
]
=
0
;
llOOO\
OlOOll
[
6
]
=
0
;
llOOOOlOO\
ll
[
7
]
=
0
;
}
lO\
O\
lO\
OOlOllO
::
lOOlOOOlOlll
::
lOOl\
OOOlOll\
l
(
)
{
llO\
OOOlO\
ll\
O\

=
0
;
ll\
OOO\
OOll\
Ol
=
0
;
llOO\
OO\
lOlOO
=
0
;
lO\
lO\
l\
l\
O\
Oll\

=
0
;
llOOOOO\
lllO
=
0
;
}
lO\
OlOOOl\
OllO
::
lOO\
lOOOlO\
llO
(
)
{
llllOlOOOlO
.
Clea\
r
(
)
;
lOOlOO\
OllOOO
=
0
;
lO\
O\
lO\
OOllO\
O\
l\

=
0
;
}
lOOlOOOlOll\
O\

::
~
lOOlOOOlOll\
O\

(
)
{
lO\
Ol\
OOOlO\
l\
lO
::
Fin\
al\
ise
(
)
;
}
voi\
d
lOOlOO\
O\
lOllO
::
In\
i\
t\
iali\
s\
e
(
fl\
o\
at
llO\
l\
OlO\
lOl\
l
,
int
llOlO\
lOllOO
,
const
AABB
&
lOOOO\
OOl\
ll
)
{
int
lOOOllOOO\
l
;
fl\
oat
llOl\
Ol\
lOOlO
=
lOOOO\
OO\
l\
ll
.
v3Exte\
nt
[
lOO\
OOOOlll
.
v3E\
xtent\

.
Ge\
tGr\
ea\
t\
e\
s\
tAxis
(
)
]
*
2.0f
;
int
lOOlOO\
Oll\
O\
l\
O\

=
16
;
float
ll\
OlO\
llOO\
OO
=
(
llOlOl\
l\
O\
O\
l\
O
/
llOlO\
lOlO\
ll\

+
1.0f
)
;
if
(
llOl\
Oll\
OOOO
>
(
fl\
oa\
t\

)
(
1
<<
lOOlOOOllOlO
)
)
llO\
l\
O\
l\
lO\
OOO
=
(
fl\
o\
a\
t
)
(
1
<<
lOOlOO\
OllOlO
)
;
in\
t
lOOl\
OOOll\
O\
ll
=
(
int
)
llOlOllO\
OOO
;
if
(
lOOl\
OOO\
l\
l\
Oll
<
1
)
lOOlOO\
OllOl\
l
=
1
;
for
(
lOO\
O\
l\
lO\
OOl
=
0
;
lOOOll\
OOOl\

<
32
;
lO\
OOllOO\
O\
l
++
)
{
if
(
lOO\
lOO\
O\
llOll\

&
(
1
<<
lOOOl\
lOOOl
)
)
lOO\
l\
OO\
OllOOO
=
lO\
OOllOOOl
;
}
lO\
OlOOOllO\
O\
O\

++
;
llllOlOOOlO
.
v3Center
=
lOO\
OOOOlll
.
v3Cent\
e\
r
;
ll\
llO\
lOO\
OlO
.
v3Exte\
n\
t
.
x
=
llO\
l\
OlO\
l\
O\
ll\

*
lOOlOOOllOO\
O\

;
if
(
llllOlOOOl\
O
.
v3\
Exte\
nt
.
x
<
llO\
lO\
l\
lOOlO
)
lll\
lOlO\
OOl\
O\

.
v3Extent
.
x
=
llO\
lOllOOlO\

;
llllO\
lO\
OO\
lO
.
v3\
E\
xte\
nt
.
x
*=
0.5f
;
llllOlOOOlO\

.
v3\
Extent
.
y
=
llll\
O\
lOOOl\
O
.
v3\
E\
xtent
.
x
;
llllOlO\
O\
Ol\
O
.
v3Extent
.
z
=
lll\
lOlOOOl\
O
.
v3Exten\
t
.
x
;
const\

int
lOOlO\
O\
Olll\
OO
=
siz\
e\
of
(
llOOOOOlOOO
)
;
if\

(
llOl\
OlOllOO\

<
lOOl\
OOOlll\
OO
)
{
lOOOlll\
OlO
(
0
,
"CollisionOctree::Initialise. Minimum octree memory clamped to 1k")
;
ll\
O\
l\
OlOll\
OO\

=
lOOlOOOlll\
OO
;
}
llO\
lO\
lO\
llO\
O
/=
4
;
lOOlOOOOOO\
OO
.
Init\
i\
al\
ise
(
ll\
OlOlO\
l\
lOO\

,
llOlOlOllOO
)
;
lOO\
lOO\
OOOOOO
.
lOO\
llllOlO\

(
)
;
int
lO\
O\
lOOlOOO
=
0
;
int
lOOl\
OOlO\
O\
l\

=
ll\
Ol\
OlOllOO
;
lOOll\
OlllOl
=
0
;
lOOlO\
OOlllO\
l
=
0
;
lOOl\
OOOll\
OOl\

=
0
;
fo\
r
(
;
;
)
{
if
(
lOOl\
O\
Ol\
OOO
+
(
int\

)
(
sizeof
(
llOO\
OOOlOOO\

)
/
4
)
>=
lOOlOO\
lOO\
l\

)
br\
ea\
k\

;
llOO\
OOOlOOO
*
llOO\
OOOlOOl
=
(
ll\
OOOOOlOO\
O
*
)
&
lOOlOOOOOOOO\

[
lOOl\
O\
O\
lOO\
O\

]
;
lOOlOO\
lOO\
O\

+=
(
int
)
(
sizeo\
f
(
llOOOOOlOO\
O
)
/
4
)
;
lOOlO\
OO\
O\
OOOl
=
lOOl\
O\
O\
l\
O\
O\
O
;
lOOOllll\
llll
(
ll\
OO\
O\
OOlOOl\

)
;
if\

(
!
lOO\
l\
OOOl\
lOO\
l
)
{
lO\
OlOOOl\
lOOl\

=
llOOOOOlO\
Ol
;
lOO\
lOOO\
l\
l\
OOl
->
lOlO\
ll\
OOll
|=
lOOlOO\
OllllO\

;
}
else
{
llO\
OO\
OOOl\
OO
(
llOOOO\
O\
l\
OOl
)
;
}
if
(
lOOlOOlOOO
>=
lO\
O\
lOOlOOl
-
(
int
)
(
sizeo\
f
(
lOO\
lOO\
Ol\
O\
lll
)
/
4
)
)
br\
eak
;
lO\
OlOOlO\
Ol
-=
(
int
)
(
siz\
eof\

(
lOO\
lOOO\
lOlll
)
/
4
)
;
lOOl\
OO\
O\
lO\
l\
ll
*
lOO\
lOO\
Oll\
ll\
l
=
(
lOOlOO\
Ol\
Olll
*
)
&
lOO\
lOOOOO\
OOO
[
lOO\
lOOl\
O\
Ol
]
;
lOOlOOOOOOll
=
llOlOlOllOO
-
lOOlOOlO\
Ol\

;
lOO\
lOOOOO\
Ol\
O
(
lOOlOOOllll\
l
)
;
lO\
Ol\
OOlOOOO\
O
(
lO\
O\
l\
O\
OO\
lllll\

)
;
}
lOOl\
OOO\
O\
OO\
Ol\

=
lO\
Ol\
OOlOO\
O
;
lOOlOOO\
OOOll
=
ll\
OlOlOll\
OO
-
lO\
O\
l\
OOl\
OOl
;
}
void\

lOOl\
O\
OO\
lO\
llO
::
Finalise
(
)
{
lOO\
l\
OOOllOOl\

=
0
;
lll\
lO\
l\
OOOlO
.
Clear
(
)
;
lOO\
lOO\
OllOOO
=
0
;
lO\
Ol\
OOOO\
OOOO
.
Fi\
n\
alise
(
)
;
}
void
lOOlOO\
OlO\
l\
lO\

::
lOlOlOOOOl\

(
Sp\
ac\
eDi\
vi\
s\
ionObject
&
llO\
O\
OO\
O\
OO\
OO
)
{
lOOOOOO\
l\
lO
(
lOOOllll\
ll\
lO
==
0
,
"CollisionOctree::Add, Error: Called during CollisionOctree::ForAllIntersectionsWithLineSegment")
;
if\

(
ll\
OOOOO\
O\
O\
OO
.
llOOO\
O\
lOlll
)
lOOl\
llllll
(
llOOO\
OOOOO\
O
)
;
llOOO\
OOlOOO\

*
llOO\
OO\
OlOOl
;
const
AABB
&
lOOl\
O\
OlOOOOl
=
llO\
O\
OOO\
O\
OO\
O
.
GetCol\
l\
isio\
nGridWorl\
dAABB
(
)
;
flo\
at
lOOl\
OOl\
OO\
OlO\

=
lOOlOOlO\
OOOl\

.
v3Extent\

[
lO\
OlO\
OlOO\
OOl
.
v3Ext\
e\
nt\

.
GetGre\
a\
testA\
xis
(
)
]
;
float\

lOOlOOlOO\
Oll\

=
llllO\
l\
OOOl\
O
.
v3\
Extent
.
x
;
int\

lOOlOOlOOlOO
=
(
1
<<
lOO\
lO\
OOl\
lO\
O\
O
)
;
fl\
oat
ll\
Olll\
O\
OO\
l\

=
(
float
)
lO\
O\
lOOl\
OOl\
O\
O\

/
(
lOOlOOlOOOll
*
2.0f
)
;
float
llO\
lOOlllOO\

=
(
float
)
lOO\
lOOlOO\
l\
O\
O\

*
0.5f
;
int
ll\
OOO\
OOOll
=
Fa\
s\
tF\
loa\
t\
To\
In\
t
(
(
lOOl\
OOlOOOOl
.
v3C\
ente\
r
.
x
-
lll\
lO\
lOOO\
lO
.
v3Ce\
nter
.
x
)
*
llO\
lllOO\
Ol
+
ll\
Ol\
OOll\
lOO
)
;
Cl\
am\
p
(
llOOOO\
OOl\
l
,
0
,
lO\
OlOO\
lO\
O\
lOO
-
1
)
;
in\
t
llOOOOOl\
OO
=
Fa\
stF\
loat\
To\
In\
t\

(
(
lO\
OlOOlOOO\
Ol
.
v3C\
enter
.
y
-
llllOlOO\
OlO
.
v3Ce\
nt\
er
.
y
)
*
llOlllOOOl\

+
llOl\
OO\
lllOO\

)
;
Clamp
(
ll\
OO\
OOOl\
OO\

,
0
,
lOO\
lOOlOOlOO\

-
1
)
;
int
llOOO\
OOl\
Ol
=
Fas\
tF\
loatToInt
(
(
lOOlOOl\
OOOOl
.
v3Center
.
z
-
llllOlOOO\
lO
.
v3C\
enter
.
z
)
*
llOlll\
OOOl
+
llO\
lOOlllOO
)
;
Cla\
m\
p
(
llOOOOOlO\
l\

,
0
,
lOOlOOlOOl\
O\
O
-
1
)
;
TA_\
AS\
SERT
(
lOOlOOO\
ll\
O\
O\
l\

)
;
llOOOO\
OlOO\
l
=
lO\
OlOO\
OllOO\
l
;
in\
t\

lOO\
lOOl\
OOlOl
=
lOO\
lOOOllO\
OO
;
do\

{
lOOlOO\
l\
OOlO\
l
--
;
if
(
lOO\
lOOl\
OOlOl
<
0
)
br\
eak
;
lOOl\
OOl\
O\
O\
O\
ll
*=
0.5f
;
int
lOO\
O\
l\
OOll\
l
=
(
(
(
ll\
O\
O\
OOOOll
<<
2
)
>>
lO\
OlOO\
l\
OOlOl
)
&
4
)
+
(
(
(
llOO\
OO\
OlOO
<<
1
)
>>
lOOlOOlOO\
lOl\

)
&
2
)
+
(
(
ll\
OOOOOlOl
>>
(
lOOlO\
OlOOlOl
-
0
)
)
&
1
)
;
TA_AS\
SER\
T
(
lOO\
O\
lO\
Ol\
ll
>=
0
&&
lO\
O\
O\
l\
OOlll
<
8
)
;
lO\
O\
lOOOOOlOO
(
ll\
OOOO\
OlOOl
)
;
if\

(
ll\
OOOO\
Ol\
OOl\

->
lOl\
Ol\
lOOll
&
lO\
OlOOOll\
llO
)
{
TA_\
ASSERT\

(
llO\
OO\
OOl\
OO\
l
->
llOl\
lOOlll
>
1
||
ll\
OOOOOlOO\
l
==
lO\
OlO\
OOllOOl
)
;
if
(
!
llOOOOOlOOl
->
ll\
OOO\
O\
lOOl\
l
[
lO\
OOlO\
Ol\
ll\

]
)
{
ll\
OOOO\
O\
lOO\
l
->
ll\
OOOOlOOl\
l\

[
lOO\
O\
lOO\
ll\
l
]
=
(
llOOOOO\
lOOO\

*
)
lOOl\
OO\
lOOll\
O
(
&
ll\
OOO\
OOlOOl
)
;
if\

(
llO\
OOOOl\
OOl\

->
ll\
OO\
OOlOOll
[
lOOOlOO\
lll
]
==
0
)
break
;
llOOOOO\
l\
O\
O\
l
->
llOO\
OOlOO\
l\
l\

[
lOOO\
lOOl\
ll
]
->
llO\
OOO\
O\
l\
lOl
=
llO\
OOOOlOO\
l
;
llOOOOOlOOl
->
llOOOO\
lOOll
[
lOOO\
lOO\
lll
]
->
ll\
O\
O\
OOlOlOO\

=
lOO\
Ol\
O\
Olll
;
llO\
O\
OOO\
lOO\
l
->
llOOOOlOOll
[
lO\
OOlOOll\
l
]
->
llOllOO\
ll\
l\

=
0
;
llOO\
O\
OOlOOl
->
llO\
OOOlO\
Oll
[
lOOOlO\
Oll\
l\

]
->
lOlO\
l\
lOOll
=
0
;
llO\
OOOOlOOl\

->
llO\
llOOl\
l\
l
++
;
}
lOO\
lO\
O\
OOOlOO
(
ll\
O\
O\
OO\
O\
lOO\
l
)
;
llOOOOOlO\
O\
l
=
llOO\
OO\
OlOOl\

->
llO\
OO\
OlOOll
[
lO\
OO\
l\
OOll\
l\

]
;
lO\
Ol\
OOOOOlOO
(
ll\
OOO\
O\
O\
lOOl
)
;
}
else
{
lOOlO\
OOlOlll
*
lOO\
l\
O\
OOlllll\

=
(
lO\
OlO\
OOlO\
l\
ll
*
)
llOO\
O\
OO\
lOOl
;
if
(
lOO\
l\
OO\
O\
lll\
ll\

->
llOO\
OO\
OlllO
)
{
if
(
lOOlO\
OOlllll\

->
ll\
O\
OO\
Ol\
OO\
lO
==
lOOO\
l\
OOlll
)
{
ll\
OOOOOl\
O\
Ol
=
lOOlOOOlllll\

->
ll\
O\
OOOOl\
llO
;
lO\
Ol\
O\
OOO\
O\
l\
O\
O
(
llOOO\
OOlOOl
)
;
}
else
{
llOO\
OOOl\
O\
Ol\

=
llOOO\
Ol\
O\
OOO
(
(
ll\
OOOOO\
lOO\
O
*
*
)
&
lOOlOO\
Oll\
lll
)
;
if
(
llO\
OOOOlO\
Ol\

==
0
)
{
ll\
OOOOOlO\
Ol
=
(
ll\
O\
OOOO\
l\
OOO
*
)
lOOlOOOlllll
;
bre\
ak
;
}
if
(
lOO\
lOOOl\
lll\
l\

->
llO\
OOO\
Ol\
lO\
l\

->
lOlO\
ll\
OOl\
l
&
lOOlOO\
Ollll\
O
)
lOO\
l\
OOOl\
lll\
l
->
llOOO\
OO\
llOl
->
llOOOO\
lOOl\
l
[
lO\
OlO\
OOl\
llll
->
llOOOOl\
OlOO
]
=
llO\
OOOO\
l\
O\
Ol
;
el\
se
(
(
lOOlOOO\
lO\
l\
ll
*
)
lOOlOO\
O\
ll\
lll\

->
llO\
OOOOll\
O\
l
)
->
llOOOOOlll\
O\

=
ll\
OO\
O\
OOlOOl
;
llOO\
OOO\
l\
OOl
->
ll\
OOOOOll\
Ol
=
lO\
OlO\
O\
Olll\
ll
->
llOOOOOllOl\

;
lOO\
lOOO\
lllll
->
ll\
O\
OO\
OOll\
lO
->
llOOOOO\
llO\
l\

=
ll\
OO\
OOOl\
O\
O\
l
;
llO\
O\
OOOlO\
Ol
->
ll\
Ol\
l\
OOlll\

=
1
;
llOOO\
OOlOOl
->
llOOOO\
l\
O\
lO\
O\

=
lO\
OlOOOllll\
l
->
ll\
OOOOlOlOO
;
llOOOOO\
lOOl
->
lOlO\
l\
l\
OO\
ll
=
0
;
llO\
OO\
OOl\
OOl
->
llOOOO\
lOOlO
=
0
;
TA_\
ASSER\
T
(
ll\
O\
O\
OOOlOO\
l
->
ll\
OOOOlO\
Oll
[
0
]
==
0
)
;
TA_AS\
SERT
(
llOOOOOlO\
Ol
->
llO\
OOO\
l\
O\
Oll\

[
1
]
==
0
)
;
TA_ASS\
ER\
T\

(
llOOOOOlOO\
l
->
llOOOOlOO\
ll
[
2
]
==
0
)
;
TA_\
ASSERT
(
ll\
OOO\
O\
OlOOl
->
llOO\
OOlOOll
[
3
]
==
0
)
;
TA\
_ASSERT
(
llOOOOOlOOl\

->
llOOOOlOOll
[
4
]
==
0
)
;
TA\
_\
ASSE\
RT
(
llO\
OOOOlOOl\

->
llOO\
OOl\
O\
Oll
[
5
]
==
0
)
;
TA_ASSERT\

(
llOOOOOlOO\
l\

->
llO\
OOOlOOll
[
7
]
==
0
)
;
llOOOOO\
l\
O\
Ol
->
llOOO\
OlO\
Oll\

[
lOOl\
OOOl\
lll\
l
->
llOOOOl\
O\
Ol\
O
]
=
lOOlOOOllll\
l
->
ll\
OO\
O\
OOll\
lO\

;
ll\
OOOO\
OlOOl
->
llOOOO\
l\
OllO\

=
lOOlO\
O\
Olllll
->
ll\
O\
OO\
Ol\
OllO
;
if\

(
llOO\
O\
OOlO\
Ol
->
llO\
OOOl\
OllO
)
llOO\
OOOlO\
Ol
->
llO\
OOOlO\
l\
lO
->
llOOOOlOlll\

=
&
llOOO\
OOlOOl
->
llOO\
OOlOllO
;
llOOOOOlOOl
->
lOl\
OllOOll\

=
lOOlOOOllllO\

;
lOOlOO\
lO\
OOOO
(
lO\
O\
lOOOlll\
ll
)
;
TA_ASSERT\

(
llOO\
O\
OOlOOl
->
llO\
O\
OOl\
OOll\

[
lOO\
OlOOlll
]
==
0
)
;
ll\
OOOO\
OlO\
Ol\

->
llO\
OOO\
lOOll
[
lO\
OO\
lOOll\
l
]
=
(
llOOOOOlO\
O\
O
*
)
lO\
Ol\
OOl\
O\
O\
l\
lO
(
&
llO\
OO\
OOlOOl
)
;
if\

(
ll\
O\
OOO\
O\
lOOl
->
llOOO\
Ol\
OO\
l\
l
[
lOOOlOO\
l\
l\
l
]
==
0
)
break
;
llOOO\
OOlOOl
->
llOOOOl\
O\
Oll
[
lOOO\
lOOl\
ll\

]
->
llOOO\
OO\
llOl
=
llOOOOOlOOl
;
llOOOOOlOOl
->
llO\
OOOlOOll
[
lO\
OOl\
OOlll
]
->
ll\
OOOOl\
Ol\
OO
=
lOOOlOOlll
;
llOO\
O\
OO\
lOOl
->
llOllOOlll
++
;
TA_ASSERT\

(
llOOOO\
O\
l\
O\
O\
l
->
llO\
llO\
Olll
==
2
)
;
lOOlOOOO\
OlO\
O
(
llOOO\
OO\
lOO\
l\

)
;
llOO\
O\
O\
Ol\
O\
Ol\

=
llOOOO\
O\
lOO\
l\

->
llOOO\
OlOO\
ll
[
lOOOlO\
Oll\
l
]
;
lOOl\
OO\
OOO\
lO\
O
(
llOO\
OOOlOOl
)
;
}
}
else\

{
TA_ASS\
ERT
(
lOO\
l\
OOOl\
lll\
l
->
llOO\
O\
OO\
ll\
lO
==
0
)
;
lOO\
lOOOlllll
->
llOO\
OOOll\
lO\

=
(
llO\
OOO\
OlOOO
*
)
lOOlOOlOOl\
lO
(
(
llOO\
O\
OOlOO\
O\

*
*
)
&
lOOlO\
OO\
l\
ll\
l\
l
)
;
if\

(
lOOlOOOll\
ll\
l
->
ll\
OO\
OOOlllO
==
0
)
break
;
lOOlOO\
Oll\
l\
ll
->
llOOOOlOOl\
O\

=
lOOOl\
OOlll\

;
lOO\
lOOOllll\
l
->
llOll\
O\
Oll\
l\

++
;
lO\
OlO\
OOlll\
ll
->
llOO\
OOOl\
ll\
O
->
llOOOOlOl\
OO
=
lOOOl\
OOlll
;
lOOlOOO\
llll\
l
->
ll\
OO\
O\
OO\
lllO
->
llOOOOl\
OO\
lO
=
0
;
lO\
OlOO\
Ol\
lll\
l
->
llOOOOO\
l\
llO
->
lO\
lOll\
OO\
ll
=
0
;
lO\
OlOOOl\
llll\

->
ll\
OOOOOlllO
->
llOOOOOllOl
=
llO\
OOO\
OlO\
Ol
;
TA_ASS\
ERT
(
lOOlOOOlll\
l\
l\

->
llOll\
OOl\
l\
l\

==
1
)
;
lOO\
l\
OOO\
OO\
l\
OO\

(
ll\
OOOO\
Ol\
OOl
)
;
llO\
OO\
OOlOOl
=
lO\
OlOOOllll\
l
->
llO\
OOOOlllO
;
lOOl\
OOO\
OOlOO\

(
llOO\
O\
OO\
lOO\
l
)
;
}
}
}
while
(
lOOlOOlOOOll
>
lOO\
lO\
OlOOOlO
)
;
lOOl\
O\
OO\
OOl\
OO\

(
llO\
OOOOlOO\
l
)
;
Spac\
eDivisio\
n\
O\
bj\
e\
c\
t
*
*
ll\
O\
lOl\
lOOll
=
&
llO\
OO\
OOlOOl
->
llOOOOlOl\
l\
O\

;
llOOOOOO\
O\
OO
.
llOOOlOOOOl
=
*
llO\
lOllO\
O\
ll
;
if
(
llOOOOOOOOO
.
llOOOlOOOOl
)
llOOOOOO\
OO\
O
.
ll\
O\
OOlOOO\
Ol\

->
ll\
OOOOlOll\
l
=
&
llOOOO\
OOOOO
.
llO\
OOlOOOO\
l
;
*
ll\
O\
lOllO\
O\
ll\

=
&
llOOOOOO\
OOO
;
llO\
OOOOOOOO
.
ll\
O\
OO\
OlOlll\

=
llOlOllOOl\
l
;
lOO\
lOOOOOl\
O\
O
(
llOOOOO\
lOOl
)
;
lOO\
l\
OOOOOlll
(
lO\
O\
lOOOl\
l\
OOl
)
;
}
void
lO\
OlO\
OOlO\
llO
::
lOOlllllll
(
Sp\
aceD\
ivisi\
o\
nO\
bject
&
llOOOOOO\
OOO
)
{
lOOO\
OO\
O\
llO
(
lOOOllll\
lll\
O
==
0
,
"CollisionOctree::Remove, Error: Called during CollisionOctree::ForAllIntersectionsWithLineSegment")
;
if
(
!
llO\
OO\
OOO\
OOO
.
llOO\
OOlO\
lll
)
{
TA_AS\
SERT
(
llO\
OOO\
OOOOO
.
llOOO\
lOO\
OOl
==
0
)
;
retu\
rn
;
}
TA\
_AS\
S\
E\
R\
T
(
llOO\
OOOOOOO
.
ll\
OOOOl\
Olll
)
;
TA\
_ASSER\
T
(
*
llOO\
OOOOOOO
.
llOOO\
O\
lO\
lll\

==
&
llOOOOOOOO\
O
)
;
if
(
llOOO\
OOOOOO\

.
llOOOlOOO\
Ol
)
{
TA_ASSE\
RT
(
llOOOOOO\
O\
OO\

.
llOOOl\
OO\
OOl
->
llOO\
OOlOlll
==
&
ll\
OOOOOO\
O\
O\
O
.
llO\
O\
OlOOOOl
)
;
ll\
OOOO\
OOO\
OO
.
ll\
OOOlO\
OOO\
l
->
ll\
O\
OO\
O\
lO\
lll\

=
llOO\
O\
OOO\
OOO\

.
ll\
O\
OO\
Ol\
O\
lll\

;
*
llOOOOOOOOO
.
llOOOO\
lO\
lll
=
llOOOOOO\
OOO
.
llOO\
OlOOOOl
;
}
els\
e
{
*
llOO\
OOO\
OOOO
.
llOOOOlOl\
ll
=
llOO\
OOO\
OOOO
.
ll\
OO\
O\
lOOOO\
l
;
llOOOOO\
l\
OO\
O\

*
ll\
OOOOOl\
OO\
l
=
re\
int\
e\
rpret_\
cast
<
llO\
O\
OOOl\
OOO
*
>
(
llOOO\
OOO\
OO\
O\

.
ll\
O\
OOOlO\
l\
ll
)
;
if\

(
lOOl\
OOO\
OOOOO
.
lOlOOOOl\
lO
(
(
u32
*
)
llOO\
OO\
Ol\
O\
Ol
)
)
{
lOOlOOOOO\
lOO
(
ll\
O\
OOOOlOO\
l
)
;
while
(
llOOOOO\
l\
OOl
->
llOOOO\
O\
llOl\

)
{
TA_ASSE\
RT
(
llOOOO\
O\
l\
O\
Ol
!=
lOOl\
OOOllOOl\

)
;
lOOlOOOOOllO\

(
llO\
O\
OOOlOOl\

)
;
if\

(
ll\
OO\
OOOl\
OOl
->
lOlOl\
lOOl\
l\

&
lO\
Ol\
OO\
O\
l\
lllO\

)
{
TA_ASSERT
(
llOO\
OOO\
lOO\
l
->
llOllO\
O\
ll\
l\

>
0
)
;
if
(
llO\
O\
O\
OOl\
OOl
->
llOllO\
O\
lll
==
1
)
{
int
llOOOO\
lOOlO
;
for
(
llOOOOl\
OOlO\

=
0
;
llOOOOlOO\
lO
<
8
;
llOOOOlO\
OlO
++
)
if
(
llO\
OO\
O\
O\
lO\
Ol\

->
ll\
OOO\
OlOOll
[
ll\
O\
OOOlOOlO
]
)
brea\
k
;
TA\
_\
A\
SSERT
(
ll\
OOO\
O\
lO\
OlO
!=
8
)
;
llOOOOO\
lOO\
O
*
llOOOOO\
lll\
O
=
llOO\
O\
OO\
lOOl
->
llO\
OOO\
lOOl\
l
[
llOOO\
O\
l\
O\
OlO
]
;
Spa\
ceDi\
visi\
o\
nObjec\
t
*
llOOOOl\
OllO
=
ll\
OO\
OOOlOOl
->
llOOOOlOllO\

;
int
ll\
OO\
O\
OlOl\
O\
O
=
llOOOOOl\
O\
O\
l
->
llOOOOlO\
l\
OO
;
llOOOOOlOOO\

*
ll\
OOOOOl\
lOl
=
llO\
OOOOlOO\
l
->
llOOOOOl\
l\
O\
l
;
llOOOOOOlOO
(
llO\
O\
OO\
OlOOl
)
;
lOOlOOOlOlll
*
lOOlO\
O\
Olllll\

=
lO\
OlO\
OlOO\
l\
lO
(
&
llOOOOO\
llOl\

)
;
lO\
OlOOOl\
lll\
l\

->
llO\
OO\
O\
Ol\
lOl
=
llOOOO\
O\
llOl
;
lO\
OlO\
OOlll\
ll
->
llOl\
lOOl\
ll
=
1
;
lO\
OlO\
OOll\
ll\
l
->
llOOOOlO\
OlO
=
ll\
OOOOlOO\
lO
;
lO\
OlOOOll\
lll
->
llOOOO\
lOlOO
=
llOO\
OOlOl\
O\
O
;
lO\
Ol\
OOO\
lllll\

->
lOlOll\
OO\
ll
=
0
;
lOOlOOO\
lllll
->
llOOOOOlllO
=
llOO\
OOOll\
l\
O
;
lOO\
l\
OOOlll\
ll
->
llOO\
OOOlll\
O\

->
ll\
OOO\
OO\
ll\
Ol\

=
(
llO\
OOOO\
l\
OOO
*
)
lOOlOOOlllll
;
lOOlO\
OOl\
llll
->
ll\
OOO\
O\
lO\
llO
=
llO\
OO\
OlOl\
lO
;
if
(
lOOlOOOl\
l\
lll
->
llO\
OO\
Ol\
OllO\

)
lOOlOOOll\
lll
->
llOO\
OO\
lOl\
l\
O
->
llOOOOlOlll
=
&
lOOlOO\
Olllll
->
llO\
OO\
OlOll\
O\

;
if
(
llOOOOOllOl\

->
lOlOll\
OO\
ll
&
lO\
Ol\
OOOllllO
)
llO\
OOOOl\
lO\
l
->
llOO\
OOl\
OOll\

[
lOOlO\
O\
Olllll
->
ll\
O\
OOOlO\
lOO
]
=
(
llOOOO\
OlOOO
*
)
lOOl\
O\
OOl\
llll
;
els\
e\

(
(
lOOlOO\
O\
lOll\
l
*
)
llOOOO\
OllO\
l\

)
->
llO\
OOOOlll\
O
=
(
ll\
OO\
OOOl\
O\
OO
*
)
lOOlOOOlll\
ll
;
lOOl\
OOOOOlOO
(
(
llOOO\
OO\
lOOO
*
)
lOOl\
OOOl\
llll
)
;
}
bre\
ak
;
}
else
{
lO\
OlO\
OOlOll\
l
*
lOOlOOO\
lll\
ll
=
(
lO\
OlOO\
Ol\
O\
lll\

*
)
llOOOO\
O\
lOOl\

;
if
(
lO\
O\
l\
O\
OOlllll\

->
llO\
OOOl\
Oll\
O
==
0
&&
lOOlOOO\
l\
llll
->
llOOOOOlllO
==
0
)
{
in\
t
llOO\
OOlO\
lOO\

=
lOOlOOOlll\
ll
->
ll\
OOOO\
l\
OlOO
;
TA\
_ASSE\
RT
(
llOOOOlOl\
OO\

>=
0
)
;
TA_\
ASSERT
(
llOOO\
O\
l\
O\
l\
OO
<
8
)
;
llO\
OOOOlOO\
l
=
lOO\
lOO\
Ol\
llll
->
ll\
OOOOOll\
Ol\

;
if
(
llOOO\
O\
OlOOl\

->
lOl\
OllO\
Oll
&
lOOlO\
OO\
llllO
)
{
lOOOllllllll\

(
ll\
OO\
O\
OOlOOl
)
;
TA_\
ASSERT\

(
llOOOOO\
lOO\
l
->
ll\
OOO\
Ol\
O\
Oll
[
ll\
O\
O\
O\
Ol\
OlOO
]
==
(
llOO\
OOO\
l\
OO\
O
*
)
lOOlO\
OO\
lll\
l\
l\

)
;
lO\
OlOO\
OOOOlO\

(
lOOlOO\
Oll\
l\
ll\

)
;
lOO\
lOOlOOOOO
(
lOOlO\
OO\
lll\
ll\

)
;
llOO\
O\
OO\
lOOl
->
llOO\
O\
Ol\
O\
Ol\
l\

[
ll\
OO\
O\
OlOlOO
]
=
0
;
ll\
OOOO\
Ol\
OOl
->
llOl\
lOOl\
l\
l\

--
;
lOOl\
OOOOOll\
O
(
llOO\
O\
OO\
l\
OOl
)
;
}
el\
se
{
lO\
OlO\
OOl\
Olll
*
lOOl\
O\
O\
lOO\
lll
=
(
lOO\
l\
OO\
OlO\
lll
*
)
llO\
OOO\
Ol\
OOl
;
lOO\
lO\
OOOOO\
lO\

(
lOOlOO\
lO\
O\
lll
)
;
TA_AS\
SERT
(
lOOl\
OOl\
OO\
ll\
l
->
llOOOOO\
lllO
==
(
llOOOOOlOO\
O
*
)
lOOlOOOl\
ll\
l\
l\

)
;
lOOlO\
OOOOOlO\

(
lOOlOO\
Ol\
ll\
l\
l
)
;
lOOlO\
OlOOOO\
O
(
lOOlOOOllll\
l\

)
;
lOOlOO\
lOOlll
->
llO\
OOOOlll\
O
=
0
;
lOOlOOl\
OOl\
ll\

->
llOO\
O\
OlOOl\
O\

=
0
;
lOOlO\
OlOOll\
l
->
llOllOOlll
--
;
TA_ASSER\
T
(
lOOlOO\
lOOlll
->
llOl\
lOO\
l\
ll\

==
0
)
;
lO\
Ol\
O\
OOOOlOO\

(
llOOOOOl\
O\
Ol
)
;
}
}
el\
se
{
brea\
k\

;
}
}
}
}
}
llOO\
OOOOOOO\

.
ll\
OOO\
Ol\
Olll
=
0
;
llO\
OOOOO\
OOO
.
ll\
OOOl\
OO\
OO\
l
=
0
;
}
void
lOOl\
OOO\
lO\
ll\
O
::
llO\
OO\
lO\
O\
llO
(
const
AA\
BB\

&
lOOOO\
OOl\
l\
l\

,
void
(
TAC_C\
A\
LL
*
llOOlOllOl\
O
)
(
SpaceDivisi\
on\
Object
&
llO\
OOO\
OOO\
O\
O
,
void
*
lOOlllOOOO
)
,
void
*
lO\
O\
OOl\
lll\
O
)
{
lO\
OO\
l\
llllllO
++
;
lO\
OlOOlOlOOO
lOOl\
OOlOlOOl
;
lOO\
lOOlOl\
OO\
l
.
lOOOOOO\
lll
=
lOOO\
OOOlll
;
lOOlOOlOl\
O\
Ol\

.
llOOl\
OllOl\
O\

=
llOOlOllOlO\

;
lOOlO\
OlOl\
O\
O\
l
.
lOOOOllllO
=
lO\
OOOl\
l\
llO
;
floa\
t
lO\
OlOOlO\
OOl\
l
=
llll\
Ol\
O\
O\
OlO
.
v3\
Ex\
t\
e\
n\
t\

.
x
;
in\
t\

lO\
Ol\
OOlO\
Ol\
OO\

=
(
1
<<
lOOlOOOllOOO
)
;
float
llOl\
ll\
O\
O\
Ol
=
(
float
)
lOOlOOlOOlO\
O
/
(
lO\
OlOO\
lO\
OOll
*
2.0f
)
;
fl\
oat
llOlOOl\
l\
lOO
=
(
floa\
t
)
lOOlOOlOOlOO
*
0.5f
;
lO\
O\
lOO\
lO\
lOOl
.
llOO\
OO\
OOll\

=
FastFloatTo\
I\
nt
(
(
lOOOOO\
Olll
.
v3\
Cent\
e\
r
.
x
-
llllOlOO\
OlO\

.
v3C\
enter
.
x
)
*
ll\
OlllO\
OO\
l
+
ll\
Ol\
OO\
l\
llO\
O
)
;
Clamp
(
lOOlOOlO\
lOOl
.
llOOOOOOl\
l
,
0
,
lOO\
l\
OOl\
OO\
lOO
-
1
)
;
lOOlOO\
lOl\
O\
Ol
.
llOO\
OOO\
lOO\

=
Fast\
FloatToIn\
t
(
(
lOOOOOOlll
.
v3Ce\
nte\
r
.
y
-
llllOlO\
OO\
lO
.
v3Cente\
r
.
y
)
*
llOlll\
O\
O\
O\
l
+
llOl\
OOlllOO
)
;
Cla\
m\
p
(
lOO\
l\
OOlOl\
OOl
.
llOOOOOlOO
,
0
,
lOOlOO\
lOOlOO\

-
1
)
;
lOOlOOlOl\
OO\
l
.
llOOOO\
OlO\
l\

=
Fa\
s\
t\
Fl\
oatTo\
Int\

(
(
lOOOO\
OOlll\

.
v3Cente\
r
.
z
-
llll\
Ol\
OOOl\
O
.
v3C\
enter
.
z
)
*
ll\
Oll\
lOOOl\

+
llOlOOll\
lO\
O
)
;
Clamp
(
lOOl\
O\
Ol\
OlO\
Ol
.
llOOOOOlOl\

,
0
,
lOOlO\
Ol\
OOlOO
-
1
)
;
lO\
O\
lOOlOlOOl
.
ll\
OOOlOlOlO
=
Fast\
Flo\
atT\
oI\
nt
(
lOOOOOOlll
.
v3\
E\
xten\
t
.
x
*
ll\
Ol\
ll\
OOOl
+
0.99f
)
;
lO\
OlOOlOlOO\
l\

.
llOOOl\
Ol\
Oll
=
FastFloa\
tToI\
n\
t
(
lOO\
OOOOlll
.
v3Ext\
ent
.
y
*
llO\
lllOOO\
l\

+
0.99f
)
;
lOOlOOlOl\
OOl
.
llOOOl\
OllOO
=
FastF\
lo\
a\
tToInt
(
lOOO\
OOOlll\

.
v3Extent
.
z
*
llOlllO\
OOl
+
0.99f
)
;
llO\
OOlOl\
l\
Ol\

(
lOOlOOOll\
OOl
,
lOOl\
OOOllOOO
,
0
,
0
,
0
,
&
lO\
OlO\
OlO\
lOO\
l
)
;
lO\
OOlll\
l\
l\
llO
--
;
}
voi\
d
lO\
OlOO\
O\
l\
Oll\
O\

::
llOO\
Ol\
Oll\
lO\

(
co\
nst\

Vec3
&
lO\
OlO\
lOll\
l
,
cons\
t\

Vec\
3
&
lOOlOllOO\
l
,
voi\
d
(
TAC\
_C\
AL\
L
*
ll\
OOlOllOl\
O
)
(
Spa\
ceD\
ivisio\
nOb\
je\
c\
t\

&
llO\
OO\
OOOOOO
,
vo\
id
*
lOOl\
ll\
OOOO\

)
,
void
*
lO\
OOOl\
lllO\

)
{
lOOlOOlO\
l\
OlO
lO\
OlO\
OlOlO\
O\
l
;
lOOlOOlOlOOl
.
lOllOll\
OOO\
l\

=
thi\
s
;
lOOlOOlOlOO\
l
.
ll\
O\
OlO\
l\
lO\
lO\

=
llOOlO\
llOl\
O
;
lOOlOOlOl\
OOl
.
lOOOOllll\
O\

=
lOO\
OO\
llllO\

;
lO\
Ol\
OOlOlOOl\

.
lOOl\
O\
lOl\
ll
=
lOOlOl\
Olll\

;
lOOlOO\
lOlOOl
.
lOOlOl\
lOO\
l
=
lOOlOl\
lOO\
l
;
Ve\
c3
lOOOlOO\
OO\
O
=
lOOl\
Oll\
O\
Ol\

-
lOOlOl\
Olll\

;
lO\
Ol\
OOl\
Ol\
O\
O\
l
.
lOOlO\
llOOO
=
lOOOl\
OOO\
OO
.
Ge\
t\
Magn\
it\
ude
(
)
;
lOOlOOl\
O\
l\
OOl\

.
lO\
OO\
OOllOl
[
0
]
.
llOOOllOO\
lO
=
lO\
Ol\
O\
l\
Olll
.
x
;
lOOlO\
Ol\
OlO\
Ol
.
lOOO\
OOllO\
l
[
1
]
.
llOOOllOOlO
=
lO\
OlOlOll\
l\

.
y
;
lOOlOOlOlOO\
l
.
lOOOOOllO\
l
[
2
]
.
llOOOl\
lO\
OlO
=
lO\
OlO\
l\
Ol\
ll
.
z
;
lOO\
lOOl\
O\
lOOl\

.
lO\
OO\
O\
OllOl
[
0
]
.
llOO\
OllOOl\
l
=
lO\
OOlOOOOO
.
x
;
lOOlOOlO\
lOOl
.
lOOO\
O\
OllOl
[
1
]
.
ll\
OO\
O\
llO\
Oll
=
lO\
OO\
lOO\
O\
OO\

.
y
;
lOOlOOlOlOOl
.
lOO\
OOOllO\
l
[
2
]
.
llO\
O\
O\
ll\
O\
Oll
=
lOOOlOOO\
OO
.
z
;
if\

(
Fa\
bs
(
lOOOlOOOOO
.
x
)
>
lOOO\
lO\
OO\
ll
)
{
lO\
OlO\
OlO\
lOOl
.
lO\
OOO\
OllOl
[
0
]
.
ll\
OO\
Ol\
lO\
lOO
=
1.0f
/
lO\
OO\
lO\
OOOO
.
x
;
lOO\
lO\
OlOl\
OOl
.
lOOO\
OOl\
l\
Ol
[
0
]
.
llOOOl\
lOlOl
=
1
;
}
else
{
lO\
OlOO\
lOlOOl
.
lOO\
O\
OO\
llOl
[
0
]
.
llOO\
Oll\
OlOl
=
0
;
lOOlOO\
lOlOO\
l\

.
lOOO\
O\
OllO\
l
[
0
]
.
llO\
OOll\
OllO
=
(
lOOlO\
lOll\
l
.
x
+
lOOl\
Ol\
lOOl
.
x
)
*
0.5f
;
lO\
O\
l\
OOlO\
lO\
Ol\

.
lO\
OOOOllO\
l
[
0
]
.
llOO\
Ol\
lO\
lll
=
Fabs
(
lO\
OlO\
lOlll\

.
x
-
lOOl\
Ol\
lOOl
.
x
)
*
0.5f
;
}
if
(
Fabs
(
lO\
OOlOOO\
OO
.
y
)
>
lOO\
O\
lO\
O\
Oll
)
{
lOO\
lO\
OlO\
l\
O\
O\
l
.
lOOOOOllOl
[
1
]
.
llOOOllOlOO
=
1.0f
/
lOO\
OlO\
OO\
O\
O
.
y
;
lOO\
lOOlOlOOl\

.
lOOO\
OOllOl\

[
1
]
.
llOOOll\
OlO\
l
=
1
;
}
else
{
lOO\
lO\
O\
lO\
lOOl
.
lOOO\
OO\
llO\
l\

[
1
]
.
llO\
OO\
llOlOl
=
0
;
lO\
OlOO\
lOl\
OOl
.
lO\
OOO\
Oll\
Ol
[
1
]
.
llOOOl\
l\
OllO\

=
(
lOO\
lOlO\
lll\

.
y
+
lO\
OlO\
llOO\
l
.
y
)
*
0.5f
;
lOOlOOlO\
l\
OOl\

.
lOO\
OO\
O\
ll\
Ol\

[
1
]
.
llOO\
OllO\
l\
ll
=
Fabs\

(
lOOl\
OlO\
ll\
l
.
y
-
lOO\
lOllO\
O\
l
.
y
)
*
0.5f
;
}
if
(
Fabs\

(
lOO\
Ol\
OOOOO
.
z
)
>
lOO\
OlO\
OOll
)
{
lOO\
lOOlOlO\
O\
l\

.
lO\
O\
O\
OO\
llOl
[
2
]
.
llOOO\
llO\
lOO
=
1.0f
/
lOOOlO\
OOOO
.
z
;
lOO\
l\
OOl\
OlO\
Ol
.
lOOOOOllO\
l
[
2
]
.
llOO\
OllOlOl
=
1
;
}
else\

{
lO\
OlOOlOlOOl\

.
lOOO\
OOll\
Ol
[
2
]
.
llOOOllO\
lOl\

=
0
;
lOOl\
O\
OlOlO\
Ol\

.
lO\
OO\
OOl\
lO\
l
[
2
]
.
llO\
OO\
l\
lOllO
=
(
lOOl\
O\
l\
Oll\
l
.
z
+
lOO\
lOllO\
Ol
.
z
)
*
0.5f
;
lOO\
l\
OOlO\
lOOl
.
lO\
OOOOllOl\

[
2
]
.
llOOOllOl\
ll
=
Fabs\

(
lOOlOlOlll
.
z
-
lOOlOll\
OOl
.
z
)
*
0.5f
;
}
llOO\
Ol\
ll\
OOO\

(
lOOlOOOll\
OOl
,
llll\
Ol\
OOOlO
.
v3Extent\

.
x
,
llll\
Ol\
O\
OOlO\

.
v3Ce\
n\
te\
r
,
&
lOO\
lOOl\
OlOOl\

)
;
}
lOOlOOOlOllO
::
llO\
OO\
O\
O\
lOOO\

*
lO\
OlO\
OOlOllO\

::
ll\
OOOOlOOOO
(
llOO\
OO\
Ol\
OOO
*
*
lOO\
lO\
O\
lOlOll
)
{
ll\
OOOO\
OlOO\
O
*
llOOOOOll\
ll
=
lOOll\
OlllOl
;
if\

(
lOOllOlllOl\

)
{
lOOllOlllOl\

=
lOO\
llOlllOl
->
lOOOOOlOO\
Ol
(
)
;
if
(
lOOllOl\
llO\
l
)
{
TA_AS\
S\
ERT\

(
lOO\
llOll\
lOl
->
lOl\
OllOOll\

&
lO\
Ol\
OOlOllOO\

)
;
lOOllO\
l\
llOl
->
lO\
OlOOOO\
O\
lO
(
)
=
&
lOO\
llO\
l\
llOl\

;
}
TA\
_ASSER\
T
(
llOOOOOllll
->
lOlOllOOl\
l
&
lOO\
l\
OOlOllOO
)
;
memset
(
llOO\
OOOll\
ll
,
0
,
sizeof
(
llOOOOO\
l\
OOO
)
)
;
lOOOllll\
lll\
l
(
llO\
OOOOllll\

)
;
}
else
{
if\

(
lO\
OlOOO\
OO\
Oll
<=
0
)
return
0
;
cons\
t
int
lO\
OlOOl\
O\
llOl
=
lO\
OlOOOOOOOl
;
int
lO\
OlOOlOll\
lO
=
lOOlOOO\
OOOOO
.
lOOOll\
lOOl
(
)
-
lOOlOOOOO\
O\
ll\

;
const
int
lOOlOO\
lOlll\
l
=
lO\
O\
lOOlO\
lllO\

-
lOOlOOl\
O\
l\
lOl
;
in\
t
lOOlOOl\
lOOOO
=
(
int\

)
(
sizeof
(
llOOOOOlOOO
)
/
4
)
-
lOOlOOlOl\
lll
;
whil\
e
(
lOO\
lOOllOO\
O\
O\

>
0
)
{
if\

(
!
lOOlOOOlllOl
)
retur\
n
0
;
lO\
OlOOllOOO\
l
(
lOOlOO\
lO\
lll\
O
,
lOOlOOl\
OlO\
l\
l\

)
;
lOO\
l\
OOlOlll\
O
+=
(
int
)
(
siz\
eof
(
lO\
Ol\
OO\
O\
lOll\
l
)
/
4
)
;
lOOl\
OOllOOO\
O
-=
(
in\
t
)
(
sizeo\
f
(
lO\
Ol\
OOOlOll\
l
)
/
4
)
;
lOO\
lOO\
OOOOll
=
lOOlO\
OOO\
OO\
O\
O
.
lOOO\
lllOOl
(
)
-
lOO\
lOOlOl\
llO
;
}
ll\
O\
OOO\
O\
ll\
l\
l
=
(
llOOO\
OOlOOO
*
)
&
lOO\
lO\
O\
OOO\
O\
OO
[
lOOlOOlOllOl
]
;
me\
ms\
e\
t\

(
ll\
OOO\
OOllll
,
0
,
sizeof
(
ll\
O\
OOOOlOO\
O
)
)
;
lO\
Ol\
OOOOO\
OO\
l
+=
(
int
)
(
size\
of
(
ll\
OOOOOl\
OO\
O
)
/
4
)
;
TA_\
AS\
SE\
RT
(
lOOlOO\
OOOO\
O\
l\

+
lOOl\
OOOOOOll
<=
lOOl\
O\
O\
OOO\
O\
OO\

.
lO\
OO\
l\
llOOl
(
)
)
;
lOOOll\
ll\
lll\
l\

(
llOOO\
OO\
llll
)
;
}
re\
tu\
r\
n\

ll\
OOO\
OOll\
ll
;
}
void
lO\
Ol\
O\
O\
O\
lOl\
l\
O
::
llOOOOOOlO\
O
(
llOOOO\
Ol\
O\
OO\

*
ll\
OOOO\
O\
lOOl
)
{
TA_A\
SSER\
T\

(
(
llOOOOOl\
O\
Ol
->
lOlOllOOll
&
lOOl\
OOlOllO\
O
)
==
0
)
;
lO\
O\
Olllll\
l\
ll\

(
llOOOOO\
lOO\
l
)
;
TA_A\
SSERT
(
!
lOO\
l\
lOlllOl
||
lO\
Oll\
Ol\
llOl\

->
lOOlO\
O\
OOOlO
(
)
==
&
lO\
OllOlllOl
)
;
ll\
OOOO\
OlOOl
->
lO\
OOOOlOOOl
(
)
=
lO\
OllOl\
ll\
O\
l
;
if
(
lOOll\
Ol\
l\
lO\
l
)
lOOll\
Ol\
ll\
O\
l
->
lOOlOOO\
OOl\
O
(
)
=
&
ll\
OO\
O\
OOlO\
Ol
->
lOOOOOl\
OOOl
(
)
;
lOOl\
lOl\
l\
l\
Ol\

=
ll\
OOOO\
OlO\
Ol
;
llO\
OOOOlOOl\

->
lOOlOO\
OOOlO
(
)
=
&
lOOllOl\
llO\
l
;
ll\
OOO\
OOlO\
Ol
->
lOlOllOO\
ll
=
lOOlOOlOllOO
;
}
lOO\
lOO\
OlOl\
l\
O
::
lOOlOOOl\
Ol\
l\
l\

*
lOOlO\
OOlOllO
::
lO\
Ol\
OO\
l\
OO\
llO
(
llOOOO\
O\
lOOO\

*
*
lOOlO\
OlOlO\
ll
)
{
lOOlO\
OOlOlll
*
llOO\
OOOl\
l\
ll
=
lOOlO\
OOl\
ll\
O\
l
;
if\

(
lOOlOOOlll\
Ol\

)
{
TA\
_\
A\
SS\
ER\
T
(
llOO\
OOOl\
lll
->
lOlOllOOll\

&
lO\
O\
lO\
OlOll\
O\
O
)
;
lOOlOOOl\
llOl\

=
lO\
OlO\
O\
Ol\
llO\
l
->
lOOO\
OOlO\
OOl
(
)
;
if\

(
lO\
Ol\
OOOl\
llO\
l
)
{
TA_\
A\
SSERT\

(
lOOlOO\
OlllOl
->
lOlOl\
l\
OOll\

&
lOO\
lO\
OlOl\
lOO
)
;
lOOlOO\
OlllO\
l
->
lOO\
lO\
OO\
OOlO\

(
)
=
&
lOOlO\
O\
Ol\
llOl
;
}
TA_\
ASSE\
RT\

(
ll\
O\
OO\
OOllll
->
lOlO\
llO\
O\
l\
l\

&
lO\
O\
lOOlOllO\
O\

)
;
me\
mset
(
llOOO\
OO\
l\
l\
ll
,
0
,
sizeof
(
lOOl\
OOOlOlll
)
)
;
lOO\
l\
OOOOO\
OlO
(
ll\
O\
O\
OOOl\
ll\
l
)
;
}
else
{
if
(
lO\
O\
l\
OOOOOO\
O\
l
<=
siz\
eof
(
ll\
OO\
OOOlO\
OO\

)
||
!
lOOl\
lOl\
ll\
Ol
)
retu\
rn
0
;
int
lO\
O\
lOOlOl\
lOl
=
lOOlOOOOOOO\
l\

;
int
lOOlOO\
lO\
l\
llO
=
lO\
O\
l\
OO\
OOOOO\
O
.
lOOOlllO\
Ol
(
)
-
lOOlOOOOOOll\

;
co\
n\
s\
t
int\

lO\
OlOOlOll\
ll
=
lOOlOOl\
Oll\
l\
O\

-
lOO\
lO\
OlOl\
l\
Ol
;
int
lOOl\
OOll\
OO\
OO
=
(
(
(
int\

)
sizeof
(
lOOlOOOlOl\
ll
)
/
4
)
-
lOOlOOlOllll
)
;
if\

(
lO\
OlOOllO\
OOO\

>
0
)
{
TA_A\
SS\
ER\
T
(
lOO\
lOO\
l\
lOO\
OO
-
(
int\

)
(
sizeof
(
llO\
O\
OO\
OlO\
OO
)
/
4
)
<=
0
)
;
lOOlOOlOll\
Ol
-=
(
int
)
(
siz\
eof
(
ll\
OOOOO\
l\
OO\
O
)
/
4
)
;
lO\
OlOO\
l\
lOOl\
O
(
lOOlOOlOl\
lO\
l
,
lO\
OlO\
OlOlOll
)
;
}
lOOlOO\
O\
OOOOl\

=
lOOlOOlOllO\
l
;
lOOlOOlOlllO
-=
(
(
int
)
size\
of
(
lOOlO\
O\
OlOl\
ll\

)
/
4
)
;
llO\
OO\
OOl\
ll\
l
=
(
lOO\
lO\
OOlOll\
l
*
)
&
lOOlOOOOO\
OO\
O
[
lO\
OlOOl\
Ol\
l\
lO
]
;
memset
(
llOO\
O\
OO\
llll
,
0
,
sizeof\

(
lOO\
lOOOlO\
lll
)
)
;
lOOlO\
O\
O\
O\
OOll
=
lOO\
lOOOOO\
OOO
.
lOO\
OlllO\
O\
l
(
)
-
lOOlO\
Ol\
OlllO
;
TA_\
ASSERT
(
lOO\
l\
OOO\
OO\
OOl\

+
lO\
O\
lO\
OOO\
O\
Oll
<=
lO\
O\
lOOOOOOOO
.
lOOOl\
llOO\
l
(
)
)
;
lOOlO\
OOOOOlO
(
llO\
O\
OOOll\
ll
)
;
}
ret\
urn
llOO\
O\
OOllll\

;
}
voi\
d
lOOlOOOl\
OllO
::
lOO\
l\
OOlOOOOO
(
lOOlOOOlOll\
l
*
llOOOO\
OlOO\
l
)
{
TA_ASSER\
T\

(
(
llOOO\
OOlOOl
->
lO\
lOllOOll
&
lO\
OlOOlO\
llOO\

)
==
0
)
;
lOOl\
O\
OOO\
OOlO\

(
ll\
OOOO\
O\
lOOl\

)
;
TA_\
AS\
SER\
T
(
!
lOOlOO\
Olll\
Ol\

||
lO\
OlO\
OOl\
llOl
->
lOOlO\
O\
OO\
O\
lO
(
)
==
&
lOOl\
OO\
Ol\
llOl
)
;
llOOOO\
OlOOl
->
lOO\
OO\
OlOOOl\

(
)
=
lO\
OlOOO\
lll\
Ol
;
if
(
lOO\
lO\
OOll\
lOl
)
lOO\
lOO\
OlllOl
->
lOO\
lOOOO\
O\
l\
O
(
)
=
&
llOOOOOl\
OO\
l
->
lOOOOOlOO\
Ol\

(
)
;
lOO\
lOOO\
lll\
Ol
=
ll\
OO\
OOOl\
OOl\

;
ll\
OOOOOlOOl
->
lOOl\
OO\
O\
OOlO
(
)
=
&
lOOlOOO\
lllOl\

;
llOOOO\
Ol\
OOl\

->
lOlOllOO\
ll
=
lO\
Ol\
OO\
lOllOO
;
}
voi\
d\

lOOlO\
OO\
l\
O\
l\
lO
::
lO\
OlO\
Ol\
l\
OOlO\

(
int
lOO\
lO\
O\
l\
lOOll
,
llO\
O\
OOO\
l\
O\
O\
O\

*
*
lOO\
l\
OO\
lOlO\
ll
)
{
lO\
OlOOO\
OOlll\

(
lO\
OlOO\
Oll\
OO\
l\

)
;
ll\
OO\
OOO\
lOOO
*
llOO\
OOO\
l\
OOl
=
(
llOO\
O\
OOl\
OOO
*
)
&
lOOlOOOOOO\
OO\

[
lOOlOOl\
l\
OO\
ll
]
;
if
(
ll\
O\
O\
O\
OOlOOl
->
lO\
lOllOOl\
l
&
lO\
Ol\
OO\
lO\
llO\
O
)
{
lO\
OOllll\
llll
(
llOOOOO\
lOOl
)
;
lOO\
lOOO\
O\
llOO
(
(
ll\
OOOO\
OlOO\
O
*
)
lOOl\
lO\
l\
ll\
Ol
,
(
ll\
O\
OOO\
O\
lOOO\

*
)
llOO\
OO\
O\
lO\
Ol
)
;
TA_\
ASSERT
(
&
lOO\
lO\
OOO\
OOO\
O\

[
lOOlO\
O\
llOOll
]
!=
(
u3\
2
*
)
lOO\
l\
OOOll\
O\
Ol
)
;
TA_\
ASSE\
RT
(
!
llOOOOO\
l\
OOl
->
lOO\
OOOlOO\
Ol
(
)
||
llOOOOOl\
OOl
->
lOOOOOlOO\
Ol\

(
)
->
lOOlOOO\
O\
O\
lO\

(
)
==
&
llO\
OOOOlOOl
->
lO\
O\
O\
O\
Ol\
OOOl\

(
)
)
;
TA_AS\
SERT\

(
llOOOOOl\
OO\
l
->
lOOlOO\
O\
OO\
lO
(
)
)
;
TA_\
AS\
S\
ERT\

(
*
llOOOOOlOO\
l
->
lOOlO\
O\
OOOl\
O
(
)
==
llOO\
OOOlO\
O\
l
)
;
*
ll\
O\
O\
OO\
OlOOl
->
lOOlO\
OO\
OOlO\

(
)
=
ll\
OO\
OOOlOOl
->
lOOOOO\
lOOO\
l
(
)
;
if\

(
llOO\
O\
OO\
lO\
Ol
->
lO\
OOOOlOOO\
l
(
)
)
llOOOOO\
lOOl\

->
lOOOO\
OlOOOl
(
)
->
lOOlOO\
OOO\
lO\

(
)
=
llOOOOOlOOl
->
lOOlOOO\
O\
OlO
(
)
;
}
else
{
TA\
_\
ASSER\
T
(
&
lO\
OlO\
OOOOO\
OO
[
lO\
OlO\
OllOOll
]
!=
(
u32
*
)
lO\
OlOO\
OllOOl
)
;
lO\
Ol\
OOOOOlOO\

(
llOOOOOl\
OO\
l
)
;
llO\
OOOO\
lOOO
*
ll\
OO\
O\
O\
Ol\
lll
=
lOOllOl\
l\
l\
O\
l\

;
TA_ASSE\
RT
(
llOOOOO\
ll\
l\
l
)
;
lOOl\
lOlllOl\

=
lOO\
llOll\
lOl\

->
lOOOOOl\
O\
OOl\

(
)
;
if\

(
lO\
OllOlllO\
l
)
lO\
Ol\
l\
OlllO\
l\

->
lOOl\
O\
OOOOlO
(
)
=
&
lOOllOlllOl
;
lOO\
Ollllll\
ll\

(
llOOO\
OOllll
)
;
memcpy\

(
llOO\
OOOllll
,
llOOOOO\
lOOl\

,
si\
z\
eof
(
llOOOO\
O\
lOOO
)
)
;
fo\
r
(
int
lOOOl\
lOO\
O\
l
=
0
;
lO\
OOl\
lOOOl
<
8
;
lOOOllOO\
O\
l
++
)
{
if
(
llOOOO\
Ol\
lll
->
llOOOOlOOll
[
lOOOllO\
OO\
l
]
)
ll\
OOOO\
Oll\
ll
->
ll\
OOOOlO\
Oll
[
lOO\
OllO\
OOl
]
->
ll\
OOO\
OOl\
lOl
=
llOOOOO\
llll
;
}
if
(
llOOOOOllll\

->
llOOOOO\
llOl\

->
lOlOllOOll\

&
lO\
OlOOOlll\
lO\

)
ll\
OOO\
OO\
lll\
l\

->
llOOOOO\
ll\
O\
l
->
llOOO\
OlOOll\

[
llO\
O\
OOOlll\
l
->
llOOOOl\
OlOO\

]
=
llOOOOOllll
;
else\

(
(
lO\
O\
lOOOlOlll
*
)
ll\
O\
OOO\
Ollll\

->
llO\
OO\
OO\
l\
l\
Ol\

)
->
llOOOOO\
lll\
O
=
llOOOOOllll
;
if
(
llOOOO\
Ollll
->
llOO\
OO\
lOllO\

)
llOO\
OO\
Oll\
ll
->
ll\
OOOOlOll\
O
->
llOOOOlOll\
l
=
&
ll\
O\
OOOOllll\

->
llOO\
OOlOll\
O
;
lOOlO\
OOOOlOO
(
llO\
OOOOlll\
l
)
;
lO\
OlOOO\
OOlOO\

(
ll\
OOOOO\
llll
->
llO\
OOOOll\
Ol
)
;
if
(
*
lOOlOOlOlOll\

==
llO\
OO\
OOlOOl\

)
*
lOOlOOlO\
lOll
=
llOOOOOll\
ll
;
lO\
OlOOOO\
Ol\
OO
(
*
lO\
Ol\
OO\
lOlOl\
l
)
;
}
lOOl\
O\
OO\
OOl\
ll
(
lOOlO\
OOllOOl
)
;
}
vo\
id\

lOOl\
O\
OOlOllO
::
lOOl\
OOllO\
OOl\

(
int\

lOOlO\
Oll\
OOll
,
ll\
OOOOOlO\
OO
*
*
lOOlO\
Ol\
OlO\
ll
)
{
lOOlOOO\
OOll\
l
(
lOOlOOOll\
OOl\

)
;
lOOlO\
OOl\
O\
lll
*
ll\
O\
OO\
OO\
lOO\
l\

=
(
lOO\
lOOOl\
Oll\
l\

*
)
&
lOOlO\
O\
OOOO\
OO
[
lOOlOOllO\
O\
l\
l\

]
;
if
(
ll\
OO\
OOOl\
OOl\

->
lOlO\
llOOll
&
lO\
O\
lOOlOll\
O\
O\

)
{
lOOl\
OO\
OOOOlO
(
ll\
O\
OOOOlOOl
)
;
lOOlOO\
OOll\
O\
O\

(
(
llO\
OOOOl\
O\
OO
*
)
lOOl\
OOOlllOl
,
(
ll\
OOOOO\
lOO\
O
*
)
llOOO\
OOl\
OO\
l
)
;
TA\
_ASSERT\

(
!
llOO\
O\
OO\
lO\
Ol\

->
lOOO\
OOlOOO\
l
(
)
||
*
ll\
OOOOOlO\
Ol
->
lO\
OOOOlO\
OOl\

(
)
->
lO\
OlOOOOOlO
(
)
==
llOOOOO\
lO\
Ol
->
lOOO\
OOlOOOl
(
)
)
;
TA\
_\
ASS\
E\
RT
(
!
llOO\
OOO\
lO\
Ol
->
lOOOOO\
lO\
OOl
(
)
||
llOOO\
OOlOO\
l
->
lOOO\
O\
OlOOOl
(
)
->
lOOlOOOO\
OlO\

(
)
==
&
llOOOOOlO\
Ol\

->
lOOOO\
OlOOOl\

(
)
)
;
TA_A\
SSERT
(
llOOO\
OOlO\
Ol
->
lOOl\
OOO\
OOlO
(
)
)
;
TA_A\
SSE\
RT
(
*
llOOO\
OO\
l\
OO\
l
->
lO\
O\
l\
OO\
OOOlO
(
)
==
llO\
O\
OOOl\
OOl
)
;
*
llOOOOO\
lOOl
->
lOOlO\
OO\
OOlO
(
)
=
llOOO\
OOlO\
O\
l
->
lOOOO\
OlOOOl\

(
)
;
if
(
llOO\
OOO\
lOOl\

->
lOOOO\
OlOOOl\

(
)
)
llOOOOOlOO\
l\

->
lO\
OOO\
Ol\
OOO\
l
(
)
->
lOOl\
OOO\
O\
O\
lO
(
)
=
llOOOOOlO\
Ol
->
lOOlOO\
OOO\
lO
(
)
;
}
else
{
lOOlOOOOlO\
Ol
(
lOOlOO\
OllOOl
,
(
llOOOOOl\
OOO
*
)
ll\
OOOO\
O\
lOOl
)
;
lOOlOO\
O\
OO\
lOO
(
(
ll\
OOO\
O\
O\
lOO\
O
*
)
llOOOOO\
l\
OOl
)
;
lOOl\
OOOlOll\
l\

*
ll\
OOOOOlll\
l\

=
lOOlOOOlll\
Ol\

;
TA_A\
SS\
ERT\

(
llOOO\
OOll\
ll
)
;
lOOlO\
O\
O\
l\
ll\
Ol
=
lOOlOOOlllO\
l\

->
lO\
O\
OO\
OlOOO\
l
(
)
;
if
(
lOOlOOOlllOl\

)
lOO\
lO\
O\
O\
lllOl
->
lOO\
lOOOO\
O\
lO
(
)
=
&
lOO\
lOO\
O\
lllO\
l
;
lOOlOOOOOO\
lO
(
llO\
OOOOl\
l\
l\
l
)
;
mem\
c\
py
(
llOO\
OOOll\
ll
,
llOOOO\
O\
lOOl\

,
si\
zeof
(
lOOlO\
OOlOlll
)
)
;
if
(
llOO\
OOOllll
->
llOOOOOl\
ll\
O
)
llOOO\
O\
Ollll\

->
llOO\
OOO\
l\
llO
->
llOOOO\
Oll\
Ol
=
(
llOO\
O\
OOlOOO
*
)
llOOO\
OO\
lll\
l
;
TA_\
ASSER\
T
(
llOOOOO\
l\
lll
->
llOOOOOllOl
)
;
if
(
llO\
O\
OOO\
lll\
l\

->
llOOOOOl\
l\
O\
l
->
lOlOllO\
O\
l\
l
&
lOOlOO\
O\
l\
lllO\

)
llOOOO\
O\
llll
->
llOO\
O\
OO\
llOl
->
llOOO\
O\
lOOll
[
ll\
OO\
OOO\
lll\
l
->
llOOOOlOlOO
]
=
(
llO\
OOOOlOOO
*
)
llOOO\
OOllll
;
el\
se
(
(
lOOl\
OO\
O\
l\
O\
lll
*
)
ll\
O\
OOO\
Ollll
->
llOOOOOllO\
l
)
->
llOOO\
OO\
lllO
=
(
ll\
OO\
OOO\
l\
O\
OO
*
)
llOO\
O\
OOllll
;
if\

(
ll\
OOOOO\
llll
->
ll\
OO\
OOlO\
llO
)
llOOO\
O\
O\
llll
->
llOOOOlO\
llO\

->
llOO\
O\
O\
lOl\
ll
=
&
llOOOO\
O\
l\
lll
->
llOOOOl\
Oll\
O\

;
lO\
O\
lOOOO\
OlO\
O
(
(
ll\
OOOO\
OlOOO\

*
)
llOOO\
OOlll\
l
)
;
lOOl\
OOOOOlO\
O\

(
llOOOOOlll\
l\

->
llOOOO\
O\
l\
lOl\

)
;
if
(
*
lOOlOOl\
Ol\
Oll
==
(
llOOOOOlOOO
*
)
ll\
OO\
O\
OO\
lO\
O\
l
)
*
lO\
O\
lOOl\
O\
lOll
=
(
ll\
OO\
OOOl\
OOO
*
)
llO\
O\
O\
OOll\
ll
;
lOO\
lOOOOOlOO\

(
*
lOO\
l\
OOl\
Ol\
O\
ll
)
;
}
lOO\
l\
OOO\
O\
Olll
(
lOOlO\
OOl\
lOO\
l
)
;
}
void
lOOlOOOl\
Ol\
lO
::
lOOlOOOOOlOl
(
ll\
OO\
OOOlOO\
O\

*
llO\
OOOOlOOl
,
bool\

lOOl\
OOllOlO\
O
)
{
#ifdef _DEBUG
if\

(
!
lO\
OlOOOllO\

)
retu\
rn\

;
TA_ASS\
ERT
(
llO\
OOOOlOOl
)
;
TA_ASSERT\

(
(
llOO\
OOOl\
OOl
->
lOlOllOOll
&
lOOl\
OOlOllO\
O
)
==
0
)
;
if
(
llO\
OOO\
Ol\
O\
Ol
->
ll\
OO\
O\
O\
lOllO\

)
{
TA\
_\
ASS\
ERT\

(
llOO\
OOOlO\
Ol
->
llOOO\
OlO\
ll\
O
->
ll\
OOOOlOl\
l\
l\

==
&
llOO\
OOO\
lOOl
->
llOOOOlOl\
lO
)
;
}
if
(
ll\
OO\
OO\
OlOOl
->
lOlOl\
lOOll
&
lOOl\
OOOllllO
)
{
if
(
llOO\
O\
OOlO\
Ol\

!=
lOOl\
OOOll\
OO\
l
)
{
lOOOl\
l\
ll\
llll\

(
ll\
OOOO\
Ol\
O\
Ol
)
;
if
(
lOO\
lOO\
l\
lO\
lO\
O\

)
{
TA_AS\
SERT\

(
llOOO\
O\
O\
lOOl
->
llOllOOll\
l
>
1
)
;
}
TA_ASSERT
(
llO\
OOO\
O\
l\
OOl\

->
llOl\
lOOlll\

>
0
)
;
TA_\
ASS\
E\
R\
T
(
llOOOOOlOOl
->
ll\
OOOOO\
ll\
Ol\

)
;
}
TA_\
AS\
SERT
(
llOOOOOlOO\
l
->
llOllO\
Oll\
l
<=
8
)
;
TA\
_AS\
SE\
R\
T
(
ll\
OO\
O\
OOlOOl
->
llOO\
O\
O\
lOOlO
==
0
)
;
int
llOllOO\
lll
=
0
;
for
(
in\
t\

lO\
OOl\
l\
OOOl
=
0
;
lOO\
O\
llO\
OOl\

<
8
;
lOO\
OllOOO\
l\

++
)
{
if\

(
llOOOOOlOOl
->
llOOOO\
lO\
Oll
[
lOOO\
llO\
OOl
]
)
{
TA_ASSE\
RT
(
ll\
OO\
OOOl\
OOl
->
ll\
OOOOlOOll
[
lOO\
Oll\
OOO\
l
]
->
ll\
O\
OOOOl\
lOl\

==
llOOOOOl\
OO\
l
)
;
TA\
_ASS\
ER\
T
(
llOOO\
O\
Ol\
OOl
->
llOOOOlOO\
ll\

[
lOOOl\
lOOOl
]
->
ll\
OO\
O\
O\
l\
OlOO\

==
lOOOllOOOl
)
;
llOllO\
O\
l\
ll\

++
;
}
}
TA_\
ASSE\
R\
T
(
ll\
O\
ll\
OOl\
ll
==
llOO\
O\
O\
OlOOl
->
llOllO\
Ol\
ll
)
;
}
else
{
TA_AS\
S\
ERT
(
ll\
O\
OOO\
O\
lOOl
!=
lOO\
lO\
OOll\
O\
Ol\

)
;
lOOlO\
O\
OlOl\
l\
l
*
lOO\
lOOOlllll\

=
(
lO\
OlO\
OO\
lOl\
ll
*
)
llOOOOO\
lO\
Ol
;
lO\
OlOOOOOO\
l\
O
(
lO\
OlOO\
Ol\
llll\

)
;
TA_ASSERT
(
lOOlOOOl\
l\
lll
->
llO\
llOOl\
ll
<=
1
)
;
TA_\
ASSERT
(
lO\
O\
l\
OO\
O\
lll\
ll
->
llOOOOOllOl
)
;
if
(
lOO\
l\
O\
OOlll\
ll
->
llOOOOOll\
l\
O\

)
{
TA_A\
S\
S\
ERT
(
lOOl\
OOO\
l\
lll\
l\

->
ll\
OllO\
O\
ll\
l
==
1
)
;
TA_AS\
SERT
(
lOO\
lO\
OO\
ll\
ll\
l
->
llOOOOlO\
OlO\

==
lO\
Ol\
OOO\
lllll\

->
llOOOO\
O\
lllO
->
llOO\
O\
OlOlOO
)
;
TA_ASSE\
R\
T
(
llO\
OOO\
OlOOl
==
lO\
O\
lOOO\
lll\
ll
->
llOOOO\
OlllO\

->
llOO\
OOOllOl
)
;
}
else
{
TA_ASS\
ERT
(
lO\
OlO\
OO\
lllll\

->
llO\
llOOlll
==
0
)
;
}
}
if
(
llOOO\
OOlOOl\

->
llOOOOO\
llOl\

)
{
if
(
llOOO\
OOlOO\
l
->
llO\
OOOOll\
Ol
->
lOlOl\
lOO\
ll
&
lO\
Ol\
OOOllllO
)
{
TA_ASSERT
(
llOOOO\
O\
l\
O\
Ol
->
llOOO\
OO\
l\
l\
Ol
->
llOOO\
OlO\
Oll\

[
ll\
OOOOOlOO\
l
->
llOOOO\
lOl\
OO\

]
==
llO\
OOOOl\
O\
Ol
)
;
}
els\
e
{
TA\
_ASSERT
(
(
(
lOOlO\
OO\
lOl\
ll\

*
)
ll\
OO\
OOOl\
OOl
->
ll\
OOO\
OOl\
lO\
l\

)
->
llO\
OO\
OOll\
lO
==
llO\
OOO\
OlO\
Ol
)
;
TA_ASS\
ER\
T
(
(
(
lO\
OlOOOlO\
l\
ll
*
)
llO\
OOO\
OlO\
Ol
->
llOO\
OOO\
ll\
O\
l
)
->
llO\
OO\
O\
lOOlO
==
ll\
O\
OO\
OO\
lO\
Ol
->
llOO\
OOlOl\
OO
)
;
}
}
#endif //
}
voi\
d
lO\
OlOOO\
l\
OllO
::
ll\
OOOlOllOl
(
llOOOOOlO\
OO
*
ll\
OOOOOlOOl
,
in\
t
lO\
OlOO\
lOOlOl\

,
int
llO\
OOOO\
Oll
,
int
llO\
O\
OOOlOO\

,
int\

llO\
OOOOl\
Ol\

,
lOOlOOlOlOO\
O
*
lOOl\
OO\
l\
l\
Ol\
Ol
)
{
lOOl\
OOOlO\
l\
lO
::
ll\
OOOOOlOOO
lOOlOOllOllO
;
TA_\
ASSERT
(
lO\
OlOOl\
OOl\
Ol\

>=
0
)
;
TA_AS\
SERT
(
llOOOO\
OlO\
Ol\

)
;
lO\
O\
l\
O\
OOOOlOO
(
llOOOO\
OlO\
Ol
)
;
for\

(
Space\
Divis\
i\
o\
nObject
*
llOO\
OOllOOO
=
llOO\
OOOlOO\
l
->
llO\
OOOlOllO\

;
ll\
OOOO\
l\
l\
O\
OO
;
llOOO\
OllOOO
=
llOOOOll\
OOO
->
llO\
O\
O\
lOOOOl
)
{
lOOl\
OOl\
l\
O\
lOl\

->
llOOlOllOlO
(
*
llOOOOllOOO
,
lOOlOOllOlOl
->
lO\
OOOlll\
lO
)
;
}
lOOlOOlOOl\
Ol\

--
;
llOOOOOOll
<<=
1
;
llO\
O\
OO\
O\
lO\
O
<<=
1
;
llOOOOOlOl
<<=
1
;
int\

lOlO\
OOllOl
=
0
;
if
(
llOOOO\
OlOOl
->
lOlOll\
O\
Ol\
l
&
lOOlO\
O\
Olll\
lO
)
{
#define lOOlOOllOlll(llOOOOOOll, llOOOlOlOlO, lOOlOOlllOOO, lOOlOOlllOOl)									\
		const int llOOOlOlOlO = (lOOlOOllOlOl->llOOOlOlOlO >> (lOOlOOlOOlOl)) + 1;					\
		if (Abs(llOOOOOOll + 0 - (lOOlOOllOlOl->llOOOOOOll >> lOOlOOlOOlOl)) <= llOOOlOlOlO)						\
		{																					\
			const int lOOlOOlllOOO = 0;															\
			lOOlOOlllOOl																			\
		}																					\
		if (Abs(llOOOOOOll + 1 - (lOOlOOllOlOl->llOOOOOOll >> lOOlOOlOOlOl)) <= llOOOlOlOlO)						\
		{																					\
			const int lOOlOOlllOOO = 1;															\
			lOOlOOlllOOl																			\
		}
lO\
OlOO\
llOlll\

(
llOOOOO\
Oll\

,
llOOOlOlOlO
,
lOOl\
O\
Ol\
ll\
O\
OO
,
lOOlO\
O\
l\
lOlll
(
ll\
O\
OO\
OO\
lO\
O
,
llOOOlOl\
Ol\
l
,
lOOlOO\
l\
l\
l\
OlO
,
lOO\
lOO\
llOlll
(
llOOOOO\
lOl\

,
llO\
OOlOll\
O\
O
,
lOOlOOlll\
Oll
,
{
const\

int
llOOO\
Ol\
O\
lOl
=
(
lOOlOOlllOOO
<<
2
)
+
(
lO\
O\
lOO\
l\
llOlO
<<
1
)
+
lOOlOOl\
l\
l\
Oll
;
TA\
_A\
SSE\
RT
(
llOOO\
O\
lOlO\
l
>=
0
&&
llOOOOlOlOl\

<
8
)
;
if
(
llOOO\
OOl\
OOl
->
llOOO\
OlOO\
ll
[
llOOO\
Ol\
OlOl
]
)
{
llOO\
Ol\
OllOl
(
llOOOOO\
lOOl
->
llOO\
O\
OlOOl\
l
[
llOOOOl\
O\
lOl
]
,
lO\
O\
lOOlOOlOl
,
llO\
O\
OOOOll
+
lO\
OlOO\
lllO\
O\
O
,
llOO\
OO\
Ol\
O\
O
+
lO\
OlOOlllOlO
,
ll\
O\
OOOO\
lO\
l
+
lOO\
lOO\
lllOll\

,
lOOlOOllOlOl
)
;
}
}
)
)
)
#undef lOOlOOllOlll
}
el\
s\
e
{
lOOlOO\
OlOlll
*
lOO\
lOOOlll\
ll
=
(
lOOlOOOlOlll
*
)
ll\
OOOOOlOOl
;
if
(
lOOlOO\
O\
lllll\

->
llOOO\
OOlllO
)
{
co\
ns\
t
in\
t
llO\
OOlOlOlO\

=
(
lOO\
l\
OOllOlOl
->
llOOOlOlOlO\

>>
(
lO\
OlOOlOOlOl\

)
)
+
1
;
const
int\

lOOlOO\
l\
llOO\
O\

=
(
(
lOO\
lOO\
O\
lllll\

->
ll\
O\
OOOlOOlO
>>
2
)
&
1
)
;
if
(
Abs
(
llOO\
O\
OOOll\

+
lOOlOO\
l\
l\
l\
OO\
O\

-
(
lOOlOOl\
lOlOl
->
llOOOOOOll
>>
lOOlO\
Ol\
O\
OlOl
)
)
<=
ll\
OOOlOlO\
lO
)
{
co\
nst
int
llO\
OOl\
OlO\
l\
l
=
(
lOOlOOll\
O\
lOl\

->
llOOO\
lOlOl\
l
>>
(
lOOl\
OOl\
OOl\
O\
l
)
)
+
1
;
cons\
t\

int\

lO\
O\
l\
OOll\
lO\
lO\

=
(
(
lOO\
l\
O\
OOllll\
l
->
llOOOOlOOlO\

>>
1
)
&
1
)
;
if\

(
Abs
(
llOOOOO\
lOO\

+
lOOl\
OOll\
lOl\
O\

-
(
lOO\
lO\
Oll\
Ol\
Ol
->
ll\
OO\
O\
OO\
lO\
O\

>>
lOO\
lO\
Ol\
OOlO\
l\

)
)
<=
llOOOlOlOll\

)
{
con\
st\

int\

llOOOl\
O\
llOO
=
(
lO\
OlO\
Ol\
l\
OlO\
l
->
llOOOl\
OllOO
>>
(
lOOlOO\
lOOl\
Ol
)
)
+
1
;
co\
n\
s\
t
int\

lOOl\
OO\
lllO\
ll\

=
(
lOOlOOOlllll
->
llOO\
OOlOO\
lO\

&
1
)
;
if\

(
Abs
(
llOO\
OOOlO\
l\

+
lOOl\
OOlllOll
-
(
lO\
OlOOllOl\
Ol\

->
llO\
OOO\
O\
lOl
>>
lOOlO\
OlO\
O\
lOl
)
)
<=
llOOOlOllOO
)
{
ll\
OOOlOl\
lOl
(
lOO\
lOOOllll\
l
->
llOOOOOlll\
O
,
lOO\
l\
OOlO\
OlO\
l
,
llOOOOOOl\
l
+
lOOl\
O\
O\
lllOOO\

,
llO\
OO\
OOlOO
+
lOOl\
OOlllOlO
,
llOOOOOlOl\

+
lO\
OlO\
OlllO\
ll\

,
lOOlOO\
llO\
lOl
)
;
}
}
}
}
}
}
vo\
id
lOOlOO\
OlOllO
::
llOOO\
lllO\
OO
(
llOOOOO\
lO\
O\
O
*
llOOO\
OOlO\
Ol
,
float\

llOlllOOOl
,
Vec3
&
v3Cent\
er\

,
lOOlO\
OlO\
l\
OlO\

*
lOOl\
OOll\
OlO\
l
)
{
float\

lOO\
OOO\
ll\
l\
l\

;
float
lOOllO\
OOOl\

=
0.0f
;
float
lOOllO\
O\
OlO
=
lO\
OlO\
Ol\
l\
Ol\
Ol
->
lO\
Ol\
OllOOO
;
fo\
r
(
int
lOOO\
l\
l\
l\
lOl
=
0
;
lOO\
OllllOl
<
3
;
lOO\
Ol\
ll\
l\
O\
l
++
)
{
float
llOOO\
llO\
l\
ll
=
ll\
O\
ll\
l\
OOO\
l
*
3.0f
;
lO\
OlOOlO\
lOl\
O
::
Ax\
is
&
lOOOOOll\
O\
l
=
lOOlO\
O\
llOlOl\

->
lOOOOOl\
lO\
l
[
lOOOll\
llOl
]
;
float
llOOOll\
Oll\
O\

=
v3\
C\
enter
[
lOO\
O\
llllO\
l
]
;
lOO\
O\
O\
Ollll\

=
Sign
(
lOOOOOll\
Ol
.
llOO\
OllOlOO
)
;
if
(
lOO\
OOOllOl
.
llO\
OOllOlOl\

)
{
llOOOllOlll
*=
lO\
O\
O\
O\
Ollll\

;
flo\
a\
t\

lOlOlll\
OO\
l
=
llO\
OO\
ll\
Ol\
l\
O\

-
lOO\
OOO\
l\
l\
Ol\

.
llO\
O\
Ol\
lOOlO
;
floa\
t
lOO\
ll\
OOllO
=
(
lOlOl\
llOO\
l\

-
llOOOl\
lOlll
)
*
lOOOOOllOl
.
llOOO\
l\
lO\
lOO
;
if\

(
lOOl\
l\
OOO\
l\
O\

<
lO\
OllOOllO
)
ret\
urn\

;
fl\
oat
lOOllOOlll
=
(
lOl\
O\
l\
llOOl
+
llOOOll\
Ol\
ll\

)
*
lOOOOO\
l\
lO\
l\

.
llO\
OOllOlO\
O
;
if
(
lOOllOOOOl
>
lO\
OllOO\
lll\

)
return
;
Clam\
pIfLessT\
hen
(
lOOllOOOOl
,
lOOllOOll\
O
)
;
ClampI\
fG\
rea\
te\
rTh\
en\

(
lOOll\
OOOlO
,
lO\
OllOOlll
)
;
}
else\

{
if
(
Fabs
(
lO\
O\
OOO\
llOl\

.
llOO\
O\
llOll\
O
-
llOOOllO\
llO
)
>
lOOO\
OOllOl\

.
llO\
OO\
llO\
l\
ll
+
llOOO\
llOl\
ll
)
retu\
r\
n
;
}
}
TA_ASS\
ERT
(
llOOOO\
OlOOl
)
;
for
(
Spac\
eDivis\
i\
on\
Object
*
llOOO\
OllO\
OO
=
llOOOOO\
lO\
Ol
->
ll\
O\
OO\
OlO\
l\
lO\

;
llOO\
OO\
l\
lO\
O\
O
;
ll\
OOOO\
llOO\
O\

=
llOOOOllOO\
O
->
ll\
O\
OOlOOOO\
l
)
{
lOO\
lOOl\
l\
O\
lOl
->
llO\
O\
l\
OllO\
lO
(
*
ll\
O\
OOO\
llOOO\

,
lOOlOO\
ll\
Ol\
Ol
->
lOOOOll\
llO\

)
;
}
llOll\
lO\
O\
Ol
*=
0.5f
;
if
(
llOOOOOlOOl\

->
lOlOl\
lOO\
ll
&
lOO\
lOOO\
lll\
lO\

)
{
for\

(
int\

ll\
OO\
OOlOlO\
l
=
0
;
llOOO\
OlOlO\
l
<
8
;
llO\
OOOlOlOl
++
)
{
if
(
llO\
OOOOlOOl
->
llO\
OOOlOOll
[
ll\
O\
O\
OOlOlOl
]
)
{
Vec3
lOOOOOOlO\
O
=
v3\
Center
;
lOOOOO\
OlOO
.
x
+=
llOlllO\
OOl
*
(
flo\
at
)
(
(
(
llOOO\
Ol\
OlOl
&
0x4
)
>>
1
)
-
1
)
;
lOOOOOO\
lOO
.
y
+=
ll\
O\
lllOOOl
*
(
float
)
(
(
ll\
OOOO\
l\
OlO\
l
&
0x2
)
-
1
)
;
lOOOO\
O\
OlOO\

.
z
+=
ll\
OlllOOOl
*
(
flo\
a\
t\

)
(
(
(
llO\
OO\
O\
l\
OlOl\

&
0x1
)
<<
1
)
-
1
)
;
llOOO\
lll\
O\
OO\

(
llOO\
OOOl\
O\
Ol
->
llOO\
OOl\
OO\
ll
[
llOOOOlOl\
Ol
]
,
llOlllOOO\
l
,
lOOOOO\
O\
lOO
,
lOO\
l\
OOllOlO\
l
)
;
}
}
}
else\

{
lOOlOOO\
lOlll\

*
lOOl\
OOO\
lllll
=
(
lOO\
l\
OO\
Ol\
O\
l\
l\
l
*
)
llO\
OOOOl\
OO\
l
;
if
(
lOOlO\
OOlllll
->
ll\
OOO\
OOlllO
)
{
int
llOOOO\
lOl\
Ol
=
lOO\
lOOOll\
ll\
l\

->
ll\
OO\
OOlOOlO
;
Ve\
c3
lOO\
OOOO\
lO\
O\

=
v3Cent\
er\

;
lOO\
O\
OOOlO\
O
.
x
+=
ll\
Oll\
lOOOl
*
(
fl\
oat\

)
(
(
(
llOOOOlOlO\
l\

&
0x4
)
>>
1
)
-
1
)
;
lO\
O\
OO\
OO\
lOO
.
y
+=
llO\
lllOOOl\

*
(
fl\
oat
)
(
(
ll\
O\
OOOlOlOl
&
0x2
)
-
1
)
;
lOOOO\
OO\
lOO
.
z
+=
llOlllOOOl
*
(
fl\
oat
)
(
(
(
llOO\
OO\
lOl\
Ol
&
0x1
)
<<
1
)
-
1
)
;
llOO\
O\
lll\
OOO
(
lOOl\
O\
OOlllll
->
ll\
OOO\
OOl\
l\
lO
,
llOlllOO\
Ol
,
lOO\
OOOOlO\
O
,
lOO\
lO\
Ol\
lOl\
Ol\

)
;
}
}
}
vo\
id
lOOlOOO\
lOllO
::
lOOl\
OOO\
O\
lO\
OO
(
llOOO\
OOlOOO
*
ll\
O\
OO\
OOlOO\
l
)
{
#ifdef _DEBUG	
if\

(
!
lOOlO\
O\
Oll\
O
)
ret\
u\
rn
;
lOO\
lOO\
O\
OO\
lOO
(
llOOOOO\
lOOl\

)
;
TA_AS\
SERT
(
llOO\
OOOlO\
Ol
)
;
if
(
llOOO\
OOlO\
Ol
->
lO\
lOllOOll
&
lO\
OlOO\
OllllO
)
{
for\

(
in\
t
llO\
OO\
OlO\
lOl
=
0
;
llOOOO\
lOl\
Ol
<
8
;
llO\
OOOl\
OlOl
++
)
{
if
(
ll\
OOOOOlOOl\

->
llOOOOlOO\
ll
[
ll\
O\
OOOl\
OlOl
]
)
lOOlOOOO\
lO\
OO
(
llOO\
O\
OOlOOl
->
llOO\
OOl\
OOll
[
llO\
OOOlOlOl\

]
)
;
}
}
el\
s\
e\

{
lOOlOOOlOlll
*
lOO\
l\
OOOlllll
=
(
lOOl\
OOOlOll\
l
*
)
llOO\
OOO\
lO\
Ol\

;
if
(
lOO\
lOOOlllll
->
llO\
OOOOlllO
)
lOOl\
OOOOlO\
OO
(
lOOlOOOl\
l\
lll\

->
llOO\
OOOl\
ll\
O
)
;
}
#endif //
}
bo\
ol\

lO\
OlO\
OO\
lO\
ll\
O
::
lOOl\
OOO\
OlO\
ll
(
llO\
OO\
OOl\
OO\
O
*
ll\
OOOOOlO\
Ol
,
ll\
O\
OO\
O\
Ol\
O\
O\
O
*
lOOlO\
OOO\
lO\
l\
O
)
{
#ifdef _DEBUG	
if
(
!
lOOlOOOllO
)
ret\
urn
true\

;
lOO\
lOOOO\
O\
l\
OO\

(
llOOO\
OOlOOl\

)
;
TA\
_AS\
SERT\

(
ll\
OOOO\
Ol\
O\
Ol
)
;
if
(
ll\
OO\
OOOlOOl
==
lO\
OlO\
OOO\
lOl\
O
)
return
tru\
e\

;
if
(
llO\
OO\
OOlO\
Ol\

->
lOl\
O\
llOOll\

&
lO\
O\
lOO\
O\
l\
lll\
O
)
{
for\

(
int
llO\
OO\
Ol\
Ol\
Ol
=
0
;
llO\
OOOlOlO\
l
<
8
;
llOO\
O\
Ol\
OlOl\

++
)
{
if
(
llOOO\
OO\
lOOl
->
llO\
OOOlO\
O\
ll
[
ll\
OOOOlOlO\
l\

]
)
{
if
(
lOOlO\
OOOlOl\
l
(
llO\
OO\
OOlOOl
->
llOOOO\
lOOll
[
ll\
OOOOlOlOl
]
,
lOO\
l\
OOOOlOlO
)
)
return\

true
;
}
}
}
el\
se
{
lOOlOOOl\
Olll
*
lOO\
l\
OOOl\
lll\
l\

=
(
lOOlOOO\
lO\
lll
*
)
llOOOO\
OlO\
Ol
;
if
(
lOO\
l\
OO\
Olllll
->
llOOOO\
OlllO
)
{
if\

(
lOOlO\
OOOlO\
ll
(
lOO\
lOOO\
lllll
->
ll\
OOOOOl\
llO
,
lOOl\
OOOOlOlO
)
)
return
tr\
ue\

;
}
}
retur\
n
fals\
e
;
#else
retu\
rn
true
;
#endif //
}
void
lOOlOOOlO\
l\
l\
O\

::
lOO\
lO\
O\
OOll\
Ol\

(
llO\
O\
OO\
Ol\
OOO
*
llOO\
OOO\
lOOl
,
ll\
OOOO\
O\
l\
O\
O\
O
*
lOOl\
OOOOlOlO
)
{
for
(
;
ll\
OO\
OOOlOOl\

;
ll\
O\
OOO\
OlOOl
=
llOOOOOlO\
Ol
->
lOOOOOlOOOl
(
)
)
if
(
llOOO\
OO\
lOOl\

==
lOOlOOOOlO\
lO
)
ret\
urn\

;
TA_\
ASSERT\

(
0
)
;
}
}

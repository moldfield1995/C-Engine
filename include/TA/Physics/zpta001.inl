//---------------------------------------------------------------------------------
// File Name: zpta001.inl
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

namesp\
ac\
e
TA
{
in\
l\
in\
e
Collis\
io\
n\

::
Co\
l\
li\
sion
(
)
{
Cle\
ar
(
)
;
}
inline
const
Ve\
c3\

&
Co\
llis\
ion
::
Ge\
tPosi\
ti\
on
(
)
const\

{
return
lOOOO\
l\
l\
lll\

;
}
inline\

void\

Collis\
ion
::
Se\
t\
Position\

(
cons\
t
Vec3
&
lOO\
OOlll\
ll
)
{
this
->
lO\
O\
O\
O\
l\
ll\
ll\

=
lO\
O\
O\
O\
ll\
lll
;
}
inl\
i\
ne
const
Vec3
&
Colli\
si\
on
::
GetN\
ormal\

(
)
con\
st
{
return
lOOOlOOO\
OO
;
}
inlin\
e
void
Collisi\
on\

::
SetNor\
mal
(
co\
n\
s\
t
Vec3
&
lO\
O\
OlOO\
OO\
O\

)
{
th\
is
->
lO\
OOlOOO\
O\
O
=
lOO\
OlOO\
O\
OO
;
}
inli\
ne\

Dynamic\
O\
bjec\
t
*
Colli\
s\
ion\

::
GetObjectA\

(
)
const
{
return
lOllOO\
OllOl
;
}
in\
l\
ine
DynamicObjec\
t
*
Co\
lli\
sion
::
GetObjectB
(
)
cons\
t
{
return
lOl\
lOO\
OlllO
;
}
in\
l\
i\
n\
e
vo\
i\
d
Colli\
si\
o\
n
::
SetO\
bje\
c\
tA
(
Dyna\
micO\
b\
je\
ct
*
lO\
lll\
OOlOO\
O
)
{
lO\
l\
lOOOllOl
=
lOlllOOlOOO
;
}
inline
voi\
d
Col\
l\
is\
i\
on
::
Se\
tObjec\
tB
(
DynamicObje\
c\
t
*
lO\
lll\
O\
OlO\
OO
)
{
lOllOOOlllO\

=
lO\
lllOOl\
O\
OO
;
}
inline
Col\
l\
isi\
onOb\
ject
*
Co\
llisi\
o\
n
::
GetCo\
llisionObjectA\

(
)
{
if
(
lOlOllO\
O\
ll
&
(
Collisi\
on
::
FLAG\
_J\
OINT\

|
FLAG_JO\
INT\
_L\
I\
MIT\

)
)
return
0
;
re\
t\
u\
rn\

lOllOOO\
lll\
l\

;
}
inli\
ne
Col\
l\
isio\
nObject
*
Collision
::
Get\
Collisi\
onObjectB
(
)
{
if\

(
lOlOll\
O\
Oll
&
(
Col\
lis\
i\
on\

::
FLAG\
_JO\
IN\
T
|
FLAG\
_J\
OIN\
T_LIMIT
)
)
ret\
u\
rn\

0
;
return\

lOllOOlOOOO
;
}
inline
con\
st
Coll\
isio\
nO\
bje\
ct
*
Col\
lis\
i\
o\
n\

::
Get\
C\
ollision\
Ob\
jectA
(
)
cons\
t
{
ret\
u\
rn\

lO\
ll\
Ol\
lOlO\
l
(
)
->
GetCollisionObjectA
(
)
;
}
inl\
ine
const
Col\
l\
is\
i\
on\
O\
bje\
c\
t
*
Co\
llision
::
Ge\
t\
Col\
lision\
O\
b\
jectB
(
)
con\
s\
t\

{
return
lO\
ll\
OllO\
lOl\

(
)
->
GetC\
ollisionO\
b\
jectB
(
)
;
}
inl\
in\
e
vo\
i\
d
Co\
llision\

::
SetC\
ollisi\
o\
nObje\
ctA\

(
Colli\
sionO\
b\
ject
*
lO\
ll\
OOOllll
)
{
TA\
_AS\
S\
ERT
(
(
lOlOllOOl\
l
&
(
Colli\
sion
::
FLA\
G\
_JOI\
NT
|
FL\
AG\
_JO\
INT_LIMIT
)
)
==
0
)
;
thi\
s
->
lO\
llOOOll\
ll
=
lO\
ll\
OOOll\
ll
;
}
inline
void\

Collis\
ion
::
SetCollisi\
onObjec\
t\
B
(
CollisionObject
*
lOl\
lO\
OlO\
O\
OO
)
{
TA\
_A\
SS\
ER\
T
(
(
lOlOllOOll
&
(
Co\
lli\
si\
on
::
FLAG\
_J\
OIN\
T\

|
FLAG\
_JOI\
N\
T_\
L\
IMIT
)
)
==
0
)
;
th\
is
->
lOllO\
OlOOOO
=
lOll\
OOl\
OOO\
O
;
}
inline
int
Col\
l\
ision
::
GetFlags
(
)
con\
st
{
return
lO\
l\
Ol\
lOOll
;
}
inline
vo\
i\
d
Col\
lisio\
n
::
SetF\
lags\

(
u32
lOlO\
l\
l\
OOl\
l
)
{
this
->
lOlOllOOl\
l
=
lOlOll\
OOll
;
}
inlin\
e
u32\

&
Co\
ll\
is\
i\
o\
n
::
Fla\
gs
(
)
{
re\
turn\

lOl\
OllOOll
;
}
in\
line
fl\
oat
Col\
lisi\
on
::
GetRes\
ti\
tution
(
)
co\
ns\
t
{
ret\
ur\
n
lO\
llO\
O\
lOl\
O\
l
;
}
inline
voi\
d
Colli\
sio\
n
::
SetRestitution
(
floa\
t
lOllOO\
lOlOl
)
{
this
->
lO\
llOOlOl\
Ol
=
lO\
ll\
OOl\
OlOl
;
}
inline\

float
Collisio\
n\

::
GetIm\
pulse
(
)
con\
st
{
ret\
ur\
n
lO\
l\
lOO\
lOlOO
;
}
inlin\
e
void
Col\
lisi\
on\

::
Set\
Impu\
ls\
e
(
fl\
o\
at
lOll\
OOl\
OlOO\

)
{
this\

->
lOllOOlO\
l\
OO
=
lO\
l\
lOOl\
Ol\
O\
O
;
}
in\
l\
in\
e
fl\
oat
Col\
lisio\
n
::
Ge\
tFr\
i\
ctio\
nCoe\
fficie\
n\
t
(
)
const
{
ret\
urn
lOllO\
Ol\
Oll\
O
;
}
inlin\
e
void
Col\
li\
sio\
n
::
SetFrictionC\
oeffici\
ent\

(
floa\
t\

lOl\
lOO\
l\
OllO
)
{
this
->
lOllOOl\
OllO
=
lOl\
lOOlOllO
;
}
in\
lin\
e
float
Co\
lli\
s\
ion
::
Ge\
tT\
ime\

(
)
cons\
t
{
return
lllOl\
l\
ll\
l\
O
;
}
inline\

voi\
d
Coll\
i\
si\
on
::
SetTim\
e\

(
fl\
oat\

lllO\
llll\
lO
)
{
thi\
s
->
lllOlllllO\

=
lllO\
lllllO
;
}
in\
line
float
Collision
::
GetInter\
se\
c\
ting\
Dep\
th
(
)
const
{
retu\
rn
lOllOOlO\
Oll
;
}
inline
void\

Co\
llision
::
Set\
Inter\
sectingDept\
h
(
float
lOllOOlOOll
)
{
this\

->
lOll\
O\
OlOOll
=
lOl\
lOOlOOll
;
}
inline\

u32
Collis\
io\
n
::
GetColli\
sionId\
A\

(
)
const
{
retu\
rn
lOllOllOOll
;
}
inline
void
Collision
::
Set\
Col\
li\
s\
i\
o\
nId\
A
(
u32
lO\
l\
lO\
llOO\
ll\

)
{
this
->
lO\
l\
lOl\
lOOll
=
lOl\
l\
Ol\
l\
OOl\
l
;
}
inline
u32\

Collis\
io\
n
::
GetColli\
si\
on\
I\
dB
(
)
const
{
re\
turn\

lOllOllOlOO\

;
}
inline
void
Collision
::
SetC\
olli\
si\
on\
IdB
(
u3\
2\

lOll\
O\
llOl\
O\
O
)
{
this
->
lOllOllOlO\
O
=
lOll\
OllO\
lOO
;
}
in\
line\

u3\
2
Coll\
ision
::
Ge\
tAtt\
r\
i\
but\
eA
(
)
con\
s\
t\

{
return
lO\
ll\
OO\
lOOOl
;
}
in\
li\
n\
e
void
Col\
li\
sio\
n
::
SetAt\
tri\
bu\
teA\

(
u32
lOll\
O\
OlOOOl\

)
{
this
->
lOllOO\
lOOO\
l\

=
lOl\
lO\
O\
l\
O\
O\
O\
l\

;
}
in\
li\
n\
e
u32
Col\
lis\
ion
::
Get\
At\
tributeB
(
)
co\
n\
st
{
return\

lOllOOl\
O\
OlO
;
}
inline
void
Collision
::
SetAttri\
bute\
B
(
u32
lOll\
OOlOOlO
)
{
this
->
lOl\
lOOlO\
Ol\
O
=
lOllOOlO\
O\
lO
;
}
inli\
n\
e
Ph\
ysicsJoi\
nt
*
Co\
llision
::
GetJoi\
nt
(
)
{
if
(
(
lO\
lOl\
l\
O\
Oll
&
(
Co\
ll\
is\
ion
::
FL\
AG_JOINT
|
FLAG_\
JOI\
N\
T_LIMIT
)
)
==
0
)
retu\
rn\

0
;
re\
tur\
n
(
Physi\
csJoint
*
)
lOllOOOlll\
l\

;
}
inli\
ne\

con\
st
Ph\
ysi\
cs\
Joint\

*
Co\
lli\
sion
::
Ge\
tJoint
(
)
const
{
lOllO\
llO\
lO\
l
(
)
->
Get\
Joi\
nt\

(
)
;
}
in\
line
bool
Col\
l\
isio\
n
::
CollisionO\
ccurred
(
)
const
{
re\
turn
(
lOlOllOO\
ll
&
FLA\
G\
_\
C\
OLLI\
SI\
ON_OCCUR\
R\
ED\

)
!=
0
;
}
inli\
ne
Collision
*
Collis\
ion
::
Get\
Next
(
)
{
retur\
n
lO\
OO\
OOl\
O\
OOl
;
}
in\
lin\
e\

vo\
id
Col\
lision\

::
In\
itialise
(
Ty\
pe
lOl\
l\
lOO\
lOO\
l
,
float
lOllO\
Oll\
lOO
,
floa\
t
lOllO\
OlllOl
,
const
Ve\
c3\

&
lOl\
l\
O\
O\
lll\
lO
,
co\
n\
st
Vec\
3
&
lOllOOll\
l\
l\
l
,
Physics\
J\
o\
i\
nt
*
lOll\
lOOlOl\
O
)
{
if\

(
lOl\
llOOlOlO\

==
0
)
{
TA_\
ASSER\
T
(
lOl\
llOOlO\
O\
l\

!=
lOllO\
l\
OOO\
O\
l
)
;
TA_\
ASSER\
T
(
lO\
l\
llO\
O\
lO\
Ol
!=
lOllOlOOO\
lO
)
;
TA_\
ASSERT
(
lOll\
l\
OO\
l\
OOl
!=
TYPE_ROTATION\
_C\
O\
NS\
TRAIN\
T\

)
;
TA_AS\
SERT
(
lOll\
lOO\
l\
OO\
l
!=
lOll\
O\
l\
O\
OOll
)
;
lOll\
OO\
O\
ll\
ll
=
0
;
}
else
{
TA_\
ASSER\
T
(
lO\
ll\
lOOlOOl
==
lO\
llOlOO\
OOl\

||
lOl\
llO\
OlOOl
==
lOllOl\
O\
OOl\
O
||
lOll\
lOOlOO\
l
==
TYPE_R\
OTATIO\
N_CO\
NSTR\
AINT\

||
lOlllOOlOO\
l
==
lO\
llOlOOOll
)
;
lOllOOOll\
ll
=
(
Co\
ll\
ision\
O\
bj\
ec\
t\

*
)
lOlllOO\
lOlO
;
}
lOl\
l\
O\
OlOOO\
O
=
0
;
lllOl\
ll\
llO\

=
lOllOOl\
llOO\

;
lOl\
lOOlOOll
=
lOll\
OOll\
lOl
;
lOOOO\
ll\
lll
=
lOllOOl\
lll\
O
;
lOOOlOOOO\
O\

=
lOllOO\
l\
l\
lll
;
lO\
ll\
OOl\
O\
OO\
l
=
0
;
lO\
l\
lO\
OlOO\
lO
=
0
;
lO\
OOOOlO\
OO\
l\

=
0
;
lOlOllOOll
=
lOlllOO\
l\
OOl\

;
lOl\
lOO\
llOOO
.
Clear
(
)
;
lO\
l\
lOOllOO\
l
.
Clea\
r
(
)
;
}
inline
const
Dy\
nami\
c\
Object
*
PreColl\
ision
::
GetOb\
jectA
(
)
con\
s\
t\

{
re\
turn
lOlllOOO\
lll
.
Ge\
tObjec\
tA
(
)
;
}
inline
cons\
t
Dyn\
amicO\
bject
*
PreCol\
lis\
ion
::
GetObjectB\

(
)
con\
st\

{
re\
tur\
n
lOlllOOO\
lll\

.
Ge\
tObje\
ctB
(
)
;
}
in\
l\
ine\

const
Colli\
sion\
Object
*
Pr\
e\
Collision
::
GetCo\
lli\
sionObje\
ctA
(
)
cons\
t
{
re\
t\
urn
lO\
lllOOOll\
l\

.
Ge\
tC\
o\
lli\
s\
ionObject\
A
(
)
;
}
inl\
ine
const
Col\
li\
s\
io\
nObject
*
PreC\
ol\
li\
si\
on
::
GetC\
o\
llisi\
onObject\
B
(
)
const\

{
retur\
n
lOlll\
OOO\
ll\
l
.
GetColl\
i\
sion\
Object\
B
(
)
;
}
inli\
ne
const
Physic\
sJ\
o\
int
*
PreCo\
llisi\
on
::
GetJ\
oint\

(
)
const
{
lOll\
lO\
OOl\
ll
.
GetJo\
int
(
)
;
}
inlin\
e
Pr\
e\
C\
ollision\

*
PreCo\
l\
l\
is\
ion
::
Ge\
tNex\
t
(
)
{
retu\
r\
n
(
Pre\
Colli\
sion
*
)
lOl\
l\
lO\
OOl\
l\
l
.
GetN\
ext
(
)
;
}
inli\
ne
cons\
t
Vec3\

&
Pre\
Collision
::
GetPo\
s\
it\
ion\

(
)
co\
n\
st
{
return\

lOl\
llO\
OOlll
.
lOOOOlllll\

;
}
inlin\
e
void
Pr\
e\
Col\
li\
si\
on
::
Set\
P\
osition
(
const
Vec3\

&
lOOOOl\
ll\
ll
)
{
lOl\
l\
l\
O\
O\
Ol\
l\
l
.
lOOOO\
lllll
=
lOOO\
Olllll
;
}
in\
lin\
e
cons\
t\

Vec3\

&
PreCol\
lision
::
Get\
Normal
(
)
con\
st
{
re\
t\
u\
r\
n
lOlll\
OOOl\
ll
.
lOOOl\
O\
OOO\
O
;
}
inline\

void
Pr\
eCollisi\
on
::
Set\
N\
orm\
al
(
const
Vec3
&
lOO\
OlO\
OOOO
)
{
lO\
ll\
lOOOlll
.
lOOOlOOO\
OO
=
lOOOlO\
O\
OOO
;
}
inl\
ine
u32
PreCollisi\
on
::
GetF\
l\
ag\
s\

(
)
co\
ns\
t
{
re\
t\
urn\

lOl\
llOO\
Olll\

.
lOlO\
llOOl\
l\

;
}
inli\
n\
e
void
Pr\
eCo\
l\
lision\

::
SetFl\
ag\
s
(
u3\
2
lOlO\
llOOll
)
{
lOll\
l\
O\
O\
Ol\
ll
.
lO\
l\
O\
llOO\
ll
=
lOlOllOOll
;
}
in\
l\
in\
e
flo\
at\

Pr\
eCo\
llisio\
n\

::
GetR\
estitu\
tio\
n
(
)
con\
st
{
retu\
rn
lOl\
ll\
O\
OO\
l\
ll
.
lOllO\
OlOl\
Ol
;
}
inli\
n\
e\

void
Pr\
eCo\
lli\
s\
io\
n
::
SetRe\
stit\
ution
(
float\

lOll\
O\
OlOlOl\

)
{
lOl\
llOOOl\
l\
l
.
lOllO\
OlO\
lOl
=
lO\
llOO\
lO\
lO\
l
;
}
inl\
i\
ne
fl\
oat
PreC\
o\
ll\
is\
ion\

::
Get\
Fri\
ct\
io\
nCoef\
ficien\
t
(
)
co\
nst\

{
return
lOl\
ll\
O\
OOlll
.
lOllO\
O\
lO\
ll\
O
;
}
in\
line
voi\
d
PreCo\
l\
lision
::
SetFric\
tio\
nCo\
efficient
(
flo\
at
lO\
llOOlOll\
O
)
{
lOl\
llOO\
O\
lll
.
lOl\
lO\
OlOl\
lO
=
lOllOOlOllO
;
}
inline
float
PreCol\
l\
ision\

::
GetTime
(
)
const\

{
return\

lOlllOO\
Olll\

.
lllOll\
lllO
;
}
in\
line\

void
PreCollisi\
on\

::
Se\
tT\
ime
(
float
ll\
lOlllll\
O
)
{
lOlllOOOl\
ll
.
lllOlllllO
=
ll\
lOl\
l\
lllO
;
}
inl\
ine
fl\
oat
PreC\
ollision
::
Ge\
t\
IntersectingDepth
(
)
const\

{
return\

lOl\
llOO\
Oll\
l\

.
lOllOOlOO\
ll
;
}
in\
li\
ne
void
PreColli\
sion
::
SetInte\
r\
se\
c\
t\
ing\
Dep\
th\

(
float\

lOl\
lOOlOOl\
l
)
{
lOlllOOOll\
l
.
lOllO\
OlOOll\

=
lOl\
lOOlOOll
;
}
inline
u32
PreC\
ol\
l\
ision
::
GetAttri\
buteA\

(
)
con\
s\
t
{
retur\
n
lOll\
lOOOlll
.
lOll\
OO\
lOO\
Ol
;
}
in\
line
u32\

Pre\
Collisio\
n
::
Get\
A\
ttrib\
uteB\

(
)
const\

{
return
lOl\
llO\
O\
O\
l\
ll\

.
lOllOO\
lO\
OlO
;
}
inline
u32
PreCollis\
i\
o\
n
::
GetC\
ollis\
io\
nIdA
(
)
cons\
t\

{
re\
turn
lO\
lllOO\
Olll\

.
lOllOll\
OOl\
l\

;
}
inl\
i\
ne\

u32
PreCollisi\
on
::
Ge\
tC\
oll\
isionI\
dB\

(
)
co\
nst
{
ret\
u\
rn
lO\
ll\
lOOOlll
.
lOl\
lOl\
lOlOO
;
}
inl\
ine\

Dynamic\
Obje\
ct
*
Pos\
tCollision
::
Get\
Obj\
ec\
t\
A
(
)
{
retu\
rn
lO\
lll\
OOOlll
.
GetOb\
ject\
A
(
)
;
}
in\
li\
ne
Dynamic\
Ob\
ject\

*
PostColl\
is\
ion
::
GetO\
bje\
ct\
B\

(
)
{
ret\
urn\

lOlllOOO\
ll\
l\

.
GetObjectB\

(
)
;
}
in\
line\

Co\
ll\
is\
ion\
Object
*
PostCollisi\
on
::
GetC\
ollision\
O\
bje\
ct\
A
(
)
{
retur\
n\

lO\
l\
l\
lOOOlll\

.
GetCo\
l\
lisionOb\
ject\
A
(
)
;
}
inline\

CollisionO\
b\
j\
ect\

*
Pos\
tC\
ol\
lision\

::
GetCollisionOb\
jectB\

(
)
{
return
lOlllOOOlll
.
GetC\
o\
l\
lisionObjectB
(
)
;
}
inl\
ine
Ph\
ysicsJo\
int\

*
Post\
Colli\
sion\

::
GetJo\
int\

(
)
{
lOll\
lOOOl\
ll
.
GetJo\
int
(
)
;
}
inlin\
e
Post\
C\
ollis\
ion
*
PostCo\
llision
::
Ge\
tN\
ext\

(
)
{
return
(
Post\
C\
ollis\
io\
n\

*
)
lOl\
llOOO\
ll\
l\

.
Get\
Ne\
xt
(
)
;
}
inl\
ine\

cons\
t
Vec\
3
&
Post\
Col\
l\
ision
::
Ge\
t\
Pos\
it\
i\
on
(
)
co\
nst\

{
re\
tu\
r\
n\

lOlllOOO\
lll
.
lOOOO\
ll\
lll
;
}
inlin\
e\

const
Vec3
&
PostCollision
::
GetN\
o\
rmal\

(
)
co\
n\
s\
t\

{
retu\
rn
lO\
ll\
lOOO\
ll\
l
.
lOO\
OlOO\
OOO
;
}
in\
li\
ne
u32
Post\
Colli\
sion\

::
Get\
Flags
(
)
co\
ns\
t
{
retu\
rn
lOlllOOOl\
ll
.
lOlO\
llOOll\

;
}
in\
li\
ne
float
PostCollisi\
o\
n
::
GetIm\
pulse\

(
)
const
{
re\
t\
u\
r\
n
lOl\
llOOOll\
l\

.
lOllO\
Ol\
O\
lOO
;
}
in\
lin\
e
floa\
t
Post\
Collis\
ion\

::
GetTime\

(
)
cons\
t
{
re\
turn
lOlllOOO\
lll
.
lll\
Ollll\
lO
;
}
inli\
n\
e\

float\

Pos\
t\
C\
ol\
li\
s\
ion
::
Ge\
tInte\
r\
secti\
ngDe\
pth
(
)
con\
s\
t
{
re\
tu\
r\
n\

lOlllOOOlll
.
lO\
l\
lOO\
lOOl\
l
;
}
inlin\
e
u32
PostCol\
lision\

::
GetA\
t\
t\
ri\
but\
eA
(
)
co\
ns\
t
{
retur\
n
lOl\
l\
lO\
O\
Ol\
ll
.
lOllO\
O\
lO\
OOl
;
}
inl\
in\
e
u32
Po\
st\
C\
ollision\

::
GetAttrib\
u\
t\
eB
(
)
const\

{
return
lO\
lllO\
O\
Ol\
ll
.
lOllOOlOOlO
;
}
in\
li\
ne
u32
PostCollisi\
o\
n\

::
Get\
Col\
lisionI\
dA
(
)
con\
st
{
ret\
ur\
n\

lOlllOO\
Ol\
l\
l
.
lOllO\
l\
lOO\
l\
l\

;
}
in\
l\
i\
ne
u32
Po\
stColl\
ision\

::
GetCol\
lis\
io\
nIdB
(
)
const
{
return\

lOl\
ll\
OO\
Olll
.
lOllO\
llOl\
O\
O\

;
}
}

//---------------------------------------------------------------------------------
// File Name: zpta015.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define llOllOlOOll
#define lOllOllOOlO
#include "CollisionObjectSphere.h"
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef llOllOOlOOO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef TA_COLLISIONOBJECTLINELIST_H
#include "CollisionObjectLineList.h"
#endif //
#ifndef lllOOOllOOO
#include "../Physics/zpta007.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
#ifndef TA_COLLISION_H
#include "Collision.h"
#endif //
na\
mespac\
e
TA
{
void
Colli\
sionObjectSp\
he\
re
::
Initialise
(
co\
nst
Vec3\

&
v3C\
enter
,
flo\
a\
t
lllllOOOO\
l
)
{
ll\
lOOOOllOO\

=
v3\
Ce\
nter\

;
lOlOlOOlOlO
=
ll\
l\
llOOO\
Ol\

;
lOOOOOOllO
(
llll\
lOOOOl\

>=
0.0f
,
"CollisionObjectSphere::Initialise. fRadius is <= 0.0f")
;
}
void
Co\
l\
l\
isionO\
bje\
c\
tSp\
he\
re
::
Final\
is\
e
(
)
{
lll\
OOO\
OllOO
.
Cl\
ear
(
)
;
lOlO\
lOOlOlO
=
0.0f
;
}
vo\
i\
d
Collision\
Obj\
ectSphere\

::
Ser\
i\
alise
(
Serialise\
r
&
lOO\
OlO\
l\
l\
Ol\

,
co\
ns\
t
Ver\
si\
on
&
lllOlO\
Ol\
OO
)
{
lOO\
OOOOllO
(
ll\
l\
OlO\
OlOO
<=
llOllOO\
llOO\

,
"CollisionObjectSphere::Serialise. The version number is too new.")
;
lOO\
Ol\
OllOl
.
Serialise
(
lllOOOOllOO
)
;
lOOO\
l\
OllO\
l\

.
Serialise
(
lO\
lOl\
OOl\
OlO
)
;
}
void
Collis\
i\
o\
nOb\
jectSphere
::
Re\
n\
de\
r
(
co\
nst
MFrame
&
lOOO\
O\
OOOO\
l\

)
{
co\
nst
int
lllO\
l\
OlOl\
OO\

=
6
;
co\
nst\

int
ll\
lOlOlOl\
O\
l\

=
4
;
Mat33
lllOlO\
lOllO
;
lllOlOlOl\
l\
O\

.
SetToIden\
tity\

(
)
;
for\

(
int
lll\
O\
lOlOlll
=
0
;
lllO\
lO\
lO\
l\
ll\

<
lllOl\
OlOl\
OO\

;
lllOlOlOl\
l\
l
++
)
{
flo\
at\

lO\
O\
OO\
llOOll\

;
float
lOOOO\
l\
l\
OlOO
;
SinA\
ndCos
(
(
flo\
at\

)
lll\
OlOlOl\
ll
/
(
fl\
oat
)
lllOlO\
lOlO\
O
*
(
k_fPi
*
2.0f
)
,
lOOO\
O\
llO\
Oll
,
lOOOO\
llOlOO\

)
;
Ve\
c3
ll\
lO\
lOll\
OO\
O
=
(
ll\
lOlOlOllO
.
v3X
*
lO\
OO\
O\
llO\
lOO
+
ll\
lOlOl\
O\
llO
.
v3Y
*
lOOOOllOO\
ll
)
;
SinAn\
dCos
(
(
float
)
(
lllOlOlOlll
+
1
)
/
(
floa\
t
)
lllO\
lOlOl\
OO
*
(
k_\
fPi\

*
2.0f
)
,
lOO\
O\
OllOO\
ll
,
lOOOOllOl\
OO
)
;
Vec3
lll\
Ol\
Ol\
l\
OO\
l\

=
(
lllO\
lO\
lO\
l\
l\
O
.
v3X
*
lOOO\
O\
l\
l\
OlOO
+
lllOlOlOllO\

.
v3\
Y\

*
lO\
OOO\
l\
lOOll
)
;
{
con\
st
Vec3
ll\
lO\
lO\
ll\
Ol\
O\

[
4
]
=
{
(
lllOO\
OO\
ll\
O\
O
+
lll\
OlOl\
lOO\
O
*
lOlOl\
OO\
l\
OlO
)
*
lO\
OO\
OOOO\
Ol
,
(
ll\
lO\
OOO\
llOO\

+
ll\
lOlOl\
lOOl
*
lOlOlOOlOl\
O
)
*
lOOOOOOOO\
l
,
(
lllO\
OO\
OllOO
+
ll\
lO\
lOllO\
Ol
*
lOlOlOOl\
O\
lO\

)
*
lO\
OOOOO\
OOl
,
(
ll\
lO\
OO\
OllOO
+
lllOlOllOOO
*
lO\
lO\
lOOl\
Ol\
O
)
*
lO\
OOOOOO\
Ol\

,
}
;
const\

Vec\
3\

lllOlOll\
Oll
[
4
]
=
{
lllOl\
Oll\
O\
O\
O\

*
lOOOOOOOO\
l
.
m33\
R\
o\
tation
,
lllOlO\
llOOl
*
lOOOO\
OOO\
Ol
.
m3\
3Rotation\

,
lll\
O\
lO\
llOOl
*
lOOO\
O\
O\
OO\
Ol
.
m33Rotation\

,
ll\
lOl\
O\
ll\
O\
O\
O
*
lOOOO\
OOOOl
.
m33Rot\
at\
ion
,
}
;
Physic\
sRende\
r\

::
RenderPolyg\
on
(
4
,
ll\
lOlOllOl\
O
,
ll\
lOlOll\
O\
ll
)
;
}
for
(
int
lllOlOlllOO
=
0
;
lllOlOl\
llO\
O\

<
lllOlOlOlOl
;
lllO\
l\
Ol\
l\
lOO
++
)
{
SinAnd\
Cos
(
(
fl\
oat
)
lllOlOlllO\
O
/
(
float
)
lllOlOlOlOl
*
(
k_f\
Pi
)
,
lOOOOllOO\
ll
,
lO\
OO\
OllO\
lOO
)
;
Ve\
c3
lllO\
lOll\
lOl
=
lllOlOll\
OOO
*
lOOOOll\
OlOO
+
lllOlOlOl\
lO\

.
v3Z\

*
lO\
O\
O\
O\
llOOl\
l
;
Vec3\

lll\
OlOlll\
l\
O
=
lllO\
lO\
llOOl
*
lOO\
OO\
llOlOO
+
lllOlOl\
O\
ll\
O\

.
v3\
Z
*
lOOOOll\
O\
Ol\
l
;
SinAnd\
Cos
(
(
float\

)
(
lllOl\
O\
lllOO
+
1
)
/
(
flo\
at\

)
lll\
OlOlOlOl\

*
(
k_\
f\
Pi
)
,
lOOO\
O\
llOOll\

,
lOO\
OOl\
lO\
lO\
O
)
;
Vec3
ll\
lOlOlllll
=
lllO\
lOll\
OOO
*
lOOOOl\
lO\
l\
OO
+
lllO\
l\
Ol\
O\
l\
lO
.
v3Z
*
lOOOOl\
lOO\
l\
l
;
Ve\
c3
lll\
Ol\
lOOO\
OO\

=
lllOlOll\
O\
O\
l\

*
lOOOOll\
OlOO
+
lll\
O\
lOlOl\
l\
O
.
v3Z\

*
lO\
OOOl\
lOO\
ll
;
{
const
Vec3
lllOlOl\
lOlO
[
4
]
=
{
(
lllO\
OOOllOO
-
lllOl\
Ol\
l\
lOl
*
lOl\
OlOOlO\
lO
)
*
lOO\
O\
OOOOO\
l
,
(
ll\
lOOOOllOO
-
ll\
lOlOlll\
ll
*
lOlOl\
O\
OlOlO
)
*
lOO\
OO\
OOO\
Ol\

,
(
lll\
O\
OO\
Oll\
OO
-
lllOllOO\
OOO
*
lOlOlOO\
lO\
l\
O
)
*
lOOOO\
OOOO\
l\

,
(
lllOOOO\
llOO
-
lllOlOlll\
lO
*
lO\
l\
OlOOlO\
lO
)
*
lOOOOOO\
O\
O\
l
,
}
;
co\
nst
Vec\
3
lllOlO\
llOl\
l
[
4
]
=
{
-
lllO\
l\
Ol\
llO\
l
*
lO\
O\
OOO\
OOOl
.
m3\
3R\
ot\
ation
,
-
ll\
l\
O\
lOlll\
ll\

*
lOOOOOO\
O\
Ol
.
m33Rotati\
on\

,
-
lll\
OllOOOOO
*
lOOOO\
OOO\
Ol
.
m33\
Rot\
ation
,
-
lll\
O\
lOl\
l\
ll\
O
*
lOOO\
OOO\
OO\
l
.
m33\
R\
o\
tation
,
}
;
Phys\
icsRen\
d\
er\

::
Rende\
r\
Pol\
ygon
(
4
,
lllOlOllO\
l\
O
,
lllO\
lOl\
lOll
)
;
}
{
co\
nst
Vec3
ll\
l\
OlOl\
lOlO
[
4
]
=
{
(
ll\
l\
OOOO\
l\
lOO\

+
lllOlOlllO\
l
*
lO\
l\
O\
lOO\
lOlO
)
*
lOO\
OOOO\
OOl
,
(
lllOOOOllOO
+
lllOlOl\
l\
lll
*
lOlOlOO\
lO\
lO
)
*
lO\
OOOOOO\
Ol
,
(
lll\
OOOO\
llO\
O
+
lllO\
l\
lOOOOO\

*
lOl\
O\
lOOlO\
l\
O
)
*
lOOOO\
OOOOl\

,
(
ll\
lOOO\
OllOO
+
lll\
OlOl\
lllO\

*
lOlO\
lOOlOlO
)
*
lOOOOO\
O\
O\
O\
l\

,
}
;
const
Vec3
lllOlOl\
lOll
[
4
]
=
{
lll\
Ol\
OlllOl
*
lOOOOOOOO\
l
.
m33\
Rotation
,
lllOlOlllll\

*
lOOOOOO\
OO\
l\

.
m3\
3Rotat\
ion
,
lllOllO\
OO\
O\
O
*
lO\
O\
OOO\
OOOl\

.
m3\
3Rota\
t\
ion
,
lllOlO\
llllO\

*
lOO\
OOOOOOl
.
m3\
3R\
otati\
on
,
}
;
Phy\
sics\
Rend\
er
::
Render\
Polygo\
n
(
4
,
lllOl\
OllOl\
O
,
lllOlOl\
lOll
)
;
}
}
}
}
AABB
Coll\
isi\
o\
nObjectSp\
he\
r\
e
::
Cal\
cu\
lateBoundin\
g\
Bo\
x
(
)
co\
nst
{
AAB\
B
lOOO\
OOOlll
;
lOOOOO\
O\
l\
ll
.
v3\
Cent\
e\
r
=
ll\
lOOOOll\
OO\

;
lOO\
O\
OO\
Oll\
l
.
v3E\
xtent
.
x
=
lOlOl\
OOl\
O\
l\
O\

;
lOOO\
OOO\
lll
.
v3Extent
.
y
=
lOlOl\
O\
O\
lO\
lO\

;
lO\
OO\
OOOlll
.
v3E\
xt\
ent
.
z
=
lO\
l\
O\
lOOlOlO
;
ret\
urn
lO\
OOOOO\
lll
;
}
vo\
id
Collis\
io\
nObjectSph\
ere
::
Calc\
u\
lateMass
(
flo\
at
lll\
Ol\
lOOO\
O\
l
,
fl\
oat\

&
lOllOOOOllO
,
Ve\
c3
&
ll\
lOllOO\
OlO
,
Ma\
t33\

&
lllOllOOO\
l\
l\

)
con\
st
{
lO\
llO\
OOO\
l\
lO
=
4.0f
/
3.0f
*
k_f\
Pi\

*
lOlO\
lOO\
lOlO\

*
lO\
l\
OlOOlOl\
O\

*
lOlOlO\
OlOlO
*
lllOll\
OOOO\
l
;
lllOllO\
OOl\
l
.
SetTo\
Iden\
tity
(
)
;
ll\
l\
O\
llOOOl\
l
.
M1\
1\

(
)
=
2.0f
/
5.0f
*
lO\
l\
l\
O\
OO\
Ol\
lO
*
lOlO\
lOOlOlO
*
lO\
lOlOO\
l\
OlO\

;
lllOll\
O\
OOll
.
M22
(
)
=
lllO\
llOOOl\
l\

.
M11
(
)
;
lllOllOOOll
.
M3\
3\

(
)
=
lllO\
l\
lOOO\
ll
.
M11\

(
)
;
ll\
lO\
llOOO\
lO
=
lllOO\
OOll\
OO
;
}
bool
Co\
l\
l\
isionOb\
je\
ctSp\
here\

::
TestLi\
neForColli\
si\
o\
n
(
co\
nst
Ve\
c3
&
lOOl\
OlOlll
,
const\

Vec\
3
&
lO\
OO\
lOO\
OO\
O
,
float\

lOOl\
Ol\
lOOO\

,
Collision\

&
llOllllOl\
ll
)
const
{
Ve\
c3
lO\
OlOllOO\
l\

=
lOOlOlOlll
+
lOOOlOOOO\
O
*
lOOlOl\
lOOO
;
float
lll\
lOl\
OOll
;
Ve\
c\
3\

lOllll\
OOll
;
Vec3
lOll\
llOl\
OO
;
if\

(
Geometry
::
Test\
PointMov\
e\
ment\
Agai\
n\
st\
S\
phere
(
lO\
OlOlO\
lll\

,
lOOlO\
l\
l\
O\
Ol
,
ll\
lO\
O\
O\
OllOO\

,
lOlOlOO\
lOlO
,
llllOl\
OOl\
l
,
lOll\
llOOll
,
lOl\
lllOl\
O\
O\

)
)
{
float\

lO\
lOl\
ll\
OOl\

=
lO\
OOlOOOOO
.
Do\
t
(
lOllllOOll
-
lOOlOlOl\
ll
)
;
if
(
lOlO\
l\
l\
lO\
O\
l
<
llO\
l\
lllOll\
l
.
lOll\
OOl\
OOl\
l
)
{
Vec3
lllOll\
Ol\
OOO\

=
lOOlOlO\
ll\
l
+
lOlO\
lllOOl\

*
lO\
OOlO\
OOO\
O
;
llO\
llllOll\
l
.
Initiali\
se
(
0
,
0
,
lOlOlll\
O\
Ol
/
lOOlO\
llOOO
,
lOlOlll\
OOl
,
lOllllOO\
ll
,
lOlll\
lOlOO\

)
;
llOl\
lllO\
lll
.
SetCo\
l\
lision\
Obj\
ectA
(
con\
st_ca\
s\
t\

<
Col\
lisi\
onObje\
ctSphere
*
>
(
this
)
)
;
ret\
u\
rn
true
;
}
}
retur\
n\

false
;
}
Colli\
sionObj\
ect\
S\
ph\
e\
re
*
TAC\
_C\
ALL
Co\
lli\
sionO\
bje\
ctSphere
::
Cr\
e\
a\
teNew
(
)
{
Coll\
is\
io\
nO\
bje\
ctS\
pher\
e
*
lOlOllOlOO\
l
;
lOOOOOllO\
l\
O\

(
lO\
lOll\
OlOOl
,
Co\
l\
lisio\
n\
O\
b\
ject\
Sphere
)
;
re\
tur\
n\

lOlO\
ll\
OlOOl
;
}
Coll\
i\
si\
onObjec\
tSphe\
re
::
Collisi\
onObjectSphere\

(
)
:
Coll\
isionObj\
ect\
S\
impl\
e
(
Collisi\
o\
n\
Ob\
je\
ct\

::
TYPE\
_SPHE\
RE
)
{
ll\
lOOOO\
llO\
O\

.
Clear
(
)
;
lOlOl\
OOlOlO
=
0.0f
;
}
Col\
lis\
ionO\
b\
jec\
tSphere
::
~
Collis\
ionObj\
ect\
Sphere\

(
)
{
Final\
ise
(
)
;
}
#ifndef DOXYGEN
vo\
id\

TAC_CALL
llllO\
Ol\
l\
OlO
(
const
MFrame
&
lO\
lllOO\
OO\
Ol
,
co\
n\
st\

MFram\
e
&
lOl\
llOOOO\
lO
,
lOl\
lOlll\
OOO
*
lOll\
l\
OOOOl\
l\

)
{
TA_ASSE\
RT
(
lO\
lllOO\
O\
Oll
->
lOl\
lOOO\
llll
->
GetColl\
is\
ion\
Object\
T\
yp\
e
(
)
==
Collisio\
nOb\
jec\
t\

::
TYPE\
_SP\
HERE
)
;
cons\
t
CollisionObjectS\
p\
her\
e
&
lllOl\
lOlll\
O
=
*
(
const
Co\
ll\
isio\
n\
Objec\
tSph\
er\
e
*
)
lOlllO\
OOO\
ll\

->
lOl\
lO\
OO\
llll
;
TA_ASSERT\

(
lOl\
ll\
O\
O\
OO\
ll
->
lO\
llOOlOOOO
->
GetCol\
lisionObjec\
tType
(
)
==
Collisio\
nObje\
ct
::
TYP\
E_SP\
H\
ERE
)
;
const
Col\
li\
s\
ion\
ObjectS\
p\
he\
r\
e
&
lllOllOllll
=
*
(
const
Co\
llisionObj\
e\
ct\
S\
pher\
e\

*
)
lOlll\
OO\
OO\
l\
l
->
lOll\
OOlOOO\
O
;
const
flo\
at
lOl\
lOlO\
lll
=
0.0001f
;
Ve\
c\
3\

lOOOllll\
ll\
OO\

=
lllOl\
l\
O\
l\
llO
.
lllOOOOll\
O\
O
*
lOlllO\
OOO\
Ol
;
float
lllOlllOlOO
=
lllO\
llO\
l\
l\
lO
.
lO\
lO\
lOOlOlO
+
lllO\
l\
lO\
l\
lll
.
lOlOl\
O\
O\
lOl\
O
;
Ve\
c\
3
lO\
OOl\
OOOOO
=
lO\
OOllllllO\
O
-
lllOllOllll
.
lllO\
OOOllOO\

;
fl\
oat
ll\
lO\
OlO\
lll\

=
lO\
O\
OlOO\
OOO\

.
GetMagnitudeSqr\
d
(
)
;
if\

(
lll\
O\
O\
lO\
lll
<
ll\
lOlllOlOO
*
lllOll\
lO\
lOO
&&
ll\
l\
O\
OlOl\
l\
l\

>
lOllOlOlll
)
{
fl\
oa\
t
lOll\
llO\
lO\
l\

=
Sqr\
t
(
ll\
lOO\
lOl\
l\
l
)
;
lOOO\
l\
OOO\
OO
/=
lOll\
ll\
OlO\
l
;
Co\
llisio\
n\

lOllOll\
Ol\
ll\

;
lO\
l\
lOll\
Oll\
l
.
Initia\
li\
se
(
Collision
::
lOll\
OlOO\
OOO
,
0.0f
,
lll\
Olll\
O\
l\
O\
O\

-
lOl\
lllO\
l\
O\
l
,
(
lllOllOlll\
l
.
ll\
lO\
O\
OOllO\
O
+
lOOOl\
l\
l\
lllOO
)
*
0.5f
,
lOOO\
lOOO\
OO
)
;
ll\
lOl\
l\
llOO\
O
(
lO\
l\
l\
OllOlll
,
lO\
lllOO\
OOll
)
;
ret\
ur\
n
;
}
Vec3
lOOOl\
lll\
llOl
=
lllOll\
Oll\
lO
.
lllOOOOllOO\

*
lOll\
lO\
O\
OO\
lO\

;
if
(
!
lOl\
l\
l\
OOOO\
ll
->
lO\
llO\
lllOll
)
retur\
n\

;
float
lll\
l\
O\
lOOll\

;
Vec3
lO\
lllOl\
lOO
;
if
(
Geo\
me\
try
::
Tes\
tPo\
intMoveme\
ntAga\
instSpher\
e\

(
lOO\
Ol\
lll\
llOO\

,
lOO\
Ollll\
llOl
,
lllOllOllll\

.
lll\
O\
OOO\
l\
lOO
,
lllOlllOl\
O\
O\

,
lll\
lOlOOl\
l
,
lOlllOllOO\

,
lOOO\
lOOOO\
O
)
)
{
Collision
lO\
l\
lOllO\
l\
ll
;
lOl\
l\
OllOlll
.
Initia\
l\
i\
se\

(
Colli\
sion
::
lOllOlOOOOO
,
llllOlOO\
ll
,
0
,
lOlllO\
llOO
+
(
lOO\
OlOO\
OOO
*
lllOll\
Ollll
.
lOlOlOOlOlO
)
,
lOOOlOOOOO
)
;
lllOlll\
lOOO\

(
lOllOllOlll
,
lOlllO\
OOO\
l\
l
)
;
retur\
n\

;
}
}
voi\
d
TA\
C_\
C\
ALL
ll\
ll\
OlO\
O\
OOO
(
const
MFra\
me
&
lO\
lll\
OOOOOl
,
const\

MF\
rame
&
lOll\
lOOOO\
lO
,
lOll\
Ol\
ll\
OO\
O
*
lOll\
lO\
OOO\
ll\

)
{
lllOO\
llO\
OlO
(
)
;
TA\
_ASS\
ERT\

(
lO\
l\
llO\
OOOll
->
lOl\
lOO\
O\
l\
lll\

->
GetColli\
sionOb\
jec\
tTyp\
e
(
)
==
Col\
li\
s\
ionObjec\
t
::
TY\
PE_S\
PHERE
)
;
con\
st
CollisionOb\
jectSp\
h\
er\
e\

&
ll\
lO\
l\
l\
ll\
O\
lO
=
*
(
co\
ns\
t
Col\
l\
i\
sionO\
bj\
ectSphere\

*
)
lOlllO\
OOOll
->
lOllOO\
Oll\
ll
;
TA_ASSERT
(
lO\
l\
llOOO\
Ol\
l\

->
lO\
l\
l\
OOl\
OOO\
O
->
Ge\
tColli\
s\
i\
o\
nO\
bje\
ctType\

(
)
==
Co\
l\
li\
s\
io\
nObj\
ect\

::
TYPE\
_CA\
CHE\
D_P\
OLY_\
DATA
)
;
co\
n\
s\
t
Col\
lisi\
o\
nO\
bje\
ctCache\
d\
Pol\
yDat\
a
&
ll\
Ollll\
lO\
Ol
=
*
(
con\
s\
t
Colli\
s\
io\
nObjectCa\
che\
dPolyDat\
a
*
)
lOlll\
OOOOll
->
lOllOO\
lO\
OOO
;
Ve\
c3
lOO\
l\
Ol\
Ol\
ll
=
ll\
lO\
ll\
ll\
OlO
.
lll\
OOOO\
ll\
OO\

*
lOlll\
OOOOO\
l
;
Vec3
lO\
Ol\
OllOOl
=
lllOlll\
lO\
l\
O\

.
lll\
OO\
O\
O\
llOO
*
lOl\
l\
lOOOOlO\

;
for
(
in\
t
lll\
O\
llll\
llO
=
0
;
lllOl\
lll\
llO\

<
llO\
llll\
lOOl
.
ll\
lO\
l\
O\
OlOl\
O
(
)
;
)
{
const
Collisio\
nObjec\
tC\
ac\
hedPo\
ly\
D\
ata
::
Pol\
yg\
on
*
llOOOlOl\
OO\

=
(
const
Collision\
ObjectCa\
ch\
edPolyData
::
Pol\
yg\
on\

*
)
llOlllllOOl\

.
lllO\
lOO\
l\
OOl
(
lllOllllllO
)
;
lllOl\
ll\
lll\
O\

+=
llOlllllOOl
.
lllOOl\
lOOOl
(
llOO\
OlO\
lO\
O\

->
lO\
ll\
OlllOl\

)
;
#define lOlllOlOlOl(lOOOllOOOl) llOOOlOlOO->llOllllOlO[lOOOllOOOl].lOOOOlllll
#define lOllllOOOlO(lllOlllllO, lllOlllllll, llOOOlOlOO, lOOOOlllll, lOOOlOOOOO)							\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lOllOllOlll.lOllOOlOOlO = llOOOlOlOO->llOlllOlOOO;																\
	lllOOllOlll(lOllOllOlll, lOlllOOOOll);							\
}
#define lOlllOlllOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOlO) \
	lllOlOOOllO(lllOlllllO, lllOlllllll, llOOOlOlOO->llOlllOlOOO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOlO)
#define lOllllOOOOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lOlllOlOOl, lllOOlllOll, lllOOOlllOO, lOOOOlllll, lOOOlOOOOO) \
	lllOOlllOlO(lllOlllllO, lllOlllllll, llOOOlOlOO, lOlllOlOOl, lllOOlllOll, lllOOOlllOO, lOOOOlllll, lOOOlOOOOO)
#define lOlllOllOll(lllllllll, lOOOOOOOOO, lOllOlOlOlO) \
	lllOlOOOlll(lllllllll, lOOOOOOOOO, lOllOlOlOlO)
#define lOllllOOOOO(lllOOOlllOO) \
	lllOlOOOOOO(lllOOOlllOO, lllOlOOOOOl)
#define lOlllOlOOOl(llOOlllllO) (llOOOlOlOO->lOOOlOOOOO.Dot((llOOlllllO) - llOOOlOlOO->llOllllOlO[0].lOOOOlllll))
con\
s\
t
boo\
l
lOlll\
lO\
lOOl
=
fa\
lse
;
#include "../Physics/zpta004.inl"
#undef lOlllOlOlOl
#undef lOllllOOOlO
#undef lOlllOlOOOl
#undef lOlllOlllOl
#undef lOllllOOOOl
#undef lOlllOllOll
#undef lOllllOOOOO
}
lll\
OOll\
O\
Oll\

(
lOll\
lOOOO\
ll
)
;
}
voi\
d
TA\
C_CA\
L\
L
lll\
lOO\
l\
lO\
O\
O\

(
co\
ns\
t\

MF\
ra\
m\
e
&
lOll\
l\
OOOOOl
,
const
MFrame\

&
lO\
lllOOOOlO\

,
lOllO\
l\
ll\
OOO
*
lO\
lll\
O\
O\
O\
O\
ll\

)
{
TA\
_ASS\
ERT\

(
lOll\
lOOOOll
->
lOllOOOll\
ll
->
GetC\
ollis\
io\
nObj\
e\
ct\
Type\

(
)
==
Coll\
isionObject
::
TYP\
E\
_SP\
H\
ER\
E\

)
;
TA_AS\
SE\
RT
(
lOlll\
OO\
O\
Oll
->
lO\
ll\
OOlOOO\
O\

->
Get\
CollisionOb\
jectType
(
)
==
Coll\
ision\
Obje\
ct\

::
TY\
PE\
_\
LINE_\
LIST
)
;
const\

Co\
lli\
si\
o\
nOb\
jec\
tSph\
e\
re
&
lll\
Ol\
lllOlO
=
*
(
CollisionObjec\
tSp\
here
*
)
lOlllO\
OO\
Ol\
l\

->
lOll\
OOOllll
;
const
Collis\
i\
o\
nObje\
c\
tLi\
n\
eLis\
t\

&
llllOO\
OO\
OOl\

=
*
(
CollisionObjectLi\
neList
*
)
lO\
ll\
lOOOOll
->
lOll\
OOlOOO\
O
;
Vec3
lOlllO\
Oll\
ll
=
lll\
Ollll\
OlO
.
lllO\
OOOllO\
O
*
lOl\
l\
lOOOOO\
l
;
for
(
int
ll\
lOOO\
Ol\
O\
O
=
0
;
lllOOOOlOO
<
ll\
llO\
OOOO\
Ol
.
lll\
lOOOOOl\
l
.
lO\
OO\
lllOOl
(
)
;
lll\
OO\
OOl\
O\
O\

++
)
{
fl\
oat
llllOl\
O\
Oll\

;
Vec3
lO\
lll\
l\
OOll\

;
Vec3\

lOllllOl\
O\
O
;
if\

(
Ge\
omet\
r\
y
::
Tes\
tPoi\
ntMovement\
Against\
Sph\
ere
(
llll\
O\
O\
OOOOl
.
lll\
lOO\
OOOl\
l\

[
lllOO\
OOlOO\

]
.
lOOlOl\
O\
lll
,
llllOOOOO\
Ol
.
llll\
OOOO\
Oll\

[
lllOOOOlOO
]
.
lO\
O\
lOllOOl
,
lOl\
l\
lOO\
ll\
ll
,
lllOll\
l\
lOlO
.
lO\
lOl\
OOlOlO
,
llll\
O\
lOOll
,
lO\
lll\
l\
OO\
l\
l\

,
lOllll\
Ol\
OO\

)
)
{
Coll\
ision
lOl\
lO\
ll\
Olll\

;
lOllO\
llOll\
l\

.
Initial\
i\
se
(
Collision
::
lOll\
OlOOl\
O\
O\

,
0.0f
,
ll\
llOlOOl\
l
,
lOllll\
OOl\
l\

,
lOllll\
OlOO
)
;
lOl\
lOl\
lOlll\

.
lOllOOlOO\
O\
l\

=
lllOOOOlOO
;
if
(
!
lOlllOOOOl\
l
->
lOl\
l\
Ol\
lllOO
)
lO\
ll\
OllOlll\

.
lOl\
l\
O\
OlOOlO\

=
0
;
el\
se
lOllOl\
l\
Olll
.
lO\
llOOlOO\
lO\

=
1
;
if
(
!
lllOllll\
OOO
(
lO\
l\
lOl\
lOlll
,
lOlll\
O\
O\
OOl\
l
)
)
re\
t\
u\
rn\

;
}
}
}
#endif //
}

//---------------------------------------------------------------------------------
// File Name: zpta007.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define lOllOllOOlO
#include "CollisionObjectCachedPolyData.h"
#ifndef lllOOOllOOO
#include "../Physics/zpta007.h"
#endif //
namespace
TA
{
struct\

ll\
lOOO\
l\
lOOl
{
enum\

{
lllOOOll\
OlO
=
0x1
,
ll\
lOOOllOll
=
0x2
,
}
;
flo\
at\

lOllOOlOOll
;
float
lllOlllllO\

;
int
ll\
OlllOl\
OOO
;
u32
lOl\
O\
llOOll
;
Ve\
c\
3\

lll\
O\
OOlll\
OO\

;
Vec3
lO\
OOOlllll
;
Vec\
3
lOOOlOO\
OOO
;
Ve\
c3
lllOOOl\
l\
lOl
;
}
;
st\
ruct
lll\
OOOllll\
O\

{
Vec\
3
lOO\
OOlll\
l\
l
;
Ve\
c3
lllOO\
Olll\
ll
;
}
;
struc\
t
lllO\
OlOOO\
OO
{
fl\
oa\
t\

lOllOOlOOl\
l
;
fl\
o\
at\

lllO\
lllllO
;
u3\
2
llOl\
l\
lOlOO\
O
;
in\
t
lOllO\
lOlOlO
;
Ve\
c3
lOl\
l\
llO\
O\
llO
;
Ve\
c3
lOlllO\
ll\
OlO\

;
Vec3
lOOOOlllll
;
Vec\
3
lO\
OO\
lOOOOO
;
}
;
static
int
ll\
l\
OOlOO\
O\
Ol\

=
0
;
st\
a\
ti\
c
co\
ns\
t
int
lllOO\
lOO\
O\
l\
O
=
lOl\
OlOlO\
l\
l
;
st\
ati\
c
lllOO\
O\
ll\
O\
Ol
lllOOl\
OOOl\
l\

[
ll\
l\
OOlO\
OOlO
]
;
stati\
c
int
ll\
l\
OO\
lOOlOO
[
2
]
=
{
0
,
0
}
;
stati\
c\

cons\
t
int
lllOOl\
OO\
lO\
l\

=
32
;
stati\
c\

Vec\
3
ll\
lOOl\
OOllO
[
lllOOl\
OOlOl\

]
[
2
]
;
static
int\

ll\
l\
OO\
l\
OOlll
=
0
;
st\
ati\
c
lllOOO\
llllO
lll\
O\
OlOlOOO
[
lllO\
OlOOlOl
]
;
sta\
t\
ic
int
lllOO\
lO\
lOOl
=
0
;
static
co\
nst
int
lllO\
Ol\
OlOlO
=
lO\
l\
O\
lOlOlO
;
sta\
tic
lllOOlOO\
OO\
O
lllOOlOl\
Oll
[
lllO\
O\
lOlO\
lO\

]
;
st\
atic
int
lll\
OOlOllOO
[
3
]
=
{
0
,
0
,
0
}
;
static\

cons\
t
int
lllOOlO\
llOl
=
lll\
OO\
lO\
lO\
lO
;
static
Ve\
c3
lllOOlOlllO
[
3
]
[
ll\
l\
OOlOllO\
l
]
[
2
]
;
vo\
i\
d
Col\
li\
s\
i\
o\
nO\
bjectC\
ac\
hedP\
oly\
Dat\
a
::
Polygon
::
Ge\
n\
erateEdgeN\
o\
rma\
l\
s
(
)
{
for
(
int\

lOOOll\
OO\
Ol
=
0
;
lOOOllOOOl
<
lOll\
OlllO\
l
;
lOOOllOOOl
++
)
{
const
Vec3
&
llllOOOOll\

=
ll\
OllllOlO
[
lOOO\
llOO\
Ol\

]
.
lOOOOlllll
;
con\
st
Vec\
3
&
llllO\
O\
OlOO\

=
llOllll\
OlO
[
lOOO\
l\
lO\
OOl\

<
lOl\
l\
O\
l\
llOl
-
1
?
lOO\
OllOOOl\

+
1
:
0
]
.
lOOO\
Olllll
;
Vec3
lO\
l\
llOlOlll
=
lO\
OOlO\
OO\
OO
.
Cross\

(
lll\
lOOOOll
-
lll\
lOOO\
lOO
)
;
TA_ASSERT
(
lOll\
l\
O\
lOlll
.
GetM\
ag\
nit\
u\
de
(
)
>
0.0f
)
;
lOlllOlOlll\

.
Nor\
malis\
e
(
)
;
llOllllOl\
O\

[
lO\
OO\
llO\
OOl
]
.
lOlllO\
lOlll
=
lOlllO\
lOl\
ll\

;
}
}
void
CollisionObject\
CachedPolyDat\
a
::
Init\
ia\
lis\
e
(
)
{
lOO\
O\
llO\
O\
lOO
.
Initia\
l\
i\
se\

(
0
,
8
*
1024
)
;
lll\
OOlOllll
=
0
;
}
void
Col\
lis\
i\
on\
Obje\
ctCache\
dPolyData
::
Finalis\
e
(
)
{
lOOOllOOl\
OO
.
Fin\
al\
ise
(
)
;
lllOOlOl\
l\
l\
l
=
0
;
}
CollisionObje\
ctC\
ac\
he\
dPoly\
Dat\
a
::
Po\
l\
y\
g\
on\

*
Collis\
i\
o\
nO\
bje\
ctC\
achedP\
ol\
yD\
a\
ta
::
Ge\
tNewPo\
ly\
gon
(
int
lOllOlllOl
)
{
TA_ASSER\
T
(
lOOOl\
lO\
O\
lOO\

.
lOO\
l\
lllO\
l\
l\

(
)
>
0
)
;
const
in\
t\

lllOOllOO\
OO
=
lllOOllOOO\
l\

(
lOl\
lO\
lllOl
)
;
if
(
lO\
OOl\
lOO\
lO\
O\

.
lOOO\
ll\
lOOl\

(
)
+
lllOOll\
O\
OO\
O\

>
lOOOll\
OOl\
OO
.
lOOllllOll
(
)
)
ret\
u\
rn
0
;
const\

in\
t\

ll\
Ol\
ll\
OlOOl
=
lOOOl\
lOOlO\
O
.
lOO\
O\
lllOOl
(
)
;
lOO\
Ol\
l\
OOlOO
.
lOO\
lllllOl\

(
ll\
lOOll\
OOOO
)
;
Poly\
gon
*
ll\
O\
llllllOO\

=
(
Po\
lyg\
on
*
)
&
lOOOllO\
O\
lO\
O
[
llOlllOl\
OOl
]
;
ret\
urn
llOllllllO\
O
;
}
Collision\
ObjectC\
ac\
hed\
Po\
l\
yDa\
t\
a
*
TAC\
_CA\
LL
Co\
l\
l\
isionOb\
jectCache\
d\
Pol\
yData
::
Crea\
te\
Ne\
w
(
)
{
Col\
l\
isi\
o\
nO\
b\
jec\
tCachedPoly\
Data
*
lOlO\
ll\
O\
lOO\
l
;
lOOO\
OO\
llOlO\

(
lOl\
O\
llOlOO\
l
,
Co\
lli\
sionObje\
ctC\
a\
c\
he\
d\
Po\
l\
yData
)
;
ret\
ur\
n
lO\
lOllOl\
OOl\

;
}
CollisionObj\
e\
ctCach\
edPolyDa\
ta
::
CollisionO\
b\
je\
ctCached\
P\
ol\
yData\

(
)
:
Co\
ll\
ision\
O\
bject
(
TY\
PE_C\
ACHED_PO\
LY_DA\
TA
)
{
}
Co\
l\
lision\
O\
bje\
ctCac\
hed\
PolyDa\
ta
::
~
Co\
ll\
ision\
Obje\
c\
tCac\
he\
dPol\
yD\
a\
ta
(
)
{
Finalis\
e
(
)
;
}
#ifndef DOXYGEN
voi\
d\

TA\
C_C\
ALL
lllO\
Ol\
lOOlO
(
)
{
lllOOlO\
O\
OO\
l
=
0
;
lll\
O\
OlO\
OlO\
O\

[
0
]
=
0
;
lll\
O\
O\
lOO\
lO\
O\

[
1
]
=
0
;
lllO\
O\
lOl\
OOl
=
0
;
lllOOlOl\
lOO
[
0
]
=
0
;
lllOOl\
OllOO
[
1
]
=
0
;
lllOOlOllOO
[
2
]
=
0
;
lllOOlO\
Oll\
l\

=
0
;
}
void
TAC_CAL\
L\

ll\
lOOl\
lO\
Oll\

(
lOll\
Ol\
l\
l\
O\
OO
*
lOlllOOOOll
)
{
for
(
int
lll\
OOllOlO\
O
=
0
;
lllOOllO\
lOO
<
lll\
O\
O\
lO\
O\
OO\
l\

;
ll\
lOOll\
O\
lOO\

++
)
{
const
lll\
OOOl\
lOO\
l
&
ll\
lOOllO\
lOl
=
lllOO\
lOOOll\

[
lll\
OO\
l\
lOlO\
O
]
;
if
(
(
lllO\
Ol\
lO\
lOl
.
lO\
lOl\
l\
OO\
l\
l
&
lllOO\
OllOO\
l
::
lll\
OOOl\
lO\
ll
)
==
0
)
{
const
fl\
oat\

lOl\
l\
OlOl\
ll\

=
0.0001f
;
boo\
l
lllO\
O\
llO\
llO
=
fals\
e
;
for
(
int
lOllOlOlOl\
O
=
0
;
lO\
llOl\
OlOlO\

<
2
;
lOllOlOlO\
lO
++
)
{
in\
t
lOOOl\
l\
O\
OO\
l
;
for
(
lOO\
OllOOOl\

=
0
;
lOOO\
ll\
OOOl
<
ll\
l\
OOlOOlOO
[
lO\
llOlOlO\
l\
O
]
;
lOOOl\
lO\
O\
Ol
++
)
{
if\

(
(
ll\
lO\
Ol\
OOllO
[
lOO\
O\
ll\
OO\
Ol
]
[
lOll\
Ol\
O\
lO\
lO
]
-
lll\
OOl\
l\
Ol\
Ol\

.
lllOOOl\
llOO
)
.
Ge\
t\
Magnit\
ude\
Sqrd
(
)
<
lOllOlOlll\

*
lOl\
l\
OlOlll
)
bre\
a\
k
;
}
if
(
lOO\
O\
llOOOl
!=
lllOOl\
O\
OlOO
[
lOl\
l\
OlOlOl\
O
]
)
{
lllOOl\
l\
OllO
=
true\

;
break
;
}
if\

(
lll\
O\
O\
llOlOl
.
lOlOllOO\
ll
&
ll\
lOOOllOO\
l
::
lllOO\
O\
l\
lOlO\

)
{
fo\
r\

(
lOOO\
l\
lOO\
Ol\

=
0
;
lOO\
Oll\
OOOl
<
lllOOlOO\
lll
;
lO\
OOl\
l\
OO\
Ol
++
)
{
if
(
(
lll\
O\
Ol\
OlOOO
[
lOOOl\
lO\
OOl
]
.
lOOOO\
lllll\

-
lllOOllOlOl
.
lllOOO\
lllOO
)
.
Get\
M\
agni\
tu\
deSq\
rd
(
)
<
lOllOlOlll
*
lOllOlO\
l\
l\
l
&&
(
lllOOlO\
l\
O\
OO\

[
lOO\
OllOO\
Ol
]
.
ll\
lOOO\
l\
llll
-
lll\
OOllOlOl
.
ll\
l\
OOOl\
ll\
Ol
)
.
GetMagn\
itu\
deSqrd
(
)
<
lOll\
Ol\
O\
ll\
l
*
lOll\
O\
lO\
ll\
l\

)
bre\
ak
;
}
if
(
lOOOl\
lOOO\
l
!=
ll\
lOOl\
O\
O\
lll
)
lll\
OOll\
OllO
=
true
;
br\
eak
;
}
}
if
(
lllO\
Ol\
lO\
l\
lO
)
con\
tinue
;
}
Col\
l\
isi\
o\
n
llOlll\
lOlll
;
llOlll\
l\
O\
lll
.
Initialise
(
Col\
l\
i\
si\
on
::
lOllOlO\
OOOO
,
lllOOll\
OlO\
l
.
lllO\
lllll\
O
,
lllO\
OllOlOl
.
lOllOO\
lOOl\
l
,
lllOOll\
Ol\
Ol
.
lOOOOl\
lll\
l
,
lllOOl\
lOlOl
.
lO\
OO\
lOOOO\
O
)
;
ll\
OllllOlll
.
lOllOO\
lOOl\
O\

=
lllOOllO\
lOl
.
ll\
Olll\
Ol\
OOO
;
ll\
lOOl\
l\
Ol\
ll
(
llOll\
l\
lOl\
ll
,
lOl\
ll\
OOOOl\
l
)
;
}
for
(
int
lllOOlllOOO
=
0
;
lll\
OOlllOOO\

<
lllOOlOlOO\
l
;
lllOOl\
l\
lOOO
++
)
{
cons\
t\

ll\
lOO\
l\
OOO\
O\
O\

&
lllOOlllOOl\

=
lll\
OO\
lOlO\
ll
[
lll\
OOl\
llOO\
O
]
;
co\
nst
int\

lO\
l\
lO\
lOlOlO
=
lll\
OOlllOO\
l
.
lO\
llOl\
Ol\
OlO
;
int
lOOOllO\
O\
Ol\

;
fo\
r
(
lOO\
OllO\
OOl\

=
0
;
lO\
OO\
ll\
OO\
Ol
<
lllOOlOll\
OO
[
lOl\
l\
OlOlO\
lO
]
;
lOO\
OllOOOl
++
)
{
cons\
t\

floa\
t\

lOl\
lOlOll\
l
=
0.0001f
;
if
(
(
(
ll\
lOOlO\
lllO
[
lO\
l\
lOl\
O\
lOlO
]
[
lOOO\
llOOOl
]
[
0
]
-
lllOO\
lll\
OOl
.
lOllllOO\
llO\

)
.
Ge\
tMag\
ni\
tu\
d\
eSq\
rd\

(
)
<
lOllOlO\
lll
*
lOll\
O\
lOlll
)
&&
(
(
lllO\
Ol\
O\
lllO
[
lOll\
OlOlOlO\

]
[
lOO\
OllOOOl
]
[
1
]
-
lll\
OOlll\
OO\
l
.
lOl\
llOl\
lOlO
)
.
Ge\
tMag\
nitudeS\
qrd\

(
)
<
lOllOlO\
lll\

*
lO\
l\
lO\
lOlll\

)
)
br\
e\
ak
;
}
if
(
lOO\
Ol\
lOOO\
l
!=
lllOO\
lOllOO
[
lOl\
l\
O\
lO\
lOlO
]
)
co\
nti\
nue
;
Collision
lOllOll\
O\
lll\

;
lO\
l\
lOllOll\
l
.
Initialise
(
Collision
::
lOl\
lOlOOOOO\

,
lllOO\
lllOO\
l
.
lllO\
ll\
ll\
l\
O
,
ll\
lOOlll\
O\
Ol\

.
lO\
ll\
OOlOOll
,
lllOOlll\
OOl\

.
lOOOOll\
l\
ll
,
lll\
O\
Olll\
OOl
.
lOOO\
lO\
OOOO
)
;
lOll\
O\
llOlll
.
lO\
llOOl\
OOlO\

=
lll\
OOl\
l\
lOO\
l
.
llO\
l\
ll\
O\
lOOO
;
lllO\
OllOll\
l
(
lOll\
OllOlll
,
lOl\
llOOOOll
)
;
}
}
void\

TAC\
_CA\
L\
L
ll\
l\
O\
Oll\
l\
O\
lO\

(
fl\
oat
lll\
Oll\
lll\
O
,
flo\
a\
t\

lO\
llOO\
lOOl\
l\

,
const\

Coll\
isionObjec\
t\
CachedPolyDat\
a
::
Polyg\
on
*
llOOOlO\
l\
OO
,
int
lOlllOl\
OOl\

,
boo\
l\

lllOO\
lllOll
,
con\
st
Ve\
c3
&
lllOOOl\
l\
l\
OO
,
co\
nst
Vec3
&
lllOOllllO\
O
,
const
Ve\
c3
&
lO\
OOl\
OOO\
OO\

)
{
TA_AS\
SER\
T
(
lllOO\
lOOOOl
<
lllOO\
lOOOlO
)
;
if
(
lllOOlOOOOl\

>=
lllOOl\
O\
OOlO
)
re\
tur\
n\

;
TA\
_A\
S\
SERT
(
lll\
O\
lllllO
>=
0.0f
)
;
TA_ASSERT
(
lll\
O\
ll\
lllO\

<=
1.0f
)
;
TA_A\
SSERT
(
lOll\
lOlOOl\

>=
0.0f
)
;
TA_ASSE\
R\
T
(
lOlll\
OlOOl
<
llOO\
Ol\
OlOO
->
lOll\
OlllO\
l
)
;
ll\
lO\
OOllOOl
&
ll\
lO\
Oll\
Ol\
Ol\

=
lll\
O\
OlO\
OO\
ll\

[
lllOOl\
O\
OOOl
++
]
;
ll\
lO\
Ol\
l\
OlO\
l
.
lO\
ll\
O\
OlOOll
=
lOllO\
OlOO\
l\
l
;
lllOOl\
lO\
lOl
.
lllOl\
llllO
=
ll\
lOl\
llll\
O
;
lll\
O\
OllOlOl
.
lllOOOl\
llOO
=
lll\
O\
OO\
l\
l\
lOO
;
ll\
lOOllOl\
Ol
.
lOOOOllll\
l
=
lllO\
Olll\
lOO
;
lllOOllO\
l\
Ol
.
lO\
lOll\
OOll
=
0
;
ll\
lO\
O\
llOlOl
.
lO\
OOlOOOOO\

=
lOOOlO\
OO\
OO
;
lllOO\
llO\
lOl
.
lllO\
O\
Olll\
Ol
.
Clear
(
)
;
lllOOll\
Ol\
Ol\

.
llOlllOlOOO
=
llOO\
Ol\
OlOO\

->
ll\
O\
lllOl\
O\
OO
;
if
(
lllOOlllOll
)
{
con\
s\
t
float\

lO\
llOlOl\
ll
=
0.0001f
;
const
int\

lO\
lllOllOO\
O
=
lO\
lllO\
lOO\
l
+
1
<
ll\
OOOlOlO\
O
->
lOllOlllOl\

?
lOl\
llOl\
O\
Ol
+
1
:
0
;
co\
ns\
t
in\
t
lOlllOll\
l\
l\
O
=
lOlllOlOOl\

-
1
>=
0
?
lOlllOlOO\
l
-
1
:
llO\
OOlOlO\
O\

->
lOl\
l\
Ol\
l\
lOl
-
1
;
const
Vec3
&
lOll\
l\
lOOl\
l\
O\

=
llOO\
OlOlOO
->
llOlll\
l\
O\
lO\

[
lOll\
lOlOOl\

]
.
lO\
OOO\
ll\
lll\

;
con\
st
Vec3
&
lOlll\
O\
ll\
OlO
=
ll\
OOOlOlO\
O
->
ll\
Ol\
l\
llOlO
[
lOlllOllOOO
]
.
lO\
OOOllll\
l
;
con\
s\
t
Vec\
3
&
lll\
O\
O\
llll\
Ol
=
ll\
OOOlOlOO\

->
llOllll\
OlO
[
lOlllOll\
llO
]
.
lO\
OO\
O\
lll\
ll
;
TA_\
ASSERT
(
(
lll\
OOO\
lllOO
-
lOllllOO\
llO
)
.
IsZ\
e\
r\
o
(
)
)
;
flo\
at
lllO\
Ollll\
lO\

=
llOOOlOl\
OO
->
llOllllOlO
[
lOl\
ll\
OlOOl
]
.
lOlllOlOll\
l
.
Do\
t
(
lOOO\
l\
OOOOO\

)
;
float
lllOOlll\
l\
ll
=
llOOOl\
Ol\
OO
->
llO\
ll\
llOlO\

[
lOll\
lOl\
ll\
l\
O
]
.
lOl\
llOl\
O\
lll\

.
Do\
t
(
lOOOl\
OOO\
OO
)
;
if
(
lllOOl\
l\
lllO\

>=
0.0f
&&
lllOO\
lll\
lll
>=
0.0f
)
{
lll\
OOllOlOl\

.
lOOOlOO\
OOO\

=
llOOOlOlOO
->
lOOOlOOOO\
O
;
lll\
OOl\
lOlOl
.
lOlO\
llOOll
|=
lllOOOll\
O\
Ol
::
lllOOOllO\
ll
;
lllOlOOOOOO
(
lllO\
OOlll\
O\
O
,
lllOl\
O\
OOOO\
l\

)
;
}
else
{
bool
ll\
l\
O\
lOOOOlO
=
true
;
{
Ve\
c3
lllOO\
Olll\
l\
l\

=
lOlllOllO\
lO\

-
lO\
ll\
ll\
OOl\
l\
O
;
if\

(
(
lllOOOlllll
)
.
Do\
t\

(
lOOOlO\
OOOO\

)
>
0.0f
)
{
if
(
lllOO\
lllllO
<
0.0f
)
{
Vec3\

ll\
lOl\
O\
O\
OOll
=
lllOOOlllll
.
Cross\

(
lO\
O\
O\
lOOOOO
.
Cro\
ss
(
ll\
l\
OOOl\
llll
)
)
;
float
lO\
l\
lllO\
lO\
l
=
lll\
O\
lOOOO\
ll
.
GetMag\
ni\
tude
(
)
;
if
(
lOlll\
lOlO\
l
>
lOll\
Ol\
Oll\
l
*
lOllOl\
Olll
)
lllOl\
OOOOll
/=
lOl\
lllOlOl
;
els\
e
lll\
OlOOOOll
=
llOOOl\
Ol\
O\
O\

->
lOOOl\
OOOOO
;
lllOOllOlOl
.
lOOO\
lO\
O\
OO\
O
=
ll\
lOl\
OOO\
Oll
;
lllOO\
llOlOl\

.
lOlOll\
OOll
|=
lll\
OOOllO\
Ol
::
lllOOO\
ll\
Ol\
O
;
lll\
OOllOlOl
.
lllO\
OOlllOl
=
ll\
lOOOlll\
ll
;
lllOlOOOOlO\

=
false
;
lllOlOOOOOO
(
lllOOOl\
ll\
OO
,
lllO\
lO\
OOlOO
)
;
}
el\
se
{
lllOlOOOOO\
O
(
lll\
O\
OOll\
lOO
,
ll\
lOOOlllll
)
;
}
}
}
{
Vec3
lllOOOlll\
ll
=
lllOOl\
l\
l\
lO\
l
-
lO\
lll\
lOO\
ll\
O
;
if
(
lllOO\
O\
lllll
.
Do\
t
(
lOO\
OlOOO\
O\
O\

)
>
0.0f
)
{
if
(
lll\
OOll\
llll
<
0.0f
)
{
Vec3
ll\
lO\
lOO\
OOll\

=
lllOOOlllll
.
Cros\
s\

(
lOOO\
lOOOOO\

.
Cross\

(
ll\
l\
OOOl\
llll
)
)
;
float
lOlll\
lOlO\
l
=
lllOlOOOOll
.
GetMagnitude\

(
)
;
if
(
lO\
llllOlO\
l
>
lOll\
OlOlll
*
lOllOl\
Oll\
l
)
ll\
lOlOOOOll
/=
lOllll\
OlOl
;
else
ll\
lOlOO\
OOll
=
ll\
OOOlOlO\
O
->
lOOOlOO\
O\
OO\

;
lllOOll\
OlO\
l
.
lOOO\
lOOOOO\

=
ll\
lOlOOOOll
;
lllOOllO\
lOl
.
lOlOl\
lOOll\

|=
lllO\
OOll\
OOl
::
ll\
lO\
O\
O\
l\
lOlO\

;
ll\
l\
OOllOlOl
.
lllOOOll\
l\
Ol
=
lllO\
OO\
lllll
;
lll\
OlOOO\
OlO
=
fal\
se\

;
lllOl\
OO\
OOO\
O
(
lllOOO\
lllOO\

,
ll\
lO\
l\
OOOlOO
)
;
}
else
{
lllO\
lOOOO\
OO
(
lll\
OO\
OlllOO
,
ll\
lO\
O\
O\
l\
llll
)
;
}
}
}
}
}
TA_AS\
SER\
T\

(
lllOO\
ll\
O\
lO\
l\

.
lOO\
Ol\
O\
O\
OOO
.
IsNo\
rm\
a\
l\
ise\
d\

(
)
)
;
}
void
TAC_\
CALL\

lllOlO\
OOOO\
O\

(
const
Vec3\

&
lllOlOOOlOl
,
int
lOllOlO\
lOlO
)
{
TA_ASSER\
T
(
lllOOlOO\
lOO\

[
lOl\
lOlO\
lOlO\

]
<=
lllOOlOO\
l\
Ol\

)
;
TA_ASS\
ER\
T
(
lO\
ll\
O\
lOl\
O\
l\
O
>=
0
)
;
TA\
_A\
SSERT
(
lO\
llOlOlOlO
<=
1
)
;
if\

(
ll\
l\
OOlOO\
lOO\

[
lOl\
lO\
l\
OlOl\
O\

]
>=
lllO\
O\
lOOl\
O\
l
)
re\
turn\

;
lllO\
OlO\
Ol\
lO
[
lllOO\
lOO\
lOO\

[
lOllOl\
OlOl\
O
]
++
]
[
lOl\
l\
Ol\
OlOlO
]
=
lllO\
lOOOlOl
;
}
voi\
d\

TA\
C_\
CAL\
L\

lllO\
lOO\
OO\
OO
(
co\
n\
st
Vec3
&
lll\
OlOOO\
lOl
,
con\
s\
t
Vec3
&
lll\
OO\
Ol\
l\
lll
)
{
TA_AS\
SER\
T
(
ll\
lOOlOOlll
<=
lll\
O\
Ol\
O\
OlOl\

)
;
if\

(
lllOO\
lOOlll
>=
lllOOlOOlOl
)
ret\
urn\

;
lll\
OOlOlOOO
[
lllOO\
lOOl\
ll
]
.
lO\
OO\
O\
llll\
l
=
ll\
lO\
lOO\
Ol\
Ol\

;
lll\
O\
OlOlOOO
[
lllOOlOOl\
ll\

]
.
lllOO\
Ol\
llll
=
lll\
OOO\
lll\
ll
;
lllOOlOOl\
l\
l
++
;
}
void
TAC_\
CAL\
L
ll\
lOlOOO\
llO
(
flo\
at\

lllOlllll\
O
,
fl\
o\
a\
t
lOllOO\
lOOll
,
u32
llO\
lll\
O\
lOOO
,
const
Ve\
c3
&
lOl\
lllOOllO
,
co\
nst\

Vec3\

&
lO\
lllOl\
lOl\
O
,
const
Vec3
&
ll\
lO\
OllllOO
,
const\

Ve\
c3\

&
lOO\
OlO\
OOOO
,
int
lOl\
lOlOl\
O\
lO
)
{
TA_\
ASSERT
(
lllO\
OlOlOO\
l\

<
ll\
lOO\
lOlOlO
)
;
if
(
ll\
lOOlO\
lO\
Ol
>=
lllOO\
lOlOlO
)
ret\
u\
r\
n
;
TA_\
AS\
S\
ERT
(
ll\
lO\
lllllO
>=
0.0f
)
;
TA_AS\
S\
E\
RT
(
lllO\
l\
ll\
llO\

<=
1.0f
)
;
ll\
lOOlOOOOO\

&
ll\
lOOlllOOl
=
ll\
l\
OOlOl\
O\
ll\

[
lll\
OO\
lOl\
OO\
l
++
]
;
lll\
OO\
lll\
O\
O\
l\

.
lOl\
lO\
OlOOll\

=
lOllOO\
lO\
Oll\

;
lllOO\
lllOOl
.
lllO\
lllllO
=
lllO\
lllllO
;
lll\
OOll\
lOOl\

.
ll\
Olll\
O\
lO\
OO
=
llOll\
lOlOOO
;
Ve\
c\
3
ll\
lllOl\
OOO
=
lOl\
llO\
llOlO\

-
lOl\
lllOO\
llO\

;
int
lOOOl\
l\
llOl
=
ll\
l\
llO\
lOOO
.
Get\
Gr\
eatestAxis
(
)
;
if
(
llll\
l\
OlO\
OO
[
lOOOlll\
lO\
l\

]
>
0.0f
)
{
lllO\
OlllOOl
.
lOllllOOl\
lO
=
lO\
llllOO\
llO
;
lllOOlllO\
O\
l
.
lOl\
l\
l\
O\
llOlO\

=
lO\
lllOllOlO
;
}
else
{
lllOOlllO\
O\
l
.
lO\
ll\
llOOllO
=
lOlllO\
llOlO
;
lllOOlll\
OOl
.
lOll\
l\
OllOlO
=
lOl\
lllO\
Ol\
lO
;
}
lll\
OO\
lllOOl
.
lO\
OO\
Olllll
=
lllOOl\
lll\
OO
;
lllO\
O\
l\
llOOl
.
lOO\
OlOOOO\
O
=
lOOOlOOOOO
;
lll\
O\
OlllO\
Ol
.
lO\
llOl\
O\
lOlO
=
lO\
llO\
lOl\
Ol\
O
;
}
void\

TA\
C_C\
A\
L\
L
lll\
OlOOOlll
(
cons\
t
Ve\
c\
3
&
lOllllOOl\
lO
,
co\
n\
st
Vec3
&
lOlllO\
l\
l\
OlO
,
in\
t
lO\
l\
lOlOl\
Ol\
O
)
{
TA\
_AS\
SERT
(
lO\
ll\
OlOlOl\
O\

>=
0
&&
lOll\
OlOlO\
l\
O
<
3
)
;
if
(
lllOO\
lO\
l\
lOO\

[
lOll\
OlOlOlO\

]
>=
ll\
lOOl\
OllOl
)
re\
turn
;
Vec3
lllllO\
lOOO
=
lO\
ll\
lOl\
l\
O\
lO\

-
lO\
l\
l\
l\
lOOllO
;
int
lOO\
Oll\
llOl
=
lllll\
O\
l\
O\
OO\

.
Get\
G\
reates\
t\
Axi\
s\

(
)
;
if
(
lll\
llOlOOO
[
lOO\
Olll\
lOl
]
>
0.0f
)
{
lll\
OO\
lOl\
llO\

[
lOllOlOl\
O\
l\
O\

]
[
lllOOlOllO\
O
[
lOllOlOlO\
lO
]
]
[
0
]
=
lOllll\
OOllO\

;
ll\
lOOlOll\
lO
[
lO\
l\
lOl\
OlOlO\

]
[
lllO\
O\
l\
Oll\
O\
O
[
lOllO\
lOl\
OlO
]
]
[
1
]
=
lO\
lllO\
l\
l\
O\
l\
O
;
}
els\
e
{
lllOOlOlllO
[
lOllOlO\
lOlO\

]
[
ll\
lOOlO\
llO\
O
[
lO\
l\
lOlOlOl\
O
]
]
[
0
]
=
lOll\
l\
OllOlO\

;
lllOOl\
O\
l\
llO
[
lOl\
lOlOlOlO
]
[
lll\
OO\
l\
O\
llOO
[
lO\
ll\
OlO\
l\
OlO
]
]
[
1
]
=
lOl\
ll\
l\
OOllO
;
}
ll\
lOOlO\
llOO\

[
lOllOlOlOlO\

]
++
;
}
#endif //
}

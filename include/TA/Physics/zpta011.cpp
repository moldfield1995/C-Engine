//---------------------------------------------------------------------------------
// File Name: zpta011.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define llOllOlOOll
#define lOllOllOOlO
#include "CollisionObjectConvex.h"
#ifndef lOOllOllll
#include "../Common/zcta001.h"
#endif //
#ifndef TA_MFRAME_H
#include "../Common/MFrame.h"
#endif //
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef TA_CONVEXHULL_H
#include "../Common/ConvexHull.h"
#endif //
#ifndef llOllOOlOOO
#include "../Physics/zpta013.h"
#endif //
#ifndef TA_COLLISION_H
#include "Collision.h"
#endif //
#ifndef lllOOOllOOO
#include "../Physics/zpta007.h"
#endif //
#ifndef TA_COLLISIONOBJECTCAPSULE_H
#include "CollisionObjectCapsule.h"
#endif //
#ifndef TA_COLLISIONOBJECTCYLINDER_H
#include "CollisionObjectCylinder.h"
#endif //
#ifndef TA_COLLISIONOBJECTSPHERE_H
#include "CollisionObjectSphere.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef TA_COLLISIONOBJECTLINELIST_H
#include "CollisionObjectLineList.h"
#endif //
#ifndef lOlOOlllOO
#include "../Common/zcta003.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
namesp\
ace
TA
{
#define lllllOOlOlO(lOllOOOlOl, lOOOlOOlll) ((lOOOlOOlll) + 1 < (lOllOOOlOl).lOllOlllOl ? (lOOOlOOlll) + 1 : 0)
cons\
t\

int
lll\
l\
l\
O\
O\
lOll
=
128
;
const
int
lll\
l\
lOOll\
O\
O\

=
128
;
stati\
c\

Vec\
3\

ll\
ll\
lO\
Ol\
lOl
[
ll\
ll\
lO\
O\
lOll\

]
;
sta\
ti\
c
Ve\
c3
lll\
l\
lOOll\
lO\

[
lllll\
OOlOl\
l
]
;
str\
uct
lllllOOll\
l\
l
{
Ve\
c3\

lOOOOlllll
;
Vec3
lllllO\
l\
O\
OOO
;
Vec\
3\

llOl\
lllllO\
l
;
Ve\
c\
3
lOlllO\
lOlll
;
int
llOl\
llOlOOO
;
int
lllllOlOOOl
;
float
lOllO\
OlOOll\

;
}
;
static
int
ll\
lOO\
lOlOOl\

=
0
;
sta\
tic
con\
st
int
lllOO\
lOlOlO\

=
lOlO\
l\
OlOlO
;
stat\
ic
lll\
l\
lO\
Oll\
l\
l
llll\
lOlOOl\
O
[
ll\
lO\
OlOlOl\
O
]
;
st\
atic
vo\
i\
d
lll\
llOlOOll
(
)
;
st\
atic
void
lllllOlO\
lOO\

(
)
;
st\
atic
void
lllll\
OlO\
lOl
(
lOllOl\
l\
lOOO
*
lOlllOOOOll
,
int
lllllO\
l\
OOOl\

,
u32\

ll\
OlllOlOOO\

,
fl\
oa\
t
ll\
lOl\
llllO\

,
fl\
o\
at
llll\
l\
OlOllO
,
co\
ns\
t
Vec3
&
lO\
OO\
Olllll\

,
con\
st
Vec\
3
&
ll\
lllOlOOOO
,
const
Vec3
&
ll\
O\
l\
lll\
llOl
,
const\

Vec3
&
lOlllOlOll\
l
)
;
TA_ALI\
GN_\
16
struct
Co\
llisionObject\
Conve\
x
::
lllllO\
lO\
lll
{
Vec3\

lOlllOlOll\
l
;
int\

llOllllO\
OO\

;
int\

ll\
Olll\
lOO\
l
;
}
;
st\
r\
uct
Col\
lisio\
n\
Object\
Con\
vex
::
Polygon
{
Vec3
lOO\
OlOO\
OOO\

;
in\
t
lOllO\
ll\
lOl
;
flo\
at
lOl\
Ol\
ll\
OO\
l
;
u3\
2
ll\
ll\
lO\
l\
lOOO
;
u32
lll\
OlOOlOOO
;
llll\
lOlOll\
l
ll\
O\
llllOl\
O
[
lOlllOOlOll
]
;
}
;
st\
ruct
Co\
ll\
ision\
Ob\
ject\
Conve\
x
::
ll\
lll\
OllOOl
{
in\
t
ll\
l\
llOllO\
lO
;
int
lll\
ll\
Ol\
l\
O\
l\
l\

;
int
llOlOllO\
lO
;
int
llOlO\
llO\
ll
;
}
;
st\
ru\
ct\

Co\
lli\
si\
on\
Obje\
ct\
Conve\
x
::
Vertex\

{
int
lllllO\
lllO\
O\

;
int
lllll\
Ol\
llOl
[
256
]
;
}
;
struct\

Collision\
Object\
Convex
::
Data
{
enu\
m
{
llll\
lOllll\
O
=
0x1
,
}
;
int\

lO\
lOll\
OOll
;
Vec3
lll\
OllO\
OOl\
O\

;
AABB
lOOOO\
OO\
lll
;
lOOOOlOll\
O
<
Vec3
,
false
>
lllllO\
lllll\

;
lOOOOlOllO\

<
int\

,
fa\
ls\
e
>
lOll\
OOll\
l\
l
;
lOOOO\
lOll\
O\

<
u8
,
fa\
lse
>
lOll\
OOlllO
;
lOOO\
OlOl\
l\
O\

<
llll\
lOllOOl
,
fal\
se
>
llllllOO\
OOO
;
lOOO\
OlOllO
<
int
,
fa\
lse
>
llllll\
OO\
OOl
;
lOOOOlOllO
<
u8
,
fals\
e\

>
llll\
llOOO\
l\
O
;
}
;
#define llllllOOOll(llOOOOOOOOO, llOllOOOOl) \
(*(CollisionObjectConvex::Polygon*)&(llOOOOOOOOO)->GetData()->lOllOOlllO[(llOOOOOOOOO)->lOlOOlOllO->lOllOOllll[(llOllOOOOl)]])
#define llllllOOlOO(llOOOOOOOOO, lOlllOlOOl) \
(*(CollisionObjectConvex::Vertex*)&(llOOOOOOOOO)->GetData()->llllllOOOlO[(llOOOOOOOOO)->lOlOOlOllO->llllllOOOOl[(lOlllOlOOl)]])
stati\
c\

int
llllllOO\
lOl\

(
int
lO\
ll\
Ol\
llO\
l
)
{
return
sizeof
(
Vec3
)
+
si\
ze\
of\

(
int
)
*
4
+
size\
o\
f
(
const
Co\
lli\
sionObje\
ctConvex\

::
lllllO\
l\
Olll
)
*
lOllO\
lllOl
;
}
void
Coll\
isi\
onObjec\
tCon\
vex
::
In\
i\
tia\
l\
ise
(
)
{
In\
iti\
aliseAs\
ABo\
x
(
1.0f
,
1.0f
,
1.0f
)
;
}
voi\
d\

Colli\
s\
ionObjectCo\
nve\
x
::
In\
i\
tiali\
s\
eAsAB\
ox
(
float
lll\
l\
OlO\
O\
lO\
O
,
floa\
t\

ll\
l\
lOl\
OOlO\
l\

,
floa\
t
llllO\
lOOllO
)
{
AA\
BB
lOOOOOOl\
l\
l
;
lOOOOO\
O\
lll
.
v3C\
e\
nt\
er
.
Cle\
a\
r
(
)
;
lOOOOOOlll
.
v3\
E\
x\
tent
.
In\
iti\
ali\
s\
e\

(
llll\
O\
lOOlOO\

*
0.5f
,
llllO\
lOOl\
Ol
*
0.5f
,
lll\
lOlOOll\
O
*
0.5f
)
;
Initi\
ali\
s\
eAsA\
Box
(
lO\
O\
OOO\
Olll
)
;
}
voi\
d
Colli\
si\
onObject\
Convex
::
Ini\
t\
iali\
s\
eA\
s\
ABox\

(
const\

AA\
BB
&
lOOOOO\
Olll
)
{
lllll\
lO\
OllO\

(
lOO\
O\
OOOlll
,
0
)
;
}
void\

Co\
lli\
sion\
Ob\
ject\
Convex
::
In\
itialiseAsAnO\
rie\
nted\
Box
(
co\
ns\
t
AABB\

&
lOO\
O\
OO\
Oll\
l
,
const\

MFram\
e
&
lOOO\
O\
O\
O\
O\
Ol
)
{
ll\
l\
ll\
lO\
Ol\
lO
(
lOOOO\
OOlll\

,
&
lO\
OOO\
OO\
OO\
l\

)
;
}
bool\

Co\
llisi\
o\
n\
ObjectConvex\

::
Initia\
liseFro\
mPoin\
tL\
is\
t
(
co\
nst
Ve\
c\
3
*
llllOlOlOll
,
int
lll\
lOl\
OllOO
)
{
Con\
vexHull\

ll\
l\
lllOOlll
;
if
(
!
llllll\
OOlll\

.
In\
iti\
alise
(
ll\
llOl\
OlO\
l\
l
,
llllO\
lOllOO
,
lOlllOOlOll
)
)
{
lOOOlllOlO\

(
0
,
"CollisionObjectConvex::InitialiseFromPointList. Convex hull initialise failed")
;
AAB\
B
lOO\
O\
OO\
Ol\
l\
l
;
if\

(
llllOl\
OllOO
<=
0
)
{
lO\
OOOOOlll
.
v3\
Cente\
r\

.
Clear
(
)
;
lOO\
O\
OOOll\
l
.
v3E\
xt\
e\
nt
.
x
=
0.5f
;
lOOO\
OOOlll\

.
v3Ex\
tent\

.
y
=
0.5f
;
lOOO\
O\
OO\
lll\

.
v3Extent\

.
z
=
0.5f
;
}
el\
se\

{
lOOO\
OOO\
lll
.
v3\
Center
=
lll\
lOlOlOll
[
0
]
;
lOO\
O\
OO\
O\
l\
ll
.
v3Extent
.
Cl\
ea\
r\

(
)
;
for
(
int\

lO\
lllOlOOO\

=
0
;
lOlllOlOOO
<
ll\
llOlOl\
lO\
O\

;
lOlllOl\
OOO
++
)
lO\
O\
O\
OOOl\
l\
l\

.
Ex\
pandTo\
Fit\

(
llll\
OlOlOll
[
lOlllOlOOO\

]
)
;
const
float
llllllOl\
OOO
=
0.04f
;
if
(
lOOO\
OOOl\
ll
.
v3Ext\
e\
n\
t
.
x
<
llll\
ll\
OlOOO
)
lOOOO\
OOlll
.
v3Exte\
nt
.
x
=
ll\
llllOlO\
OO
;
if
(
lOOO\
O\
OOl\
ll\

.
v3\
E\
xte\
nt
.
y
<
ll\
llllOl\
O\
OO\

)
lO\
OO\
O\
OO\
lll\

.
v3Extent
.
y
=
llllllOlOOO
;
if
(
lOO\
OOOO\
lll
.
v3Ex\
te\
nt
.
z
<
ll\
ll\
llOlOOO
)
lOOOOO\
O\
ll\
l\

.
v3\
Exte\
nt
.
z
=
lllll\
lOl\
OOO
;
}
InitialiseAsABo\
x\

(
lOOO\
O\
OOlll
)
;
ret\
urn
false
;
}
Init\
i\
ali\
s\
eF\
ro\
mCo\
nvexHull
(
ll\
ll\
llOO\
l\
l\
l
)
;
return
true
;
}
void
Co\
llis\
i\
onOb\
ject\
Convex
::
Initia\
l\
iseFromPla\
neLi\
st\

(
const
Vec3\

*
llOOl\
OOlOl
,
const
Vec3
*
llOOlOO\
l\
l\
O\

,
int
llOOl\
OOlll\

)
{
ConvexHull
lllll\
lO\
Oll\
l
;
if
(
!
lll\
lllO\
O\
l\
l\
l
.
Init\
ia\
lis\
e
(
llO\
Ol\
O\
OlO\
l
,
ll\
OOl\
OOll\
O
,
llOOlO\
Oll\
l
)
)
retur\
n
;
Ini\
tia\
liseFr\
omCon\
vexH\
ull\

(
lll\
l\
l\
lOO\
lll\

)
;
}
voi\
d
Collisi\
on\
Obje\
ctCon\
ve\
x
::
In\
it\
ia\
li\
s\
eFrom\
ConvexHull\

(
ConvexHul\
l\

&
lllll\
lOOl\
ll\

)
{
if
(
lOlOOlOl\
lO
)
{
lO\
OOlllOl\
O
(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Finali\
se
(
)
;
}
lOOOOOllO\
lO\

(
lOl\
O\
Ol\
OllO
,
Dat\
a
)
;
if
(
llllllOOlll
.
GetNumPoi\
nts
(
)
>
lllll\
OO\
l\
Oll
)
retur\
n\

;
lO\
lO\
O\
lO\
llO
->
lOlO\
llOOll
=
0
;
lO\
lOOlOllO
->
lllllOll\
ll\
l\

.
Initi\
a\
lise
(
0
,
ll\
l\
lllOOl\
ll
.
Get\
NumP\
oin\
ts
(
)
)
;
for
(
int
lll\
l\
llO\
lOO\
l
=
0
;
llllllOlOOl
<
ll\
lll\
lOOlll
.
Get\
NumPo\
i\
nts
(
)
;
llllllOl\
O\
Ol
++
)
lOlOOlO\
llO
->
lllllOll\
lll
.
lO\
OOll\
lOO\
O
(
lll\
lllO\
Olll
.
GetPo\
in\
t\

(
llllllOl\
O\
Ol
)
)
;
int
llOlll\
O\
OOlO
=
0
;
int
llllllOlOl\
O\

=
0
;
lOlOOlOllO
->
lOllO\
O\
llll\

.
Initi\
al\
ise
(
0
,
ll\
lll\
lO\
Olll
.
GetNumPolyg\
on\
s
(
)
)
;
int
llOll\
OO\
O\
Ol
;
for
(
llOllO\
OOOl
=
0
;
llOll\
OO\
O\
Ol
<
llllllO\
Olll
.
GetN\
um\
Poly\
go\
ns
(
)
;
llOll\
OO\
OOl
++
)
{
lOl\
OO\
lOllO
->
lOllOOllll\

.
lOOOl\
llO\
O\
O\

(
llOlllO\
OO\
lO\

)
;
con\
st
ConvexH\
u\
ll\

::
Poly\
gon
&
lOllOOO\
lOl\

=
llll\
llO\
Olll\

.
Get\
Po\
lygon
(
llO\
l\
lOO\
O\
Ol
)
;
llOl\
ll\
OOOlO\

+=
llllllOO\
lO\
l
(
lOllOOOlOl
.
lOllOlllOl\

)
;
llllllOlOlO
+=
lO\
ll\
OOO\
lOl
.
lOll\
Ol\
llOl
;
}
lOlOOl\
O\
l\
lO\

->
lOllOO\
lllO
.
Init\
i\
al\
is\
e
(
ll\
O\
ll\
lOO\
OlO
,
llOlllOO\
OlO
)
;
int
ll\
OlllO\
lO\
Ol\

=
0
;
for
(
llOllOOOOl
=
0
;
llOll\
O\
OOO\
l
<
llll\
llO\
Olll
.
Ge\
t\
Num\
Polygon\
s\

(
)
;
ll\
OllOOO\
Ol
++
)
{
const
Co\
nvexHu\
l\
l
::
Polygo\
n\

&
ll\
llllOlOll
=
lll\
lll\
OOlll
.
GetP\
ol\
yg\
o\
n\

(
llOllOOOOl
)
;
Polygon\

&
lOl\
lOOOl\
O\
l
=
*
(
Polygon
*
)
&
lOlOOlOllO\

->
lO\
llO\
OlllO\

[
llOlllOlOOl
]
;
lOll\
OOOlOl\

.
lO\
ll\
OlllOl
=
llllllOlOll\

.
lOllOl\
ll\
Ol
;
for
(
int\

lO\
ll\
lO\
lOOl
=
0
;
lO\
lllOl\
O\
O\
l
<
lO\
l\
lO\
OOlOl
.
lOllO\
lllOl
;
lO\
l\
llOlOO\
l\

++
)
{
lOll\
O\
OO\
lOl
.
llOlll\
l\
OlO
[
lOlllO\
lOOl
]
.
llO\
llllOO\
O
=
lll\
l\
l\
lOlOl\
l\

.
llOllll\
OlO\

[
lOlllO\
lO\
Ol\

]
.
llOlll\
lOOO
;
lOllOOOlO\
l
.
ll\
Ol\
lllOlO
[
lOlll\
OlOOl
]
.
llOllllOOl
=
ll\
l\
lllOlOl\
l
.
ll\
Olll\
l\
OlO
[
lOlllOlO\
O\
l
]
.
llOlll\
lOOl
;
lOl\
l\
O\
OOlOl
.
llOll\
llOl\
O
[
lOlllOlOOl
]
.
lOll\
l\
O\
lO\
lll
.
Cl\
ear
(
)
;
}
llOlllOlOOl\

+=
llll\
llOOl\
Ol
(
lOl\
l\
OOOlOl\

.
lOllOlllO\
l
)
;
}
ll\
lll\
lOllO\
O
(
)
;
lOl\
O\
OlOl\
l\
O
->
lll\
l\
l\
lOOOO\
O
.
Initialise\

(
0
,
lll\
lllOlOlO
>>
1
)
;
for\

(
ll\
OllO\
O\
OOl\

=
0
;
llOllOO\
OOl
<
llllllOOlll\

.
Ge\
t\
N\
um\
Polygon\
s
(
)
;
ll\
OllO\
OOOl
++
)
{
Pol\
y\
g\
on
&
lO\
llOOOlO\
l
=
llllllOOO\
ll\

(
thi\
s
,
llOllOOO\
O\
l
)
;
for
(
in\
t\

ll\
llllOll\
Ol
=
0
;
llllllOllOl
<
lOllOOOlOl
.
lO\
llOlllO\
l
;
llll\
l\
lOll\
Ol
++
)
{
in\
t
lllllOllO\
l\
O
=
lOllO\
O\
OlO\
l
.
llOlll\
lOl\
O\

[
llll\
llOllO\
l
]
.
llOllllOOO
;
int
lllll\
Ol\
lOll\

=
lOllOOOlOl\

.
llO\
llllO\
lO
[
lllllOOlOlO
(
lOllOO\
OlOl
,
lll\
ll\
lO\
llOl\

)
]
.
ll\
Ol\
l\
llO\
OO
;
in\
t
llOlOl\
Oll\
O
;
for
(
llOlO\
lO\
llO
=
0
;
ll\
OlOlOllO
<
lOlO\
Ol\
OllO
->
lll\
lll\
OOOOO\

.
lO\
OOl\
l\
lO\
O\
l
(
)
;
ll\
OlO\
lOll\
O
++
)
{
lll\
llOl\
lOOl
&
ll\
OlOl\
OOlO
=
lO\
lOOl\
OllO
->
llllll\
O\
O\
O\
OO
[
llOlOlOl\
lO
]
;
if\

(
(
llOlOlOOlO\

.
ll\
lllOl\
lOl\
O
==
ll\
l\
l\
l\
Oll\
OlO
&&
llO\
lO\
lOO\
lO
.
lll\
ll\
O\
l\
l\
O\
l\
l
==
lllll\
OllOll\

)
||
(
llOlOlOOlO
.
lll\
llOllOlO
==
lllllO\
llO\
ll
&&
llOlOl\
OOlO
.
ll\
l\
llOllO\
ll
==
lll\
llOl\
lOl\
O
)
)
{
br\
e\
ak
;
}
}
if\

(
ll\
OlOlOl\
lO
!=
lOlOOlO\
l\
lO\

->
ll\
llllOO\
OOO
.
lOOOl\
llO\
O\
l\

(
)
)
co\
nt\
in\
u\
e
;
lll\
llO\
llOO\
l
&
ll\
OlOlOOl\
O
=
lOlOO\
lO\
llO
->
ll\
l\
l\
l\
lOOOOO
.
lOOO\
lllOOO
(
)
;
ll\
OlO\
l\
OOlO
.
lll\
llO\
llOlO
=
lllllO\
ll\
O\
l\
O
;
ll\
Ol\
OlOOl\
O
.
llll\
lOll\
Oll\

=
lllllOllOl\
l
;
llOlOlOOlO
.
ll\
OlO\
l\
lOlO
=
llOl\
lOOOOl\

;
llOlO\
lOO\
lO\

.
llO\
lOllOl\
l
=
lOllO\
OOl\
Ol
.
ll\
OllllOlO
[
llllllOllOl\

]
.
llO\
llllO\
Ol\

;
}
}
TA\
_ASSERT
(
lOlOOlO\
l\
l\
O\

->
ll\
llllO\
OOOO\

.
lOOOlll\
O\
Ol\

(
)
==
lOl\
OOlO\
ll\
O
->
lll\
lllO\
OOOO\

.
lOOl\
l\
ll\
Oll\

(
)
)
;
ll\
ll\
llOlllO
(
)
;
InitialiseComm\
o\
n
(
)
;
}
void
Co\
l\
lis\
ionO\
bject\
Conv\
e\
x\

::
Finalise
(
)
{
if
(
lOlOOlOllO
)
{
lO\
Ol\
OOOOOO
(
lOlO\
OlO\
llO\

,
Dat\
a\

)
;
lOlOOlOll\
O
=
0
;
}
}
void
CollisionObject\
Co\
nvex
::
Seri\
a\
l\
is\
e
(
Se\
rialiser
&
lOOO\
lOll\
Ol\

,
const
Version\

&
lllOlOOl\
O\
O
)
{
lOOOOO\
OllO
(
ll\
lOlOOlOO\

<=
llOllO\
Oll\
OO
,
"CollisionObjectConvex::Serialise. Version number is too new")
;
if
(
lO\
OOl\
Ol\
l\
O\
l
.
lOOOll\
O\
OOO
(
)
)
{
if\

(
lOlOOlO\
llO\

)
{
lOO\
OlllOl\
O
(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Fin\
alise
(
)
;
}
lOOOOOl\
lOl\
O
(
lO\
lOOlO\
llO
,
Data
)
;
}
lOOOlOllO\
l
.
Serial\
i\
s\
e
(
lOlOOlOl\
lO
->
lll\
OllOOOlO
)
;
lO\
OOl\
OllO\
l
.
Seria\
li\
s\
e
(
lO\
lO\
OlO\
ll\
O
->
ll\
lO\
ll\
OO\
OlO\

)
;
if
(
lllO\
lO\
Ol\
OO
>=
Versio\
n
(
1015
,
0
)
)
lOOOlOllOl
.
Ser\
i\
a\
lise
(
lOlOOlOllO\

->
lO\
lO\
ll\
OOll
)
;
else
lOl\
O\
O\
l\
OllO
->
lOlOl\
lOOll
=
0
;
lOOOlO\
l\
lOl
.
lO\
OOlOl\
lll
(
lOlOO\
lO\
llO
->
lll\
l\
l\
Oll\
lll
)
;
lOOOlOll\
Ol
.
lO\
O\
OlOll\
ll
(
lOlOOlOllO
->
lOllOOll\
ll\

)
;
lOOOlOllOl
.
lO\
OO\
lO\
llll
(
lOl\
OOlOllO
->
lO\
llOO\
ll\
l\
O
)
;
lO\
OOl\
OllO\
l\

.
lOO\
OlO\
llll
(
lOlOOl\
OllO
->
ll\
llll\
O\
O\
OOO
)
;
lOOOlOllOl
.
lOOOlO\
llll
(
lOl\
OOlOllO
->
llllllOO\
OOl
)
;
lOOOlOllOl
.
lOOOlOll\
ll
(
lOlOOlOl\
lO
->
ll\
llllO\
OOlO
)
;
}
AA\
B\
B
Coll\
isionO\
bje\
ctConvex
::
Ca\
lculate\
Boundi\
ngBox\

(
)
con\
st
{
AAB\
B
lO\
OO\
OOO\
lll
;
if\

(
lO\
l\
OOlOl\
lO
&&
lOl\
OOlOl\
l\
O
->
lllllOllll\
l
.
lO\
O\
OlllOOl
(
)
)
{
lOO\
OOOOll\
l\

.
Initia\
l\
i\
s\
e
(
lOl\
OOlO\
llO
->
ll\
ll\
lOlllll
[
0
]
,
k_v\
3Zero
)
;
for
(
in\
t
lOlllO\
l\
OOl
=
1
;
lOl\
llOlO\
Ol
<
lO\
lOOlOllO
->
lll\
l\
l\
Ol\
llll\

.
lOOOlllOO\
l
(
)
;
lOll\
l\
OlOOl
++
)
lO\
OOOOO\
lll
.
Expa\
ndToFi\
t
(
lOlO\
O\
lOl\
lO\

->
ll\
l\
llOlllll
[
lOll\
l\
OlOO\
l
]
)
;
}
else\

{
lOOOOOO\
lll
.
v3\
Cente\
r\

.
Cl\
ear\

(
)
;
lO\
OOO\
OOl\
ll
.
v3Ext\
ent
.
Cle\
ar\

(
)
;
}
re\
t\
urn\

lOOOOO\
Olll
;
}
void
Colli\
sionObject\
Con\
vex
::
Ca\
l\
cul\
a\
teMa\
ss\

(
fl\
oat
ll\
lOll\
OOO\
Ol
,
floa\
t\

&
lOllOOOOll\
O\

,
Ve\
c\
3
&
lll\
Ol\
lOOOlO
,
Ma\
t33\

&
lllOll\
OOOll
)
const\

{
float
lll\
lllOllll
=
0.0f
;
float\

lll\
l\
lll\
OOOO
=
0.0f
;
fl\
oa\
t
lllllllOOO\
l
=
0.0f
;
fl\
o\
at
lll\
llllO\
OlO
=
0.0f
;
floa\
t
ll\
l\
l\
lllOOl\
l
=
0.0f
;
flo\
at
ll\
ll\
l\
llOlOO
=
0.0f
;
float\

ll\
lll\
llO\
lOl
=
0.0f
;
float
ll\
lllllOllO
=
0.0f
;
float\

lllllllOlll
=
0.0f
;
float
llll\
l\
lllOOO
=
0.0f
;
for\

(
int
llO\
l\
lOO\
O\
Ol
=
0
;
llOl\
l\
O\
OOOl
<
lOlOOl\
OllO
->
lO\
l\
lOOll\
l\
l\

.
lOO\
Oll\
l\
O\
Ol
(
)
;
llOllOOOOl
++
)
{
Polyg\
o\
n
&
lO\
ll\
OOOlOl
=
*
(
Polygon\

*
)
&
lO\
lO\
O\
l\
OllO\

->
lO\
llOOll\
lO
[
lOlOOlO\
llO\

->
lOll\
O\
Oll\
ll\

[
ll\
OllOOO\
Ol
]
]
;
for
(
int
llllllllOOl
=
0
;
llllllllOOl
<
lOll\
OO\
Ol\
O\
l
.
lOll\
OlllOl\

-
2
;
ll\
l\
lll\
llOO\
l
++
)
{
cons\
t
Vec3
&
lll\
ll\
llll
=
lOlO\
OlOllO\

->
llll\
l\
Olll\
ll
[
lOl\
lOO\
OlO\
l\

.
llOllllOlO
[
0
]
.
llOlll\
lO\
O\
O
]
;
const
Ve\
c\
3
&
lOOO\
OO\
OOOO
=
lOl\
OOlO\
l\
lO
->
ll\
lllOlll\
ll\

[
lOl\
lOOOl\
Ol
.
llOllllOl\
O
[
ll\
ll\
ll\
llO\
Ol
+
1
]
.
llOl\
l\
l\
l\
OOO\

]
;
co\
n\
s\
t
Vec3
&
llll\
OO\
lOOO
=
lOlOOlOllO\

->
lllllOl\
l\
lll
[
lO\
ll\
OOOlO\
l\

.
llO\
l\
lllO\
lO\

[
ll\
ll\
lll\
l\
OOl
+
2
]
.
llO\
llllO\
O\
O
]
;
float
ll\
ll\
lll\
lOlO
;
flo\
at
lllllll\
lO\
ll
;
floa\
t\

llll\
Olll\
lO
;
lllll\
l\
l\
lOl\
O\

=
ll\
l\
l\
ll\
l\
ll
.
x
+
lOOOO\
OOOO\
O
.
x
;
llll\
llll\
Ol\
l
=
lllllllll
.
x
*
llll\
l\
llll
.
x
;
llllOlll\
lO
=
llllllllOl\
l
+
lOOOO\
OOO\
OO
.
x
*
lllllll\
lO\
l\
O
;
float
ll\
l\
l\
l\
ll\
llOO
=
ll\
lll\
ll\
lOlO\

+
llll\
O\
Ol\
OOO
.
x
;
float
ll\
l\
llllllO\
l
=
ll\
llOlll\
lO
+
llllO\
O\
lOO\
O\

.
x
*
lll\
lllll\
lOO
;
fl\
oa\
t
lllllllll\
lO
=
lllllllll\

.
x
*
lllll\
l\
l\
lOl\
l
+
lOOOO\
O\
OOO\
O
.
x
*
llllOllllO
+
lll\
lOOl\
OO\
O
.
x
*
lll\
ll\
llllOl
;
llllll\
llOl\
O
=
llllll\
lll
.
y
+
lO\
OOOOO\
OO\
O\

.
y
;
lll\
l\
llllOll
=
lllll\
l\
lll
.
y
*
llll\
l\
llll
.
y
;
ll\
llOll\
llO
=
lll\
lllll\
O\
ll
+
lOO\
O\
OO\
OOO\
O
.
y
*
lll\
lllll\
OlO
;
fl\
oat
llllll\
llll\
l\

=
lllll\
l\
llOlO
+
lll\
lO\
Ol\
O\
O\
O
.
y
;
float\

lO\
O\
OO\
O\
OOOOOO
=
llllO\
llllO
+
lll\
lOOlOOO\

.
y
*
ll\
llllllll\
l
;
float
lO\
OOOOO\
OOO\
Ol\

=
ll\
l\
llllll
.
y
*
lll\
l\
l\
lllOll
+
lO\
O\
OOOOOO\
O
.
y
*
lll\
l\
OllllO
+
ll\
l\
lOO\
l\
OO\
O
.
y
*
lOOOO\
OOOOOOO
;
llll\
llllOlO\

=
lll\
llll\
ll\

.
z
+
lO\
OO\
O\
OOOOO\

.
z
;
lll\
lll\
llOll\

=
lllllll\
ll
.
z
*
lll\
llll\
ll\

.
z
;
ll\
l\
lOllllO
=
lllllll\
l\
O\
ll
+
lOO\
OO\
OOOOO
.
z
*
lll\
lllllO\
lO
;
float
lOOO\
OO\
OOO\
O\
lO
=
lllllll\
lOlO
+
ll\
ll\
OOl\
OOO\

.
z
;
float
lO\
OO\
OOOOO\
Oll\

=
llllOllllO
+
llllOOlO\
OO
.
z
*
lO\
O\
O\
OOOOOOlO
;
floa\
t
lOOOOOO\
OOl\
OO
=
llll\
lll\
ll
.
z
*
llllll\
llOl\
l
+
lOO\
OO\
OOOO\
O
.
z
*
llllOl\
l\
l\
lO\

+
llllOOlOOO
.
z
*
lOO\
OOOOOOOll
;
Vec3\

lOll\
lllOO\
O
=
(
lOOOOOO\
OOO
-
llllllll\
l
)
.
Cross
(
llll\
OOlOOO
-
lll\
l\
llll\
l
)
;
ll\
l\
lllOllll
+=
lOlll\
llOO\
O
.
x
*
lllllll\
llOO
;
llllll\
lOOOO
+=
lOl\
lll\
lO\
OO
.
x
*
ll\
l\
ll\
lll\
lOl
;
lllllll\
O\
O\
O\
l\

+=
lOll\
lllOOO
.
y
*
lO\
OOOO\
O\
OO\
OO\
O
;
ll\
llll\
l\
O\
OlO
+=
lOlllllOOO\

.
z
*
lO\
OOOO\
OOOOl\
l
;
lllllllOOl\
l
+=
lOl\
llll\
OOO\

.
x
*
lllllll\
lll\
O\

;
lll\
llllOlOO\

+=
lOllll\
l\
OOO\

.
y
*
lOOOOOOO\
OO\
Ol
;
llllll\
l\
O\
l\
O\
l\

+=
lOll\
lllO\
OO
.
z
*
lOOOOOOO\
OlO\
O
;
lllll\
l\
llOlO\

=
lllll\
llll
.
y
*
(
lllllllllO\
l
+
llll\
lll\
ll
.
x
*
(
lllllllllOO
+
llll\
ll\
l\
ll
.
x
)
)
+
lOO\
OOO\
OOOO\

.
y
*
(
llllll\
lllOl
+
lOOOOOOOOO
.
x
*
(
lll\
llllllOO
+
lOO\
OOO\
OOOO
.
x
)
)
+
llll\
OOlO\
OO\

.
y
*
(
ll\
l\
llllll\
Ol
+
lll\
lOO\
lOO\
O
.
x
*
(
ll\
llll\
l\
llOO
+
ll\
ll\
O\
OlOOO
.
x
)
)
;
ll\
llll\
l\
OllO
+=
lO\
l\
llllOOO
.
x
*
lll\
ll\
l\
l\
lOlO
;
lll\
lll\
l\
lOlO\

=
llllll\
l\
ll
.
z
*
(
lO\
O\
OO\
OOO\
O\
OOO\

+
lll\
lllll\
l
.
y
*
(
llllllll\
lll
+
llllllll\
l\

.
y
)
)
+
lOOOOOOOOO\

.
z
*
(
lOO\
OO\
OOOOOOO\

+
lO\
OOO\
OOOOO\

.
y
*
(
lllllllllll
+
lOO\
OOO\
OO\
OO\

.
y
)
)
+
lll\
l\
OO\
l\
OO\
O\

.
z
*
(
lOOOO\
OOO\
O\
O\
OO\

+
llll\
OOlOOO
.
y
*
(
ll\
lllllllll
+
llllO\
OlOO\
O
.
y
)
)
;
llllll\
l\
Olll
+=
lOlllllOOO
.
y
*
llllll\
l\
lOl\
O
;
lllll\
lll\
O\
lO
=
ll\
ll\
lllll\

.
x
*
(
lO\
O\
O\
OO\
OOOOll\

+
ll\
lll\
lll\
l
.
z
*
(
lOOOOO\
O\
O\
OOl\
O
+
lll\
ll\
l\
lll
.
z
)
)
+
lOOOO\
O\
O\
OOO\

.
x
*
(
lOOO\
OO\
OOO\
O\
l\
l
+
lO\
OOOOOOOO
.
z
*
(
lO\
OO\
OOOOOOl\
O\

+
lOOO\
OO\
O\
OOO
.
z
)
)
+
ll\
ll\
OOl\
O\
O\
O
.
x
*
(
lO\
O\
OOOOOOOl\
l
+
llllOOlOO\
O
.
z
*
(
lOOOOOOOOOlO
+
llllOOlOOO\

.
z
)
)
;
llll\
llllOOO
+=
lOllll\
lO\
OO
.
z
*
llll\
ll\
llOlO
;
}
}
lOllOOOOll\
O
=
ll\
llll\
Ol\
l\
ll
*
(
1.0f
/
6.0f
)
;
lOO\
O\
OOO\
ll\
O
(
lOllOOOOllO
>
0.0f
,
"CollisionObjectConvex::CalculateMass: Mass is less or equal too zero")
;
lllOll\
OOOlO
.
x
=
lllllllOO\
O\
O\

;
lll\
OllO\
OOl\
O
.
y
=
llll\
lllOOOl
;
lll\
OllOOO\
lO
.
z
=
llll\
ll\
lO\
OlO\

;
lllOl\
lOOO\
lO
*=
1.0f
/
(
24.0f
*
lOllO\
O\
OOllO\

)
;
const
fl\
oat
lOOO\
OOO\
O\
OlOl
=
1.0f
/
60.0f
;
llllll\
lOOll
*=
lOOOOO\
OOOl\
Ol
;
ll\
l\
l\
lllOlO\
O\

*=
lOOOOOO\
OOlOl
;
ll\
lllllOlOl
*=
lO\
OOO\
O\
OOO\
lOl
;
co\
nst
floa\
t
lO\
O\
OO\
OOOOll\
O\

=
1.0f
/
120.0f
;
lll\
l\
lllOllO
*=
lO\
OOOOOOOllO
;
lllllllOl\
ll
*=
lO\
OO\
O\
OOOOllO
;
llllllllOO\
O
*=
lOOOOOO\
OO\
llO
;
lllOll\
OO\
Ol\
l\

.
M1\
1
(
)
=
ll\
lllllO\
l\
OO
+
ll\
llll\
lOlOl
-
lO\
l\
lOOO\
Ol\
lO
*
(
lll\
Ol\
lOOO\
lO
.
y
*
lll\
Oll\
OO\
O\
lO
.
y
+
lllOl\
lOOOlO
.
z
*
lllOllO\
OOlO\

.
z
)
;
ll\
lOl\
lOOOll
.
M22\

(
)
=
ll\
ll\
ll\
l\
OOll\

+
lll\
l\
ll\
l\
O\
l\
O\
l
-
lOllOO\
O\
O\
llO
*
(
lll\
Oll\
OOO\
lO
.
z
*
lllO\
l\
lOOOlO
.
z
+
lll\
Oll\
OO\
OlO
.
x
*
lllOllOOOlO
.
x
)
;
ll\
lOl\
lOOOll
.
M33
(
)
=
ll\
lllll\
OOll
+
ll\
lllll\
OlOO
-
lOllOO\
OOllO\

*
(
lllOllOOOlO
.
x
*
ll\
l\
OllOOOlO
.
x
+
ll\
l\
OllOO\
OlO
.
y
*
lllO\
l\
lOOO\
lO
.
y
)
;
ll\
l\
Ol\
l\
OOO\
l\
l\

.
M12
(
)
=
lll\
OllO\
OOll
.
M21
(
)
=
lOll\
OOOOllO\

*
ll\
l\
Ol\
lOOO\
l\
O
.
x
*
lll\
OllO\
OO\
l\
O
.
y
-
ll\
ll\
ll\
l\
OllO
;
ll\
lOllOOO\
l\
l
.
M23
(
)
=
lllOl\
l\
OOO\
l\
l
.
M32
(
)
=
lOllO\
OO\
OllO
*
lll\
O\
llOOO\
l\
O
.
y
*
lllOllO\
OO\
lO\

.
z
-
ll\
lllllOlll
;
lllOll\
OOO\
ll\

.
M13
(
)
=
lllOllOO\
Oll
.
M31
(
)
=
lO\
llOOOOl\
l\
O
*
ll\
lOllO\
OOlO
.
z
*
ll\
lO\
llOO\
OlO
.
x
-
lllllll\
lO\
OO
;
lO\
ll\
O\
OO\
O\
llO\

*=
lllO\
l\
l\
OOOOl
;
lll\
OllOO\
Ol\
l
*=
lllOllOO\
O\
Ol
;
}
void\

Co\
l\
li\
s\
ionOb\
je\
ctConvex
::
Tra\
n\
sfor\
m
(
const
MFrame\

&
lOllOll\
ll\
lO\

)
{
TA_A\
SSERT
(
lOlO\
OlOllO
)
;
fo\
r\

(
int\

lOlllOlOO\
l
=
0
;
lOlllOlO\
O\
l\

<
lOlOOlOl\
l\
O
->
lllllOlllll
.
lOOOlllOOl\

(
)
;
lOlllOlO\
Ol
++
)
lO\
l\
OOlOll\
O
->
lllll\
O\
l\
l\
l\
ll
[
lOlllOlOOl
]
*=
lO\
llOlllll\
O\

;
lllll\
lOllOO
(
)
;
lOlOO\
lO\
ll\
O
->
lllOll\
OO\
OlO\

*=
lOllOlll\
llO
;
lOl\
OOlO\
llO
->
lOlO\
l\
l\
OOll
&=
~
Data
::
lllllOllll\
O
;
}
vo\
id
Col\
lis\
io\
n\
O\
bje\
c\
tC\
onve\
x
::
Rende\
r
(
const
MFra\
m\
e
&
lO\
OOOOOOOl\

)
{
TA_A\
SS\
ERT
(
lOlOOlOllO\

)
;
Ve\
c\
3
lOOOOOOO\
O\
lll
[
lOlllOOlOll
]
;
Vec3
ll\
lOlOllOll
[
lO\
lllOOlOll
]
;
int\

ll\
OllO\
OOO\
l\

;
for
(
llOllOOOO\
l
=
0
;
ll\
OllOOOOl\

<
lOl\
OOlOllO
->
lOllOOllll
.
lOOOlllO\
Ol
(
)
;
llOllOO\
OOl
++
)
{
Polygon
&
lO\
ll\
O\
OO\
lOl
=
*
(
Polyg\
on\

*
)
&
lO\
lO\
OlO\
l\
lO
->
lOll\
O\
O\
lllO
[
lOl\
OOl\
OllO
->
lOl\
lO\
O\
l\
lll\

[
ll\
Ol\
lOOOOl
]
]
;
TA_A\
S\
SERT
(
lOllOOOlOl
.
lOllOl\
l\
lOl\

<=
lOlll\
O\
OlOll\

)
;
in\
t
lOlllOlOOl
;
co\
nst\

Vec3
lOOOOO\
OOlOOO
=
lO\
llOOO\
lO\
l
.
lOOO\
l\
O\
OOOO
*
lOOOO\
OOOOl
.
m33Rota\
tion
;
for
(
lOl\
l\
lOlO\
O\
l
=
0
;
lO\
lllOlOOl
<
lOl\
lOOO\
l\
Ol
.
lOll\
OlllO\
l
;
lO\
lll\
OlOOl
++
)
{
lOOOOO\
O\
OOll\
l
[
lOlll\
OlOOl
]
=
lO\
lOO\
lOll\
O
->
lllllOlll\
ll
[
lOl\
lOOOlOl\

.
llOllllOlO
[
lOl\
llOlOO\
l
]
.
llOlll\
lO\
OO
]
*
lOOO\
OOOOOl
;
ll\
lOlOllOll
[
lO\
ll\
lOlOOl
]
=
lOOOOOOO\
lOOO\

;
}
Physic\
sRende\
r
::
Re\
nd\
er\
P\
ol\
y\
gon
(
lOl\
lOOO\
l\
Ol
.
lO\
llOl\
l\
l\
O\
l
,
lOO\
O\
OOOOOlll\

,
ll\
l\
OlO\
ll\
Oll
)
;
#ifdef lOOOOOOOlOOl
Vec3
lOOOOOOOl\
OlO
;
lOOO\
OO\
OOl\
O\
lO
.
Cl\
ear
(
)
;
for
(
lO\
l\
l\
l\
Ol\
O\
O\
l\

=
0
;
lO\
lllOlOOl
<
lOll\
OOOlO\
l\

.
lO\
llOlllOl
;
lO\
l\
ll\
OlOOl
++
)
{
int\

llOOl\
lO\
lO\
l
=
lO\
lllOlOO\
l
;
Vec3\

&
lllllllll
=
lO\
l\
OOlOl\
lO
->
lllll\
Olllll\

[
lOl\
lOOOlOl
.
ll\
O\
ll\
ll\
OlO\

[
lOll\
lO\
l\
OOl
]
.
llOllllO\
O\
O
]
;
int\

llOOll\
Ol\
lO
=
(
lOlllOlOOl
+
1
<
lO\
llOOOlOl
.
lO\
ll\
Olll\
Ol
)
?
lOlllO\
lOOl
+
1
:
0
;
Vec3
&
lO\
O\
OOO\
OOOO\

=
lOlOOl\
OllO\

->
lll\
llOlll\
ll
[
lO\
l\
lOOOlOl\

.
ll\
Oll\
llOlO
[
llOO\
llOllO\

]
.
llOll\
ll\
O\
O\
O\

]
;
lO\
O\
O\
OOOOlOlO
+=
lllll\
ll\
ll
;
Vec3\

llO\
O\
llll\
lO\

=
(
ll\
lllllll
+
lOOOOOOO\
OO
)
*
0.5f
;
Physic\
s\
Render
::
Re\
nd\
e\
rA\
rrow
(
llOOl\
l\
ll\
lO
*
lOOO\
OOOOOl
,
lO\
llOO\
OlOl
.
ll\
OllllOlO
[
lOl\
llOlOOl
]
.
lO\
l\
l\
l\
OlOlll
*
0.25f
*
lOO\
OOOOOOl
.
m33R\
otation
,
lOO\
O\
OOOO\
l\
Oll
(
255
,
0
,
255
,
0
)
)
;
}
TA_ASSERT\

(
lO\
llOO\
OlOl
.
lOllOlllO\
l\

)
;
lOOO\
OOOO\
lOl\
O
/=
(
floa\
t
)
lOll\
OOOlOl
.
lOl\
lO\
l\
l\
lOl
;
PhysicsRen\
der\

::
Render\
Arro\
w
(
lOOOO\
OOOlOlO
*
lOOOOOOOOl
,
lOl\
lOOO\
l\
Ol
.
lOOOlOOOOO
*
lOOO\
OOOO\
Ol
.
m33Ro\
tation\

,
lOO\
OOOOOlOll
(
255
,
255
,
0
,
0
)
)
;
#endif //
}
#ifdef lOOOOOOOlOOl	
for
(
in\
t
lOll\
lOlO\
O\
l\

=
0
;
lO\
l\
ll\
OlO\
Ol
<
lO\
lOOlO\
llO
->
lll\
llO\
lll\
ll
.
lOOOl\
ll\
OOl
(
)
;
lOl\
llOlOOl
++
)
{
con\
st\

Ve\
c\
3
&
lllllllll
=
lOl\
O\
OlOllO
->
llll\
l\
Ol\
l\
lll
[
lOll\
lO\
lOOl
]
;
Vertex
&
lOOOO\
O\
OOllOO\

=
lll\
l\
llOOl\
O\
O\

(
this
,
lOll\
lOl\
OO\
l
)
;
fo\
r\

(
int
lO\
O\
OOOO\
Ol\
lOl\

=
0
;
lOO\
OO\
O\
OO\
ll\
Ol
<
lO\
OOOOOOl\
lO\
O
.
ll\
lllOlllOO
;
lOOOOOOO\
l\
l\
Ol\

++
)
{
const\

Ve\
c3\

&
lO\
OOO\
O\
OOOO\

=
lOlO\
O\
l\
O\
llO
->
lllllOlll\
ll\

[
lOOOOO\
O\
Ol\
lO\
O
.
lllllO\
l\
ll\
O\
l
[
lOOOOOOOllOl\

]
]
;
PhysicsRender
::
Re\
n\
der\
A\
rr\
ow
(
llll\
lllll\

*
lOOO\
OO\
OOOl\

,
(
(
lOOOOOOOOO\

-
ll\
lllllll
)
*
lOO\
OOOOOO\
l
.
m33R\
ota\
t\
i\
o\
n\

)
*
0.25f
,
lOOOOOOOlOll\

(
255
,
255
,
0
,
255
)
)
;
}
}
#endif //
#ifdef lOOOOOOOlllO
for
(
llO\
llOOOO\
l
=
0
;
ll\
O\
llOO\
OOl\

<
lO\
lO\
OlO\
l\
lO
->
lOllOOl\
l\
l\
l
.
lOOOlllOOl
(
)
;
llOllOOOOl
++
)
{
Polygo\
n
&
lOllOOOlOl
=
*
(
Polygon
*
)
&
lOlOOlOllO
->
lOllO\
Oll\
lO
[
lOl\
OO\
lOll\
O
->
lOllOOll\
ll
[
ll\
Ol\
lOO\
OOl
]
]
;
TA_ASSE\
RT
(
lOl\
lOOOlOl
.
lOl\
lOlllOl\

<=
lOl\
llO\
Ol\
O\
ll\

)
;
in\
t
lOl\
llO\
lOOl
;
for
(
lOl\
l\
lO\
lOOl
=
0
;
lOl\
l\
lOlOOl\

<
lOllOOOlOl
.
lOll\
O\
lllO\
l
;
lO\
lllOlOOl
++
)
{
lOOOOOO\
OOll\
l
[
lOlll\
Ol\
OOl
]
=
lO\
lOOlOl\
l\
O
->
lllllOlllll\

[
lOl\
lOOO\
lOl\

.
llOlll\
lO\
lO
[
lOl\
llOlOOl
]
.
llOllllOOO\

]
*
lO\
OOO\
OOOOl
;
}
if
(
lOOOO\
OO\
Ollll
==
&
lOll\
OO\
O\
lOl
)
{
for
(
lOlllO\
lOO\
l
=
0
;
lOlll\
O\
lOOl\

<
lOl\
lOOO\
lO\
l
.
lOllOlll\
O\
l\

;
lO\
lllOl\
OOl
++
)
{
int
llOOll\
OlOl\

=
lO\
lllO\
lOOl\

;
Vec3
&
lllllllll
=
lOOO\
OOOOOlll
[
llO\
O\
llOlO\
l
]
;
in\
t
ll\
OO\
ll\
O\
l\
lO
=
(
lOll\
lOlO\
O\
l\

+
1
<
lOllOO\
OlOl\

.
lO\
ll\
OlllO\
l
)
?
lOll\
lOlOO\
l
+
1
:
0
;
Vec\
3
&
lO\
OOOOOOOO
=
lOOOOO\
OOO\
lll\

[
llO\
Ol\
lOll\
O
]
;
PhysicsRender
::
Re\
nde\
r\
L\
ine
(
llll\
lll\
ll
,
lOOOOOOOOO
,
lOOOOOOO\
lOll
(
255
,
255
,
255
,
0
)
)
;
}
}
}
#endif //
}
bo\
ol
Co\
llis\
io\
nObje\
ctCo\
nv\
e\
x
::
Tes\
tLineFor\
Colli\
sio\
n
(
const
Vec3\

&
lOOlOl\
Olll
,
const
Vec3
&
lOOOlOO\
OOO
,
flo\
at
lO\
OlO\
llOOO
,
Collisi\
on
&
llOl\
ll\
l\
Ol\
ll
)
co\
nst
{
if
(
!
lOlO\
OlOllO
)
retu\
rn\

false
;
for
(
in\
t
llOl\
lOOOOl
=
0
;
ll\
Oll\
O\
OOO\
l
<
lOlOOlOllO\

->
lOll\
OO\
lll\
l
.
lOOOlll\
OOl\

(
)
;
llOllOO\
OOl
++
)
{
Polyg\
on\

&
lOllOOOlOl\

=
llllllO\
OO\
ll
(
this\

,
llOllOOOOl
)
;
float
lOllllOOOO
=
lOl\
lOO\
OlO\
l\

.
lOOOlOOOO\
O
.
Dot
(
lOOlO\
lO\
lll
)
-
lO\
llOOO\
lO\
l
.
lOlOl\
llOOl
;
flo\
at
lO\
l\
ll\
l\
OOlO
=
lOll\
ll\
OO\
OO
+
lOllOOOlOl\

.
lOOO\
lOOO\
OO
.
Dot
(
lO\
OOl\
O\
O\
OOO\

)
*
lOOl\
OllOO\
O
;
if
(
lOl\
ll\
lO\
O\
OO
<
0.0f
||
lOllllOOlO\

>=
0.0f
)
cont\
inue
;
floa\
t
ll\
lOlllllO
=
lOllllOOOO
/
(
lOll\
llOOOO
-
lO\
lll\
lOOlO
)
;
if
(
ll\
lOll\
lllO
>=
ll\
OllllO\
lll
.
lllO\
l\
l\
l\
llO
)
con\
ti\
nue\

;
Vec3
lOOOOO\
OlOOOO
=
lOO\
l\
OlO\
lll
+
(
lOOlOllOOO
*
ll\
lO\
lllllO
)
*
lOOOlO\
OOOO
;
int
llOlOlOll\
O
;
for\

(
ll\
OlO\
lOllO
=
0
;
llOlOl\
OllO
<
lOllOOOlOl\

.
lOl\
lOl\
llO\
l
;
ll\
O\
lOlOllO
++
)
{
co\
nst\

lllllOlO\
lll\

&
lOOOOO\
OOllOO\

=
lOl\
lOOOlOl\

.
llO\
llllOlO
[
llOlOl\
OllO
]
;
cons\
t\

Vec\
3\

&
ll\
OOlllllO
=
lOlOOlO\
llO
->
lllllO\
lll\
l\
l
[
lOOOOOO\
Ol\
lOO
.
llOll\
llO\
OO
]
;
if
(
lOO\
OOOOO\
llOO
.
lOlll\
OlOlll
.
Dot\

(
lOOOOOOlOOOO
-
llOOll\
lllO
)
<
0.0f
)
brea\
k\

;
}
if
(
llOl\
Ol\
Ol\
lO\

<
lOl\
lO\
OOlOl
.
lOll\
Ol\
llO\
l
)
continue
;
llOllllOlll
.
lOlOllO\
Ol\
l\

|=
Coll\
isi\
on
::
FLAG\
_CO\
LLISION_OCCU\
R\
R\
ED
;
llOl\
l\
llOll\
l\

.
lOOOOl\
llll
=
lOOOO\
OOlOOO\
O
;
ll\
Ol\
ll\
lOl\
ll
.
lOO\
O\
lO\
OOOO\

=
lOl\
lOOOl\
O\
l
.
lOOOlOO\
O\
OO
;
llO\
llll\
Oll\
l
.
ll\
l\
O\
lllllO
=
ll\
lO\
lllllO
;
llO\
lll\
lOl\
ll
.
lOllOOlOOll
=
lll\
O\
lllllO\

*
lO\
Ol\
OllOOO
;
llO\
l\
l\
llOl\
l\
l
.
SetCollis\
i\
o\
nO\
bjectA
(
con\
st_\
cast
<
Col\
lisio\
nO\
bjec\
tConvex
*
>
(
this
)
)
;
return
true
;
}
ret\
urn
fals\
e
;
}
Coll\
isionObj\
ec\
tCon\
ve\
x
*
TA\
C_C\
A\
LL
Coll\
is\
ionObjec\
tConv\
e\
x
::
CreateNew
(
)
{
Coll\
isio\
nObjectCo\
n\
vex
*
lOlO\
llOl\
OOl
;
lOOOOOll\
Ol\
O\

(
lOl\
O\
l\
lOlOOl
,
Coll\
i\
s\
ionObjec\
t\
Co\
nvex
)
;
return
lOlO\
l\
lOlO\
Ol
;
}
Collis\
io\
n\
Objec\
tC\
onve\
x\

::
Colli\
sion\
O\
bje\
ctConvex
(
)
:
Collisi\
onObject\
Simple
(
Col\
lision\
Ob\
j\
ect
::
TY\
PE\
_CONVE\
X
)
{
lO\
lOOl\
O\
l\
lO
=
0
;
}
Collis\
i\
onOb\
j\
ectCon\
vex
::
~
Coll\
isionOb\
jectConv\
ex
(
)
{
Fi\
n\
a\
l\
ise
(
)
;
}
void
Col\
lisionO\
b\
j\
ectCon\
vex\

::
Initial\
i\
s\
eComm\
o\
n\

(
)
{
TA_AS\
SERT
(
lOlO\
OlOllO
)
;
lOlO\
OlOllO\

->
llllllOOO\
Ol
.
Init\
i\
alise
(
0
,
lOlO\
O\
lOllO
->
lllllOll\
l\
l\
l
.
lOO\
Oll\
lOOl
(
)
)
;
cons\
t\

in\
t
lO\
OO\
O\
O\
Ol\
OOOl\

=
lO\
lO\
OlOl\
lO
->
llll\
lOlllll
.
lOO\
Ol\
llOO\
l
(
)
+
lOlOOl\
O\
ll\
O
->
llllllO\
OO\
OO\

.
lOOOll\
l\
OOl
(
)
*
2
;
lOlOOl\
O\
llO
->
ll\
l\
lllOOOlO
.
In\
i\
ti\
a\
lise
(
0
,
lOOOOO\
OlOOOl
*
sizeo\
f
(
int\

)
)
;
for
(
int
lOlllOlO\
Ol
=
0
;
lOl\
ll\
O\
l\
OOl
<
lO\
l\
OOlOllO\

->
lllllOl\
l\
lll
.
lO\
OOlllO\
Ol\

(
)
;
lOlll\
O\
lO\
Ol\

++
)
{
lOlOOlOll\
O
->
ll\
llllOOOOl
.
lO\
O\
Oll\
l\
O\
O\
O
(
lO\
lOO\
lOl\
lO
->
ll\
l\
lllO\
O\
OlO
.
lOOOlllOOl
(
)
)
;
lOl\
OOl\
OllO
->
llll\
llOO\
OlO\

.
lOOlll\
l\
l\
Ol
(
siz\
eof
(
int
)
)
;
in\
t\

&
lOOOOOO\
lOOlO
=
(
int
&
)
lOlO\
OlOl\
lO
->
lllll\
l\
OO\
OlO
[
lOl\
OOlOllO
->
ll\
ll\
ll\
OO\
OlO
.
lOOOlllO\
Ol\

(
)
-
sizeof\

(
int\

)
]
;
lO\
OOOOOlOO\
l\
O
=
0
;
for
(
in\
t
llO\
lOlO\
ll\
O
=
0
;
llOlOl\
OllO\

<
lOl\
O\
O\
lOllO
->
llllllO\
OO\
OO
.
lOOOl\
ll\
OOl
(
)
;
llOlOlOllO\

++
)
{
if\

(
lO\
lOOl\
Ol\
lO\

->
llllllOO\
O\
OO\

[
llOl\
OlOllO\

]
.
ll\
ll\
lOllOlO
==
lOl\
l\
lO\
lOOl
)
{
lOl\
OOl\
OllO\

->
llll\
llOOO\
lO
.
lOOllll\
l\
Ol
(
siz\
eof
(
in\
t
)
)
;
int\

&
lO\
OOOOO\
lOOll
=
(
in\
t
&
)
lOl\
OOl\
OllO\

->
lllll\
lOOO\
lO
[
lOlOOlOllO\

->
ll\
ll\
llOOOlO
.
lOOOll\
lOOl\

(
)
-
sizeof\

(
int
)
]
;
lOOOO\
OOl\
O\
Oll
=
lOl\
O\
O\
lOllO
->
llllllOOOOO
[
llOlO\
lO\
ll\
O
]
.
lll\
l\
l\
OllOll
;
lOO\
OOO\
OlOOlO\

++
;
}
else
if
(
lOl\
OOl\
OllO
->
lll\
ll\
lO\
OOOO
[
llOl\
OlOll\
O\

]
.
lll\
l\
lO\
llOll
==
lOlll\
OlOOl
)
{
lOlOOlOllO
->
lll\
l\
llOOOlO\

.
lO\
Oll\
ll\
lOl
(
sizeo\
f
(
int
)
)
;
int
&
lOOOOO\
Ol\
OOll\

=
(
in\
t
&
)
lOlO\
OlO\
ll\
O
->
llllll\
OOO\
lO
[
lOlOOl\
Ol\
lO
->
ll\
ll\
ll\
O\
O\
OlO
.
lOOO\
lllOOl
(
)
-
sizeof
(
int
)
]
;
lOOO\
O\
OOlO\
O\
ll\

=
lOlOOl\
O\
llO
->
ll\
llllO\
OOOO
[
llOlOlOllO\

]
.
lllllOllOl\
O
;
lOO\
OOOOlOO\
lO
++
;
}
}
}
TA_ASS\
ERT
(
lOl\
OOlOl\
lO\

->
lll\
lllOOOOl
.
lOOOl\
llOOl
(
)
==
lOlOOl\
Ol\
lO
->
llllllOOO\
Ol
.
lOOll\
l\
l\
Ol\
l
(
)
)
;
TA_ASSERT
(
lOlOOlOllO\

->
llllllOOOlO
.
lOOOl\
llO\
Ol
(
)
==
lOl\
O\
OlOllO
->
ll\
llll\
O\
OO\
lO
.
lOOl\
ll\
lOl\
l
(
)
)
;
}
voi\
d
Collis\
i\
onObjectCon\
vex
::
llll\
llOOll\
O
(
const
AAB\
B
&
lOOO\
O\
O\
Olll
,
cons\
t
MF\
ra\
me
*
lO\
OO\
OOO\
lOlOO
)
{
#ifdef lOOOOOOOlllO
lOOO\
O\
OOOllll
=
0
;
#endif //
if
(
lOl\
O\
OlOl\
lO
)
{
lOOOlll\
OlO
(
0
,
"CollisionObjectConvex::InitialiseAsABox. Already initialised.")
;
Finalis\
e\

(
)
;
}
lOO\
OOOllOlO
(
lOlOO\
lO\
llO
,
Data
)
;
if
(
!
lO\
OOOOO\
l\
OlOO
||
(
lOOOOOO\
lOl\
O\
O
->
m33Rotat\
i\
on
.
v3X\

.
IsEqu\
alWith\
InErr\
or
(
k_v3Un\
itX
,
0.00001f
)
&&
lO\
O\
O\
O\
OOlOlOO
->
m33Rotatio\
n
.
v3Y\

.
Is\
E\
qualWith\
InEr\
ror
(
k_v3UnitY
,
0.00001f
)
&&
lOO\
OO\
OOlOlOO
->
m33Rot\
a\
t\
ion
.
v3Z
.
Is\
Eq\
u\
alWith\
InEr\
ro\
r
(
k_v3Uni\
tZ\

,
0.00001f
)
)
)
lOlO\
OlOl\
lO
->
lOlOllO\
Oll\

=
Data\

::
lll\
l\
lO\
llllO\

;
els\
e
lO\
l\
O\
Ol\
OllO
->
lO\
lOll\
OOll
=
0
;
lOlO\
OlOl\
l\
O
->
ll\
l\
llO\
ll\
ll\
l
.
Initialis\
e
(
8
,
8
)
;
lOlO\
O\
lOl\
l\
O\

->
ll\
lllOlllll
[
0
]
.
In\
itialis\
e
(
1.0f
,
1.0f
,
1.0f
)
;
lOlOOlOllO\

->
llll\
lOl\
llll
[
1
]
.
Init\
i\
al\
ise
(
-
1.0f
,
1.0f
,
1.0f
)
;
lO\
lO\
OlO\
llO
->
llll\
lO\
l\
l\
l\
l\
l
[
2
]
.
Initialis\
e
(
-
1.0f
,
1.0f
,
-
1.0f
)
;
lO\
lOOlOl\
lO
->
lllllOlllll\

[
3
]
.
Ini\
tial\
ise\

(
1.0f
,
1.0f
,
-
1.0f
)
;
lOlOO\
lO\
llO
->
lllllOl\
ll\
ll
[
4
]
.
Initi\
alise\

(
1.0f
,
-
1.0f
,
1.0f
)
;
lOlOOlOllO
->
ll\
lll\
Oll\
ll\
l
[
5
]
.
Initial\
ise
(
-
1.0f
,
-
1.0f
,
1.0f
)
;
lOlOOlOllO
->
llll\
l\
Oll\
lll
[
6
]
.
Ini\
tiali\
se
(
-
1.0f
,
-
1.0f
,
-
1.0f
)
;
lOl\
OO\
lOl\
lO
->
llll\
l\
Olllll
[
7
]
.
Initial\
ise
(
1.0f
,
-
1.0f
,
-
1.0f
)
;
for\

(
int\

lOlllOlOOl
=
0
;
lOll\
lOlOO\
l
<
lOlOOlOllO\

->
lll\
llOllll\
l
.
lO\
OOlllOOl
(
)
;
lOll\
l\
O\
l\
OOl
++
)
{
lOlO\
OlO\
ll\
O
->
lllllOll\
ll\
l
[
lO\
lllOlOOl
]
.
x
*=
lOOOO\
OOl\
l\
l
.
v3Exte\
nt
.
x
;
lOl\
OOlOl\
l\
O
->
lllllOl\
ll\
l\
l
[
lOlllO\
lO\
Ol\

]
.
y
*=
lOOOOOOlll
.
v3E\
xt\
e\
nt\

.
y
;
lOlOO\
lOllO
->
lllllOlllll\

[
lOl\
ll\
OlO\
Ol
]
.
z
*=
lOOOOO\
Ol\
ll
.
v3Extent
.
z
;
lOlO\
O\
lOl\
lO
->
lllllOlllll
[
lOlll\
OlOOl
]
+=
lOO\
OOOO\
ll\
l
.
v3Center
;
if\

(
lOOOO\
O\
Ol\
O\
l\
OO
)
{
lOl\
OOlO\
llO\

->
llll\
lO\
l\
llll
[
lO\
lllOlOOl
]
*=
*
lO\
OO\
OO\
OlOlOO
;
}
}
in\
t\

llO\
lll\
OOOl\
O
=
ll\
l\
lllO\
OlOl
(
4
)
*
6
;
lOlO\
Ol\
OllO\

->
lOllOOlllO
.
Ini\
tiali\
se
(
llOlllOOOlO
,
ll\
O\
lll\
OOOl\
O\

)
;
in\
t\

lOO\
OOOOl\
OlOl\

=
0
;
Polygon
*
llOO\
OlOlOO
;
lOl\
OOlOllO\

->
lOl\
l\
OOllll
.
Initia\
lis\
e\

(
6
,
6
)
;
lOlOO\
lOllO
->
lOllOOllll
[
0
]
=
lOOOOOOlOl\
Ol
;
llO\
O\
O\
lOlOO\

=
(
Polygon
*
)
&
lOlOOlOllO
->
lOll\
OOlll\
O
[
lOOOO\
OOlOlOl
]
;
llOO\
Ol\
Ol\
O\
O
->
lOll\
Olll\
O\
l\

=
4
;
llO\
OOlOlOO\

->
ll\
OllllOlO
[
0
]
.
ll\
Olll\
l\
OOO
=
3
;
ll\
OOOl\
O\
lOO
->
ll\
Ol\
ll\
l\
O\
l\
O
[
1
]
.
llO\
llllOOO
=
2
;
ll\
OOOl\
OlOO\

->
llOllll\
O\
lO
[
2
]
.
llOllllOOO\

=
1
;
llO\
OOlOlO\
O
->
llOll\
llO\
lO
[
3
]
.
ll\
Ol\
l\
l\
lO\
OO
=
0
;
lO\
OO\
OOOlO\
l\
Ol
+=
llllll\
OO\
lOl
(
ll\
OOOlOlOO
->
lOl\
l\
Olll\
Ol
)
;
lOlOO\
lOll\
O\

->
lOll\
O\
Ollll
[
1
]
=
lO\
OOOOO\
l\
O\
lO\
l\

;
llO\
OOlOlOO
=
(
Po\
l\
y\
gon\

*
)
&
lOlOOlOl\
lO
->
lOllO\
OlllO\

[
lO\
OO\
O\
OOlOlOl\

]
;
llOOOlOlO\
O
->
lO\
l\
lOlllO\
l
=
4
;
llOOOlO\
lOO
->
llOll\
ll\
OlO
[
0
]
.
llO\
l\
ll\
lO\
OO
=
4
;
llO\
OOlOlO\
O\

->
llOllll\
OlO
[
1
]
.
llOlll\
lO\
OO
=
5
;
ll\
OOOlO\
lO\
O
->
llOllllOlO
[
2
]
.
llOl\
l\
llOOO\

=
6
;
ll\
OO\
OlOlOO
->
llOllllOlO
[
3
]
.
llOll\
llOOO
=
7
;
lOOOOOOlO\
lOl
+=
lllll\
l\
O\
O\
lOl
(
llO\
O\
O\
lO\
l\
OO
->
lOll\
Ol\
ll\
Ol
)
;
lOlOOlO\
llO\

->
lOllOOllll
[
2
]
=
lO\
OO\
OOOlOlOl\

;
llOOOlOl\
O\
O\

=
(
Polygon\

*
)
&
lOlO\
OlOllO
->
lOllOOlllO
[
lOO\
OOOOlO\
l\
Ol
]
;
llOO\
OlO\
l\
O\
O
->
lO\
llOll\
lOl
=
4
;
ll\
OOOlOlOO
->
llOll\
ll\
Ol\
O\

[
0
]
.
llO\
llllOO\
O
=
0
;
llOOOlO\
lOO
->
llOl\
l\
llO\
lO
[
1
]
.
llO\
l\
lllOOO
=
1
;
ll\
O\
OOlOl\
OO
->
llOll\
llOlO
[
2
]
.
llOllllOOO
=
5
;
llOO\
Ol\
OlO\
O
->
ll\
Ollll\
OlO
[
3
]
.
llO\
lll\
l\
OO\
O
=
4
;
lO\
OO\
OOOlOlO\
l
+=
llll\
l\
lOOl\
Ol
(
llOOOl\
OlOO
->
lOll\
O\
lll\
Ol
)
;
lOlO\
OlO\
l\
lO
->
lOll\
OOllll\

[
3
]
=
lOO\
OOOOlO\
lOl
;
ll\
OOOlOlOO\

=
(
Pol\
yg\
o\
n
*
)
&
lOl\
OOl\
O\
ll\
O
->
lO\
llO\
OlllO
[
lO\
OOOO\
Ol\
OlOl
]
;
llO\
O\
OlOl\
OO
->
lO\
l\
lOlllOl
=
4
;
llOOOlOlOO
->
ll\
O\
l\
lllOlO
[
0
]
.
llOlll\
l\
OO\
O
=
1
;
llOO\
Ol\
O\
l\
OO
->
llOllllOl\
O
[
1
]
.
llO\
lll\
lOO\
O
=
2
;
ll\
OO\
OlO\
lOO
->
llOl\
lllOl\
O\

[
2
]
.
llOllllOO\
O
=
6
;
llOOOl\
OlOO
->
ll\
O\
l\
l\
llOlO
[
3
]
.
llO\
lll\
lO\
OO\

=
5
;
lO\
OOO\
OOlOlOl
+=
llllllO\
OlOl
(
llOO\
OlOl\
O\
O
->
lOllOl\
llO\
l
)
;
lOlOOlOl\
lO
->
lOll\
O\
Olll\
l
[
4
]
=
lOOO\
OOOlOlOl\

;
llOO\
OlOlOO\

=
(
Polygon
*
)
&
lOlO\
OlOllO
->
lOll\
O\
OlllO\

[
lOOO\
O\
OOlOl\
Ol
]
;
llOOO\
lO\
l\
OO
->
lO\
l\
lO\
l\
llOl\

=
4
;
ll\
O\
O\
O\
lOlOO
->
llOl\
ll\
lOlO
[
0
]
.
llOll\
llO\
OO
=
2
;
ll\
OOOlO\
lO\
O
->
llOllllOl\
O
[
1
]
.
llOllllOO\
O
=
3
;
llOO\
O\
lOlO\
O
->
llOl\
lll\
OlO
[
2
]
.
llOllllOOO
=
7
;
ll\
OOOl\
Ol\
O\
O\

->
llOl\
ll\
lOl\
O\

[
3
]
.
llO\
l\
lllOOO\

=
6
;
lO\
OO\
OOOlO\
lOl\

+=
llllll\
O\
OlOl
(
ll\
OOO\
lO\
lOO
->
lOllOlll\
Ol
)
;
lO\
l\
O\
OlO\
ll\
O
->
lO\
l\
lOOl\
l\
ll
[
5
]
=
lOOOOOO\
lOlOl
;
ll\
OOOlOl\
O\
O
=
(
Po\
l\
ygo\
n\

*
)
&
lOlOOlOl\
l\
O
->
lOl\
lOO\
lll\
O
[
lOOOOOOlO\
lOl
]
;
llOOOlOl\
OO
->
lO\
l\
lOlllO\
l
=
4
;
llOO\
OlOlOO
->
ll\
Olll\
l\
O\
lO
[
0
]
.
llOlll\
lOOO\

=
3
;
llO\
OOl\
OlOO
->
ll\
O\
llllOl\
O
[
1
]
.
ll\
OllllOO\
O
=
0
;
llO\
OOlOlOO\

->
ll\
Ol\
l\
llOl\
O\

[
2
]
.
llOll\
llOOO
=
4
;
llO\
O\
O\
lO\
lOO
->
ll\
Olll\
lOlO
[
3
]
.
llOllllOOO
=
7
;
lOOOO\
OOlOl\
Ol
+=
llllllO\
O\
lOl
(
llOOOlOlOO
->
lO\
llO\
lllOl
)
;
TA\
_ASS\
ERT
(
lOOO\
O\
OOlOl\
O\
l\

==
lOl\
OOlOl\
lO
->
lOllO\
Ol\
llO
.
lO\
OOlllOOl
(
)
)
;
lOl\
OOlOllO\

->
llllll\
OOOOO
.
Init\
ia\
lise
(
0
,
12
)
;
int
llO\
llO\
O\
OO\
l\

;
for
(
llO\
llOOOO\
l
=
0
;
llOllOOOOl\

<
lOl\
OO\
lOl\
lO
->
lO\
l\
lO\
Ol\
ll\
l
.
lOO\
Ol\
llOO\
l\

(
)
;
ll\
Oll\
OOO\
O\
l
++
)
{
Polygon
&
lOll\
O\
O\
OlOl
=
*
(
Pol\
ygo\
n
*
)
&
lOlO\
OlOllO
->
lO\
llOOlllO
[
lOlO\
OlOl\
l\
O
->
lO\
l\
l\
OO\
llll
[
llOll\
OOOOl
]
]
;
TA\
_ASSER\
T\

(
lOllOO\
OlOl
.
lO\
ll\
OlllOl
<=
lOlll\
OOlO\
l\
l\

)
;
for
(
in\
t
lOl\
llOlOOl
=
0
;
lOl\
llOlOOl
<
lOll\
OOO\
lOl\

.
lOllOlllOl
;
lOlllOlOOl
++
)
{
lO\
llOO\
OlOl
.
llOllll\
OlO
[
lOl\
llOl\
O\
Ol
]
.
llOllllOO\
l\

=
-
1
;
}
}
for
(
ll\
O\
ll\
O\
OOOl
=
0
;
ll\
Ol\
lOOOOl
<
lOlO\
OlOllO
->
lOll\
OO\
llll
.
lOOOl\
llOO\
l
(
)
;
llO\
l\
l\
OO\
OO\
l
++
)
{
Poly\
gon
&
lOllOOO\
lOl
=
*
(
Polyg\
on
*
)
&
lOlOOlOllO\

->
lOl\
lOOl\
l\
lO
[
lOlO\
OlOllO
->
lO\
llOOl\
lll
[
ll\
OllOOOOl\

]
]
;
TA\
_AS\
SERT\

(
lOllOO\
OlOl\

.
lO\
llO\
lllOl
<=
lOlllOOlOll\

)
;
fo\
r
(
int
lOl\
llOlOOl\

=
0
;
lO\
ll\
lOlO\
Ol
<
lOllOOO\
lOl
.
lOllO\
l\
l\
lOl
;
lOlllOl\
O\
Ol\

++
)
{
int
lOO\
OOOO\
l\
O\
l\
lO
=
lOl\
lOOOl\
Ol
.
llOllllOl\
O
[
lOl\
l\
lOlOOl
]
.
llOllllOOO
;
if
(
lOllOOOl\
Ol
.
llO\
l\
ll\
lOlO\

[
lOlllO\
l\
OOl
]
.
llOllllOOl
!=
-
1
)
con\
tin\
u\
e\

;
int
lOO\
O\
OOOl\
O\
lll
=
(
lO\
l\
llOlO\
Ol
+
1
<
lOl\
lOOO\
lOl\

.
lOl\
lOlllO\
l
)
?
lO\
l\
lOO\
OlOl\

.
llOllll\
OlO
[
lOlllOlO\
Ol\

+
1
]
.
ll\
Ollll\
O\
O\
O
:
lOllOOOlOl\

.
llOllllO\
lO\

[
0
]
.
ll\
Ollll\
OOO\

;
fo\
r
(
in\
t
lO\
O\
OOOOl\
lO\
OO
=
llOllOOOOl
+
1
;
lO\
OOOOO\
ll\
O\
OO
<
lOl\
OOlOllO
->
lOl\
lOOlll\
l
.
lOOO\
lllOO\
l
(
)
;
lOOO\
OOOllOOO
++
)
{
Polyg\
on
&
lOOOOO\
OllOOl
=
*
(
Polygon\

*
)
&
lOlOOlOl\
lO\

->
lOl\
l\
OOl\
l\
lO
[
lOlOOl\
Oll\
O
->
lOllO\
Oll\
l\
l
[
lOOOO\
O\
OllOO\
O
]
]
;
for
(
int\

lOO\
OOOOllO\
lO
=
0
;
lOO\
OOOO\
llOlO
<
lOOO\
OOO\
l\
lO\
Ol
.
lO\
l\
l\
Oll\
lOl
;
lO\
OO\
OOOll\
OlO
++
)
{
int\

lOOOOOOll\
Oll\

=
lOOO\
O\
OOl\
l\
O\
O\
l
.
llO\
llllOlO\

[
lOOOOO\
Ol\
lO\
lO\

]
.
llOllll\
OOO\

;
in\
t\

lO\
OOOOOlll\
OO
=
(
lO\
O\
OOOOl\
lOlO
+
1
<
lO\
OOOOOllOO\
l
.
lO\
llOl\
llOl
)
?
lO\
OO\
OO\
O\
llOO\
l\

.
llOlll\
l\
OlO
[
lOOOOO\
OllO\
lO\

+
1
]
.
llO\
llllO\
OO
:
lOOOOOO\
llO\
Ol
.
ll\
OllllOl\
O\

[
0
]
.
ll\
Olll\
l\
OO\
O
;
if
(
(
lOOOOOOl\
Oll\
O
==
lO\
O\
O\
O\
OOl\
lOll
&&
lO\
O\
OOOO\
lOlll
==
lOOOOOOlllOO\

)
||
(
lOOOOOO\
lOllO
==
lO\
O\
OOO\
O\
lllOO
&&
lO\
OOO\
O\
O\
lOl\
ll\

==
lOOOO\
OOll\
Oll
)
)
{
lOllOO\
O\
lOl
.
llOllll\
OlO
[
lOlllOl\
OOl
]
.
llOlll\
lOOl
=
lOOO\
OOO\
l\
lOO\
O
;
lOOOO\
OOll\
OO\
l
.
llOll\
llOl\
O
[
lOO\
OOOO\
llOl\
O\

]
.
ll\
O\
lll\
lO\
Ol\

=
ll\
Oll\
OO\
OOl\

;
lllll\
Ol\
lOO\
l
&
ll\
Ol\
O\
lOOl\
O
=
lOlOOlO\
llO
->
llllllOOO\
O\
O
.
lO\
OO\
lllOOO\

(
)
;
llOlO\
lOOlO
.
ll\
l\
llOll\
O\
lO
=
lOOOOOOlOll\
O
;
llOlO\
lOOlO
.
llll\
lO\
ll\
Ol\
l
=
lO\
OOOOOlO\
l\
l\
l
;
llOlOlOOl\
O
.
llOlOll\
OlO\

=
llO\
ll\
OOOOl\

;
llOlOlOOlO
.
ll\
OlOl\
l\
Oll
=
lOOOOOOllOO\
O
;
br\
eak
;
}
}
}
TA_A\
SSERT\

(
lOllOOOl\
Ol\

.
ll\
OllllO\
l\
O
[
lOlllOlOOl
]
.
llOll\
l\
lO\
Ol
!=
-
1
)
;
}
}
TA_ASSERT
(
lOlO\
OlO\
l\
lO
->
llllllOOO\
O\
O
.
lOOO\
ll\
lOOl\

(
)
==
lOlOOlOll\
O
->
lllll\
lOOOOO
.
lO\
Ol\
lll\
Oll
(
)
)
;
for
(
llOll\
OOOOl
=
0
;
llOllO\
OOOl
<
lOlOO\
lO\
ll\
O
->
lO\
llO\
Ollll
.
lO\
OOl\
l\
lOOl
(
)
;
llOl\
lOO\
OO\
l
++
)
{
Po\
l\
ygon
&
lO\
llOO\
Ol\
O\
l
=
*
(
Po\
l\
ygon
*
)
&
lOlOOlO\
l\
lO
->
lOllOOll\
lO
[
lO\
lOO\
lOl\
lO\

->
lOl\
l\
OO\
llll
[
llOl\
l\
OOOOl\

]
]
;
TA_AS\
SERT
(
lOll\
OOOlO\
l
.
lO\
ll\
OlllOl
<=
lOlllOO\
l\
Oll\

)
;
Vec3\

lOOOlO\
O\
OOO
;
lO\
OOl\
O\
OO\
OO\

.
Cl\
ear
(
)
;
int
lOlll\
O\
lO\
Ol
;
for
(
lOlllOl\
OOl\

=
1
;
lO\
lllO\
lOOl\

<
lO\
llO\
OOl\
Ol
.
lOll\
O\
lllOl
;
lOl\
ll\
O\
l\
OOl\

++
)
{
int\

llOOl\
lO\
l\
O\
l
=
lO\
lll\
Ol\
O\
O\
l\

;
Ve\
c3
&
llll\
lllll
=
lOlOOlOllO
->
lll\
llO\
ll\
lll
[
lOllOOO\
lOl
.
llOlll\
l\
OlO
[
llOOllOlOl\

]
.
llOllllOO\
O
]
;
int
llOOll\
O\
llO
=
(
lOl\
llOlOOl\

+
1
<
lOllO\
O\
OlOl\

.
lOllO\
lllOl
)
?
lOlllOlO\
Ol
+
1
:
0
;
Vec3
&
lOOOOO\
OO\
OO\

=
lOlOOlOllO\

->
lll\
l\
lOl\
llll
[
lOllOOOlOl\

.
llOl\
lllOl\
O
[
llOO\
llO\
l\
lO
]
.
llOll\
llOO\
O\

]
;
Vec3\

&
llll\
OO\
lOO\
O
=
lOl\
OOlOl\
lO
->
ll\
ll\
l\
O\
ll\
lll
[
lO\
l\
lOOOlOl
.
ll\
O\
llllO\
lO
[
0
]
.
llOl\
lllOOO
]
;
Vec3\

lOlllOl\
Olll
=
lOOOlO\
O\
O\
OO
.
Cros\
s
(
lOOOOOOOOO
-
lll\
llll\
ll
)
;
lOO\
OlO\
OOOO
+=
(
llllll\
lll\

-
llllOOlOOO
)
.
Cr\
oss\

(
lOOOOOOO\
OO
-
llll\
OOlO\
O\
O
)
;
}
float\

lOl\
l\
llOlOl\

=
lOOO\
l\
OO\
OOO\

.
GetM\
a\
gnit\
ude
(
)
;
TA_ASS\
ERT
(
lO\
llll\
OlOl
>
0.0f
)
;
lO\
O\
Ol\
OO\
OO\
O
/=
lOllllOlOl\

;
lO\
llOO\
OlOl\

.
lOOOl\
OOOOO
=
lOOOlOOOO\
O
;
lO\
llO\
O\
OlOl
.
lO\
l\
Ol\
llOOl
=
lOllO\
OOlOl
.
lOOOlOO\
O\
O\
O\

.
Do\
t
(
lOlO\
Ol\
OllO\

->
ll\
l\
l\
l\
Ollll\
l\

[
lOll\
O\
O\
OlOl\

.
ll\
OllllOlO
[
0
]
.
llOllllO\
OO
]
)
;
for
(
lOl\
llOlO\
Ol
=
0
;
lOlllOlOOl
<
lOl\
lO\
OO\
lOl
.
lOl\
lOl\
ll\
Ol\

;
lO\
ll\
lOlOOl
++
)
{
int
llO\
O\
ll\
OlO\
l
=
lO\
lllOl\
OOl
;
Ve\
c\
3
&
ll\
l\
ll\
llll
=
lOlOOl\
OllO\

->
llll\
lOl\
l\
lll\

[
lO\
l\
l\
OOO\
lO\
l
.
llO\
llllOlO
[
ll\
O\
Ol\
lO\
l\
Ol\

]
.
llOllllO\
OO\

]
;
in\
t\

llOOllOllO\

=
(
lOlllOlO\
O\
l
+
1
<
lOllOOO\
lO\
l\

.
lOllO\
l\
l\
l\
O\
l
)
?
lOlllOl\
O\
Ol
+
1
:
0
;
Vec3
&
lOOO\
OOOO\
O\
O
=
lO\
l\
OOlO\
l\
l\
O
->
lll\
ll\
Oll\
l\
ll
[
lOllOOOlOl
.
llOllllOlO
[
llO\
OllOl\
lO
]
.
llOl\
lllOO\
O
]
;
Vec\
3
lOl\
l\
l\
OlOlll
=
lOOOlOOOOO
.
Cro\
ss
(
lO\
OOOOOOO\
O
-
lllllll\
ll
)
;
lOllllO\
lOl
=
lOlllO\
lO\
lll
.
Ge\
t\
Mag\
nitude\

(
)
;
TA_ASS\
ER\
T
(
lOlll\
lOl\
Ol
>
0.0f
)
;
lOlllOlOl\
ll
/=
lO\
lll\
lO\
lOl
;
lOllOOOlOl\

.
llOl\
lllOlO
[
lOl\
l\
lOl\
O\
O\
l
]
.
lO\
lll\
OlOlll
=
lO\
lllOlOlll
;
}
}
lll\
ll\
lOlll\
O
(
)
;
In\
i\
ti\
a\
l\
iseComm\
on\

(
)
;
}
vo\
id
Co\
ll\
isionOb\
jectConvex
::
llll\
l\
lOlllO
(
)
{
TA\
_ASSERT
(
lOl\
OOl\
OllO\

)
;
lOlOOlOl\
l\
O
->
ll\
lOllOO\
Ol\
O
.
Clear
(
)
;
if
(
lOlOO\
lOllO
->
lOlOllOO\
ll\

&
Data\

::
ll\
lllOllllO
)
{
if
(
lOlOOlO\
llO
->
lllllO\
lllll\

.
lOOO\
lllOOl
(
)
)
{
lOlOOlOllO
->
lO\
OO\
OOOl\
ll\

.
In\
i\
t\
ialise
(
lO\
lOOlOllO
->
ll\
l\
l\
l\
O\
lllll
[
0
]
,
k_v3Ze\
ro\

)
;
for\

(
int\

lO\
l\
l\
lOlOOl
=
1
;
lO\
l\
llO\
l\
OO\
l
<
lO\
lOOlOllO\

->
lllll\
Olllll
.
lOOOlll\
OOl
(
)
;
lO\
lll\
OlO\
Ol\

++
)
lOlOOlOl\
lO
->
lO\
OOOOOlll\

.
Expan\
d\
To\
F\
i\
t
(
lOlOO\
lOllO
->
lll\
l\
lO\
ll\
lll
[
lO\
l\
ll\
O\
lOO\
l
]
)
;
lO\
l\
OOlOl\
lO\

->
lllO\
llOOOlO
=
lOlOOlOllO\

->
lO\
OOOOOlll\

.
v3Cen\
ter\

;
}
}
else\

{
if
(
lO\
l\
OO\
lOllO
->
lll\
l\
lOlllll\

.
lOO\
Oll\
l\
OOl\

(
)
)
{
for
(
int
lOl\
ll\
O\
l\
OOl
=
0
;
lOlllOl\
OOl
<
lO\
lO\
Ol\
OllO
->
llll\
lOl\
llll\

.
lOOOlllOOl
(
)
;
lOll\
lOlO\
O\
l\

++
)
lOl\
O\
OlOll\
O\

->
lllOllOOOlO
+=
lOl\
OOlOllO
->
lllll\
Oll\
l\
ll
[
lOll\
lO\
lOOl
]
;
lO\
lOO\
lOllO
->
lllOl\
lOOOlO
/=
(
floa\
t
)
lOlO\
O\
lOll\
O
->
ll\
l\
llOlllll
.
lOO\
Olll\
OO\
l\

(
)
;
}
}
}
voi\
d\

Colli\
si\
o\
nObject\
Conv\
e\
x
::
lllll\
lOllOO
(
)
{
fo\
r
(
int
ll\
O\
l\
lOO\
O\
Ol\

=
0
;
llO\
l\
lOOO\
Ol
<
lOlOO\
lO\
l\
lO\

->
lOl\
lOOllll
.
lOOOlllOO\
l
(
)
;
llO\
llOOOOl
++
)
{
Po\
lyg\
on
&
lOllOO\
OlO\
l
=
ll\
l\
lllOOOl\
l
(
th\
is
,
ll\
OllO\
O\
O\
Ol\

)
;
TA_\
ASS\
ERT
(
lO\
llOOO\
lO\
l
.
lOl\
l\
O\
lll\
Ol
>=
3
)
;
int
lllllOllOlO\

=
lOllOOOlOl
.
ll\
O\
ll\
l\
lOlO
[
0
]
.
llOll\
llO\
OO
;
Vec3\

lO\
OOlO\
OOO\
O
;
lOOO\
l\
OOOO\
O
.
Cle\
ar
(
)
;
in\
t\

lllll\
lOllO\
l\

;
for
(
ll\
llllOl\
lO\
l
=
1
;
llll\
l\
l\
Oll\
Ol
<
lOl\
l\
OOOlOl
.
lOllO\
lllOl\

;
llll\
l\
lOl\
lOl
++
)
{
in\
t
llll\
lO\
llOl\
l
=
lOll\
OOO\
lO\
l
.
llOllllOl\
O
[
llllll\
Oll\
Ol
]
.
llOl\
ll\
l\
OO\
O
;
int
lO\
O\
OOO\
Ol\
llOl
=
lO\
l\
lOOOlOl
.
llOllllO\
lO
[
ll\
lllOO\
lOlO
(
lOllOOOlOl
,
lllll\
lOllOl
)
]
.
llO\
l\
lll\
OOO
;
lO\
OO\
lOO\
OOO
+=
(
lO\
lOO\
lOllO
->
lllllOlllll\

[
lll\
llOllOl\
l\

]
-
lOlOO\
lOllO
->
lllllOlllll
[
llll\
lOllOlO
]
)
.
Cr\
os\
s\

(
lO\
lO\
OlOllO\

->
lllllOll\
lll\

[
lOOO\
OOOl\
llOl
]
-
lOlOOlOllO
->
lllll\
Ol\
l\
lll
[
lll\
ll\
Oll\
Ol\
O
]
)
;
}
TA\
_AS\
SERT
(
lOOOl\
OO\
OOO
.
GetMa\
g\
nitu\
d\
e
(
)
>
0.0f
)
;
lOO\
OlOOOOO
.
Nor\
ma\
lise
(
)
;
lOllO\
OO\
l\
Ol
.
lO\
OOlOOOOO
=
lOO\
OlO\
OO\
OO
;
lOllOOOlO\
l
.
lOl\
O\
lllOOl
=
lOO\
OlOOOO\
O
.
Dot\

(
lOlOOlO\
ll\
O\

->
lllllOl\
lll\
l
[
llll\
lOllO\
l\
O\

]
)
;
for\

(
llll\
llOllOl
=
0
;
ll\
llll\
OllOl
<
lO\
l\
lOOO\
lOl\

.
lOllOlll\
O\
l\

;
lll\
lllO\
llO\
l
++
)
{
int
lllllOllOll
=
lOllOOOl\
O\
l
.
llOllllOl\
O
[
lll\
l\
llOllOl
]
.
llOll\
ll\
OOO
;
int
lOOOO\
O\
Oll\
lOl
=
lOllO\
OOlOl\

.
llOl\
l\
llOlO
[
ll\
lllO\
OlOlO
(
lO\
llOOO\
lO\
l
,
lllll\
lO\
llOl
)
]
.
llOll\
l\
lO\
OO\

;
Vec3
lO\
lll\
Ol\
O\
l\
ll
=
lOOOl\
O\
OOO\
O
.
Cross
(
lOlO\
OlOllO\

->
lllllOlllll\

[
lOOOOOOl\
llOl
]
-
lOl\
OO\
l\
Ol\
lO
->
lllllOl\
l\
ll\
l
[
lllll\
Ol\
lO\
ll
]
)
;
TA\
_ASSER\
T
(
lO\
lll\
O\
lOl\
l\
l
.
Get\
Mag\
ni\
tude
(
)
>
0.0f
)
;
lOlllOlOll\
l
.
Nor\
m\
alise\

(
)
;
lOll\
OOOlO\
l
.
ll\
O\
lll\
lOl\
O
[
ll\
l\
lllOl\
l\
O\
l
]
.
lO\
l\
llOl\
O\
l\
ll
=
lO\
lll\
OlOlll
;
}
}
}
inl\
i\
n\
e
void
CollisionObj\
ect\
Convex
::
lOOO\
OO\
Ol\
ll\
l\
O\

(
int\

lOOOOOOll\
l\
ll
,
co\
nst
Vec3
*
lOOOOO\
OO\
O\
lll\

,
int
&
lO\
OOOOlO\
OOO\
O
,
int
&
lOOOOO\
lOO\
OO\
l\

,
floa\
t\

&
lOOOOO\
l\
OO\
OlO
)
con\
st
{
TA_AS\
SE\
RT
(
lOl\
OOlOl\
lO
)
;
int
llO\
ll\
OOOO\
l\

;
for\

(
llOllO\
O\
OOl
=
0
;
ll\
O\
llO\
O\
O\
Ol\

<
lO\
l\
OO\
lOllO\

->
lOllOOlll\
l
.
lOO\
Olll\
OOl
(
)
;
llOl\
lO\
O\
OO\
l
++
)
{
Polygon\

&
lO\
l\
lOOOlO\
l\

=
llll\
llOOOll
(
this
,
llOllOOO\
Ol
)
;
flo\
a\
t
lOOOO\
OlOOOl\
l
=
k_fMaxFloat\

;
int
lO\
OOOOlOOlOO
=
-
1
;
for\

(
in\
t
lO\
lll\
O\
lOOl
=
0
;
lOlllOlO\
Ol
<
lOOOOOOlll\
ll
;
lO\
lllO\
l\
OOl\

++
)
{
fl\
o\
at
lOlOlllO\
Ol
=
lOllO\
OO\
lOl
.
lOOO\
lOOO\
OO
.
Dot
(
lOOO\
OOOOO\
l\
ll
[
lOlllOlO\
Ol
]
)
-
lO\
llOOOlOl
.
lO\
lOl\
llOOl
;
if
(
lOOOO\
Ol\
OOOll\

>
lOlO\
lll\
OOl
)
{
lOOOOOl\
OO\
Oll
=
lOl\
O\
ll\
l\
OOl
;
lOOOOOlO\
OlOO\

=
lO\
l\
llOlO\
Ol
;
}
}
TA_\
ASSERT
(
lOOOO\
OlOOlOO
!=
-
1
)
;
if
(
lOOO\
O\
O\
lOO\
OlO
<
lOOOOOlO\
O\
O\
ll
)
{
lOOOOOl\
OOO\
lO\

=
lOO\
O\
OOlOOOll\

;
lOO\
OOOlO\
OOOO
=
llO\
l\
l\
OOOO\
l
;
lOO\
O\
OOlO\
OO\
O\
l\

=
lOO\
OOOl\
OOlO\
O\

;
}
}
TA_\
ASSER\
T
(
lO\
O\
OOOl\
O\
OOO\
O
!=
-
1
)
;
TA_AS\
SER\
T\

(
lO\
OOO\
OlOO\
OOl
!=
-
1
)
;
}
inline
voi\
d\

Co\
ll\
i\
si\
onObjectCon\
ve\
x
::
lOOOO\
OlOO\
lOl
(
in\
t
lOO\
OOOOl\
lll\
l
,
cons\
t\

Vec\
3
*
lO\
OOOOlOOllO
,
const
Vec3\

*
lO\
O\
OOOlO\
O\
ll\
l
,
Pol\
ygon
&
lOllOOO\
lOl
,
lOll\
Oll\
l\
OOO
*
lOlllOOOOll
,
con\
s\
t
MFr\
ame
&
lOOOOOOO\
Ol
,
fl\
oat
lOOO\
OOlOlOOO
)
co\
nst
{
for
(
int
llll\
llOlOOl
=
0
;
llllll\
Ol\
O\
Ol
<
lOOO\
OOOl\
l\
ll\
l
;
llllllOlO\
O\
l\

++
)
{
co\
ns\
t
Vec3
&
llllll\
l\
l\
l
=
lOOOOO\
lOOll\
O
[
llllllOlOOl
]
;
const
Vec3
&
lOOOOOO\
O\
O\
O\

=
lO\
O\
OOOl\
OOlll
[
llllll\
Ol\
O\
Ol\

]
;
float\

lOlOllOlO\
O
=
lOllOOOl\
Ol
.
lO\
OOlOO\
OO\
O
.
Dot
(
lll\
llllll
)
-
lOllOO\
O\
lOl
.
lOlOlll\
O\
Ol
;
fl\
oat
lOlOl\
lOlO\
l
=
lOllOOOl\
Ol
.
lOOOl\
OOOOO
.
Do\
t
(
lOO\
OOOOOOO
)
-
lO\
llOO\
Ol\
Ol
.
lOlOlllO\
Ol
;
fl\
oat\

lllOlll\
llO
;
float
lOl\
lOOlOOll
;
Vec\
3
llOO\
llll\
l\
O
;
if
(
lOlOl\
lOl\
O\
O
>
0.0f
)
{
if
(
lOlOll\
OlOl
>
0.0f
||
!
lO\
lllO\
OO\
Ol\
l\

->
lO\
llO\
lllOll
)
continue
;
TA_\
ASSER\
T
(
(
lOlOl\
l\
OlO\
O
-
lO\
lOllOlOl
)
!=
0
)
;
lll\
Oll\
lllO
=
lOlO\
llOl\
OO
/
(
lOlOllO\
l\
OO
-
lOlO\
ll\
O\
l\
Ol
)
;
lOll\
O\
OlOO\
l\
l
=
0
;
ll\
O\
Oll\
lllO
=
ll\
l\
llllll\

+
lll\
Ol\
llll\
O
*
(
lOOOOOOOOO
-
ll\
llllll\
l
)
;
}
else\

{
lll\
OlllllO
=
0.0f
;
lOllOOl\
OOll\

=
-
lOlOllOlOO
;
ll\
OO\
llll\
lO
=
lllllll\
ll
;
}
int\

llOlOlOllO
;
for
(
llOlOlOl\
lO
=
0
;
llOlOlOl\
lO
<
lOl\
lO\
OO\
lO\
l
.
lOllOlllOl
;
llOl\
OlOllO\

++
)
{
cons\
t
Vec3
&
lllllll\
ll\

=
lO\
lOO\
l\
Ol\
lO
->
ll\
l\
l\
lOllll\
l\

[
lOll\
O\
OOlOl
.
llOllllO\
l\
O
[
llOlOlOll\
O
]
.
llO\
llllOOO
]
;
co\
ns\
t
Vec\
3
&
lOO\
OlOOOOO
=
lOllOOOlOl
.
ll\
Ollll\
OlO
[
llOl\
Ol\
OllO\

]
.
lOl\
llO\
lOlll
;
if\

(
lOOOlO\
OOOO
.
Dot
(
ll\
OOl\
llllO
-
lllllllll\

)
<
0.0f
)
break\

;
}
if
(
llO\
l\
Ol\
O\
llO
!=
lO\
llOOOl\
Ol
.
lOl\
lO\
lllOl
)
contin\
ue
;
Co\
lli\
sion
lOll\
OllOlll\

;
lOllO\
ll\
O\
l\
ll
.
Initi\
alise
(
Co\
lli\
sion
::
lOllOlO\
OOOO\

,
lllOl\
ll\
llO
,
lOll\
OOl\
OOll
,
llOOllll\
l\
O
*
lOOOOOO\
OOl
,
(
lO\
llOO\
O\
lOl\

.
lOOO\
l\
OO\
OOO
*
lOOOOOlOlOOO
)
*
lOOO\
O\
OOOOl
.
m33\
Rotati\
o\
n
)
;
lllO\
llllOOO\

(
lOllO\
llOl\
ll
,
lOl\
llO\
O\
OOll
)
;
}
}
flo\
at
Col\
lisio\
n\
Object\
Co\
nvex\

::
lO\
OOO\
OlOlOOl
(
const
Vec\
3
*
lOOOOOlOlOl\
O
,
const
Co\
l\
lision\
Obje\
ctConve\
x
&
lllOllOlll\
l
,
int\

&
lOOO\
O\
Ol\
OlOl\
l
,
int\

&
lOOOOOlOll\
OO\

)
const\

{
cons\
t
Colli\
sionObjec\
tC\
on\
v\
e\
x
&
lllO\
l\
lOll\
lO
=
*
this
;
float\

lOOOO\
Ol\
OllOl\

=
k_fMaxFlo\
at
;
for
(
;
;
)
{
bool
lO\
OOOOlO\
l\
llO
=
true\

;
{
const
Vec\
3\

&
lOO\
OOOlOl\
l\
ll
=
lOOOOOlO\
lOlO\

[
lO\
OOOOlO\
llO\
O
]
;
con\
st\

Co\
llis\
ionOb\
je\
ctCo\
nv\
e\
x
::
Polyg\
on
&
lOllOlOOlO
=
ll\
l\
lllOOOll
(
&
lllOllOlllO
,
lO\
OO\
O\
Ol\
Ol\
O\
ll
)
;
lOOOOOlOllOl
=
lOllOl\
OO\
l\
O
.
lOO\
OlO\
OOO\
O
.
Dot\

(
lOOOOOlOllll
)
-
lOllO\
lOO\
lO\

.
lOl\
Olll\
OOl
;
for
(
int
lOOOllOOO\
l
=
0
;
lOOOll\
O\
O\
Ol
<
lOllOlOOlO
.
lOllO\
lllO\
l\

;
lOOOll\
O\
O\
O\
l\

++
)
{
cons\
t
Coll\
is\
i\
o\
n\
ObjectConvex
::
Polygon
&
lOOOOO\
llOOOO
=
llllll\
OOOll
(
&
lllO\
llOlllO
,
lOllOlOOl\
O\

.
llOl\
lllOl\
O
[
lOOOllOO\
Ol\

]
.
ll\
Olll\
lOO\
l
)
;
float\

lO\
lO\
l\
llO\
Ol
=
lOOO\
O\
OllO\
OOO\

.
lO\
O\
OlOOO\
OO\

.
Do\
t
(
lOOOOOlOllll\

)
-
lOOO\
O\
Oll\
OOOO
.
lOlOlllOO\
l
;
if
(
lOOOOOlOl\
lO\
l
<
lOlO\
lllO\
Ol
)
{
lOOOOOlOllO\
l
=
lOlO\
lllO\
Ol
;
lOO\
OOOlOl\
Ol\
l\

=
lOO\
Oll\
O\
OOl
;
lOOO\
OOlO\
lll\
O\

=
fal\
se
;
}
}
}
{
con\
st
Collis\
ionO\
bje\
ctConv\
ex\

::
Polygon
&
lOllO\
lOOlO\

=
llll\
l\
lO\
OOl\
l
(
&
ll\
l\
OllO\
l\
ll\
O
,
lOOOOOlOlOll
)
;
con\
st
Vec3
&
lOOOOO\
lO\
lll\
l\

=
lOOOOOl\
O\
lOlO\

[
lOOOOOl\
Oll\
OO
]
;
const
Co\
llis\
ionObjectCo\
nvex
::
Vertex
&
lOOOO\
OllOO\
Ol
=
ll\
llll\
OO\
l\
OO
(
&
lllO\
l\
lOlllO
,
lOOO\
O\
OlOllOO
)
;
lOO\
OOOlOll\
O\
l
=
lOll\
OlOO\
lO\

.
lOOOl\
OOO\
OO
.
Do\
t
(
lOOOOOlOllll
)
-
lOll\
O\
lOOlO
.
lOlOl\
l\
lOOl\

;
for
(
int
lOO\
O\
llOOOl\

=
0
;
lOOO\
ll\
OOOl
<
lO\
O\
OOOllOOOl
.
lllllOl\
ll\
OO
;
lOOOllOOOl
++
)
{
co\
n\
st
Ve\
c3
&
lOOOO\
OllOOlO\

=
lOOOOOlOlOlO
[
lOOOO\
OllOOOl
.
lllllOlllOl
[
lOOOl\
lOOO\
l\

]
]
;
fl\
oa\
t
lOlO\
lllOOl\

=
lOl\
lOlOOlO
.
lOOOl\
OO\
OOO
.
Do\
t
(
lO\
O\
O\
OOllOOlO\

)
-
lOllOlOOlO
.
lO\
lOll\
lOO\
l
;
if
(
lO\
OOOOlOllOl
>
lOlO\
ll\
lOOl
)
{
lOOOOOlOl\
lOl
=
lO\
lOlllOOl\

;
lOOOOO\
l\
OllOO
=
lOO\
OOOllO\
OOl
.
ll\
lllOll\
lOl
[
lOOO\
ll\
OOO\
l
]
;
}
}
}
if
(
lOOOO\
OlO\
l\
llO
)
break
;
}
retu\
rn
lOOOO\
Ol\
O\
llOl\

;
}
int
Collisi\
on\
Obj\
e\
ct\
Conv\
ex
::
lOOO\
OOl\
lOOl\
l
(
int
lOO\
OOOl\
OO\
OOl\

,
const
Vec3
&
lOOOOOllO\
lOO
)
const
{
const
Vec3
&
lOO\
OO\
O\
llOl\
Ol\

=
lOlOO\
lO\
llO\

->
ll\
lllOlll\
l\
l\

[
lO\
OO\
OOl\
O\
OOOl\

]
;
co\
nst
Collisi\
onOb\
ject\
Con\
vex
::
Vertex
&
lO\
O\
OOO\
OOllOO
=
llllllO\
OlOO
(
thi\
s
,
lOO\
OOO\
lOOOOl
)
;
float
lOOOOOlOll\
O\
l
=
lOOOOOllOl\
OO
.
Do\
t
(
lOO\
OO\
Ol\
lOlOl
)
;
for
(
;
;
)
{
bo\
o\
l
lOOOO\
OllOl\
lO\

=
fal\
se
;
for
(
int
lO\
O\
Ol\
lOOOl
=
0
;
lOOO\
llOOOl\

<
lOOO\
OOO\
O\
llOO\

.
lll\
l\
lO\
lll\
OO\

;
lOOO\
llOOOl
++
)
{
const
Ve\
c3
&
lOOO\
OOllOll\
l
=
lOlOOl\
OllO
->
lllllOllll\
l
[
lOO\
OOO\
O\
Oll\
OO\

.
llll\
lOl\
llOl
[
lOOOl\
l\
O\
OOl
]
]
;
float\

lO\
lOlll\
OOl
=
lOOO\
OOllOlOO\

.
Do\
t\

(
lOOOOOllO\
lll
)
;
if\

(
lOOOO\
O\
lOllOl
>
lO\
l\
Oll\
l\
OOl\

+
Fab\
s
(
lOlOlllOOl
)
*
0.001f
)
{
lO\
OOOOlO\
llOl\

=
lO\
lOlll\
O\
Ol
;
lOO\
O\
O\
OlO\
OOO\
l\

=
lOOOOOOOl\
lOO\

.
lllllOlllOl\

[
lOOOl\
l\
OO\
Ol\

]
;
lO\
OO\
OOllOllO
=
true
;
}
}
if
(
!
lO\
OOOO\
l\
lOl\
lO\

)
return
lOOO\
O\
OlOO\
OO\
l
;
}
}
in\
t\

Coll\
i\
sionOb\
ject\
Convex
::
lO\
OO\
O\
Olll\
OOO
(
const
Vec3
&
lOO\
OOOl\
l\
Ol\
OO
)
const
{
if
(
lO\
lO\
O\
lOl\
l\
O\

->
lOlOllOOl\
l
&
Da\
t\
a\

::
lllllOll\
llO
)
{
Vec3
lOl\
O\
OOOO\
lOl
=
lOl\
OOlO\
llO\

->
lO\
O\
OOOOlll\

.
v3Center\

-
lOOOO\
O\
llO\
l\
OO
;
u32
lOOO\
l\
OOl\
ll
=
(
(
(
u32\

&
)
lOlO\
OO\
OO\
lOl
.
x
)
>>
31
)
|
(
(
(
(
u32\

&
)
lOl\
O\
OO\
OOlOl
.
y
)
>>
30
)
&
0x2
)
|
(
(
(
(
u3\
2
&
)
lOlOOOOOlOl
.
z
)
>>
29
)
&
0x4
)
;
TA_A\
S\
SE\
RT\

(
lOOOlOO\
lll
>=
0
)
;
TA_AS\
SER\
T
(
lOO\
OlOOll\
l
<
8
)
;
st\
atic\

const
in\
t
lOOOO\
OlllOOl\

[
8
]
=
{
0
,
1
,
4
,
5
,
3
,
2
,
7
,
6
}
;
re\
t\
urn\

(
lOOOOOll\
lO\
Ol
[
lO\
OOlO\
Oll\
l
]
)
;
}
int
lOOO\
O\
O\
lOOOOl\

=
-
1
;
flo\
a\
t\

lOO\
OOOlOl\
lO\
l
=
k_\
fM\
ax\
Float\

;
fo\
r
(
in\
t
lOlllO\
l\
OOl\

=
0
;
lO\
lllO\
lOO\
l
<
lOlO\
OlOllO\

->
lll\
llOllll\
l
.
lOOOlllO\
Ol\

(
)
;
lOlllOlOO\
l\

++
)
{
co\
ns\
t
Vec3
&
llO\
Ollll\
lO\

=
lOl\
O\
OlOllO
->
lll\
l\
l\
Oll\
l\
ll\

[
lOll\
l\
O\
lOO\
l\

]
;
floa\
t
lOlO\
l\
ll\
OOl
=
llOOll\
lll\
O\

.
Do\
t
(
lOOOOOllO\
lO\
O\

)
;
if\

(
lOOOOO\
lOllOl\

>
lOlOlllOOl
)
{
lO\
OOOO\
l\
Oll\
Ol
=
lOlO\
l\
l\
lO\
Ol
;
lOOOOOlOO\
OO\
l
=
lOlllOlOOl
;
}
}
TA_A\
SSERT
(
lOOOO\
Ol\
OOO\
Ol
!=
-
1
)
;
ret\
urn
lOO\
OOO\
lOOOOl
;
}
#ifndef DOXYGEN
struc\
t\

lOO\
OO\
OlllOlO\

{
Vec\
3
lO\
OOO\
Ol\
llOll
[
4
]
;
Vec3\

lOOOOO\
llllOO
[
4
]
;
Vec3\

lO\
O\
OOOllllOl
[
4
]
;
int\

lOOOOOlllllO
;
in\
t
lOO\
O\
OOllllll\

;
int
lO\
OOO\
lO\
OOOO\
O
;
floa\
t
lO\
l\
llO\
OlOl\

;
Vec3
lOl\
O\
OlOO\
lO\
O
;
int
llOll\
OOll\
l
;
int
lOlllOlOOO
;
}
;
lOlOl\
OlOOl
void
lOO\
OOl\
O\
OO\
OOl
(
lO\
OOOOll\
lOl\
O
&
lOOOOl\
O\
OO\
O\
lO
,
con\
st\

int
lOOOOlO\
OOOl\
l
,
const
int
lO\
OO\
OlOO\
OlO\
O
,
co\
nst
in\
t\

lOOOOl\
O\
OOl\
O\
l
,
const\

int\

lOOOOl\
O\
OO\
l\
lO
)
{
Vec3\

lOOOO\
llOllO
=
lOOOOlOO\
O\
OlO
.
lOOOOOllll\
O\
l\

[
lOO\
OOlOOOlOO
]
-
lO\
OOOlOOOOlO
.
lOOOOO\
llllO\
l
[
lOO\
OOlO\
OOOl\
l\

]
;
fl\
oa\
t
lO\
OOOlO\
OOlll
=
lO\
OOO\
l\
OO\
O\
O\
lO
.
lOOOOOl\
ll\
lO\
l
[
lOO\
OOlOO\
OOl\
l\

]
.
Do\
t
(
lOO\
OO\
llOl\
lO
)
;
float
lOO\
OOlO\
O\
l\
O\
O\
O\

=
lOOOO\
lOO\
OOlO\

.
lOOOOOllllO\
l
[
lOOOO\
lO\
OOl\
OO
]
.
Dot\

(
lOOOOl\
l\
OllO
)
;
fl\
oat
lOOOOlO\
OlOOl\

=
lO\
OOOlOOOO\
lO
.
lOOOO\
O\
ll\
llO\
l
[
lOO\
O\
OlO\
O\
OlOl
]
.
Dot
(
lOO\
OOllOllO
)
;
lOO\
OO\
llO\
ll\
O
=
lO\
O\
O\
OlOO\
OO\
lO
.
lOOOOOll\
llO\
l
[
lOOOO\
l\
OOO\
lOl
]
-
lO\
OOOlOOOOl\
O
.
lOOOOOllllOl
[
lOOOO\
lOOOOl\
l
]
;
flo\
at
lOO\
OOlOOlOlO
=
lOO\
OOlO\
OO\
Ol\
O
.
lOOO\
O\
OllllO\
l\

[
lO\
OOOlO\
OOOl\
l\

]
.
Dot
(
lOO\
OOllOllO
)
;
fl\
oat\

lO\
OOOl\
OOlOll
=
lOO\
O\
OlOO\
OOlO
.
lO\
O\
OO\
Olll\
lOl\

[
lO\
O\
OOlOOOlOO
]
.
Dot
(
lOOO\
O\
llOll\
O
)
;
float\

lOO\
OO\
OO\
Oll
=
lOO\
OOlOOO\
OlO
.
lO\
OO\
O\
OllllOl
[
lOOOOlOOO\
lO\
l
]
.
Do\
t
(
lOOOOllOllO
)
;
Vec3
lOOOO\
lOOllOO\

;
lO\
OO\
OlOOl\
lOO
.
x
=
(
lOOO\
OlO\
OlOOO\

*
lOO\
O\
O\
OOOll
-
lOOO\
Ol\
OOlOll\

*
lO\
O\
OOlOOlOOl
)
;
lOO\
OOlOOll\
OO
.
y
=
-
(
lO\
OO\
OlOO\
O\
l\
ll
*
lOOOOOOOll
-
lOOOO\
lOO\
lOlO
*
lOO\
OOl\
OO\
lOO\
l
)
;
lOO\
OOl\
OOll\
OO
.
z
=
(
lOO\
O\
Ol\
OO\
Ol\
ll
*
lO\
O\
OOl\
OO\
l\
Oll
-
lO\
OOOlOOlOlO
*
lO\
O\
OOl\
O\
OlOOO
)
;
{
co\
nst
fl\
oat
lOOOlOllOOl\

=
lOO\
OOlOOllOO
.
x
+
lOOOO\
lOOllOO
.
y
+
lOO\
O\
Ol\
OOllO\
O
.
z
;
if
(
lO\
OOlOl\
lOOl\

>
0.001f
)
{
Vec3
lOOOOlOOllO\
l
;
lO\
O\
OOlOOllO\
l
=
lO\
OOO\
lOOll\
OO
/
lOOOlO\
llOO\
l\

;
lOO\
O\
Ol\
OOllOl
=
lOOOO\
l\
O\
Ol\
l\
Ol
.
x
*
lO\
OOO\
lOOO\
O\
l\
O
.
lOO\
O\
OOll\
llOl
[
lOOOOlOO\
OOll\

]
+
lOOOOlO\
OllOl\

.
y
*
lOOOO\
l\
OOOOlO\

.
lO\
O\
OOOllll\
Ol
[
lO\
OO\
O\
l\
OOOlO\
O
]
+
lOOOOlO\
Ol\
l\
Ol
.
z
*
lOOO\
OlOOOOlO
.
lOOOO\
OllllOl
[
lOOOO\
l\
OOOlOl\

]
;
float
lOOO\
OOlllO
=
(
lOOO\
Ol\
O\
OOOlO
.
lOOOOO\
llllO\
l
[
lOOOOlOO\
O\
Oll
]
-
lOOOOlOO\
OOl\
O
.
lOOOOOl\
ll\
lOl
[
lO\
OOOlOO\
Ol\
OO
]
)
.
Dot\

(
lOOOOl\
O\
OllOl
)
;
TA_AS\
SERT\

(
Fa\
bs
(
lO\
OOO\
Oll\
lO
<
0.001f
)
)
;
lOOOOO\
lllO
=
(
lOO\
OO\
lOOOOlO\

.
lOOOOOlll\
l\
Ol
[
lOOOO\
lO\
OOlOO
]
-
lOOOOlOOOOlO
.
lOOOOOll\
llOl
[
lOOOO\
lOOOlO\
l
]
)
.
Dot
(
lOOOOlOOl\
lOl
)
;
TA_\
ASS\
E\
RT
(
Fabs\

(
lOO\
OOOll\
l\
O\

<
0.001f
)
)
;
lOO\
OOOlllO
=
(
lOOO\
Ol\
OOOOl\
O
.
lOOO\
OOllllOl
[
lOO\
O\
Ol\
O\
OOlOl\

]
-
lOO\
O\
Ol\
OOOOlO
.
lOO\
O\
OOllllOl\

[
lOOOOl\
OOOOll
]
)
.
Dot
(
lOOOOlOOllOl
)
;
TA_A\
SS\
ER\
T
(
Fabs
(
lO\
OO\
OOlllO\

<
0.001f
)
)
;
lOOOOOlllO
=
(
lOOOOlO\
OO\
O\
l\
O\

.
lOO\
OOOllll\
Ol
[
lOOOOlOOOlOl\

]
-
lOO\
OO\
lOO\
OOl\
O
.
lO\
OOOOl\
lllO\
l\

[
lOOOOl\
OOO\
Oll
]
)
.
Cross
(
lO\
OOOl\
OOOOlO
.
lOO\
OOOll\
llOl
[
lOOOOlOO\
Ol\
OO
]
-
lO\
OOOlO\
OOOl\
O\

.
lOOO\
OOllllOl
[
lOOOOlOOO\
Ol\
l
]
)
.
Dot
(
lOOO\
OlOOllOl\

-
lOOOOl\
O\
OO\
O\
lO
.
lO\
OOOO\
l\
ll\
lOl\

[
lO\
OO\
OlOOOOll
]
)
;
TA_AS\
SER\
T\

(
Fabs
(
lOO\
OOO\
lllO
<
0.001f
)
)
;
}
}
if\

(
lOOOO\
l\
OOl\
lOO\

.
x
>
0.0f
&&
lOO\
OO\
lOOl\
lO\
O\

.
y
>
0.0f
&&
lO\
OOOlO\
Oll\
O\
O
.
z
>=
0.0f
)
{
lOO\
OOlOOOO\
lO
.
llOl\
lOOlll
++
;
co\
n\
st\

floa\
t
lOOOlOl\
lO\
O\
l
=
lOOO\
OlO\
OllOO
.
x
+
lOOOOlO\
OllOO
.
y
+
lOOOOl\
OO\
llOO
.
z
;
TA_ASS\
E\
RT
(
lOOO\
lOllOOl
>
0.0f
)
;
lOOOO\
lOO\
ll\
OO
/=
lOOOlOllOOl\

;
lOOOOlOOllOO
=
lOO\
OOl\
O\
Ol\
l\
OO
.
x
*
lOOOO\
lOO\
OOlO
.
lOO\
OOOllllOl\

[
lO\
OO\
Ol\
OOOOl\
l
]
+
lO\
OOOl\
O\
OllOO
.
y
*
lOOOOl\
OOO\
OlO
.
lO\
OOOOllllOl
[
lOO\
OOlO\
O\
OlOO
]
+
lOO\
OO\
l\
OOllOO
.
z
*
lOOOOlOOOO\
lO
.
lOOOOO\
lll\
lOl
[
lOO\
OO\
l\
OOOl\
Ol\

]
;
cons\
t
float
lOlllO\
O\
lll
=
lOOOOl\
OOllOO\

.
GetMa\
g\
ni\
tudeSqr\
d
(
)
;
if
(
lOOOOlOOO\
Ol\
O
.
lO\
l\
llOOlO\
l
>
lOlll\
OOl\
l\
l
)
{
lOO\
OOlO\
OO\
OlO
.
lOl\
ll\
OOl\
Ol\

=
lOlllOOll\
l
;
lOO\
OOlOOOOl\
O\

.
lOOOOOlllllO
=
lOO\
O\
OlO\
OOl\
l\
O
;
lOO\
OOlOOO\
Ol\
O
.
lOlO\
OlO\
OlO\
O\

=
lO\
OO\
OlOOl\
lOO\

;
}
}
}
lOlOlOlOO\
l
void\

lOOOO\
lOOlll\
O\

(
const
Vec3
&
lll\
ll\
ll\
ll
,
const
Vec3\

&
lOOO\
OOOOOO
,
con\
s\
t
Vec\
3
&
ll\
llOOlO\
O\
O
,
Vec3\

&
lOl\
O\
OlO\
OlOO\

)
{
Vec\
3
lO\
OO\
Oll\
OllO
=
lOO\
OOO\
OO\
OO
-
lll\
l\
ll\
l\
l\
l\

;
fl\
o\
at\

lOOOOlOOOlll
=
llll\
lllll
.
Dot
(
lOO\
OOllOl\
l\
O
)
;
floa\
t\

lOOOOlOO\
lOOO\

=
lOOOO\
O\
OOOO
.
Do\
t
(
lOOOOll\
OllO\

)
;
float\

lOOOOlO\
OlOOl
=
llllOO\
l\
OO\
O
.
Dot
(
lOOOO\
ll\
OllO
)
;
lOOOO\
llOll\
O
=
ll\
llOOlOOO
-
llllll\
l\
ll
;
floa\
t
lO\
OOOl\
OOlO\
lO
=
lll\
l\
llll\
l
.
Do\
t
(
lOOOOllOllO
)
;
float
lOOOOlO\
OlOl\
l
=
lO\
OO\
O\
OOOOO
.
Dot
(
lOO\
O\
O\
l\
lOllO
)
;
float\

lO\
OO\
O\
O\
OOl\
l
=
llllOOl\
O\
OO
.
Do\
t\

(
lOOO\
Oll\
OllO
)
;
Ve\
c3\

lOOOOlOOllOO\

;
lOO\
O\
OlOOllO\
O
.
x
=
(
lOOOOlO\
O\
lOO\
O
*
lOO\
OOOO\
Ol\
l
-
lOOO\
OlOO\
lO\
l\
l
*
lOOO\
OlO\
OlOOl
)
;
lOOOOlOO\
l\
l\
OO
.
y
=
-
(
lO\
OO\
OlOOO\
ll\
l\

*
lOO\
OOOOOll
-
lOOOOl\
O\
OlOl\
O
*
lOO\
OOlOOlOO\
l
)
;
lO\
O\
OOlOOl\
lOO
.
z
=
(
lO\
OOOl\
OO\
Olll
*
lOOOOlOOlO\
ll
-
lOOOOlOOl\
Ol\
O
*
lOOOOl\
OOlOOO
)
;
{
cons\
t
float
lO\
OO\
l\
Ol\
lOOl
=
lOOOOl\
OOll\
O\
O
.
x
+
lOOOOlOOllOO
.
y
+
lOOOOlOOllOO\

.
z
;
TA\
_A\
S\
SER\
T
(
lOOO\
lOllO\
O\
l
>
0.0f
)
;
lO\
OO\
O\
lOOl\
lO\
O
/=
lOOOlO\
llOOl
;
lOOOOl\
OOllOO\

=
lO\
O\
OOl\
O\
O\
l\
lO\
O
.
x
*
lll\
ll\
l\
lll
+
lOOOOlO\
Ol\
lOO
.
y
*
lOOOOO\
OO\
OO\

+
lO\
OOOlOOllO\
O
.
z
*
llllOO\
l\
OOO
;
lOlO\
OlOO\
l\
O\
O\

=
lO\
O\
OOlOOllO\
O\

;
}
}
lOlO\
lOlOOl
void
lOOOOlO\
Oll\
ll
(
lOO\
OO\
Ol\
llOlO\

&
lOOOO\
lOOOO\
lO
,
con\
st\

in\
t
lOO\
OOlOOOO\
ll
,
co\
nst
int\

lOOO\
OlOO\
OlO\
O\

,
const
int
lOOOOl\
OOOlOl\

,
con\
st
int
lOOOOlOO\
O\
l\
lO\

)
{
Ve\
c3\

lOO\
OOllOl\
lO\

=
lOOO\
OlOOOOlO\

.
lO\
OOOOll\
l\
lOl\

[
lOO\
OOlOOOlO\
O\

]
-
lOOO\
Ol\
O\
OO\
OlO\

.
lOOOO\
Ollll\
Ol
[
lOO\
OOlOOO\
Oll
]
;
flo\
a\
t
lOO\
OO\
lOOOl\
l\
l
=
lOOOOl\
OO\
OOlO
.
lOOOOOllll\
Ol\

[
lO\
OOOlO\
OOOl\
l
]
.
Dot
(
lOOOOll\
O\
ll\
O
)
;
fl\
oat
lOOOO\
lOOlO\
OO
=
lO\
O\
OOl\
OO\
OO\
lO
.
lOOOOOl\
ll\
l\
O\
l\

[
lOO\
O\
OlOOOlOO
]
.
Dot
(
lO\
OOOllOllO\

)
;
Ve\
c3
lOOOOl\
OOllOO
;
lOOOOlOOllOO
.
x
=
lOO\
OO\
lOO\
lOOO
;
lOOOOl\
OO\
llOO
.
y
=
-
lOOOOl\
OO\
O\
lll
;
if
(
lOOOOl\
O\
O\
ll\
OO
.
x
>
0.0f
&&
lOOOO\
l\
O\
OllO\
O
.
y
>
0.0f
)
{
lOOO\
O\
lO\
OOOl\
O
.
llOllOOlll
++
;
const\

float
lOOOlOl\
lOOl
=
lOO\
OOlOOllOO\

.
x
+
lOOOOlO\
OllO\
O
.
y
;
TA_\
ASS\
ERT\

(
lOOO\
lO\
l\
lO\
Ol
>
0.0f
)
;
cons\
t
fl\
oat
lOOOlOllOlO\

=
1.0f
/
lOO\
Ol\
OllO\
Ol
;
lOOOO\
lOOll\
OO
.
x
*=
lOO\
OlOllOlO
;
lOOO\
O\
lOO\
llOO
.
y
*=
lOOOlOllO\
l\
O
;
lOOOO\
lOOllOO
=
lOOOOlOO\
l\
l\
OO
.
x
*
lOOOOl\
O\
OOOlO
.
lOO\
OO\
Oll\
llOl
[
lOO\
OOlOOOO\
ll
]
+
lO\
O\
OOlOOllOO
.
y
*
lOOOOlOOOOlO\

.
lOOOO\
Oll\
l\
lOl\

[
lO\
OOO\
lOOO\
l\
OO\

]
;
float
lOOOOOll\
lO
=
(
lOOOO\
l\
O\
OOOlO\

.
lOOOOOllllOl
[
lOOOOlOOOO\
ll\

]
-
lOOO\
OlOOOOlO
.
lOOOOOllllOl
[
lOOO\
Ol\
O\
OO\
l\
OO\

]
)
.
Dot\

(
lOO\
OOlO\
O\
l\
lO\
O\

)
;
TA_A\
SSE\
R\
T
(
Fabs
(
lOO\
OO\
Olll\
O
)
<
0.001f
)
;
Vec\
3\

llll\
O\
O\
lOOl
=
(
lOOO\
OlOOllO\
O
-
lOOOOlO\
OO\
Ol\
O\

.
lO\
OOOO\
llllOl
[
lOO\
OOl\
OOOOll
]
)
.
Cr\
oss
(
lOOO\
O\
lO\
O\
O\
Ol\
O\

.
lOO\
OO\
Ol\
lllOl
[
lOO\
OOl\
O\
OOlOO
]
-
lOOOOlOOllO\
O
)
;
TA_AS\
SER\
T
(
Fab\
s\

(
ll\
llOOlO\
Ol
.
Ge\
tM\
agnitud\
e\
Sqrd
(
)
)
<
0.001f
)
;
const
float\

lOlllOOll\
l
=
lOOO\
OlO\
Ol\
lO\
O
.
GetM\
agnitu\
d\
eSqrd
(
)
;
if
(
lOOOO\
lOO\
O\
OlO
.
lOl\
ll\
OOl\
O\
l
>
lOlllOO\
ll\
l
)
{
lO\
OOOlO\
OOOl\
O
.
lO\
l\
l\
lOOlOl
=
lOl\
llOOlll
;
lOO\
O\
OlOO\
OOlO
.
lOOO\
OOl\
l\
lll\
O
=
lOOOO\
lOOOlOl
;
lOOOOlOOO\
OlO
.
lOOOOOlllll\
l
=
lO\
OOOlOO\
OllO
;
lO\
OO\
OlOOO\
Ol\
O
.
lOlO\
O\
lOOlOO
=
lO\
OOOlOOl\
lOO
;
}
}
}
lOlOlOlOO\
l
void
lOO\
OOlOl\
OOO\
O
(
cons\
t
Vec3\

&
lllll\
llll
,
co\
nst
Vec\
3
&
lOOOOOOOOO
,
Vec3
&
lOlOOlOO\
lOO
)
{
Ve\
c\
3
lOOOOllOl\
lO
=
lOOO\
OOO\
OOO
-
lllll\
lll\
l
;
float
lO\
OOOlOOOl\
l\
l
=
llll\
ll\
lll
.
Dot\

(
lOO\
O\
O\
llOllO\

)
;
float
lOOOOl\
OO\
lOO\
O
=
lOOOOOOOOO
.
Dot
(
lO\
OOOl\
l\
Ol\
l\
O\

)
;
lOlOO\
lO\
OlOO
.
x
=
lOOO\
Ol\
OOlOOO
;
lOl\
OOl\
O\
OlO\
O
.
y
=
-
lOO\
OOl\
O\
OO\
lll\

;
{
cons\
t
flo\
at
lOOO\
l\
O\
l\
lOOl\

=
lOlOO\
lOOlOO
.
x
+
lOl\
O\
OlOO\
lOO\

.
y
;
TA_ASSE\
RT
(
lOOOlOl\
lO\
O\
l\

>
0.0f
)
;
const
float\

lOOO\
lOllOlO
=
1.0f
/
lOO\
OlOl\
lOOl
;
lO\
l\
OOlO\
OlOO
.
x
*=
lOOOlO\
llOl\
O\

;
lOl\
OOl\
OOlOO\

.
y
*=
lOO\
OlO\
l\
lOlO
;
lOlOOlOOl\
OO\

=
lO\
lOOlOOl\
OO
.
x
*
lllll\
llll
+
lOlOO\
lOOlOO\

.
y
*
lO\
O\
OOO\
OO\
OO
;
}
}
lO\
lOlOl\
O\
O\
l
vo\
id
lOOO\
OlOlO\
OOl
(
lO\
O\
O\
OOl\
llOlO
&
lOO\
OOlOOO\
O\
lO
,
con\
st
int\

lOOOOlO\
OOO\
l\
l
,
const
in\
t\

lOO\
OOl\
OOOl\
OO\

,
const
int
lOOOOlOOO\
lOl
,
cons\
t
in\
t\

lOOOO\
lOOOll\
O
)
{
co\
nst
float\

lOlllOOl\
ll\

=
lOOO\
O\
lOOOOlO
.
lOOOO\
OllllO\
l
[
lO\
OO\
OlOOOO\
ll\

]
.
GetMagnitud\
eSqr\
d
(
)
;
if\

(
lO\
OOO\
l\
OO\
OOl\
O
.
lO\
lll\
OO\
l\
Ol
>
lOlllOO\
l\
ll\

)
{
lOOO\
OlOO\
OOl\
O
.
lO\
lllOOl\
Ol\

=
lOlllOOll\
l\

;
lOO\
O\
O\
lOO\
OOl\
O
.
lOlOOlO\
OlOO
=
lOO\
OOlOOOO\
lO\

.
lOOOOOllllOl
[
lO\
OOOl\
O\
OOOll
]
;
lOOO\
OlOOOOlO
.
lO\
O\
OOOlll\
llO
=
lOOO\
OlOOOl\
OO\

;
lOOO\
OlO\
OOOlO
.
lOO\
O\
O\
Oll\
lll\
l
=
lOOO\
Ol\
OOOlOl
;
lO\
OOOlO\
O\
OOlO
.
lOOOO\
lOOO\
OOO\

=
lO\
OOOlOOO\
llO
;
}
}
lO\
lO\
lOl\
OOl\

void
lOOOO\
l\
OlO\
OlO
(
lOOOOOl\
llO\
lO
&
lOOOOlOOOOlO
,
in\
t
lOOOO\
lOlOOll
)
{
swit\
c\
h\

(
lO\
OOOlOlOOll
)
{
case
0
:
lO\
OOOlOOO\
Ol\
O\

.
lOO\
OOOllllOl
[
0
]
=
lOO\
O\
Ol\
OOO\
OlO\

.
lOOOOOllllOl
[
1
]
;
cas\
e\

1
:
brea\
k
;
default
:
ll\
lOOlO\
O\
OO
;
}
lOOOOlO\
OOO\
l\
O\

.
lOlllOlOOO
--
;
}
lOlOl\
OlOOl
void
lO\
OOOlOlOlOO
(
lOOOOOll\
lOlO
&
lOO\
O\
O\
lO\
OOOl\
O\

,
int
lOOOOlO\
lO\
Oll
)
{
swi\
tch
(
lOOOO\
lOlOOll\

)
{
case
0
:
lO\
OOOlOOOOlO
.
lOO\
OOO\
llll\
Ol
[
0
]
=
lOOOOlOOOOlO\

.
lOOOO\
Olll\
l\
Ol\

[
1
]
;
cas\
e\

1
:
lOO\
OOlOO\
O\
OlO
.
lO\
OOO\
Olll\
lO\
l
[
1
]
=
lO\
OOO\
lOOOO\
lO
.
lOO\
OOO\
l\
lllOl
[
2
]
;
case
2
:
br\
eak
;
default\

:
lllOOl\
O\
OOO
;
}
lOOOOlO\
OO\
O\
lO
.
lOll\
lOlO\
OO
--
;
}
lOl\
O\
lOl\
OO\
l
void
lO\
OOOl\
O\
lOlOl
(
lOOO\
O\
O\
lllOlO
&
lOO\
OOlOOOO\
l\
O\

,
int
lOOOO\
lOlO\
Ol\
l\

)
{
swit\
ch
(
lO\
OOOl\
OlOOl\
l
)
{
case
0
:
lOOOOlOOOO\
lO
.
lOOOOO\
l\
ll\
l\
O\
l
[
0
]
=
lOO\
O\
OlO\
OOOlO\

.
lOOOOOlll\
lOl\

[
1
]
;
case
1
:
lOOO\
Ol\
O\
O\
OO\
l\
O
.
lOO\
OOO\
lll\
lO\
l\

[
1
]
=
lOO\
OOl\
OOOOlO\

.
lOOO\
OO\
l\
l\
llO\
l
[
2
]
;
ca\
se
2
:
lOOOOl\
OO\
OOlO
.
lO\
OOOOllllOl
[
2
]
=
lOOOOl\
OOOO\
lO
.
lOOOO\
O\
ll\
llOl
[
3
]
;
case
3
:
brea\
k
;
defa\
ult
:
lll\
OOlOOOO
;
}
lO\
OOOlOOOO\
l\
O
.
lOl\
llO\
lO\
OO
--
;
}
void
TAC_CALL\

llll\
O\
OlO\
lOO\

(
co\
n\
st
MFrame
&
lOlll\
O\
O\
OO\
Ol\

,
con\
st
MFra\
m\
e\

&
lOlll\
OOOO\
l\
O\

,
lOllO\
l\
ll\
OO\
O\

*
lO\
ll\
lOOO\
O\
ll
)
{
in\
t
lOll\
l\
OlOOl
;
TA\
_A\
SSERT
(
lOlllOO\
OOll\

->
lOllO\
O\
Oll\
l\
l
->
Ge\
tCo\
llisi\
onObj\
e\
ctT\
ype
(
)
==
Colli\
si\
onObject
::
TYPE\
_C\
O\
NVE\
X
)
;
TA\
_\
A\
SSE\
RT
(
lOlllOOOOll
->
lOllOOlOO\
O\
O\

->
Ge\
t\
Co\
ll\
ision\
Objec\
tType
(
)
==
Co\
llisionObj\
ect
::
TYPE_\
CONV\
E\
X
)
;
con\
st
Co\
llisi\
onObjectC\
onvex
&
lllO\
l\
l\
O\
l\
ll\
O
=
*
(
Col\
lisi\
on\
O\
b\
jectConvex\

*
)
lOlllOOOOll
->
lOll\
OOOlll\
l\

;
const
CollisionO\
bj\
ec\
tCon\
v\
e\
x
&
lllOllOll\
ll\

=
*
(
Collis\
i\
on\
Ob\
j\
ectConvex
*
)
lOlll\
OOOOll
->
lO\
l\
lO\
OlOOOO
;
MFram\
e
lO\
OOOl\
OlOllO\

=
lOl\
llOOOOOl
.
GetInverse\

(
)
;
Col\
li\
sion\
Ob\
jectCo\
n\
vex
::
Poly\
g\
o\
n
*
ll\
OOllllll
=
0
;
Col\
l\
i\
sionO\
bje\
ct\
Co\
nvex
::
Po\
lyg\
o\
n
*
llOlOOOOOO
=
0
;
flo\
at
lOOOOlOlOll\
l
=
0.0f
;
float
lOOOO\
lOllOOO\

=
0.0f
;
cons\
t
bool\

lOOO\
O\
l\
OllOOl
=
false
;
if\

(
lOOO\
Ol\
Ol\
lOOl
)
{
Vec\
3
lOOOOl\
O\
l\
lOl\
O
;
stat\
ic
lOOOOOlll\
OlO
lOO\
OOlO\
O\
O\
Ol\
O
;
bool
lOOOOlOl\
l\
Oll
=
fa\
l\
se
;
int
llOl\
l\
Oll\
ll
=
0
;
lO\
OO\
O\
l\
OOOOlO\

.
lOlllO\
lOO\
O\

=
0
;
lOOOOlOll\
O\
lO
=
k_v3UnitY
;
int
lOO\
OO\
lOll\
lOO\

=
0
;
int
lOOOO\
lOll\
lO\
l
=
0
;
float
lOOOOlO\
lll\
l\
O
=
0.8f
;
for\

(
;
;
)
{
ll\
OllO\
l\
ll\
l
++
;
if
(
ll\
O\
ll\
O\
lll\
l\

>
40
)
{
bre\
ak\

;
}
lOOOOl\
Oll\
lOO
=
lllOl\
lOl\
ll\
O
.
lOO\
O\
OOllOO\
ll
(
lOO\
O\
O\
l\
Olll\
OO
,
lOO\
OOlOllOlO
*
lOOOO\
lOlO\
ll\
O
.
m33Ro\
tation\

)
;
lOO\
OOl\
OlllOl
=
lllOl\
lO\
llll
.
lOOOOO\
ll\
OO\
ll\

(
lOOOOl\
Ol\
llOl
,
-
lOOOO\
lOllOl\
O
)
;
lO\
OOO\
l\
OO\
OOl\
O
.
lO\
OOOOll\
lOll\

[
lOO\
OO\
l\
OOOO\
lO
.
lO\
lllO\
lOOO
]
=
ll\
lOll\
Ol\
llO
.
lOlOO\
lO\
l\
lO
->
lllll\
Ol\
llll
[
lOOOOlOll\
l\
OO
]
;
lOOOO\
lOOOOlO
.
lO\
OO\
OO\
llll\
OO\

[
lO\
OO\
O\
lOOO\
O\
lO\

.
lOl\
l\
lOlO\
OO
]
=
ll\
l\
O\
l\
lOllll
.
lOlOOlOllO\

->
lllllOlllll
[
lOOO\
Ol\
OlllO\
l
]
;
if
(
!
lOlll\
OOOOl\
l\

->
lO\
l\
lOll\
l\
Oll
)
{
Vec3
lOlOOOOO\
lOl
=
lO\
O\
OOlOOOOlO
.
lOOOOO\
ll\
l\
O\
l\
l\

[
lO\
OOOl\
OO\
OOl\
O
.
lOlllOlOOO
]
*
lOlllOOO\
OOl
-
lOO\
OOlOOO\
OlO
.
lOOO\
OO\
l\
lllOO\

[
lO\
O\
O\
O\
lOO\
OOlO
.
lOlllOlOOO
]
;
if\

(
lO\
OOO\
l\
OllOlO
.
Dot
(
lOl\
OOO\
OOlOl
)
>
-
0.0001f
)
{
if
(
llO\
llO\
l\
lll
==
1
)
in\
t
lOlO\
OO\
llOl
=
0
;
ret\
urn\

;
}
}
lO\
OOOlOOOOl\
O
.
lOOO\
OOl\
llO\
ll
[
lOOOO\
lOOO\
OlO\

.
lOlll\
OlOOO\

]
=
lOOOOlOllllO
*
(
lOO\
O\
O\
lO\
O\
O\
O\
lO
.
lO\
O\
OOOll\
lOll
[
lO\
OO\
OlOO\
OOl\
O
.
lOll\
l\
OlOOO
]
-
lllOl\
l\
OlllO
.
lOlOOl\
OllO
->
lll\
Ol\
lOO\
Ol\
O
)
+
lllOll\
Ol\
llO
.
lOlO\
OlOllO
->
lllO\
llOOOlO
;
lOOOOlOO\
O\
Ol\
O
.
lO\
OOO\
O\
llllOO\

[
lOO\
O\
OlOO\
OOlO\

.
lO\
ll\
l\
OlO\
OO
]
=
lOO\
OO\
lOl\
lll\
O\

*
(
lOO\
OOlOOO\
Ol\
O
.
lOOOOOlll\
lOO
[
lO\
OO\
OlO\
OOOl\
O
.
lOll\
lOlOO\
O\

]
-
lll\
OllOllll
.
lOlOOlOllO\

->
ll\
l\
Ol\
lOOO\
lO
)
+
ll\
lO\
ll\
Ollll
.
lO\
lO\
OlOllO
->
lll\
OllO\
OOlO
;
Vec\
3
lOOOO\
lO\
l\
llll\

=
lOOOOl\
O\
O\
OOl\
O
.
lOOOOOlllOll
[
lOO\
OOl\
OOOOlO
.
lO\
lllOlOOO
]
*
lOlllOOOO\
O\
l
-
lO\
OOOlOOOOl\
O\

.
lOOO\
OO\
llllOO
[
lOOO\
Ol\
OO\
OOlO\

.
lOlllOlOOO
]
;
if\

(
lO\
O\
OOl\
OllOlO
.
Dot
(
lO\
OOOlOll\
lll
)
>
-
0.0001f
)
bre\
ak
;
lO\
OOOlO\
OOOlO\

.
lOOOOOllll\
O\
l
[
lO\
OO\
O\
l\
OOO\
O\
l\
O\

.
lOll\
lOlO\
OO
]
=
lOO\
O\
OlO\
ll\
l\
ll
;
{
#ifdef lOOOOllOOOOO
for\

(
lOOO\
llOO\
O\
l
=
0
;
lOOOllOO\
Ol
<=
lOOO\
O\
l\
O\
OOOl\
O\

.
lOlllOlOOO
;
lOOOllOOOl
++
)
{
PhysicsR\
ender
::
Re\
nderLi\
n\
e
(
k_mF\
ra\
meIde\
n\
tity
.
v3Tra\
nsla\
t\
ion
,
k_mFrameI\
den\
t\
ity
.
m33Ro\
t\
ation
.
v3X\

)
;
PhysicsRender
::
RenderLine
(
k_m\
Fram\
eIdenti\
ty
.
v3\
Translat\
io\
n
,
k_mF\
rame\
I\
d\
entity
.
m3\
3Ro\
tati\
o\
n\

.
v3Y
)
;
PhysicsRend\
er
::
Rende\
rLine
(
k_\
m\
FrameId\
entit\
y
.
v3\
T\
r\
anslatio\
n
,
k_mFr\
a\
meIdentit\
y
.
m33Ro\
ta\
ti\
on
.
v3Z
)
;
for
(
in\
t\

lOOlOOl\
OlO
=
lOOO\
llOOOl\

+
1
;
lOOlOOl\
Ol\
O
<=
lOO\
OOl\
OOOOl\
O\

.
lOlll\
OlOO\
O
;
lOOl\
OOlOlO
++
)
{
Ph\
y\
sicsR\
end\
er
::
RenderL\
ine
(
lO\
OOOlOOOOlO
.
lO\
OOOOllllOl
[
lOOOll\
OOOl
]
,
lOOOO\
l\
OOOOlO\

.
lOO\
OOOl\
ll\
lO\
l
[
lOOl\
O\
OlOlO
]
,
0xFF00FFFF
)
;
}
}
#endif //
}
int
lO\
OOOll\
OOOOl
=
3
;
switc\
h
(
lO\
O\
O\
O\
lO\
OOOl\
O
.
lO\
l\
llO\
l\
OO\
O\

)
{
ca\
se\

0
:
lOOO\
OlOl\
lOlO
=
lOOOOlOOOOl\
O\

.
lOOOOO\
llllOl
[
lOOOOlOOOOlO\

.
lOlllOlO\
OO\

]
;
lOOOOlOO\
O\
Ol\
O\

.
lOlllOl\
OOO\

++
;
break\

;
cas\
e
1
:
lOOOO\
lOOO\
OlO
.
lOOO\
O\
Olll\
llO
=
-
1
;
lO\
OOOlOOOOlO
.
lOO\
O\
OOllll\
ll
=
-
1
;
lOOO\
O\
lOOOOlO
.
lO\
OOOlO\
O\
OO\
OO\

=
-
1
;
lOOOO\
l\
O\
OOO\
lO
.
lO\
lll\
OOlOl
=
k_\
fM\
ax\
Fl\
oat\

;
lOOO\
O\
l\
OO\
O\
OlO
.
llOllOOlll
=
0
;
lOO\
OOlO\
O\
llll
(
lO\
OOO\
l\
O\
OOO\
lO
,
0
,
1
,
2
,
3
)
;
lOOO\
OlOOOOlO
.
lOOOOOlll\
l\
lO\

=
-
1
;
lOO\
O\
Ol\
OO\
O\
Ol\
O
.
lO\
OOOOlllll\
l
=
-
1
;
lOOOOlO\
OO\
OlO
.
lOlllO\
lOOO
++
;
if
(
lOO\
OOl\
O\
OOO\
lO
.
llO\
llO\
Olll
!=
1
)
{
lOOOOlOlO\
OOl
(
lO\
OOOlOOOOlO\

,
0
,
1
,
2
,
3
)
;
lOOO\
O\
lO\
lO\
OOl
(
lOO\
OO\
lOOOOl\
O
,
1
,
0
,
2
,
3
)
;
if\

(
lO\
O\
O\
OlO\
OOOlO
.
lOOOOOl\
l\
ll\
lO
!=
-
1
)
lOO\
OOlOlOOl\
O
(
lO\
OOO\
lOOO\
OlO
,
lOOOOlO\
O\
OOlO\

.
lOOOO\
OlllllO\

)
;
}
lOOO\
OlOllOl\
O
=
lOOOOlOOOOlO
.
lO\
l\
OOl\
OOl\
OO
;
bre\
ak
;
cas\
e\

2
:
lO\
O\
OOlOOOOlO
.
lOOOO\
Olllll\
O\

=
-
1
;
lOOOOlOOO\
OlO
.
lOOOOO\
lll\
l\
ll\

=
-
1
;
lOOO\
O\
lOOO\
Ol\
O
.
lO\
OO\
OlOO\
OO\
OO
=
-
1
;
lOOOO\
l\
OO\
OOl\
O
.
lOlllOOlOl
=
k_\
fMa\
xFlo\
a\
t
;
lOOOOlO\
OO\
OlO\

.
llOl\
lOOll\
l
=
0
;
lOOOO\
lOOOOOl
(
lOOOOlOOOOl\
O\

,
0
,
1
,
2
,
3
)
;
lOOOO\
l\
O\
O\
OOlO
.
lOO\
OO\
OlllllO
=
-
1
;
if
(
lOOOO\
lOOO\
Ol\
O
.
llO\
ll\
OOl\
ll
!=
1
)
{
lOO\
OOlO\
Olll\
l
(
lOOOOl\
O\
OO\
Ol\
O
,
0
,
1
,
2
,
3
)
;
lO\
O\
OOlOOllll
(
lOOOOlOOO\
Ol\
O
,
0
,
2
,
1
,
3
)
;
lOOO\
OlOOllll
(
lOOO\
O\
l\
OOO\
O\
lO
,
1
,
2
,
0
,
3
)
;
lOO\
OOlO\
OO\
OlO\

.
lOOO\
O\
Olll\
lll\

=
-
1
;
if
(
lOOOOl\
OOOOlO
.
llOll\
OO\
l\
ll
!=
3
)
{
lOOOOlO\
lOOOl\

(
lOO\
OOlOOOOlO\

,
0
,
1
,
2
,
3
)
;
lOO\
OO\
lOlO\
OOl
(
lOO\
OOlOOOOlO
,
1
,
0
,
2
,
3
)
;
lO\
OOO\
l\
OlOOOl\

(
lO\
OO\
OlOOO\
O\
l\
O
,
2
,
0
,
1
,
3
)
;
}
}
lOO\
O\
OlOOOOlO
.
lOlllOlOOO
++
;
if
(
lOOOOlOOOO\
l\
O
.
lOO\
OO\
Ollllll\

!=
-
1
)
{
lO\
OOOl\
OlOl\
OO
(
lOO\
OOl\
O\
O\
OOlO
,
lOOOO\
lOOOO\
lO
.
lOOO\
OOllllll\

)
;
lOOOO\
lOlOO\
lO
(
lOO\
O\
OlOOOO\
l\
O
,
lOOOOl\
OO\
OOlO
.
lOOOOOlll\
llO
)
;
}
els\
e
if
(
lOOOOl\
OOOOlO\

.
lO\
OOOOlllll\
O
!=
-
1
)
{
lO\
O\
OOlOlO\
lO\
O\

(
lOOO\
OlOO\
OO\
lO
,
lO\
OOOl\
OOOOlO
.
lOOO\
O\
Ol\
llll\
O
)
;
}
lOOOOlOl\
lOlO\

=
lOOOO\
lOOOOlO
.
lO\
lO\
Ol\
O\
O\
l\
OO
;
br\
e\
ak
;
case
3
:
{
lOOOOlOO\
OO\
l\
O
.
lO\
OOOOl\
ll\
llO\

=
-
1
;
lOOOO\
lOOOOl\
O
.
lOOOOO\
ll\
llll\

=
-
1
;
lOOO\
O\
l\
O\
OO\
O\
lO\

.
lOOOO\
lOOOOOO
=
-
1
;
lOO\
O\
OlOO\
OOl\
O
.
lOl\
ll\
OOlOl\

=
k_fMaxFloat\

;
lOOOO\
lOO\
OOlO\

.
llOllOO\
ll\
l\

=
0
;
lOOOOlO\
O\
O\
OOl\

(
lO\
OOOlOOOOlO
,
0
,
1
,
2
,
3
)
;
lOOOOlOO\
OOOl
(
lOO\
OOlOOOO\
lO
,
1
,
2
,
3
,
0
)
;
lO\
OO\
OlOOOOOl
(
lOOOOlOO\
OO\
lO
,
2
,
3
,
0
,
1
)
;
lO\
OOO\
lOO\
OOO\
l
(
lOO\
OOlOOOO\
lO
,
3
,
0
,
1
,
2
)
;
{
lOOOOlOOllll\

(
lOOOOlOOO\
Ol\
O\

,
0
,
1
,
2
,
3
)
;
lO\
OOOlO\
Oll\
l\
l
(
lOO\
OO\
lOO\
OOlO
,
0
,
2
,
1
,
3
)
;
lOOOO\
lO\
Ol\
l\
ll\

(
lOOOOlOO\
O\
OlO\

,
0
,
3
,
0
,
3
)
;
lOO\
O\
OlOOllll
(
lO\
OOOlOOOOlO\

,
1
,
2
,
0
,
3
)
;
lO\
O\
OOl\
OOl\
lll\

(
lOO\
O\
O\
l\
OOOOlO\

,
1
,
3
,
2
,
3
)
;
lOOOO\
lOOllll
(
lO\
OOOl\
OOOOl\
O\

,
2
,
3
,
0
,
1
)
;
lOO\
OO\
lOl\
OO\
O\
l
(
lO\
O\
OOlO\
OOOl\
O\

,
0
,
1
,
2
,
3
)
;
lOO\
O\
O\
lOlOOO\
l
(
lOOO\
Ol\
OOO\
OlO
,
1
,
0
,
2
,
3
)
;
lOOOOl\
O\
lOOOl
(
lOOOOlOOOOl\
O\

,
2
,
0
,
1
,
3
)
;
lOOO\
OlOlOOOl
(
lOO\
O\
OlO\
OOO\
l\
O
,
3
,
0
,
1
,
2
)
;
}
lOO\
OO\
lOOOOlO
.
lOl\
ll\
OlO\
O\
O\

++
;
if\

(
lOOO\
O\
l\
OOO\
O\
lO
.
lOOO\
O\
l\
OOO\
OOO\

!=
-
1
)
{
lOO\
OOlOlOlOl
(
lOOO\
OlOOOOlO
,
lOOOOl\
O\
OOOl\
O\

.
lOO\
OOl\
O\
OOOOO\

)
;
if
(
lOO\
O\
OlO\
O\
OOlO\

.
lOOOO\
O\
l\
lll\
ll
!=
-
1
)
{
lOOOO\
l\
O\
lOlOO\

(
lOOOOlOOOOl\
O\

,
lOOOO\
lO\
O\
O\
OlO\

.
lO\
OOOOllllll
)
;
lOOOO\
l\
OlOOlO
(
lOOOOlOO\
OO\
l\
O
,
lOOO\
O\
l\
O\
OO\
OlO
.
lO\
OOO\
Oll\
ll\
lO
)
;
}
}
else
if
(
lO\
OOO\
l\
O\
OOOl\
O
.
lOOOOOll\
l\
lll
!=
-
1
)
{
lO\
OOOlOlO\
l\
Ol
(
lO\
OOOl\
OOOO\
lO\

,
lOO\
OOl\
O\
O\
O\
O\
lO
.
lOOO\
OO\
lllll\
l
)
;
lOOOO\
lOlOl\
OO
(
lOOOOl\
O\
O\
OOl\
O
,
lOOOOlO\
OOOlO
.
lOOOOOl\
llllO
)
;
}
el\
se
{
TA\
_\
AS\
SER\
T
(
lOO\
OOlOOO\
O\
lO
.
lOOOOOlllllO
!=
-
1
)
;
if
(
lOO\
OOlOO\
O\
O\
lO\

.
lOOOO\
Olll\
l\
l\
O\

==
3
)
{
lOO\
OOl\
OllO\
ll
=
tru\
e
;
break
;
}
lOO\
OOlOlOlO\
l
(
lO\
O\
OOlOOOO\
lO
,
lOOOO\
l\
OOOOlO
.
lOOOOOlllllO
)
;
}
lO\
OOO\
l\
OllOlO
=
lOOOO\
lO\
O\
OOl\
O\

.
lOlOOl\
OOl\
O\
O
;
}
break
;
def\
ault
:
lllO\
Ol\
OOOO
;
}
#ifdef lOOOOllOOOOO
if
(
lOO\
OOl\
lO\
OOO\
l
==
3
)
{
Ph\
ysi\
c\
sRender\

::
Re\
nderLi\
ne
(
k_\
v3\
Zero\

,
lOO\
OO\
lOllO\
lO
,
0xFFFF8000
)
;
}
#endif //
if
(
lOO\
OOlOl\
l\
O\
ll\

)
bre\
ak\

;
}
{
Vec\
3
lO\
O\
O\
OO\
OOlOO\
O
=
lOOOOlOll\
O\
lO\

/
lOl\
l\
lOO\
OOOl\

.
m33\
Rotati\
o\
n
;
fl\
oa\
t
lOOO\
OllOO\
OlO
=
2.0f
;
for\

(
int\

ll\
Ol\
lOO\
O\
O\
l
=
0
;
llO\
ll\
OO\
OOl
<
ll\
lO\
llOl\
llO
.
lOlOOlO\
l\
lO
->
lOllOOllll
.
lOOOlllOOl\

(
)
;
llOllOOOO\
l\

++
)
{
Collisi\
onObjectConvex
::
Po\
lygon
&
lOl\
l\
OlOOlO
=
ll\
ll\
ll\
OO\
Ol\
l
(
&
lllO\
l\
l\
Olll\
O
,
ll\
OllOOOOl
)
;
float
lOlOOOl\
OlO\
O
=
lOO\
O\
OOOOlOO\
O
.
Dot
(
lOllOl\
OOlO
.
lOOOlO\
OO\
OO
)
;
if\

(
lOOOOll\
OOOlO
>
lOlOOO\
lOlOO
)
{
lOOOOl\
l\
O\
OOlO
=
lOlO\
O\
OlOlO\
O
;
ll\
OOllllll
=
&
lOllOl\
OOlO
;
}
}
}
{
Vec3
lOOOOOOOlO\
OO
=
-
lO\
O\
OO\
lOllOlO
;
float
lO\
OOO\
ll\
OOOl\
O
=
2.0f
;
fo\
r\

(
int
llOllOO\
OOl
=
0
;
ll\
OllOOOOl
<
lllOll\
O\
llll
.
lOlOOlOllO
->
lOllOOllll
.
lOOOlllOOl
(
)
;
llO\
llOOOOl
++
)
{
CollisionObjectConvex
::
Polygo\
n
&
lOl\
l\
O\
lOl\
OO
=
lll\
lllOOOll\

(
&
lll\
OllO\
ll\
l\
l\

,
llO\
llOO\
OOl
)
;
flo\
at
lOlO\
OOlOlOO\

=
lOO\
OOOOO\
lOOO
.
Dot
(
lO\
llOlOlOO
.
lOOOlOOO\
OO
)
;
if
(
lOOOOllO\
OOlO\

>
lOlOOO\
lOlOO
)
{
lO\
OOOllOO\
O\
lO
=
lO\
lO\
OOlOlO\
O
;
llO\
lOOO\
OOO
=
&
lOllOlO\
l\
OO
;
}
}
}
}
in\
t\

lOOOOllOOOll\

=
lllOllO\
l\
llO
.
lOlO\
Ol\
O\
l\
lO
->
ll\
lllOll\
l\
ll\

.
lOOOlllO\
Ol
(
)
;
TA_A\
SSER\
T
(
lOOO\
O\
ll\
OO\
Oll
<
llll\
lOO\
lOl\
l
)
;
for
(
lOll\
lOlOO\
l
=
0
;
lOll\
lOlOOl\

<
lO\
OOO\
l\
lO\
OO\
l\
l\

;
lO\
lllO\
lOOl
++
)
{
lll\
llOOllO\
l
[
lOlll\
O\
l\
OO\
l\

]
=
lllOllOll\
lO\

.
lO\
l\
O\
OlOllO
->
ll\
lll\
O\
lll\
ll\

[
lO\
ll\
lOlOOl
]
*
lOlllO\
O\
OO\
Ol\

;
}
in\
t
lOOOOll\
OO\
lOO
=
ll\
lOl\
l\
Ollll
.
lO\
l\
OOl\
O\
llO
->
lll\
ll\
Olll\
ll
.
lOOOl\
llO\
Ol
(
)
;
TA_\
ASSE\
RT
(
lOOO\
O\
llOOl\
O\
O\

<
llll\
lOOlOl\
l
)
;
st\
a\
tic
Vec\
3\

lOO\
OOOlOlOlO
[
lllllO\
Ol\
Ol\
l
]
;
for
(
lOl\
llOlOOl
=
0
;
lO\
lll\
O\
lOOl\

<
lOO\
OOll\
O\
O\
l\
OO\

;
lOl\
llOl\
OOl
++
)
{
lOO\
OOOlO\
lOlO
[
lOlllOlOOl\

]
=
lllO\
l\
lOll\
ll
.
lOlOOl\
OllO
->
llll\
l\
Ollll\
l\

[
lOlllOl\
OO\
l
]
*
lOOOOlOlOllO
;
}
if\

(
!
lO\
OOOlOl\
lOOl
)
{
int\

lOOOOllOO\
lOl
;
int
lOOOOll\
OO\
llO
;
int
lO\
OO\
Oll\
OOlll
;
in\
t
lOO\
O\
Ol\
lO\
lOOO
;
float\

lO\
O\
OOlOllOOO
;
flo\
at
lOOOO\
lO\
lO\
lll
;
{
lOOO\
OllOO\
ll\
l
=
-
1
;
lOOOOllOOll\
O
=
-
1
;
lOO\
OOlO\
lO\
lll\

=
-
k_\
fMa\
x\
Float
;
lllOllOllll
.
lO\
OOOOOllllO
(
ll\
lO\
llO\
ll\
l\
O
.
lOlOO\
lOl\
l\
O
->
ll\
lll\
O\
lll\
ll
.
lOOOlllOOl\

(
)
,
lllllOOllOl
,
lOO\
OOllOOl\
ll
,
lO\
O\
OOllOOllO
,
lO\
OO\
O\
lOlOll\
l
)
;
llOlOOO\
OOO\

=
&
llllllOO\
O\
ll
(
&
lllO\
llOllll
,
lOOO\
Oll\
O\
O\
lll
)
;
TA_ASSERT
(
lO\
O\
O\
OllO\
OllO
!=
-
1
)
;
if\

(
lO\
OO\
O\
lOl\
Olll
>
0.0f
&&
llOlOOO\
O\
OO\

->
lOO\
OlOOOOO
.
Dot
(
lllOllOll\
l\
O\

.
lOlOOlOllO
->
lllllOlllll
[
lOOO\
O\
llOO\
llO
]
*
lOlllOOOOlO\

)
>
llOlOOOOO\
O
->
lOlOlllOOl
)
retu\
rn
;
lOOO\
Ol\
lOOlOl
=
-
1
;
lOOOOll\
Ol\
OOO
=
-
1
;
lOOOOl\
Ol\
lOOO\

=
-
k_\
fMax\
Floa\
t\

;
lllOl\
lOl\
ll\
O
.
lOOOOOO\
l\
lll\
O
(
lllO\
llOll\
ll
.
lOlOO\
lOllO\

->
llll\
lOll\
ll\
l
.
lO\
OO\
lll\
OO\
l
(
)
,
lOOOOOlOlOlO\

,
lOOOOllO\
OlOl\

,
lOOOOllO\
l\
O\
OO
,
lOO\
O\
OlO\
llOOO\

)
;
llOOlll\
lll
=
&
llllllOOOll\

(
&
lllOll\
OlllO
,
lOOOOllO\
OlOl
)
;
TA_AS\
S\
ERT
(
lO\
OOOl\
lOlOOO
!=
-
1
)
;
if
(
lOOOOlOllOOO
>
0.0f
&&
ll\
O\
Oll\
l\
l\
ll
->
lOO\
OlOO\
OOO\

.
Do\
t\

(
lllO\
llOll\
ll\

.
lOlOOlOllO
->
ll\
l\
ll\
Olllll
[
lOOOOl\
lOlOOO
]
/
lOl\
llOO\
OO\
lO
)
>
ll\
O\
O\
llll\
ll
->
lOlOll\
l\
OO\
l\

)
return
;
}
if\

(
lOO\
O\
OlOlOll\
l
<
lOOOOlOllO\
OO\

)
{
Vec\
3
lOOOOllOlOOl
=
llOOl\
l\
l\
l\
ll
->
lOOO\
lOO\
O\
OO
*
lOl\
ll\
OO\
OO\
Ol
.
m33Rot\
ati\
on
;
float
lOO\
OOllOOO\
lO
=
2.0f
;
for\

(
int
llOllOOO\
Ol\

=
0
;
llO\
l\
l\
OOO\
Ol
<
ll\
l\
O\
llOl\
l\
ll
.
lOlOOlOllO
->
lO\
llOO\
ll\
ll\

.
lOOO\
lllO\
O\
l
(
)
;
ll\
OllOOOO\
l
++
)
{
Collisi\
o\
nObjectConvex\

::
Polygo\
n
&
lOl\
lO\
lOlOO
=
llllllOO\
Ol\
l\

(
&
lllOllOl\
lll
,
llOllOOOO\
l\

)
;
fl\
o\
a\
t\

lOlOO\
O\
lOl\
O\
O
=
lOOOOl\
lOlOOl
.
Dot\

(
lOllO\
l\
OlOO
.
lO\
OOlO\
OOO\
O
)
;
if
(
lOOOOll\
OOOl\
O
>
lO\
l\
O\
OOl\
Ol\
OO\

)
{
lO\
OO\
Ol\
lOOOlO
=
lOl\
OO\
OlO\
lOO
;
llOl\
OOO\
OOO
=
&
lOllO\
lOlOO
;
}
}
}
else
{
Vec3
lOOOOllOlOl\
O\

=
llO\
lOO\
OO\
OO
->
lO\
OOl\
OO\
OOO\

/
lOlllOOO\
OOl
.
m33R\
ota\
t\
ion
;
float\

lOOO\
O\
llOOO\
lO\

=
2.0f
;
for
(
int
llOllOOOOl
=
0
;
llOl\
lOOOO\
l
<
lllOllOlll\
O\

.
lO\
lO\
OlOl\
lO\

->
lO\
l\
lOOllll
.
lOOOll\
lO\
O\
l
(
)
;
llOll\
OOOOl
++
)
{
Coll\
is\
ion\
Ob\
jectConvex
::
Pol\
yg\
on
&
lOllOlOOlO
=
lll\
l\
llO\
OO\
ll
(
&
lllOll\
Oll\
lO
,
llOllO\
OO\
Ol
)
;
fl\
oat\

lOlOO\
Ol\
OlOO
=
lOOOO\
llO\
lOlO\

.
Do\
t
(
lOll\
O\
lOOlO
.
lOOO\
lOOOOO
)
;
if
(
lOOOO\
l\
lOOO\
lO
>
lOlO\
OOl\
OlOO
)
{
lOO\
OOllO\
OOlO
=
lOl\
O\
OOlOlOO
;
ll\
O\
Olll\
l\
ll
=
&
lOllO\
lOO\
lO
;
}
}
}
}
TA_A\
S\
SERT
(
llO\
Olllll\
l
)
;
TA_\
AS\
SERT
(
llOlOOO\
OOO
)
;
#ifdef lOOOOOOOlllO
lllOllOl\
llO
.
lO\
OOOOOOll\
ll\

=
llOOl\
lll\
ll
;
lllO\
llOl\
lll\

.
lOOOOOOOll\
ll
=
ll\
O\
l\
O\
OO\
OOO
;
#endif //
for
(
lO\
ll\
l\
OlOO\
l\

=
0
;
lOlllOlO\
Ol\

<
lllO\
l\
lO\
lllO
.
lO\
l\
O\
OlOllO
->
lll\
llOlllll
.
lO\
OOlll\
OOl\

(
)
;
lOlll\
O\
lOOl
++
)
lll\
l\
l\
O\
O\
l\
ll\
O
[
lO\
lllOl\
O\
Ol
]
=
lllOl\
l\
Ol\
l\
lO
.
lO\
lOOlOllO\

->
lllllOlllll\

[
lOlll\
O\
lOOl
]
*
lO\
lllOOOOlO
;
lll\
Oll\
Ol\
ll\
l
.
lOOOOOl\
OO\
lO\
l
(
lO\
OOO\
llO\
OOll
,
lll\
l\
lOO\
llOl
,
lll\
l\
lOO\
lllO\

,
*
ll\
OlOO\
OOOO
,
lOlllOO\
OOl\
l
,
k_mF\
rameI\
dentity
,
1.0f
)
;
static\

Vec3
lO\
OOOllO\
lO\
l\
l
[
ll\
lll\
OO\
lO\
l\
l
]
;
MFra\
me\

lOO\
O\
O\
llOll\
OO
=
lOlllOOO\
OlO
.
Ge\
t\
In\
verse\

(
)
;
for
(
lO\
lllO\
lOOl
=
0
;
lO\
lll\
Ol\
O\
Ol
<
lllO\
l\
lOll\
ll
.
lOlO\
OlO\
l\
l\
O
->
ll\
lll\
Olllll
.
lOOOlllOOl
(
)
;
lOlllOlOO\
l
++
)
lO\
O\
OOl\
l\
OlOll
[
lOl\
ll\
O\
lO\
Ol\

]
=
lllOll\
Ol\
lll\

.
lO\
l\
OO\
lOllO\

->
lllll\
Ollll\
l
[
lOlllOlO\
Ol
]
*
lO\
OOOllOllOO
;
ll\
lO\
llO\
ll\
lO
.
lO\
OOOO\
lO\
O\
l\
Ol
(
lOOOOl\
lOO\
lOO
,
lOO\
OOOlOl\
OlO
,
lOOO\
Ol\
lOlOl\
l
,
*
ll\
O\
O\
lll\
ll\
l
,
lOl\
l\
lOOOOll
,
lOlllOO\
OOOl\

,
-
1.0f
)
;
fo\
r\

(
int
lOOOOllOllO\
l\

=
0
;
lOO\
OOl\
lOllOl
<
llOOllllll
->
lOllOl\
l\
lOl\

;
lO\
OOOllOllOl\

++
)
{
int
lOOOO\
l\
lO\
l\
llO
=
lO\
OOOllOll\
O\
l
;
int
lOOOOl\
lOlll\
l
=
llO\
Oll\
l\
lll
->
llOllllOl\
O
[
lOOO\
Oll\
OlllO\

]
.
llOll\
l\
lOOO
;
int
lOOOOlllO\
OOO\

=
(
lOOO\
OllOllOl\

+
1
<
llOOll\
llll
->
lOl\
lOll\
lOl
)
?
lO\
OOOllOllOl
+
1
:
0
;
int\

lOOOOlllO\
OOl
=
llO\
Ollll\
ll
->
llOllll\
OlO
[
lOOO\
Ol\
llOO\
OO\

]
.
llOlll\
lO\
OO
;
lOOOOllOl\
llO
=
lO\
OOOllOll\
ll\

;
lO\
OOOlll\
OO\
OO
=
lOO\
O\
Olll\
OO\
Ol
;
fo\
r
(
in\
t
lOOOOlllOOlO
=
0
;
lOOOO\
ll\
lO\
Ol\
O\

<
llO\
lO\
O\
OOO\
O
->
lOl\
l\
Ol\
l\
lOl
;
lOO\
OOlllO\
OlO
++
)
{
int
lO\
OOOlll\
OOl\
l
=
lOOO\
Oll\
l\
OOl\
O
;
int
lOOOOlllOl\
O\
O
=
llO\
l\
OOOO\
OO\

->
llOlll\
lOl\
O
[
lOOOOlllOO\
l\
l
]
.
llOll\
llOOO\

;
int
lOOOO\
lllO\
lO\
l\

=
(
lOOOOlllOO\
lO\

+
1
<
llOlOO\
OOOO\

->
lOll\
Ol\
llO\
l\

)
?
lOOO\
OlllOOlO
+
1
:
0
;
int\

lO\
OOOl\
llOllO
=
ll\
O\
lOO\
OOOO
->
llOllll\
OlO
[
lO\
O\
OOlll\
Ol\
Ol\

]
.
llOllllOOO
;
lOOOOlll\
O\
Ol\
l
=
lO\
OO\
OlllOlO\
O\

;
lOOO\
Ol\
llOlOl
=
lOO\
OOll\
l\
Oll\
O
;
Vec\
3\

lllllO\
lOOl
;
Vec3
ll\
lllOl\
lll
;
if\

(
Ge\
ome\
try\

::
Fi\
ndClose\
st\
P\
o\
intOnLine\
ToL\
ineU\
nClamp\
ed
(
lllOllOl\
lll
.
lOl\
OOlOll\
O
->
ll\
lllOll\
l\
ll
[
lOOO\
Oll\
lOlO\
O
]
,
ll\
lOllO\
llll
.
lO\
lOOlOllO
->
lllllOlllll
[
lOO\
OO\
lllOll\
O
]
,
ll\
lll\
OOl\
lOl
[
lOOOOllOll\
lO
]
,
lllllOOllOl
[
lOOOOlll\
O\
O\
OO
]
,
lllll\
Oll\
ll
,
ll\
l\
llO\
lO\
O\
l
)
)
{
if
(
lOOOOlOlO\
lll
<
lOOOOlO\
llOOO\

)
{
fl\
oa\
t
lO\
lOlll\
OO\
l
=
llO\
O\
lllll\
l
->
lOOOlOOOOO
.
Dot
(
lllll\
Oll\
ll\

*
lOOO\
OlOlOl\
lO\

)
-
llOO\
llllll\

->
lOl\
Ol\
l\
lOO\
l\

;
if\

(
lO\
l\
Oll\
lO\
Ol
<
-
0.00001f
)
{
Ve\
c\
3
lOO\
OlOOO\
O\
O\

=
llll\
lOl\
lll
-
lllllOlOOl
;
fl\
oat
lOll\
llO\
l\
Ol
=
lOOOlOOOOO
.
Get\
Magnitu\
d\
e\

(
)
;
if\

(
lOllll\
Ol\
Ol
>
0.00001f
)
{
lO\
OOl\
OOOOO
/=
lOll\
llO\
lO\
l
;
Collision\

lOllO\
l\
lO\
lll
;
lO\
ll\
O\
llOl\
ll
.
In\
i\
t\
i\
a\
l\
ise
(
Co\
l\
lis\
io\
n
::
lOl\
lO\
lOOOOO
,
0.0f
,
-
lOlO\
lllOO\
l
,
llll\
lOllll
,
lOO\
OlOOO\
OO
)
;
if
(
!
ll\
lOllllO\
OO\

(
lO\
llO\
l\
lOlll
,
lOl\
ll\
O\
OO\
Oll
)
)
return
;
}
continue\

;
}
}
else\

{
floa\
t
lO\
l\
OlllOO\
l
=
ll\
OlOOOOO\
O\

->
lO\
OOlO\
O\
OO\
O
.
Dot
(
ll\
lllOlOO\
l
)
-
ll\
OlOOOOOO
->
lO\
l\
OlllO\
Ol
;
if
(
lOlOll\
lO\
Ol
<
-
0.00001f
)
{
Vec3\

lO\
OOlOO\
O\
OO
=
lllllO\
l\
lll
-
ll\
ll\
lOl\
OOl
;
fl\
oat
lOllllO\
l\
Ol
=
lO\
OOlOOO\
OO
.
GetMagni\
t\
ud\
e
(
)
;
if
(
lOllllO\
l\
O\
l
>
0.00001f
)
{
lOOOlO\
OO\
OO\

/=
lOllll\
Ol\
Ol
;
Col\
lisi\
on
lO\
llOllO\
lll\

;
lOl\
lOll\
O\
lll
.
Initia\
li\
s\
e
(
Coll\
i\
si\
on
::
lOllOlOOO\
OO
,
0.0f
,
-
lOlOlllOOl
,
lllllOlO\
Ol
,
lOOOlOOOOO
)
;
if\

(
!
lllOllll\
OO\
O
(
lOll\
Ol\
lOlll
,
lOll\
lOOOOl\
l\

)
)
ret\
urn
;
continue\

;
}
}
}
}
if
(
lOll\
l\
OOOOll
->
lO\
llOll\
lO\
ll
)
{
Ve\
c3\

lO\
llll\
OlOO
;
Vec3
lOllllO\
Oll
;
flo\
a\
t\

ll\
llO\
lOO\
ll
;
if
(
Geomet\
r\
y
::
TestEd\
g\
eMovementAgain\
st\
E\
dg\
e
(
lllllOOll\
Ol\

[
lOOO\
O\
ll\
Oll\
l\
O
]
,
lllllO\
OllO\
l
[
lO\
OOOll\
lOOO\
O\

]
,
ll\
lllOO\
ll\
lO
[
lO\
OO\
OllO\
ll\
lO
]
,
lll\
l\
lOOl\
l\
lO\

[
lO\
OOOlllOO\
O\
O
]
,
lll\
Oll\
Ol\
lll\

.
lOl\
O\
O\
lOllO
->
lll\
ll\
Ol\
l\
lll
[
lOO\
O\
Oll\
l\
OlOO
]
,
lll\
Ol\
lOl\
ll\
l
.
lOlOOlO\
llO
->
lllll\
Oll\
l\
ll
[
lOOOOlllO\
llO\

]
,
lll\
lOlOOll\

,
lOl\
lll\
OOll\

,
lOll\
l\
lOl\
OO
)
)
{
if
(
lO\
OO\
OlOlOlll\

<
lOOO\
O\
l\
Ol\
lO\
OO
)
{
if
(
lOl\
lllOlOO
.
Dot
(
ll\
OO\
ll\
llll\

->
lO\
OO\
lO\
OOOO
*
lOl\
llOOOOO\
l
.
m33R\
o\
tation
)
>
0.0f
)
lOllll\
OlOO\

=
-
lOllllOlOO\

;
}
else
{
if
(
lOlll\
l\
Ol\
OO
.
Dot
(
ll\
OlOOO\
OOO
->
lO\
OOlO\
O\
O\
O\
O
)
<
0.0f
)
lOllllOl\
OO
=
-
lOl\
lllOlOO
;
}
Collis\
io\
n\

lOl\
lO\
llO\
lll
;
lOllO\
l\
lO\
l\
ll
.
Ini\
tial\
ise
(
Col\
li\
s\
ion
::
lOl\
lOlOOOOO
,
llll\
OlOOll
,
0.0f
,
lO\
lll\
l\
O\
Oll
,
lOllllO\
l\
OO
)
;
if\

(
!
lllOl\
ll\
lOO\
O\

(
lOllOllO\
ll\
l
,
lO\
l\
llOOOO\
ll
)
)
re\
tu\
r\
n\

;
}
}
}
}
}
void
TAC_CALL
llllOOOOlOO
(
co\
n\
st
MFram\
e
&
lO\
lll\
OO\
OOO\
l
,
co\
ns\
t\

MF\
rame
&
lO\
ll\
lOOOOlO
,
lO\
llOl\
llOOO
*
lO\
lll\
OOOOll
)
{
TA_A\
SS\
E\
R\
T
(
lOlll\
OO\
O\
Oll
->
lOllOOO\
lll\
l\

->
Get\
C\
ol\
lis\
ionOb\
jectType\

(
)
==
Co\
lli\
sionObject\

::
TYP\
E\
_C\
A\
PSULE\

)
;
TA_ASS\
E\
RT
(
lOlll\
OOOOll
->
lO\
ll\
OOlOO\
OO
->
GetCollis\
ionO\
b\
jectType
(
)
==
Colli\
sionObject\

::
TYPE_\
CO\
NVEX
)
;
const
Co\
llisio\
nObjectCapsule
&
lO\
lllOl\
O\
O\
l\
O
=
*
(
Co\
ll\
isionObjec\
tCapsul\
e
*
)
lOlllOOOOll
->
lOllOOOllll
;
co\
nst
Collisi\
onObjectConv\
ex
&
lOOOOlllOlll
=
*
(
CollisionOb\
jectC\
o\
nvex
*
)
lO\
ll\
lOO\
OOll\

->
lOll\
OOl\
OOO\
O
;
bool
lOll\
Ol\
l\
lOll
=
lO\
ll\
l\
OOOOll
->
lOllOlllO\
ll\

;
Vec3
lOl\
l\
lO\
lOO\
O\
O\

[
2
]
;
lO\
lllOlOO\
O\
O
[
0
]
=
lO\
lllOl\
O\
OlO
.
ll\
lOl\
OlOOlO\

*
lOll\
lOOOOOl
;
lOlllO\
lOOOO\

[
1
]
=
lOlllOlO\
Ol\
O
.
ll\
lOlO\
l\
OO\
ll
*
lOlllOOOOOl\

;
Vec3
lOlll\
lOO\
Oll
[
2
]
;
lOll\
l\
lOOO\
ll\

[
0
]
=
lO\
ll\
lOlOOl\
O
.
lllOlO\
lOOlO
*
lOlllOOO\
Ol\
O
;
lOll\
ll\
OO\
Oll\

[
1
]
=
lOl\
ll\
OlOO\
lO
.
lllOlO\
lOOl\
l
*
lOlllO\
OOOl\
O
;
int
lOO\
OO\
O\
lO\
OOO\
O
=
-
1
;
int
lOOOOO\
l\
O\
OOOl\

=
-
1
;
float
lO\
OOOO\
lO\
OO\
l\
O
=
-
k_f\
MaxFloat\

;
lOOOOl\
llOlll
.
lOOO\
OOOllllO
(
2
,
lOlll\
O\
lOOOO
,
lO\
O\
OOOlO\
OOOO
,
lO\
OOOOl\
O\
OO\
Ol\

,
lOO\
OOO\
l\
OOOlO\

)
;
con\
st
Col\
lision\
Obj\
ectConv\
e\
x
::
Po\
lygon
*
ll\
OO\
OlOlO\
O
=
&
llllll\
O\
O\
O\
ll
(
&
lOOOOl\
l\
lO\
ll\
l
,
lOOO\
OOl\
OO\
OOO
)
;
#define lOlllOlOlOl(lOOOllOOOl) lOOOOlllOlll.GetData()->lllllOlllll[llOOOlOlOO->llOllllOlO[lOOOllOOOl].llOllllOOO]
#define lOllllOOOlO(lllOlllllO, lllOlllllll, llOOOlOlOO, lOOOOlllll, lOOOlOOOOO)								\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOllllOOO(lOllOllOlll, lOlllOOOOll);										\
}
#define lOlllOlllOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOlO)				\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOllllOOO(lOllOllOlll, lOlllOOOOll);										\
}
#define lOllllOOOOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lOlllOlOOl, lllOOlllOll, lllOOOlllOO, lOOOOlllll, lOOOlOOOOO)	\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOllllOOO(lOllOllOlll, lOlllOOOOll);										\
}
#define lOlllOllOll(lllllllll, lOOOOOOOOO, lOllOlOlOlO)
#define lOllllOOOOO(lllOOOlllOO)
#define lOlllOlOOOl(llOOlllllO) (llOOOlOlOO->lOOOlOOOOO.Dot(llOOlllllO) - llOOOlOlOO->lOlOlllOOl)
const\

bo\
o\
l
lO\
l\
lll\
Ol\
OO\
l
=
true
;
#include "../Physics/zpta002.inl"
#undef lOlllOlOlOl
#undef lOllllOOOlO
#undef lOlllOlOOOl
#undef lOlllOlllOl
#undef lOllllOOOOl
#undef lOlllOllOll
#undef lOllllOOOOO
}
void
TAC\
_\
CALL\

lll\
l\
OOl\
O\
ll\
l
(
const\

MFrame
&
lO\
ll\
lO\
OOOO\
l\

,
cons\
t\

MFrame
&
lOlllOOO\
OlO\

,
lOl\
lO\
lll\
OOO\

*
lO\
lll\
O\
OO\
O\
ll
)
{
TA_AS\
S\
ERT
(
lO\
lllOO\
OOl\
l
->
lOl\
l\
OOOllll
->
Ge\
tCo\
ll\
i\
sionO\
bj\
ectType
(
)
==
Collision\
Ob\
j\
e\
ct
::
TYPE_CYLIN\
D\
ER\

)
;
TA_\
ASSE\
R\
T
(
lOlllO\
O\
OOll
->
lOllO\
OlOOO\
O\

->
GetC\
o\
llis\
ionObject\
Type
(
)
==
Col\
li\
sionO\
bject\

::
TYPE_CONVEX
)
;
co\
nst
Coll\
i\
si\
on\
O\
bjectCyl\
i\
nde\
r
&
llOOlllOO\
OO\

=
*
(
Coll\
is\
i\
onObjectCylind\
e\
r
*
)
lO\
ll\
l\
OOO\
Oll
->
lOllOO\
Ol\
ll\
l
;
const
Co\
llis\
ion\
Obj\
ect\
Co\
nve\
x
&
lOO\
OOl\
l\
l\
O\
lll
=
*
(
Coll\
ision\
ObjectC\
onvex
*
)
lOll\
lOOOO\
l\
l
->
lO\
llOO\
lOOO\
O
;
bool
lOllOl\
llOll
=
lO\
lll\
OO\
OOll
->
lOll\
O\
lllOll
;
Vec3
lO\
lllO\
l\
OOOO\

[
2
]
;
lOl\
llO\
lO\
OO\
O\

[
0
]
=
llO\
Olll\
OO\
O\
O
.
ll\
l\
O\
l\
OlOOlO
*
lOl\
ll\
OOO\
OO\
l
;
lO\
lllOlO\
OO\
O
[
1
]
=
llOOll\
lOOO\
O
.
ll\
lOlOlO\
O\
l\
l
*
lOlllOOOOO\
l\

;
Vec3
lOl\
ll\
l\
OOOll
[
2
]
;
lO\
llll\
OOOll\

[
0
]
=
llOOll\
lOOO\
O
.
lllO\
lOl\
O\
Ol\
O
*
lOlll\
OO\
OOlO
;
lOl\
l\
ll\
OO\
Ol\
l
[
1
]
=
llOOlll\
O\
O\
OO
.
lllOlO\
lOOll
*
lOlllO\
OOOl\
O\

;
Vec3
ll\
O\
OllO\
ll\
Ol
=
lO\
l\
llOlOOOO
[
1
]
-
lO\
ll\
lO\
lOO\
OO\

[
0
]
;
TA\
_ASSE\
RT
(
ll\
O\
Ol\
lOll\
Ol
.
GetMagnitude
(
)
>
0.0f
)
;
llOOllOllOl
.
Normalise
(
)
;
int
lOOOOOlOOO\
OO
=
-
1
;
int
lOOO\
OOlOO\
OOl\

=
-
1
;
fl\
o\
a\
t
lOOOOOl\
OOOlO
=
-
k_f\
MaxFloat
;
lOOO\
O\
l\
l\
l\
Ol\
ll
.
lOOO\
OO\
OllllO
(
2
,
lOl\
llOlOOOO
,
lO\
OO\
OOlOO\
OOO\

,
lOOO\
OOlO\
OOO\
l\

,
lO\
OOO\
OlOOOlO
)
;
const
Collis\
io\
nObje\
ct\
Co\
nvex
::
Po\
lygo\
n
*
llO\
OOlO\
lOO
=
&
llll\
llOOOll
(
&
lOO\
OOlllO\
ll\
l
,
lOO\
OOO\
lOOOOO
)
;
#define lOlllOlOlOl(lOOOllOOOl) lOOOOlllOlll.GetData()->lllllOlllll[llOOOlOlOO->llOllllOlO[lOOOllOOOl].llOllllOOO]
#define lOllllOOOlO(lllOlllllO, lllOlllllll, llOOOlOlOO, lOOOOlllll, lOOOlOOOOO)								\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOllllOOO(lOllOllOlll, lOlllOOOOll);										\
}
#define lOlllOlllOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOlO)				\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOllllOOO(lOllOllOlll, lOlllOOOOll);										\
}
#define lOllllOOOOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lOlllOlOOl, lllOOlllOll, lllOOOlllOO, lOOOOlllll, lOOOlOOOOO)	\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOllllOOO(lOllOllOlll, lOlllOOOOll);										\
}
#define lOlllOllOll(lllllllll, lOOOOOOOOO, lOllOlOlOlO)
#define lOllllOOOOO(lllOOOlllOO)
#define lOlllOlOOOl(llOOlllllO) (llOOOlOlOO->lOOOlOOOOO.Dot(llOOlllllO) - llOOOlOlOO->lOlOlllOOl)
const\

bo\
ol
lOll\
llO\
lOOl
=
true
;
#include "../Physics/zpta003.inl"
#undef lOlllOlOlOl
#undef lOllllOOOlO
#undef lOlllOlOOOl
#undef lOlllOlllOl
#undef lOllllOOOOl
#undef lOlllOllOll
#undef lOllllOOOOO
}
vo\
id\

TAC_\
CAL\
L
llllOOl\
OllO
(
co\
n\
s\
t
MFram\
e
&
lO\
l\
llOOOOOl\

,
const
MFram\
e
&
lOll\
l\
OO\
OOl\
O
,
lOllO\
ll\
l\
O\
OO
*
lOlllOOO\
Oll\

)
{
TA_A\
SS\
ER\
T\

(
lOll\
l\
O\
OOOll
->
lO\
llOOO\
ll\
ll
->
GetC\
olli\
s\
io\
n\
Object\
Type
(
)
==
Colli\
s\
ionObject\

::
TYPE_\
SP\
HE\
RE
)
;
TA_\
ASSERT
(
lOll\
lO\
OO\
Oll\

->
lOllOO\
lOO\
O\
O
->
Ge\
tColli\
s\
ionObjec\
tType\

(
)
==
Col\
l\
isi\
onObject\

::
TYPE_\
CONVEX\

)
;
con\
st
Colli\
s\
i\
onObje\
ctSphe\
r\
e
&
lll\
OllllOlO\

=
*
(
Col\
l\
i\
sionObjectSphere
*
)
lOll\
lOO\
OO\
l\
l
->
lOllOOOll\
l\
l\

;
co\
nst
Col\
l\
isi\
o\
n\
Ob\
jectConvex
&
lOOOOll\
lO\
l\
ll
=
*
(
Col\
lisionObje\
c\
tConvex\

*
)
lOlllOOOOll
->
lOllO\
O\
lOO\
OO
;
Vec3
lO\
O\
lOlOl\
ll
=
lllOll\
llOlO
.
lllO\
OOOl\
lO\
O
*
lOlllO\
OOOOl
;
Vec\
3
lO\
OlOllOOl\

=
lllOl\
lllOlO
.
lllO\
OOOl\
lOO
*
lO\
l\
llOOOOlO
;
bool
lOl\
lOlllO\
ll
=
lOl\
l\
lOOOOll\

->
lO\
llOlll\
Ol\
l\

;
int
lOOOOOlOOO\
OO
=
-
1
;
int
lOOOOOlO\
OO\
Ol
=
-
1
;
fl\
o\
at
lO\
OOOO\
lOOOlO
=
-
k_fMa\
x\
Flo\
a\
t
;
lOO\
OOlll\
Oll\
l
.
lOOO\
OOOll\
l\
lO
(
1
,
&
lOOl\
O\
lO\
lll
,
lO\
OOOOlO\
O\
OOO
,
lO\
OOOO\
lOO\
O\
Ol
,
lOOOOOlOOOlO
)
;
cons\
t
Colli\
sio\
n\
Object\
Co\
nve\
x\

::
Pol\
yg\
on
*
llOOOlOlO\
O
=
&
ll\
llllOO\
Oll
(
&
lOOOOlllO\
lll\

,
lOOOOO\
lOOO\
O\
O
)
;
#define lOlllOlOlOl(lOOOllOOOl) lOOOOlllOlll.GetData()->lllllOlllll[llOOOlOlOO->llOllllOlO[lOOOllOOOl].llOllllOOO]
#define lOllllOOOlO(lllOlllllO, lllOlllllll, llOOOlOlOO, lOOOOlllll, lOOOlOOOOO)								\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOllllOOO(lOllOllOlll, lOlllOOOOll);										\
}
#define lOlllOlllOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lllllllll, lOOOOOOOOO, lOOOOlllll, lOOOlOOOOO, lOllOlOlOlO)				\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOllllOOO(lOllOllOlll, lOlllOOOOll);										\
}
#define lOllllOOOOl(lllOlllllO, lllOlllllll, llOOOlOlOO, lOlllOlOOl, lllOOlllOll, lllOOOlllOO, lOOOOlllll, lOOOlOOOOO)	\
{																											\
	Collision lOllOllOlll;																				\
	lOllOllOlll.Initialise(																				\
		Collision::lOllOlOOOOO,																				\
		lllOlllllO,																								\
		lllOlllllll,																								\
		lOOOOlllll,																							\
		lOOOlOOOOO);																							\
	lllOllllOOO(lOllOllOlll, lOlllOOOOll);										\
}
#define lOlllOllOll(lllllllll, lOOOOOOOOO, lOllOlOlOlO)
#define lOllllOOOOO(lllOOOlllOO)
#define lOlllOlOOOl(llOOlllllO) (llOOOlOlOO->lOOOlOOOOO.Dot(llOOlllllO) - llOOOlOlOO->lOlOlllOOl)
#define lOOOOllllOOO
const\

bool
lOl\
l\
llOlOO\
l
=
tr\
u\
e
;
#include "../Physics/zpta004.inl"
#undef lOOOOllllOOO
#undef lOlllOlOlOl
#undef lOllllOOOlO
#undef lOlllOlOOOl
#undef lOlllOlllOl
#undef lOllllOOOOl
#undef lOlllOllOll
#undef lOllllOOOOO
}
vo\
id
TA\
C_\
CAL\
L
lllO\
lOOlllO\

(
const
MFram\
e
&
lO\
lllOOOOOl
,
con\
st
MFr\
a\
me
&
lOl\
l\
l\
O\
O\
OO\
lO
,
lO\
llO\
lllOOO
*
lOlll\
OOOOll
)
{
TA\
_ASS\
ERT
(
lO\
ll\
lO\
O\
OO\
ll
->
lOllO\
OOll\
ll
->
GetC\
o\
ll\
i\
sio\
nObjectTy\
pe
(
)
==
Collisio\
nObje\
ct
::
TYPE\
_\
CONVE\
X
)
;
Col\
lisionObjectCo\
nvex\

&
lOOO\
Oll\
llOO\
l
=
*
(
Collis\
io\
nO\
bjectConv\
ex
*
)
lOl\
llOOOOl\
l
->
lO\
llOOOl\
lll
;
TA_ASSER\
T
(
lO\
l\
llOOO\
Oll
->
lOl\
lO\
O\
lO\
OOO\

->
GetCol\
lisio\
nO\
bje\
ctT\
y\
pe
(
)
==
Coll\
is\
ionObj\
e\
c\
t
::
TYPE_C\
ACH\
ED_P\
O\
LY\
_D\
A\
TA
)
;
Collisio\
nObje\
ct\
Cach\
e\
dPol\
yD\
at\
a
&
llOlllllO\
Ol\

=
*
(
Co\
ll\
isionOb\
jec\
t\
Ca\
c\
hedPol\
y\
D\
at\
a
*
)
lOlll\
OO\
O\
Ol\
l
->
lOllO\
OlOOOO
;
TA\
_\
ASSERT
(
lO\
OOOl\
lllOOl
.
lOl\
O\
O\
lOl\
lO
)
;
TA_AS\
S\
ER\
T
(
lOO\
OOlll\
lOOl\

.
lO\
lO\
Ol\
Ol\
lO
->
lllll\
Ollll\
l
.
lOOOlll\
OOl
(
)
<
lllllO\
O\
l\
O\
l\
l
)
;
in\
t
lOlllOlOOl
;
ll\
lllOlOOll
(
)
;
for
(
lO\
lllOlOOl\

=
0
;
lOll\
lOlOOl
<
lOOOOl\
ll\
lOO\
l
.
lOlOOlOl\
lO
->
lllllOlllll
.
lOOO\
ll\
lOOl\

(
)
;
lOl\
ll\
Ol\
OOl
++
)
ll\
ll\
lOO\
llO\
l\

[
lOlllOlO\
Ol
]
=
lOOOO\
ll\
l\
lOO\
l\

.
lO\
lOOlOllO
->
lllll\
O\
ll\
lll
[
lOlllOlO\
Ol
]
*
lOlll\
OOOOOl
;
fo\
r
(
lO\
l\
ll\
OlO\
Ol
=
0
;
lOll\
lOlOOl\

<
lOOOO\
l\
lllO\
Ol\

.
lOl\
OOlOllO\

->
ll\
lllOlll\
ll
.
lOOOl\
llOOl
(
)
;
lO\
l\
ll\
OlOOl\

++
)
llll\
lOO\
lllO
[
lOl\
l\
l\
Ol\
OOl
]
=
lO\
OOO\
lll\
lO\
Ol\

.
lOlOOlO\
llO\

->
ll\
lllOl\
l\
l\
ll
[
lOlllOlOOl
]
*
lOlll\
OOO\
O\
l\
O
;
const
Vec3\

lOOO\
Ol\
lll\
OlO
=
lOOOOllllOO\
l\

.
Get\
D\
a\
ta\

(
)
->
lllOl\
lOO\
OlO
*
lO\
lll\
OOOOOl\

;
for
(
int
lllO\
l\
l\
ll\
ll\
O
=
0
;
ll\
l\
O\
ll\
ll\
l\
lO
<
llOll\
l\
llOOl
.
lOO\
O\
ll\
OOlOO
.
lOOOlllOOl
(
)
;
)
{
CollisionObjectC\
ache\
d\
PolyDat\
a
::
Po\
lygon
*
llOOOlOlOO
=
(
Coll\
isio\
n\
ObjectC\
ached\
PolyDa\
ta
::
Polygon
*
)
&
llOlllllO\
Ol\

.
lOOOllOOlOO
[
lll\
Ol\
lllllO\

]
;
ll\
lOllllllO\

+=
llOllll\
l\
OOl
.
ll\
lOO\
l\
lOOOl
(
llO\
O\
OlO\
l\
OO
->
lOllO\
lllOl
)
;
TA\
_A\
S\
S\
ERT\

(
lO\
OO\
OllllOO\
l
.
GetD\
ata
(
)
->
lllllOlllll
.
lOOOlllO\
Ol
(
)
<
lllllOOlOl\
l
)
;
int
lOOOO\
l\
lllOll
=
0
;
for
(
lOOOOllllOl\
l
=
0
;
lOO\
O\
OllllOll
<
lOOOOl\
lllOOl\

.
Get\
D\
at\
a\

(
)
->
lll\
llOllll\
l
.
lOO\
OlllOOl
(
)
;
lOOOOllllOl\
l
++
)
{
const
Ve\
c3
&
lOOOOl\
llllOO
=
llOO\
Ol\
O\
l\
OO\

->
llO\
llllOlO
[
0
]
.
lOOOOlllll
;
co\
n\
st
Ve\
c3
&
lllllllll
=
lOOO\
OllllOlO
;
const
Vec\
3
&
lO\
OOOOO\
OO\
O
=
lllllOOl\
lOl
[
lOO\
OOl\
lllO\
l\
l\

]
;
fl\
oa\
t
lOl\
Ol\
lO\
lOO
=
llOOOlOl\
O\
O\

->
lOOO\
lOOOOO
.
Dot
(
lllllllll
-
lOO\
O\
Oll\
lll\
OO\

)
;
fl\
o\
at
lOlOll\
OlOl
=
llOO\
O\
lO\
lOO\

->
lO\
OO\
lOOOOO
.
Dot
(
lOO\
O\
OOO\
O\
OO\

-
lOOO\
Ol\
llll\
O\
O
)
;
if
(
lO\
lOl\
lOl\
Ol
>=
0.0f
||
lOlO\
ll\
O\
l\
OO\

<=
0.0f
)
cont\
i\
n\
u\
e
;
TA_AS\
SE\
RT
(
lO\
lOl\
lO\
l\
O\
O
-
lOlOllOl\
Ol
>
0.0f
)
;
fl\
oat
lO\
llllOOlO\
O
=
lOlO\
llOlOO
/
(
lOlOllOlOO
-
lOlOl\
lOl\
Ol\

)
;
Ve\
c3
lOlll\
O\
lllOO
=
ll\
lll\
ll\
ll
+
(
lOOO\
OOO\
O\
OO\

-
lll\
llll\
ll
)
*
lOl\
lll\
OOlOO\

;
in\
t
lOOOllO\
O\
Ol
;
for
(
lOO\
Oll\
OOOl
=
0
;
lOO\
Ol\
lO\
OOl
<
ll\
O\
O\
OlO\
lO\
O
->
lO\
llO\
l\
llOl
;
lO\
OOl\
lO\
O\
Ol\

++
)
{
const
Ve\
c3
&
lOlllOlOlOO
=
llO\
O\
OlOl\
OO\

->
llOlll\
lO\
lO
[
lOOO\
llO\
OOl
]
.
lOOOO\
ll\
ll\
l
;
if
(
llO\
OOlO\
lOO
->
ll\
Oll\
llOlO
[
lOOOllOOOl\

]
.
lOlllOl\
Olll
.
Dot
(
lO\
lllOlllOO
-
lOlllOlOlOO
)
<
0.0f
)
break
;
}
if
(
lOO\
Ol\
lOO\
Ol
!=
ll\
OO\
Ol\
Ol\
OO
->
lOllO\
lllOl
)
con\
ti\
n\
ue
;
con\
s\
t
fl\
oat\

lOO\
OOl\
ll\
ll\
O\
l
=
llO\
OO\
lOlO\
O
->
lOOOlOOOO\
O
.
Dot\

(
lO\
ll\
lO\
lllOO
-
lOOOOOOOOO
)
;
Collision
lOllOllOll\
l
;
lO\
llO\
llOlll
.
Initiali\
se
(
Coll\
isi\
on
::
lO\
llOlOOOOO
,
0.0f
,
lO\
OOO\
lll\
llOl
,
lO\
O\
OOOO\
OOO\

,
llOO\
Ol\
OlO\
O\

->
lOO\
OlOOOO\
O
)
;
lO\
l\
l\
OllOlll\

.
lOl\
lO\
Ol\
O\
O\
lO
=
llOOO\
lOlOO
->
llO\
l\
llO\
lOOO
;
lll\
O\
O\
ll\
O\
lll
(
lOl\
lOll\
Oll\
l
,
lOlllOO\
OOll
)
;
}
int
lOOOO\
llllllO
=
0
;
int
lOOOOl\
lll\
ll\
l
=
0
;
for
(
lOOOOlll\
l\
Ol\
l
=
0
;
lOOOOllllO\
l\
l\

<
lO\
OOOllllO\
Ol\

.
Get\
D\
ata
(
)
->
llll\
lO\
lll\
l\
l
.
lOOOl\
ll\
O\
Ol
(
)
;
lOOOOllllOll
++
)
{
const
Vec3
&
lOOOOl\
llllOO\

=
ll\
OOO\
lOlOO
->
ll\
Ol\
ll\
lOlO
[
0
]
.
lOOOOl\
l\
l\
ll
;
const
Vec3
&
ll\
lllllll
=
lllllOOll\
Ol
[
lO\
O\
O\
Oll\
llOll
]
;
cons\
t
Vec3
&
lO\
OO\
OOOOOO\

=
lllllOOll\
lO
[
lOO\
OOl\
l\
l\
lO\
l\
l
]
;
float
lOlOllOlO\
O
=
llOOOlOl\
OO\

->
lOOOlOO\
OOO
.
Dot\

(
lllllllll
-
lOOOO\
llll\
lOO
)
;
float
lOl\
O\
ll\
OlOl
=
ll\
O\
O\
OlOlO\
O
->
lOOOl\
OOOO\
O
.
Dot\

(
lO\
OOOOO\
OO\
O
-
lOO\
OO\
ll\
ll\
l\
OO
)
;
if
(
lO\
lOl\
lOlOl
>=
0.0f
&&
lOlOll\
OlO\
O
>=
0.0f
)
{
lOOOO\
llllll\
O\

++
;
continu\
e
;
}
if\

(
lOlOl\
lO\
lOO\

<=
0.0f
)
{
if
(
lO\
l\
O\
llO\
lO\
l
<=
0.0f
)
lO\
OOOll\
lll\
ll
++
;
continu\
e\

;
}
TA_AS\
S\
ERT
(
lOlOllOlOO
-
lOl\
Ol\
lOlOl\

>
0.0f
)
;
fl\
o\
a\
t
lOll\
l\
lO\
OlOO
=
lOlOllOlOO
/
(
lOlOllOlO\
O\

-
lOlOl\
lO\
lO\
l
)
;
Ve\
c3
lOlll\
O\
lll\
O\
O
=
ll\
l\
ll\
l\
ll\
l
+
(
lOOO\
OOOOOO
-
lllllll\
ll
)
*
lOll\
l\
l\
O\
OlOO
;
#ifdef _DEBUG
if
(
lO\
OlO\
OOllO
)
{
float
lOOOlOOO\
OO\
OO
=
llOO\
Ol\
Ol\
OO
->
lOOOlOOOOO
.
Do\
t
(
lO\
lllO\
l\
llO\
O
-
lOO\
OO\
l\
llll\
OO
)
;
TA\
_ASSE\
R\
T
(
Fabs
(
lOO\
O\
lOO\
O\
O\
O\
OO
)
<
0.0001f
)
;
}
#endif //
in\
t
lOOOl\
lOOOl
;
for
(
lOOOllO\
OO\
l
=
0
;
lOOO\
llOOO\
l
<
llOOOlOlOO
->
lOllOll\
lO\
l
;
lOOOl\
lOO\
Ol
++
)
{
const
Vec3
&
lO\
ll\
lOlOl\
OO
=
ll\
OOOlOlOO\

->
ll\
O\
ll\
l\
lO\
lO
[
lOOOllOO\
O\
l\

]
.
lOOOOlllll
;
if
(
llOO\
O\
lOlOO\

->
ll\
O\
llllOlO
[
lO\
O\
OllOOOl
]
.
lOlllOlOlll
.
Dot\

(
lOlllOll\
l\
OO
-
lOll\
lOl\
OlOO\

)
<
0.0f
)
br\
e\
ak
;
}
if
(
lOOOllOOOl\

!=
llOOOlOl\
OO
->
lOllOlllOl
)
conti\
nue
;
Col\
lision\

lOll\
Ol\
lOl\
ll\

;
lO\
llOllOll\
l\

.
Initi\
alise
(
Collis\
ion\

::
lO\
llOlO\
OOOO
,
lOlll\
lOOl\
OO\

,
0.0f
,
ll\
l\
l\
l\
llll\

,
llO\
OOlO\
lO\
O
->
lOO\
OlOO\
OO\
O
)
;
lOll\
O\
l\
lOlll
.
lOllO\
O\
lO\
OlO
=
ll\
OOOlOlO\
O
->
llOlll\
O\
l\
O\
OO
;
lllO\
Oll\
Olll
(
lO\
l\
lOllOlll
,
lOlll\
O\
OOOll
)
;
}
if\

(
lOO\
OOlll\
lll\
O
==
lOO\
OO\
l\
lllO\
Ol
.
GetData
(
)
->
lllllOl\
llll
.
lOO\
O\
ll\
lOOl
(
)
||
lOO\
OOllllll\
l
==
lOO\
OOllllOOl\

.
Ge\
tD\
a\
t\
a\

(
)
->
lllll\
O\
lll\
l\
l
.
lO\
OOlll\
OOl
(
)
)
con\
tinue
;
for
(
int
lOOO\
lO\
OOOO\
Ol
=
0
;
lOOOl\
OOOOOOl
<
lOOO\
Olll\
lOOl
.
GetData
(
)
->
ll\
llllO\
O\
OOO
.
lOOO\
lll\
OOl
(
)
;
lOO\
Ol\
OO\
OOOOl\

++
)
{
co\
nst
Collis\
ionOb\
j\
ect\
C\
onve\
x\

::
lllllOll\
OOl
&
llO\
lO\
l\
OO\
l\
O
=
lOOOOllllOOl\

.
Ge\
t\
Da\
ta
(
)
->
ll\
lll\
l\
OOOO\
O
[
lOO\
OlOOO\
OO\
Ol
]
;
cons\
t
Ve\
c3
&
ll\
llll\
lll
=
lOO\
OOllllOlO
;
co\
nst
Ve\
c3\

&
lOOO\
OOOOO\
O\

=
lll\
ll\
O\
OllO\
l
[
llOlOlOO\
lO
.
lll\
llOll\
Oll
]
;
const
Vec3\

&
lll\
lOOlOOO
=
lllllOO\
llOl
[
llOlOl\
OO\
lO
.
lllll\
Oll\
O\
lO
]
;
Vec3
lO\
OOlO\
OO\
O\
O\
lO
=
(
lO\
OOOO\
OOOO
-
lllllllll
)
.
Cro\
ss
(
llll\
O\
O\
l\
O\
O\
O
-
lll\
ll\
llll\

)
;
TA_\
A\
SS\
E\
RT
(
lOOOlOOOO\
O\
lO
.
GetMa\
g\
n\
itudeSq\
rd
(
)
>
0.0f
)
;
Ve\
c3\

lOOOlO\
OO\
OO\
ll
=
lOOOl\
OO\
OOOlO
.
Cro\
ss
(
lOO\
OOOO\
OOO
-
lll\
llllll\

)
;
Vec3
lOO\
OlOO\
OOl\
O\
O\

=
lO\
OO\
l\
OOOOOlO
.
Cr\
o\
ss\

(
llllO\
Ol\
OOO
-
lOOO\
OO\
OOOO
)
;
Vec\
3
lOOO\
l\
OO\
OOlOl\

=
lOO\
Ol\
OO\
OOOlO
.
Cros\
s
(
lllll\
l\
l\
ll\

-
llll\
OOlOOO
)
;
for
(
int
lOOOlOO\
OOll\
O
=
0
;
lOO\
OlO\
OOOllO
<
llOOO\
lOlO\
O
->
lOllO\
lllO\
l
;
lOO\
Ol\
OOO\
OllO
++
)
{
const
Ve\
c3
&
lOllll\
OOl\
lO
=
llOOO\
lOl\
OO
->
llOllllOlO
[
lOOOl\
OOOOll\
O
]
.
lO\
O\
OOl\
l\
lll
;
const
Vec\
3
&
lOll\
l\
OllOlO\

=
llO\
O\
OlOlO\
O
->
llOl\
lllOl\
O
[
lOOOl\
OOOOllO
<
llOOOl\
Ol\
O\
O
->
lOl\
l\
OlllOl
-
1
?
lOO\
OlOO\
OOllO\

+
1
:
0
]
.
lOOOOlllll
;
fl\
oat
lOlOll\
OlO\
O
=
lOO\
OlO\
OOOOl\
O
.
Do\
t
(
lOl\
l\
llO\
OllO
-
lll\
l\
lllll
)
;
flo\
at
lOlOllOlOl
=
lOOOlOOOOOlO
.
Dot\

(
lO\
l\
llOllO\
lO
-
lll\
l\
lllll
)
;
co\
nst\

floa\
t\

lOll\
Ol\
O\
l\
ll
=
0.0001f
;
if
(
(
lO\
lOllOlOl
>
lOllOlOl\
ll
&&
lOlOll\
OlOO
<
-
lOl\
lOlOl\
ll
)
||
(
lOlO\
llO\
lO\
O
>
lO\
llO\
lOlll
&&
lO\
lOllO\
lOl\

<
-
lOllOlOlll\

)
)
{
TA_ASSE\
R\
T
(
Fabs\

(
lOlOllOlOO
-
lO\
lOl\
lOl\
Ol
)
>
0.0f
)
;
float
lOOOlOO\
OOlll\

=
lO\
lO\
l\
lOl\
OO
/
(
lOlO\
llOlO\
O
-
lOlO\
llO\
lOl\

)
;
Vec\
3\

lO\
lllO\
lOl\
O\
O\

=
lOll\
llOO\
llO
+
(
lO\
l\
llO\
l\
lOlO\

-
lOllllOOllO
)
*
lOOOlOOOOlll
;
if
(
lOOOlO\
OOOOll
.
Dot
(
lOlll\
OlO\
lO\
O\

-
llllll\
lll
)
>=
0.0f
&&
lOOO\
lOOOOlOO
.
Dot\

(
lOl\
ll\
OlOl\
O\
O
-
lO\
O\
OOO\
OOOO
)
>=
0.0f
&&
lO\
OOlOOOOlOl
.
Do\
t
(
lO\
lllO\
lOlO\
O
-
llllOOlO\
OO
)
>=
0.0f
)
{
Vec3\

ll\
ll\
lO\
lOOOO
=
(
lll\
l\
OO\
lOO\
O
-
lO\
OOOOOOO\
O
)
.
Cro\
ss\

(
lOlllOll\
OlO\

-
lOl\
l\
l\
lO\
Ol\
lO\

)
;
fl\
o\
at
lOllllOlO\
l
=
llll\
lO\
lOOOO
.
GetM\
agni\
tud\
e
(
)
;
if
(
lOllllOlO\
l
>
lOllO\
lOlll
)
{
lllllOlOOO\
O
/=
lOllllOlOl\

;
if\

(
lllll\
OlOOOO
.
Dot
(
lOl\
llOlOl\
OO
-
llllllll\
l
)
<
0.0f
)
lll\
llO\
l\
O\
O\
OO
=
-
llll\
lOlO\
OOO
;
fl\
oat
lOOOlOOOl\
OOO\

=
Fabs
(
lOOOlOOOOlO\
O
.
Do\
t
(
lOll\
l\
OlO\
lOO
-
lOOOO\
O\
OO\
OO
)
*
ll\
ll\
l\
OlOOOO
.
Dot
(
lO\
OOl\
OO\
OOlO\
O\

)
/
lOOOlOOOOl\
OO
.
GetMa\
gnitudeSqrd
(
)
)
;
lllllO\
lO\
lOl
(
lOll\
lOOO\
O\
ll
,
lOOOl\
OO\
OOOOl
,
llOO\
Ol\
OlOO\

->
llOlllOl\
OO\
O
,
0.0f
,
lOOOlOOO\
lOO\
O
,
lOlll\
OlOl\
OO\

,
lllllOl\
OO\
OO
,
llOO\
OlOlO\
O\

->
lOOOlOOOOO\

,
llO\
OOlOl\
OO\

->
llOllllOl\
O\

[
lOOOlOOOOllO\

]
.
lOl\
l\
lOlO\
lll\

)
;
co\
n\
tin\
ue
;
}
}
}
if\

(
lOlllOO\
O\
O\
ll
->
lOllOll\
lOll
)
{
Vec3\

lO\
llllOlOO
;
Vec3
lO\
llllOOll
;
fl\
oat
llllOlO\
O\
l\
l
;
if\

(
Geom\
etry
::
Te\
st\
Ed\
geMo\
v\
eme\
ntAg\
a\
instEdge
(
ll\
lllOOllOl\

[
llOl\
O\
l\
OO\
lO
.
lllllO\
llOl\
l
]
,
llll\
lOO\
l\
lOl\

[
llOlOlOOlO
.
lll\
llO\
l\
l\
OlO
]
,
llll\
l\
OO\
l\
l\
l\
O
[
ll\
OlOlO\
OlO
.
llll\
l\
OllOll
]
,
ll\
l\
llOOlll\
O\

[
llO\
lOlOOlO
.
ll\
lllOllOl\
O
]
,
lOll\
llOOl\
lO
,
lOll\
lOllO\
lO
,
llll\
O\
lOOl\
l
,
lO\
ll\
l\
lO\
O\
ll
,
lOl\
lllOlOO\

)
)
{
lllllO\
lOlOl
(
lOlllOOOOll
,
lOOOl\
O\
O\
OO\
OO\
l
,
ll\
OO\
OlOlOO\

->
ll\
Ol\
llO\
lOO\
O\

,
llllO\
lO\
O\
l\
l
,
0.0f
,
lOlll\
lOOll
,
lOlll\
l\
OlOO\

,
ll\
OOOlO\
lOO
->
lOO\
OlOOOOO
,
llOOOlO\
lOO
->
llOllll\
O\
l\
O\

[
lOOO\
lO\
OOOllO\

]
.
lOll\
lOlOlll
)
;
}
}
}
}
}
lllll\
OlOlOO\

(
)
;
}
stati\
c
void
ll\
l\
llOl\
OOll
(
)
{
TA_A\
SSE\
RT
(
ll\
lOOlO\
lO\
Ol
==
0
)
;
}
st\
at\
ic
vo\
id
lllllOlOl\
OO\

(
)
{
ll\
lO\
O\
lOlOO\
l
=
0
;
}
sta\
tic\

voi\
d
llll\
lOlOlOl
(
lOl\
l\
O\
lllO\
OO\

*
lOlllOOO\
Oll\

,
int\

lll\
l\
lOlOOOl
,
u3\
2
llOl\
llOlOOO\

,
fl\
oat
lllOl\
lll\
lO
,
flo\
at
lllll\
OlOll\
O
,
co\
nst
Vec\
3
&
lOOO\
Ol\
llll
,
con\
st
Vec\
3
&
lllllOlOOOO
,
cons\
t
Ve\
c\
3
&
llO\
ll\
llll\
Ol
,
con\
st
Vec3
&
lOll\
lO\
lO\
lll
)
{
TA_ASSE\
RT
(
lllOOlOlO\
O\
l
<=
lllO\
Ol\
Ol\
Ol\
O
)
;
int
lllO\
OlllOOO\

;
for
(
lllO\
O\
l\
ll\
OOO\

=
0
;
lll\
OO\
l\
llOOO
<
lllOOl\
O\
l\
OOl
;
lll\
OOl\
llOOO
++
)
{
lllllOOllll
&
lllOO\
lll\
OOl
=
lllllOlOOlO
[
lllOOl\
llOO\
O
]
;
if
(
lllO\
O\
ll\
l\
OOl
.
ll\
ll\
lO\
lO\
OOl
==
ll\
lllOlO\
OOl
&&
ll\
O\
O\
l\
lOOlOO\

::
llOOll\
O\
OlO\
l
(
lll\
OOll\
lOOl
.
lO\
O\
OOlllll\

,
lO\
OOOlllll
)
)
{
if
(
(
lllllO\
lOOOO\

-
lllOOl\
ll\
OOl
.
llll\
lOl\
OO\
OO
)
.
Ge\
tMa\
gn\
it\
u\
deSqr\
d
(
)
>
0.01f
)
co\
nt\
in\
u\
e\

;
Ve\
c3
lOllOOlllll
=
ll\
l\
llO\
lO\
O\
OO
;
if
(
lO\
ll\
OO\
llll\
l\

.
Dot
(
llOllllllO\
l
)
<
0.0f
&&
lOll\
OO\
ll\
lll
.
Dot
(
lllOOll\
lOOl
.
llOl\
lllll\
Ol\

)
<
0.0f
)
lOll\
OOlllll
=
-
lOllO\
Oll\
l\
l\
l
;
if\

(
lOll\
OO\
l\
llll\

.
Do\
t
(
lOl\
llOl\
Olll
)
>
0.0f
)
{
lOllO\
Ol\
l\
lll
=
llOllllllOl
;
lllllOlOllO
=
0.0f
;
}
else\

if\

(
lO\
l\
l\
OOllll\
l\

.
Dot
(
lllO\
OlllOO\
l\

.
lOlllOl\
Ol\
ll\

)
>
0.0f
)
{
lOllOOll\
lll
=
lllO\
OlllOOl
.
ll\
O\
ll\
llllOl\

;
lllllOlOllO
=
0.0f
;
}
ll\
ll\
lO\
lOl\
lO
*=
Fabs
(
lll\
l\
lOlOO\
OO\

.
Dot
(
lOllOOlll\
ll
)
)
;
Colli\
sion\

lO\
l\
lO\
ll\
Ol\
ll\

;
lOllOl\
lOlll
.
Initia\
lise
(
Colli\
sio\
n
::
lOllOlOO\
OOO\

,
lll\
O\
lll\
llO\

,
ll\
lllOlOl\
l\
O
,
lOOOOlllll
,
lOl\
lOOll\
lll
)
;
lOllOl\
lO\
l\
ll
.
lO\
l\
l\
OOlOOlO\

=
llO\
lllOlOOO
;
ll\
lOOllOlll\

(
lOllOl\
lOl\
l\
l
,
lO\
ll\
lOOOO\
ll
)
;
lllOOl\
l\
lOOl\

.
ll\
l\
ll\
OlOOOl
=
-
1
;
brea\
k\

;
}
}
if
(
lllOOlll\
O\
OO
!=
lllOOlO\
lO\
O\
l
)
return
;
if
(
lllO\
OlOl\
O\
O\
l
>=
ll\
lO\
O\
lOlOlO
)
{
re\
tu\
r\
n
;
}
lllllO\
O\
l\
lll
&
lllOOll\
l\
OOl
=
lll\
ll\
O\
l\
OOl\
O
[
ll\
l\
OOlOlO\
Ol\

++
]
;
lllOOl\
ll\
OOl
.
lllll\
OlO\
OOl\

=
llll\
l\
O\
lO\
O\
Ol\

;
lllOOlllOOl
.
lOO\
OOlllll\

=
lOOOO\
ll\
l\
ll
;
lll\
OOlll\
O\
Ol
.
ll\
l\
ll\
OlOOOO
=
lllllOlOOOO
;
lllO\
OlllOOl
.
llOl\
lll\
llOl
=
llOllllllO\
l
;
ll\
lOO\
lllOOl
.
lO\
l\
l\
lO\
l\
Olll
=
lO\
l\
l\
lOl\
Olll
;
ll\
lO\
Oll\
lO\
Ol
.
lOll\
OOl\
OOll
=
ll\
lllOlOllO
;
}
void
TAC_\
CALL
lll\
lOOlOlOl\

(
cons\
t
MFrame
&
lOl\
ll\
O\
OOOO\
l
,
cons\
t
MF\
r\
ame
&
lOlll\
OOOO\
lO
,
lOllO\
l\
llOOO\

*
lOlllOO\
O\
Oll
)
{
TA_ASSERT
(
lOll\
l\
OO\
OOll
->
lO\
llOOOllll
->
Ge\
tCo\
ll\
isi\
onObjectType\

(
)
==
Collis\
ionO\
bjec\
t
::
TYPE_LINE\
_LIS\
T
)
;
TA_\
ASSE\
RT\

(
lOlll\
O\
OOO\
ll\

->
lOll\
OOlO\
OOO
->
GetColl\
ision\
Ob\
ject\
Type
(
)
==
Co\
lli\
s\
i\
onObject
::
TYP\
E_CO\
N\
VEX
)
;
const
CollisionO\
bjec\
tLineL\
i\
s\
t
&
ll\
llO\
OOO\
OOl\

=
*
(
CollisionObjectL\
i\
neLi\
s\
t
*
)
lOlllOOO\
Oll
->
lOllO\
O\
Ollll\

;
con\
st
Co\
l\
lis\
ionO\
bjec\
tC\
o\
nv\
e\
x\

&
lOOOOlll\
Olll\

=
*
(
Collis\
i\
onObject\
Co\
n\
vex
*
)
lOlll\
OOO\
Ol\
l\

->
lOll\
OO\
lO\
OOO
;
for
(
int
lll\
OOO\
OlOO
=
0
;
lllOOO\
Ol\
OO
<
llllOOOOOOl
.
llllO\
OO\
OOl\
l
.
lOOOll\
l\
OOl
(
)
;
ll\
lOO\
O\
OlOO
++
)
{
co\
nst
Ve\
c\
3\

lOOlOlOl\
l\
l
=
lll\
lO\
OOOOOl
.
llllOOO\
OOll
[
lllOOOOlO\
O
]
.
lOO\
lOl\
Olll\

*
lO\
lllO\
O\
OOOl
;
const
Ve\
c\
3
lOOlOll\
O\
O\
l\

=
lll\
l\
O\
O\
OOOOl
.
llllOOOOOll
[
lllOOOOl\
OO\

]
.
lOO\
l\
O\
llOOl
*
lOlllOO\
O\
OOl
;
fo\
r
(
int
ll\
O\
llO\
O\
OO\
l
=
0
;
ll\
OllOOOO\
l
<
lO\
OOO\
ll\
lO\
l\
l\
l\

.
lOlOOlOllO\

->
lOllOOllll
.
lOO\
O\
l\
llOOl
(
)
;
llOllOOOOl
++
)
{
Colli\
sio\
n\
Obj\
ectConvex
::
Pol\
yg\
on
&
lO\
llOOOlOl
=
llllll\
OOO\
l\
l
(
&
lOOO\
OlllO\
lll
,
ll\
OllOOO\
Ol
)
;
flo\
at
lOllllOOOO
=
lOl\
lOOO\
lO\
l
.
lOOOlOO\
OOO
.
Dot
(
lO\
O\
lOlOlll
)
-
lOl\
l\
OOOlOl
.
lOlOl\
llO\
Ol
;
float\

lOllll\
OO\
lO
=
lO\
llOOOlO\
l
.
lOOO\
lO\
OOOO
.
Dot
(
lOOlO\
llOOl
)
-
lOl\
lOOOlOl
.
lOlO\
lllO\
Ol\

;
if
(
lOllllOOOO
<
0.0f
||
lOllllO\
OlO
>=
0.0f
)
co\
ntinue\

;
float
lllO\
llll\
lO
=
lOllll\
OOOO
/
(
lO\
llll\
O\
OOO
-
lOl\
lllOOlO\

)
;
Vec\
3
lOOOO\
O\
Ol\
O\
OO\
O\

=
lOOlOlO\
lll
+
(
lOOlOllOOl
-
lOO\
lOlOlll
)
*
ll\
lOl\
l\
lllO
;
int\

ll\
OlO\
lOllO
;
for
(
llOl\
OlO\
llO\

=
0
;
llOlOlOllO
<
lOl\
l\
O\
O\
OlOl
.
lOll\
Oll\
l\
O\
l
;
llOlOlO\
ll\
O\

++
)
{
co\
nst
Coll\
isionO\
bj\
ec\
t\
Co\
nv\
e\
x\

::
llll\
l\
O\
l\
O\
l\
ll\

&
lOOOOOO\
OllOO
=
lO\
llOOO\
lOl\

.
llOl\
lllOlO
[
llOlOlOll\
O
]
;
cons\
t
Ve\
c\
3
&
llO\
Oll\
lllO
=
lOO\
OOlllOl\
ll
.
lOl\
OO\
l\
Ol\
lO
->
lllllOll\
lll
[
lOOO\
OOOOllO\
O\

.
llOllll\
OOO
]
;
if\

(
lOOO\
OO\
OO\
llOO
.
lOlll\
Ol\
Ol\
ll
.
Do\
t
(
lOOOOO\
OlOO\
OO
-
ll\
O\
OlllllO\

)
<
0.0f
)
brea\
k
;
}
if
(
llOlOlOllO
<
lOllO\
OOlO\
l
.
lOl\
l\
OlllO\
l\

)
co\
ntin\
u\
e
;
Co\
llisi\
on
lOllOllOll\
l\

;
lOll\
O\
l\
lOll\
l
.
In\
it\
i\
al\
ise
(
Collis\
ion
::
lOllO\
lOO\
l\
OO
,
0.0f
,
lllO\
lll\
llO
,
lOOO\
OOO\
lOO\
O\
O
,
-
lOllOO\
Ol\
O\
l
.
lOOOl\
OOOO\
O
)
;
lOllOll\
O\
ll\
l
.
lOllO\
OlOOOl
=
lllOOO\
Ol\
OO
;
if
(
!
lO\
lllO\
O\
OOl\
l
->
lOllOll\
llOO
)
lOllOllOlll
.
lOl\
lO\
Ol\
OOl\
O
=
1
;
else
lOllOl\
l\
Olll\

.
lOllOOl\
OOlO\

=
0
;
if
(
!
lllOllllOO\
O
(
lOllO\
llOll\
l
,
lO\
lllOO\
O\
Oll
)
)
retu\
rn
;
cont\
in\
ue
;
}
}
}
#endif //
}

//---------------------------------------------------------------------------------
// File Name: zpta000.h
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef llOOlOlOlll
#define llOOlOlOlll
#ifndef lOlOlOllOO
#include "../Common/zcta009.h"
#endif //
#ifndef TA_AABB_H
#include "../Common/AABB.h"
#endif //
#ifndef llOOlOllOOO
#include "../Physics/zpta015.h"
#endif //
names\
pa\
ce\

TA\

{
st\
r\
uct
AA\
BB
;
cl\
a\
ss
lOlO\
l\
llllOO\

lOll\
l\
llOl\
Ol
:
pu\
bl\
ic
llOO\
lOllO\
Ol
{
pu\
bl\
ic
:
lO\
lllllOlOl\

(
)
;
~
lOlllllOlOl\

(
)
;
voi\
d
In\
itia\
l\
ise
(
cons\
t
Vec3
&
v3\
Cen\
t\
er
,
float
lOll\
lllll\
l\
O\

)
;
void
Fi\
nali\
s\
e
(
)
;
vo\
i\
d
lOlOlOOO\
Ol\

(
Spa\
ceDivis\
io\
nO\
bje\
ct
&
llOO\
OOO\
OOOO\

)
;
void\

lOOllll\
lll
(
SpaceDivis\
ion\
Obj\
e\
c\
t
&
llOOOO\
OOOOO
)
;
void\

lOl\
llllll\
ll\

(
Sp\
aceDi\
vi\
sionObjec\
t\

&
llOOO\
OOOOOO\

)
;
voi\
d
llOO\
OO\
OOlll\

(
Spac\
eDiv\
is\
ionObject\

&
llOOO\
OOOOOO
)
;
void
llO\
OOl\
O\
O\
llO
(
co\
nst\

AAB\
B
&
lO\
O\
OOOOlll
,
void
(
TAC_CALL
*
ll\
O\
OlOllOlO\

)
(
Space\
DivisionObj\
e\
ct\

&
llOOO\
O\
O\
OOOO
,
void\

*
lOOlllOO\
OO\

)
,
vo\
id
*
lOO\
O\
Ol\
lll\
O\

)
;
vo\
id\

ll\
OOOlOlllO
(
con\
s\
t
Vec3
&
lO\
Ol\
O\
l\
Olll
,
con\
st
Vec3\

&
lOOl\
Oll\
OO\
l\

,
voi\
d
(
TAC_CALL
*
llOOlOllOlO
)
(
SpaceD\
iv\
is\
ion\
O\
b\
j\
e\
c\
t
&
llOO\
OOO\
OOOO
,
void
*
lO\
Ol\
llOOOO
)
,
void
*
lO\
OOOl\
lllO
)
;
pri\
va\
te
:
enum
Flags\

{
llOO\
OOOOOll
=
1
,
llOOOOOOllO
=
2
,
ll\
OOO\
OOlOl\
O\

=
4
,
ll\
OOl\
OOlO\
OO
=
8
,
}
;
struct
ll\
OOOOO\
lOO\
O
{
u3\
2\

llO\
OOOl\
lOlO\

;
u32
llOO\
OOll\
lOO\

;
u32
ll\
OOOOl\
l\
lOl\

;
u32
llOOOOl\
ll\
l\
O\

;
llO\
OOOOlOOO
*
llOOOOO\
l\
lOl
;
Space\
Divisio\
nObject
*
llOO\
O\
OlOl\
lO
;
u8\

lOlOllOOll
;
u8\

llOOOOl\
Ol\
O\
O
;
u8
llOO\
OOlOOlO
;
u8
ll\
O\
l\
lOOll\
l\

;
ll\
O\
OOOO\
lO\
OO
*
llOO\
OO\
l\
O\
Oll
[
8
]
;
}
;
st\
ruct
llO\
OO\
Olllll
{
u32
llOOOOll\
Ol\
O
;
u32\

llOOOOll\
lOO
;
u32\

ll\
OOOOll\
lOl
;
u32
llOOOO\
llll\
O
;
llO\
O\
O\
O\
O\
lOOO
*
llOOOOO\
ll\
Ol
;
SpaceD\
iv\
isio\
n\
O\
bj\
ec\
t
*
llO\
OOO\
lO\
l\
l\
O
;
u8\

lOlOllOO\
l\
l
;
u8
llOOOO\
l\
O\
l\
O\
O
;
u8
llOOOOlO\
OlO\

;
u8
ll\
Ol\
lOO\
l\
ll\

;
}
;
st\
ruct
llOOOO\
O\
l\
Ol\
l
{
u32\

llO\
O\
l\
Ol\
lOll
;
u32
ll\
OOlOlll\
OO
;
u32
ll\
OO\
lOll\
l\
Ol
;
u3\
2
ll\
OOl\
O\
llll\
O
;
ll\
OO\
OOOlOl\
l
*
llOOOOOlllO\

;
llOOOOO\
lOll
*
ll\
OOOOOl\
lOl
;
u8
lOlOllOO\
ll
;
u8
llOOOO\
lOlOO
;
u8
llO\
OOO\
lOOlO
;
u8
llO\
llOO\
lll\

;
llOOOOOlOO\
O
*
ll\
OOOO\
lOOl\
l
[
8
]
;
}
;
str\
uct
llOOO\
OOO\
OO\
l
{
llOOO\
Oll\
lll
ll\
OOOO\
OOlOl\

;
llOOOOOlOO\
O
ll\
OOOOOOOlO
;
}
;
stru\
ct\

llOOO\
l\
O\
l\
O\
OO
{
AABB
lOO\
O\
OO\
Olll
;
u32
llOO\
OOlllO\
O
;
u32\

llOOO\
Ol\
llO\
l
;
u3\
2
llO\
OOOll\
llO
;
u3\
2\

llO\
OOlOlOl\
O
;
u32
llOOOl\
OlOll\

;
u32
llOOOl\
OllOO
;
void\

(
TAC_\
C\
ALL\

*
llOOOl\
OOlll
)
(
Spac\
eDivisi\
onOb\
je\
ct
&
llO\
O\
O\
OOOOOO
,
void
*
lO\
OOOllllO
)
;
void\

*
lO\
OO\
O\
l\
l\
l\
lO\

;
}
;
struct
llO\
OOllOOO\
l\

{
void
(
TAC_\
CA\
L\
L
*
llOO\
O\
l\
OOlll
)
(
SpaceDivisi\
onO\
bj\
e\
ct
&
llOO\
O\
OOOO\
OO
,
void\

*
lOO\
OOll\
llO\

)
;
voi\
d
*
lOOOO\
llllO
;
fl\
oat\

lOOlOl\
l\
OO\
O
;
Vec3
lOO\
lOlOlll\

;
Ve\
c3
lOOlOll\
OO\
l
;
st\
r\
uct\

Axi\
s
{
fl\
oat\

llOOO\
l\
lOOll\

;
fl\
o\
at
ll\
OO\
O\
ll\
OOlO\

;
float
llO\
O\
OllOlO\
O\

;
int
llOOOllOlO\
l\

;
fl\
o\
a\
t
ll\
OO\
O\
llO\
llO
;
fl\
oa\
t
ll\
OO\
OllOlll
;
}
;
Axis\

lO\
O\
OO\
Oll\
Ol
[
3
]
;
}
;
Ve\
c\
3
lOlllllOllO\

;
float\

lOl\
llllOl\
ll
;
ll\
OOOOOlOOO
*
lOllll\
OlllO
;
llOOO\
OO\
l\
Oll
*
lOlll\
lllOOO
;
#ifdef _DEBUG
in\
t
lOllllllO\
Ol
;
int
lOl\
lllll\
Ol\
O
;
in\
t
lOl\
lllllOl\
l
;
int\

lOl\
llllll\
Ol\

;
int
lOlllll\
ll\
OO
;
#endif //
bo\
ol
lOl\
llllOOll
(
llO\
OOOOl\
OOO
*
llO\
O\
Olll\
OlO
)
;
boo\
l
lO\
l\
l\
lll\
OO\
Ol
(
SpaceDivis\
ionObject\

*
llOOO\
OllO\
O\
O
)
;
bool\

lOll\
lll\
OOOl
(
const\

ll\
O\
O\
OOOlOOO
*
llOOOlllOOl
)
;
void\

ll\
OOOlOllOl
(
ll\
OOOOOl\
OOO
*
llO\
O\
OOOlOO\
l
,
llO\
OO\
lOlO\
O\
O
&
llOOOl\
O\
lOOl\

)
;
void
llO\
O\
Oll\
lOOO
(
ll\
OOO\
O\
OlOOO\

*
llOOOOOlOOl
,
ll\
OO\
OllOOO\
l
&
llOOOlOl\
OO\
l
)
;
vo\
id
llO\
OOlO\
O\
O\
OO
(
llOO\
OOll\
lll
&
lOOl\
OOllll\
O
)
;
void
llOOO\
l\
OOlO\
O\

(
llOOOO\
O\
l\
OOO
*
llOOOO\
Ol\
OOl
)
;
vo\
id\

ll\
OOOlO\
OlOl
(
llOOO\
O\
Ol\
OOO\

*
llOOO\
O\
OlOO\
l
)
;
llO\
OOOO\
lOO\
O
*
llO\
OOlll\
lOl
(
llOO\
OO\
OlOOO
*
llOO\
OOOlOOl
,
llOOO\
OOlOOO
*
*
ll\
OOlOOllOO
,
llOOOOl\
l\
l\
ll
&
lOOl\
OOllllO\

)
;
void\

llOO\
lOOOOl\
O
(
llOOO\
OOl\
O\
OO
*
llOO\
O\
OOlO\
Ol
,
llOO\
OO\
l\
llll\

&
lOOlO\
Ol\
lllO\

,
u32
llOO\
l\
OOO\
OO\
l
)
;
void
llOO\
lOOOOll\

(
llO\
OOOOlOOO
*
ll\
OOO\
OOl\
OO\
l
,
llOOOO\
l\
l\
ll\
l
&
lOOlO\
Oll\
llO
)
;
voi\
d
llOO\
lOOO\
lOO
(
llO\
OO\
OOlO\
OO
*
ll\
O\
OOO\
O\
l\
O\
Ol
,
ll\
OOOOllll\
l
&
lOOlOOll\
l\
l\
O
)
;
llOOO\
O\
OlOOO
*
llOOOOlOOOO
(
)
;
vo\
id
ll\
OOOOOOlOO\

(
ll\
OOOO\
O\
lO\
OO\

*
llO\
O\
OO\
OlOOl
)
;
vo\
id\

ll\
OOlOOOlll
(
llO\
O\
OOOlOOO
*
llOOOOOlO\
Ol
)
;
vo\
id\

ll\
OOlO\
lO\
O\
Ol
(
ll\
OO\
O\
O\
Ol\
OOO
*
ll\
OOlOlOOlO
)
;
vo\
id
llOOl\
OO\
OllO
(
llOO\
OOOlO\
OO\

*
*
llOO\
l\
O\
lO\
Oll
)
;
void
llO\
Ol\
OOlOOl
(
llOO\
OO\
O\
lOOO
*
*
llO\
O\
l\
O\
Oll\
OO
)
;
void
lOl\
l\
llO\
llll
(
)
;
void
lO\
lll\
lOll\
Ol\

(
ll\
OOOO\
O\
lO\
OO
*
llOOOO\
OlOOl\

)
;
void
lOl\
l\
llOllOl
(
ll\
OOOO\
Ol\
OO\
O
*
llOOOOOl\
OOl
,
int
&
llOll\
O\
Olll
)
;
boo\
l\

lOlllllOOOl
(
co\
n\
st
llO\
OOOOlOOO
*
llOOOOOlOOl
,
cons\
t
llOOO\
OOlOOO\

*
ll\
OOOlllO\
Ol\

)
;
bo\
o\
l\

lO\
lllllO\
OOl
(
cons\
t
ll\
OOOOOlOOO
*
llO\
OO\
O\
Ol\
OOl\

,
co\
nst
Sp\
aceDiv\
isio\
nO\
bject
*
llOOO\
lll\
OOl
)
;
void
llOOlOl\
l\
lll
(
llOOOOOlOO\
O
*
llOO\
OOOl\
OO\
l
)
;
bool
ll\
OOO\
OlOOOl
(
const\

llOO\
O\
OOlOOO
*
llOOOOOlO\
Ol\

)
{
re\
t\
u\
rn\

(
llOOOOO\
lOOl
->
lOl\
O\
llOO\
ll
&
(
llOOO\
OOOO\
l\
l
|
llO\
O\
O\
OOOllO
)
)
==
ll\
O\
O\
O\
OO\
OOl\
l
;
}
bool
llO\
O\
lO\
OO\
l\
Ol
(
const\

ll\
OOOOO\
lOO\
O
*
llO\
OO\
O\
OlOOl
)
{
retu\
r\
n
(
llO\
O\
OO\
O\
lO\
O\
l
->
lO\
l\
Ol\
lOOll\

&
(
ll\
OOOOOOOll\

|
llOO\
OO\
OOllO
)
)
==
llOOOO\
OOll\
O\

;
}
sta\
tic
u32
TA_FAST\
_CAL\
L\

ll\
OOOOll\
O\
ll
(
u3\
2
lOOll\
OlOOOO
)
{
#ifdef TA_ASM_LOG2
re\
tur\
n
2
<<
Lo\
g2
(
lOOllOlOOOO
|
1
)
;
#else
lO\
Oll\
OlO\
O\
O\
O
--
;
lOOllOlOOOO
|=
lOO\
l\
lO\
lOO\
O\
O
>>
1
;
lOO\
llOl\
OOO\
O
|=
lO\
O\
llOl\
OO\
O\
O
>>
2
;
lO\
OllOl\
O\
OOO\

|=
lOOllOlOOOO\

>>
4
;
lO\
OllOlOOO\
O
|=
lOOllOl\
OO\
OO
>>
8
;
lOO\
llOlOOOO\

|=
lOOll\
OlOOOO
>>
16
;
lOO\
l\
l\
O\
lOOOO
++
;
retur\
n
lOOllO\
lOOOO\

;
#endif
}
static
u32
TA_FAST_CALL
llOOlO\
OlOlO
(
unsigne\
d
int
lOOl\
lOl\
OOOO
)
{
TA_\
ASSE\
R\
T\

(
(
lO\
Oll\
O\
lO\
O\
O\
O
&
(
lOO\
llOlO\
OOO
-
1
)
)
==
0
)
;
TA_\
A\
SSER\
T
(
lOO\
ll\
O\
l\
O\
OOO
<
0x100
)
;
sta\
tic\

cons\
t
int\

llOOllOOOO\
O\

[
8
]
=
{
0
,
1
,
2
,
4
,
7
,
3
,
6
,
5
}
;
retu\
rn
llOO\
l\
lO\
OOOO
[
(
lOOllOl\
OOOO\

*
0x17000000
)
>>
29
]
;
}
}
;
}
#endif //

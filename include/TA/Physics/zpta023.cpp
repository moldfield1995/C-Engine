//---------------------------------------------------------------------------------
// File Name: zpta023.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#define TA_PHYSICS_INTERNAL
#define lOllOllOOlO
#ifdef _DEBUG
#endif //
#include "Physics.h"
#ifndef TA_GEOMETRY_H
#include "../Common/Geometry.h"
#endif //
#ifndef lOOllOllll
#include "../Common/zcta001.h"
#endif //
#ifndef lOOlOOlllll
#include "../Common/zcta010.h"
#endif //
#ifndef TA_RANDFUNC_H
#include "../Common/RandFunc.h"
#endif //
#ifndef lOOOOlOlOl
#include "../Common/zcta006.h"
#endif //
#ifndef TA_STACKALLOC_H
#include "../Common/StackAlloc.h"
#endif //
#ifndef lOllOOOllllO
#include "../Physics/zpta014.h"
#endif //
#ifndef TA_DYNAMICOBJECT_H
#include "DynamicObject.h"
#endif //
#ifndef lOlOlllOllll
#include "../Physics/zpta008.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMBO_H
#include "CollisionObjectCombo.h"
#endif //
#ifndef TA_COLLISIONOBJECTCOMPLEX_H
#include "CollisionObjectComplex.h"
#endif //
#ifndef TA_COLLISIONOBJECTAABBMESH_H
#include "CollisionObjectAABBMesh.h"
#endif //
#ifndef TA_COLLISIONOBJECTCACHEDPOLYDATA_H
#include "CollisionObjectCachedPolyData.h"
#endif //
#ifndef llOllOOOlOO
#include "../Physics/zpta002.h"
#endif //
#ifndef lOOlOOllllOO
#include "../Physics/zpta005.h"
#endif //
#ifndef llOOlOlOlll
#include "../Physics/zpta000.h"
#endif //
#ifndef llllOOOOllO
#endif //
#ifndef lOOllOOlOOOl
#include "../Physics/zpta011.h"
#endif //
#ifndef TA_PHYSICSJOINT_H
#include "PhysicsJoint.h"
#endif //
#ifndef TA_PHYSICSRENDER_H
#include "PhysicsRender.h"
#endif //
#ifndef llllOOOOlll
#include "../Physics/zpta010.h"
#endif //
#include <memory.h>
#ifdef lOllOOOlllll
#include <crtdbg.h>
#endif //
#ifdef TA_ENABLE_PRE_FETCH
#define lOllOOlOOOOO
#endif //
#ifdef lOllOOlOOOOO
#include <mm3dnow.h>
#include <xmmintrin.h>
#include <emmintrin.h>
#define lOllOOlOOOOl(lOllOOlOOOlO) lOllOOlOOOll((char*)(lOllOOlOOOlO), lOllOOlOOlOO)
#define lOllOOlOOlOl(lOllOOlOOOlO) lOllOOlOOOll((char*)(lOllOOlOOOlO), lOllOOlOOlOO)
#else
#define lOllOOlOOOOl(lOllOOlOOOlO)
#define lOllOOlOOlOl(lOllOOlOOOlO)
#endif //
name\
sp\
a\
ce
TA
{
ex\
tern
float\

lOOlOl\
llll\
lO\

;
#define lOllOOlOOllO
#define lOllOOlOOlll	
#define lOllOOlOlOOO
lOOlOl\
l\
OllO
(
lOll\
O\
OlO\
lO\
Ol
)
;
lOO\
l\
Ol\
lOllO
(
lOllOOl\
Ol\
OlO
)
;
lOO\
lOllOllO
(
lOllO\
OlOlOll
)
;
lO\
OlO\
llOllO
(
lOl\
lOO\
lOllO\
O\

)
;
lOOlOl\
lOllO\

(
lOllOOlOl\
lOl\

)
;
lO\
OlOllOllO
(
lO\
ll\
O\
O\
l\
Ol\
ll\
O
)
;
lO\
O\
lOllO\
llO
(
lOll\
O\
O\
lO\
l\
l\
ll
)
;
lOO\
lO\
l\
lOllO
(
lOll\
OO\
llO\
O\
OO
)
;
#ifdef lOllOOOlllll
#define lOllOOllOOOl()											\
{																		\
	lOllOOllOOlO lOllOOllOOll;											\
	lOllOOllOlOO(&lOllOOllOOll);
#define lOllOOllOlOl(lllOOOOllO)										\
	 lOllOOllOOlO lOllOOllOllO;											\
	 lOllOOllOlOO(&lOllOOllOllO);									\
	lOllOOllOOlO lOllOOllOlll;											\
	_CrtDbgReport(_CRT_WARN, 0, 0, 0, "---------------------------\n");	\
	_CrtDbgReport(_CRT_WARN, 0, 0, 0, lllOOOOllO);							\
	_CrtDbgReport(_CRT_WARN, 0, 0, 0, "---------------------------\n");	\
	lOllOOlllOOO(&lOllOOllOlll, &lOllOOllOOll, &lOllOOllOllO);			\
	lOllOOlllOOl(&lOllOOllOlll);								\
}
#else
#define lOllOOllOOOl()
#define lOllOOllOlOl(lllOOOOllO)
#endif
extern
voi\
d\

lOl\
lO\
ll\
OOOO
(
Co\
l\
lisi\
on\

*
lO\
l\
lOl\
lOO\
O\
l
,
Co\
lli\
sion
*
lOOOOOlOO\
Ol
)
;
st\
ru\
ct
lO\
llOOl\
llOlO\

{
lO\
llOO\
lll\
OlO\

(
Coll\
isi\
o\
n
&
lOll\
OOlllOll\

)
:
llOlll\
lOlll
(
lOll\
OOl\
llOll
)
{
}
float
lOOl\
OllO\
O\
O
;
int\

lOl\
OllOOll\

;
Dy\
namicO\
bje\
ct\

*
lOlll\
OOlO\
OO
;
Vec\
3
lO\
OlO\
lOl\
ll\

;
Vec3
lO\
OO\
lOOO\
OO
;
Coll\
ision
&
llO\
llllOlll
;
}
;
struct\

lOll\
OOll\
ll\
OO
{
Phys\
i\
c\
s\

*
lOl\
O\
ll\
llO\
Ol\
O
;
lO\
l\
O\
OOOOOll\
l
*
lOlOOOO\
OllOO\

;
Dyn\
a\
mi\
c\
Object\

*
lOlOOOOO\
l\
lOl
;
Dynam\
i\
c\
Ob\
j\
e\
ct
*
lOl\
OOOOOlllO\

;
void
Ini\
tia\
l\
ise
(
Ph\
y\
s\
i\
cs
*
lOll\
OOl\
lll\
Ol\

)
{
lO\
l\
Ol\
ll\
lOOlO
=
lOllOOll\
llOl\

;
lOl\
OOO\
OOllOl
=
0
;
lOlOOOO\
OlllO
=
0
;
lO\
lO\
O\
OOO\
llOO
=
0
;
}
}
;
st\
atic
cons\
t
flo\
at
lOl\
lOOlllllO
=
0.6f
;
st\
at\
i\
c
const
flo\
a\
t\

lOllOOlll\
l\
ll\

=
0.005f
;
static
co\
n\
st
fl\
oat\

lOl\
lOlOOOOOO
=
0.002f
;
stati\
c
co\
nst
int
lO\
llOl\
O\
O\
OOOl
=
4
;
fl\
o\
at
lOlO\
llll\
lOll
=
1.0f
;
const
fl\
oat\

lOll\
OlOOOOlO\

=
100000000000.0f
;
Physic\
s
*
Phy\
sics
::
lO\
l\
l\
OlOOOOll
=
0
;
#ifndef DOXYGEN
static\

inl\
ine
float
lOl\
l\
OlO\
OOlOO
(
co\
n\
s\
t\

Vec3
&
lOllO\
lO\
OOlOl
)
{
re\
t\
urn
lOl\
lO\
lOOOlOl
.
x
*
lO\
llOl\
OOOlOl\

.
x
+
lOl\
l\
Ol\
OO\
O\
lOl\

.
z
*
lOllO\
lOOOlOl
.
z
;
}
st\
atic
in\
l\
ine\

floa\
t
lOl\
lOlOOOll\
O
(
fl\
oat
lOOll\
lOOlll\
l\

)
{
retur\
n\

1.0f
-
Exp
(
-
lO\
OlllO\
O\
ll\
l\
l
*
3.0f
)
;
}
st\
ruct
Phy\
si\
cs
::
lOllOlOO\
Oll\
l
{
float\

lOOOl\
OOllO\

;
Col\
lision
*
llOllOlOlll
;
}
;
#endif //
void
TAC_CALL
lOl\
lOlO\
OlOO\
O
(
con\
st
AABB
&
lOl\
lOlO\
O\
l\
OOl
,
const
Vec3\

&
lOll\
OlO\
Ol\
OlO
,
u32
lOlOllOOll
,
fl\
o\
at
lOllOl\
OOl\
O\
l\
l
,
in\
t
lOllO\
lOOl\
lOO
)
{
TA
::
Ph\
ysics\

::
Cr\
e\
a\
teIn\
stance
(
lOl\
lOlOO\
l\
OOl
,
lOllOlO\
O\
lOl\
O\

,
lOl\
O\
llOOll
,
lOllOlOOl\
Oll
,
lOllOlOOllOO
)
;
}
void\

TAC_CAL\
L\

lO\
llO\
lO\
Ol\
OOO
(
)
{
TA\

::
Physics\

::
Creat\
eIns\
t\
ance\

(
)
;
}
#ifndef TA_REMOVE_DEPRECATED
void
TAC_CALL\

Ph\
ys\
ic\
s
::
Crea\
te\
In\
stan\
c\
e
(
cons\
t
AA\
BB
&
lOllOl\
OOl\
OOl
,
con\
st
Vec3\

&
lOllOlOOlOl\
O
,
u32\

lOlOllOOl\
l
,
fl\
oat
lOllOlO\
O\
lOll\

,
int
lOl\
l\
OlOO\
l\
l\
OO
)
{
if
(
lOllOlOOOOll
)
return\

;
lOOO\
OOllOl\
O\

(
lOll\
O\
lO\
OO\
Ol\
l\

,
Phy\
sics
)
;
lO\
llOl\
O\
OO\
Oll
->
Init\
ial\
is\
e
(
lO\
llOlOOlO\
O\
l
,
lOl\
lO\
lOO\
lO\
lO
,
lOlOl\
lOOll\

,
lOl\
lOlOOlOll\

,
lO\
llOl\
OOllOO\

)
;
}
#endif //
void
TAC_C\
ALL
Physics\

::
Cre\
ateInstance
(
)
{
if
(
lO\
ll\
OlOOOOl\
l
)
re\
t\
urn
;
lO\
OO\
OOllOlO
(
lO\
ll\
Ol\
O\
O\
OO\
l\
l
,
Phy\
si\
cs
)
;
lO\
ll\
O\
lOOOO\
ll
->
Initi\
al\
is\
e
(
)
;
}
voi\
d
TAC_C\
ALL
Physics
::
De\
s\
tro\
yI\
nstance\

(
)
{
if
(
!
lO\
l\
lO\
l\
O\
OOO\
ll
)
return
;
lOO\
lO\
OOO\
OO
(
lOllOlOO\
OOll
,
Physics\

)
;
lOl\
lOlOOOOll\

=
0
;
}
void
Phys\
ics
::
SetupSimula\
tion\

(
)
{
if
(
(
lll\
O\
llOOOO
&
lOllOlOO\
ll\
Ol
)
==
0
)
return
;
TA_\
ASSE\
R\
T
(
lOOl\
l\
O\
llllOO
)
;
lllOllOOOO
|=
lOl\
lO\
lOO\
lllO
;
lll\
OllO\
OOO
&=
~
lOllOlO\
O\
llOl
;
if\

(
lOllOlOOllll
)
{
if
(
lO\
llOlOlOOO\
O
.
lOll\
OlOlO\
O\
Ol
!=
lO\
llOlOlO\
O\
lO\

.
lOllOlO\
lOOOl\

||
lOll\
O\
lOlOOOO
.
lOl\
Ol\
ll\
lOll\
l
!=
lOl\
lOlOlOOlO
.
lOlO\
llll\
Olll
)
{
lOOlOOO\
OOO
(
lO\
l\
lOlOO\
lll\
l
,
lOll\
OlOlOOl\
l
)
;
lOl\
lO\
l\
O\
Ol\
l\
ll\

=
0
;
}
}
if\

(
lOl\
l\
OlOlOlOO
)
{
if
(
lOllOlOlOOO\
O
.
lO\
llOlO\
lOlOl\

!=
lOll\
OlO\
lO\
OlO
.
lOl\
lOl\
OlOlO\
l
||
lO\
llOl\
OlOOOO
.
lO\
llOlOO\
lOOl
.
v3Ce\
nter
!=
lO\
ll\
O\
lOlOOOO\

.
lO\
l\
lOlO\
O\
l\
O\
Ol\

.
v3Center
||
lOllOl\
O\
l\
OOOO
.
lOl\
lOlOOlO\
O\
l
.
v3\
E\
xtent
!=
lOllO\
lOlOO\
OO
.
lOllOlOOlOO\
l
.
v3E\
xtent\

||
lOl\
l\
OlOlOOOO
.
lOllOlOlO\
llO
!=
lOllOl\
O\
lO\
OlO
.
lO\
llOlOlOllO
||
lOll\
OlO\
lOOOO
.
lOllOlOl\
O\
l\
ll
!=
lOl\
l\
O\
l\
OlOOlO
.
lOllO\
lO\
lOl\
ll
)
{
lOllOl\
O\
l\
lOOO
lOlOO\
lOOlO
=
lOll\
OlO\
ll\
O\
Ol
.
lOlOO\
OOlO\
O
(
)
;
for
(
;
!
lOlOOl\
OOl\
O
.
At\
End\

(
)
;
++
lOlOOlO\
OlO\

)
{
Dynami\
cO\
bject\

&
lOllOl\
OllO\
lO
=
*
*
lO\
lO\
Ol\
OOlO
;
lOllOlOlOl\
OO
->
lOOllllll\
l
(
lOl\
lOlOllO\
lO
)
;
lO\
llOlO\
lOlOO\

->
llO\
OOOOOlll
(
lOllOlOl\
l\
Ol\
O
)
;
if
(
lOllOlO\
lO\
O\
lO
.
lOl\
l\
OlO\
lOlOl
==
SPACIAL_DIV\
ISION_TY\
PE_\
C\
TR\
EE
)
lO\
llOlOllOlO\

.
lOlOOOllO\
OlO
(
)
;
}
lOOlO\
OOOOO
(
lOllOlOlOlOO
,
ll\
O\
OlOllOOl
)
;
lO\
llOl\
OlOl\
OO\

=
0
;
}
}
if\

(
lOl\
l\
OlOllOl\
l\

)
{
if\

(
lOl\
l\
OlO\
lOO\
OO
.
lOlOl\
lll\
OO\
l\
l
!=
lOllOlOlOOl\
O
.
lO\
lOl\
lllOOll
)
{
lOO\
l\
OOOO\
OO
(
lOll\
O\
lO\
llOll
,
lO\
l\
lOlOlllOO
)
;
lOll\
OlOll\
Oll
=
0
;
}
}
if
(
lOllOlOlllOl
.
lOO\
lOO\
lOOll\

(
)
)
{
if\

(
lO\
l\
lO\
lO\
lOOOO
.
lOlO\
ll\
l\
lOlO\
O
!=
lOllOl\
O\
l\
OOlO
.
lOlOllllOlOO
)
{
lO\
ll\
Ol\
Ollll\
O
.
Fina\
lis\
e
(
)
;
lOllOlOll\
l\
Ol
.
Finalise
(
)
;
}
}
lO\
llO\
O\
llOO\
Ol\

(
)
;
lOllOO\
ll\
OOOl
(
)
;
if
(
!
lOl\
lOlOOl\
lll
)
{
lOOll\
Olll\
l\
OO
->
lOlOl\
l\
llOllO\

=
lOllOlOlOOOO
.
lOllOlOlOOOl
;
lOO\
l\
lO\
ll\
l\
lOO
->
lO\
l\
O\
ll\
ll\
O\
ll\
l
=
lOllOl\
OlOOOO\

.
lOlO\
l\
l\
l\
lO\
lll
;
lOOO\
OO\
llOlO
(
lOllOlOOllll
,
lOllOlO\
lOOll
)
;
lOllO\
lOOlll\
l
->
Initia\
l\
i\
se
(
lO\
OllOl\
lll\
O\
O
->
lO\
lOlll\
lOll\
O
,
lO\
O\
llOl\
lll\
OO\

->
lOl\
Oll\
llOl\
ll
)
;
}
lOl\
lOOll\
OlOl
(
"Memory report for matrix solver:\n")
;
lOllOOl\
lOO\
Ol\

(
)
;
if
(
!
lOl\
lO\
lO\
lOl\
OO
)
{
ll\
l\
OllO\
O\
OO
&=
~
(
Physics
::
FLAG_XY_COL\
LIS\
ION\
_GRID
|
Phy\
sics
::
FL\
AG_X\
Z_COL\
LISION\
_GR\
ID
|
Ph\
ysics
::
FLA\
G_YZ\
_COL\
LI\
SION\
_G\
RI\
D
)
;
switch\

(
lOl\
lOlOl\
O\
OOO\

.
lO\
ll\
Ol\
OlOlOl
)
{
case
SPA\
C\
IAL_DIVIS\
IO\
N_TYPE_XY_CO\
L\
LISION_\
G\
RID
:
ca\
se\

SPA\
CIAL\
_DIV\
IS\
I\
ON_TYPE_XZ_C\
OL\
LISION\
_GR\
I\
D
:
case
SPACI\
AL_\
DI\
VISIO\
N_TYPE_\
YZ\
_C\
OLL\
ISION\
_GR\
I\
D
:
{
int
llO\
lO\
lOllOl
=
0
;
int\

llOl\
OlOlll\
O
=
2
;
sw\
it\
ch
(
lOllOlO\
lOOOO
.
lOl\
lO\
lOlO\
lOl
)
{
cas\
e
SPACIAL\
_\
D\
IV\
IS\
ION_TY\
PE\
_\
XY_C\
O\
LLISI\
ON_GR\
ID
:
llOlOlOllOl
=
0
;
llOlO\
lOll\
l\
O
=
1
;
lllOl\
lO\
O\
OO
|=
FLAG_X\
Y_\
COL\
LI\
S\
ION_GRI\
D
;
bre\
ak
;
case
SP\
AC\
IAL_\
DIVISION\
_TY\
PE\
_XZ\
_COLLIS\
ION\
_GRID
:
llOl\
OlOl\
lOl
=
0
;
llO\
lO\
lO\
l\
llO
=
2
;
ll\
lO\
l\
lOOOO
|=
FLAG\
_\
XZ_COLL\
ISION_G\
RID
;
break
;
ca\
se
SPACI\
A\
L_D\
I\
VISIO\
N_TYPE\
_YZ_\
COLLISION_GR\
I\
D\

:
llOlO\
lOllOl
=
1
;
llOlOlOlllO
=
2
;
lllOllOOO\
O
|=
FLAG_\
Y\
Z\
_C\
OL\
L\
ISI\
ON\
_GRI\
D
;
br\
ea\
k
;
}
ll\
OlOlO\
OOOl
*
lOllOl\
Olll\
ll\

;
lOOO\
OOll\
O\
l\
O\

(
lOllOlOll\
lll
,
llOlOlOO\
OOl
)
;
lO\
llOl\
Ollll\
l
->
Init\
ialis\
e
(
lO\
llOlO\
lOOOO\

.
lO\
llO\
lOlO\
l\
lO
,
lO\
llOlOlOOOO\

.
lO\
llOlO\
lOlll
,
lO\
ll\
OlO\
l\
OOO\
O
.
lOll\
Ol\
OO\
l\
OOl
,
ll\
OlOl\
OllO\
l
,
ll\
O\
l\
OlOlll\
O
)
;
lOllO\
lO\
lOlO\
O
=
lOllO\
lO\
lllll
;
}
bre\
ak
;
ca\
s\
e
SPAC\
IAL\
_DIVISI\
O\
N\
_\
T\
YPE_DY\
N\
AM\
IC\
_O\
CTR\
EE
:
{
lOO\
lOOOlOllO
*
lOllOll\
OO\
OOO
;
lO\
O\
O\
OO\
llO\
lO
(
lO\
llO\
llOO\
OOO
,
lOO\
l\
OOOlOllO\

)
;
lOllOllOOOOO\

->
Ini\
tiali\
s\
e
(
lO\
llOlOl\
OOOO
.
lOllOlOl\
O\
llO
,
lOllOlOlO\
OOO
.
lOl\
lOlO\
l\
Ol\
ll
,
lO\
ll\
OlOlOOOO
.
lO\
ll\
OlOOl\
OOl
)
;
lOllO\
lOlO\
l\
OO
=
lOl\
lOllOOOO\
O\

;
}
bre\
ak
;
case
SP\
A\
CIAL_DIVIS\
IO\
N_TYPE_C\
TREE
:
{
lOl\
llllOlOl
*
lOllOl\
l\
OOOOl
;
lOOOO\
OllOlO
(
lOl\
lOllO\
OOOl
,
lOllll\
lO\
lO\
l\

)
;
lO\
llOl\
lO\
O\
OO\
l
->
In\
itia\
lise\

(
lOllOlOlOO\
OO
.
lOllO\
lOOlOOl
.
v3Cen\
ter
,
lOllO\
lOlO\
OOO\

.
lOll\
O\
lO\
OlOOl
.
v3Ext\
ent\

.
GetMax\

(
)
*
2
)
;
lOllOlOl\
OlO\
O
=
lOllO\
ll\
OOOO\
l\

;
}
br\
eak
;
defa\
ult
:
ll\
lO\
O\
lOOO\
O
;
}
lO\
llOlOll\
OOO
lO\
lOOlOOlO
=
lOll\
OlOllOO\
l
.
lOl\
OOOOlOO
(
)
;
for
(
;
!
lOl\
O\
O\
lO\
OlO
.
AtEnd
(
)
;
++
lO\
l\
OOlOOlO
)
{
Dyna\
micObject
&
lOllOl\
Ol\
lOlO
=
*
*
lOlOO\
l\
OOlO
;
if
(
GetSpacialDi\
visionTyp\
e
(
)
==
SPACIAL\
_D\
I\
VISI\
O\
N_T\
YP\
E_CTREE
)
lO\
l\
lOlO\
llOl\
O
.
lO\
lOO\
OllOOOO\

(
)
;
lOllO\
lOlOlOO
->
lOll\
l\
lll\
ll\
l
(
lOl\
lOl\
O\
llOl\
O
)
;
lOllOlOl\
O\
lO\
O\

->
lOlOlOO\
OOl
(
lOl\
lOl\
OllOlO
)
;
}
}
lO\
llOOl\
l\
O\
lOl
(
"Memory report for spacial division:\n")
;
lO\
ll\
O\
OllOOOl
(
)
;
if
(
!
lO\
ll\
OlOl\
l\
lOl
.
lOOl\
OOlOOl\
l
(
)
)
{
lO\
Ol\
lOl\
l\
ll\
OO
->
lO\
lOllllOlOO
=
lO\
llOl\
OlOOOO
.
lO\
lOll\
l\
lO\
lOO\

;
lOllOlO\
lll\
Ol\

.
In\
itiali\
se
(
lOOllOllll\
O\
O
->
lOlOllll\
O\
l\
OO\

)
;
lO\
l\
lOl\
O\
l\
lOOO
lO\
lOOl\
O\
O\
l\
O\

=
lOll\
O\
l\
Ol\
l\
OOl
.
lOlOOOOlOO
(
)
;
for
(
;
!
lOl\
OOlOOlO\

.
At\
En\
d
(
)
;
++
lOlOOlOO\
lO
)
{
Dynam\
icO\
b\
ject\

&
lOl\
lOlOl\
lOl\
O
=
*
*
lOlOOlOOlO
;
if
(
lOl\
lOlO\
llOl\
O\

.
Is\
InM\
ovi\
ng\
Li\
s\
t\

(
)
)
{
Dyn\
a\
micObj\
ec\
t\

*
*
lOl\
lOllO\
OOl\
O
=
lO\
l\
lOlOll\
lO\
l\

.
Alloc\

(
)
;
TA\
_ASSERT
(
lOllO\
ll\
O\
O\
OlO
)
;
*
lOllOllOOOlO
=
&
lOl\
lOlOllOl\
O\

;
lOllOlOlll\
l\
O\

.
lOOlOOOO\
llO
(
lOllOllOOOlO
)
;
lOllOl\
OllOl\
O\

.
lOlOOlOOllOO
(
lOllO\
l\
Oll\
l\
lO
.
lOOlOOl\
OOlO\

(
)
)
;
}
el\
s\
e\

{
lOllOlOl\
l\
OlO
.
lO\
l\
OOl\
O\
OllOO
(
0
)
;
if
(
lOll\
Oll\
OOOll
)
lOll\
Ol\
lO\
OOll\

(
lOl\
lOlOl\
lOl\
O
,
lO\
llOl\
lO\
OlOO
)
;
}
}
}
lOl\
lOOl\
l\
O\
lOl
(
"Memory report for others:\n")
;
lO\
llO\
OllOOO\
l
(
)
;
if
(
!
lOllO\
lOllO\
ll
)
{
lO\
OOOOllO\
lO
(
lOllOlOllOll\

,
lOllO\
l\
O\
l\
llOO
)
;
lOOllOll\
l\
lO\
O
->
lOlO\
ll\
llO\
Oll\

=
lOll\
OlOlOOOO
.
lOlO\
lll\
lOOll
;
lOOllOllll\
OO
->
lOlOl\
l\
l\
lOlOl
=
lOl\
l\
OlOl\
OOOO
.
lOllOl\
lOO\
lOl
;
lOllOlOll\
Oll
->
Initialis\
e
(
lOOllO\
lll\
lOO
,
lOOll\
O\
l\
l\
llOO
->
lOlOll\
l\
lO\
Oll
)
;
}
lOllOO\
llO\
lOl
(
"Memory report for collision group manager:\n")
;
lOl\
l\
OO\
llOl\
Ol
(
"Total memory report:\n")
;
lOllOlO\
lO\
O\
l\
O\

=
lOllOlOl\
OO\
O\
O
;
}
vo\
id
Physic\
s
::
Up\
dat\
e
(
float\

lO\
OlllOO\
l\
lll
)
{
lOllOl\
lOOl\
l\
O\

++
;
if\

(
lO\
ll\
O\
l\
l\
OO\
l\
lO\

==
0
)
lOllOllO\
Oll\
l
(
)
;
lOO\
lO\
llllO\
l
(
lOl\
lO\
Ol\
Ol\
O\
lO
)
;
if
(
lOOl\
llOOl\
lll
<=
0.0f
)
re\
turn\

;
lOOllO\
l\
l\
llOO
->
lO\
lO\
ll\
lllO\
Ol
=
-
1
;
SetupSimulati\
on\

(
)
;
lO\
O\
O\
OO\
OllO
(
lOOllO\
ll\
l\
l\
OO\

,
"Physics::Update: Error, Physics class not initialised")
;
lO\
OllO\
llllOO
->
lOlOlll\
llO\
OO
=
lOO\
ll\
lOO\
ll\
ll\

;
lOll\
Oll\
OlOO\
O
(
lO\
Ol\
llOOllll
)
;
lOOllO\
ll\
l\
lOO
->
lOlOlllll\
OOl
=
0
;
lO\
llOl\
Ol\
lOll
->
Clear
(
true
)
;
#ifdef _DEBUG
#endif //
fo\
r
(
int\

lO\
ll\
O\
ll\
OlOO\
l\

=
0
;
lOl\
lO\
llO\
lOOl
<
2
;
lOl\
lOllOlOOl
++
)
{
lOOllOllllOO
->
lOlO\
lllllO\
Ol
=
lO\
llO\
llO\
lOOl
;
lOllOllOl\
OlO
(
lOOlllOO\
llll
,
lO\
ll\
O\
llOlOO\
l
)
;
lOllO\
lO\
ll\
lO\
O
::
Iterat\
o\
r\

lOllO\
l\
l\
Ol\
Oll
=
lOl\
l\
OlO\
llOl\
l
->
lOl\
O\
O\
OOlOO
(
)
;
for
(
;
!
lO\
ll\
OllOlOl\
l
.
AtEn\
d
(
)
;
++
lO\
llO\
llOlOll
)
{
lOl\
OllllO\
OO\
O
&
lOl\
lOllOllOO
=
(
*
lOl\
lOllOlOll
)
;
bool
lOll\
Ol\
lOllO\
l
=
lOllOl\
l\
Ol\
lOO\

.
lOllOllOlllO
(
)
;
if
(
!
lOll\
Ol\
lOl\
lOl\

)
{
bool
lOllOll\
Ol\
lll
=
fa\
lse
;
{
lOl\
lO\
lll\
OOO\
O
(
lOllOllO\
llOO
)
;
lOllOl\
llO\
O\
Ol\

(
lOOl\
llOOl\
lll
,
lOll\
O\
ll\
Ol\
lOO\

,
lO\
llO\
llOlOOl\

)
;
if
(
lO\
llOlllOOlO
(
)
)
{
if
(
lO\
llOlllO\
Oll
(
lOllOllOllOO
)
)
{
if
(
lOll\
Oll\
Ol\
OOl
==
0
)
lO\
llOlllOl\
OO\

(
lOl\
l\
O\
llO\
ll\
OO
)
;
else
lOllO\
ll\
Ol\
lll\

=
tr\
ue\

;
}
els\
e
{
lOllOl\
l\
OllOl
=
tr\
ue
;
}
}
else\

{
lOl\
l\
O\
llO\
ll\
Ol\

=
true
;
}
}
if
(
lO\
l\
l\
O\
llO\
ll\
ll\

)
{
int
lOl\
lOlllO\
lOl
=
0
;
int
lOllOl\
ll\
OllO
=
lOll\
OllOllOO
.
lOl\
lOlllOlll
(
)
*
2
+
2
;
int\

lOllOlll\
l\
OOO
=
0
;
int\

lOllOllll\
OO\
l\

=
lOllOllOl\
lOO\

.
lOl\
lOl\
lll\
O\
lO
(
)
*
2
+
2
;
lO\
O\
lllOO\
O\
l\
l
(
Dy\
nam\
icObje\
ct\

*
,
lO\
l\
lO\
l\
lllOll\

,
lOllOl\
l\
llOOl
)
;
lOOlllOOOl\
l
(
Co\
llisio\
n
*
,
lOllO\
llll\
l\
OO\

,
lO\
llOl\
llOl\
lO\

)
;
lOl\
l\
O\
lllll\
Ol\

(
lOllO\
llOllOO
,
lO\
l\
l\
Ol\
lllOll
,
lOl\
lOllllOOO\

,
lOl\
lOllllOOl\

,
lOll\
Ol\
llll\
O\
O
,
lOllOlllOlOl
,
lOllOl\
llOllO
)
;
lOllOl\
ll\
ll\
lO
(
lOllO\
l\
l\
Ol\
lO\
O\

,
lO\
ll\
OllllOll
,
lOll\
Ol\
lllOOO
,
lO\
llOlll\
llOO\

,
lOl\
lO\
ll\
lOlOl\

)
;
lO\
l\
lOl\
l\
lll\
l\
l
(
lOOl\
llOOllll
,
lOllOllOllOO
)
;
}
}
if
(
lOllO\
llO\
ll\
Ol
)
{
lO\
ll\
Ol\
lO\
llOO\

.
lOlllOOO\
O\
OOO\

(
tr\
ue
)
;
if
(
lOllOll\
OlOO\
l
==
0
)
{
in\
t
lOl\
lOlllOlOl
=
0
;
int
lOl\
lOlllOllO
=
lOll\
Oll\
OllO\
O
.
lOll\
Oll\
lOll\
l
(
)
*
2
+
2
;
int
lOl\
l\
Oll\
llO\
OO
=
0
;
int
lOl\
lOl\
ll\
lO\
Ol
=
lO\
ll\
Oll\
OllOO\

.
lOllOllllO\
lO
(
)
*
2
+
2
;
lOOlllOOOl\
l
(
Dyna\
mi\
cObject
*
,
lO\
ll\
O\
l\
lllOll
,
lOll\
Ollll\
OOl\

)
;
lOOlll\
O\
OOll
(
Collisio\
n\

*
,
lOll\
O\
lllll\
O\
O
,
lOllOl\
ll\
O\
llO\

)
;
lOllOll\
lllOl
(
lOllO\
l\
lOllOO\

,
lOllOllllOll
,
lO\
llO\
ll\
l\
lOO\
O
,
lOllOlll\
lOO\
l
,
lOllOlllllOO
,
lOllOlllO\
lO\
l
,
lOllO\
lll\
OllO
)
;
lOll\
lOOOOOOl
(
lO\
l\
lOllllOll
,
lOllOl\
lll\
O\
OO\

,
lO\
llO\
lllllOO
,
lOllOl\
llOlOl
)
;
lOlllOOOO\
OlO
(
lOllO\
l\
lOl\
lO\
O
,
lOllOl\
ll\
lOll
,
lO\
l\
lOll\
ll\
OO\
O
,
lOllOll\
lllOO
,
lOllOlll\
OlO\
l
)
;
}
els\
e\

{
int
lO\
lllOOOOOl\
l
=
lOll\
Ol\
lOl\
l\
OO
.
lOllO\
l\
llOll\
l
(
)
;
lO\
Oll\
lOOOll\

(
lOl\
l\
OlOOOlll
,
lO\
lll\
OOO\
OlOO
,
lOlllO\
O\
O\
OOl\
l
)
;
lOl\
llO\
OOOlOl\

(
lO\
llOllOl\
lOO\

,
lOlllOOO\
OlOO\

,
lOll\
lO\
OOOOll
)
;
lOOOlllllO
<
lOllO\
lOOO\
lll\

>
::
lOOOlll\
lll
(
lO\
lll\
O\
OOO\
lOO
,
lOl\
llO\
O\
OOOll
)
;
lOll\
l\
OOOOll\
O\

(
lOlllO\
OO\
OlOO
,
lOlllO\
OOOOl\
l
,
4
,
Get\
Gr\
avi\
t\
y
(
)
)
;
lOlllO\
OO\
Oll\
l\

(
lOlllOOOO\
lOO\

,
lOlllOOOOO\
ll
,
3
,
Get\
Gravity\

(
)
)
;
}
if
(
lOl\
l\
Ol\
lO\
lO\
Ol
!=
0
)
lOl\
lO\
l\
l\
lllll\

(
lOOlllO\
O\
lll\
l
,
lOllO\
llOllOO
)
;
}
lOl\
ll\
OO\
OlOOO
(
lOOll\
lOOllll
,
lOl\
lOll\
O\
lOOl
==
1
,
lOllOll\
OllO\
O\

)
;
}
lOlllOOO\
lO\
Ol
(
lO\
Ol\
llOOllll\

,
lO\
llOll\
OlOOl\

==
1
)
;
}
lOOllO\
llll\
OO
->
lO\
lOlllllOOl\

=
-
1
;
lOlll\
OOOlOlO
(
)
;
}
voi\
d
Phy\
s\
i\
cs
::
Ren\
der
(
)
{
#ifdef lOllOOlOOllO
lO\
Ol\
OllllOl
(
lOl\
lOOl\
OlOOl
)
;
lOllOl\
O\
l\
lOO\
O
lOlO\
O\
l\
OOlO
=
lO\
ll\
OlO\
llO\
Ol
.
lOl\
OOOOlO\
O
(
)
;
for\

(
;
!
lOlOOl\
O\
OlO
.
At\
End
(
)
;
++
lO\
lOOlOO\
lO
)
{
Dy\
namicO\
b\
jec\
t\

&
lOllOl\
O\
llO\
lO
=
*
*
lOlOO\
l\
OOlO
;
lOllOlOllOlO
.
Render
(
)
;
}
#endif //
}
Phys\
i\
cs
::
Phy\
si\
cs
(
)
{
lOll\
O\
lOO\
lll\
l
=
0
;
lOOllO\
l\
lllOO\

=
0
;
lOllOl\
OlOlO\
O
=
0
;
lOllOlOllO\
l\
l
=
0
;
lO\
lllOOOlO\
ll
=
0
;
lOll\
lO\
OOllOO
=
0
;
lOll\
lOOO\
llOl\

=
0
;
lOl\
l\
lOOOll\
lO
=
0
;
lOll\
l\
OOOllll
.
Clea\
r
(
)
;
lOlll\
OOl\
OOO\
O
=
0.0f
;
lO\
l\
ll\
OO\
l\
O\
OOl
=
0.0f
;
lll\
OllOO\
OO
=
0
;
lO\
lllOOlOOlO
=
0
;
lOl\
llO\
OlO\
Oll
=
0
;
lOll\
lOO\
l\
O\
lOO\

=
0
;
lO\
lll\
OOlOlO\
l
=
0
;
memset
(
&
lOllOl\
OlOOOO
,
0
,
size\
o\
f\

(
lOl\
lO\
l\
O\
lO\
OO\
O\

)
)
;
mems\
et
(
&
lOllOlOlOOlO
,
0
,
sizeof
(
lO\
llOlOlOO\
lO\

)
)
;
}
Phys\
ics
::
~
Physi\
cs
(
)
{
Fin\
ali\
s\
e
(
)
;
}
void\

Physics
::
Init\
ialise
(
const
AABB
&
lOllOlOOlOOl
,
cons\
t
Vec3
&
lOll\
O\
lOO\
l\
OlO
,
u32
lOlOllOOll
,
fl\
oa\
t
lO\
ll\
OlOOl\
Ol\
l\

,
in\
t
lOllOlO\
Oll\
OO
)
{
Ini\
tia\
lise
(
)
;
Set\
WorldDi\
m\
e\
nsi\
ons
(
lOllO\
lOO\
l\
O\
Ol\

)
;
SetG\
ravity\

(
lOllO\
l\
OOl\
OlO
)
;
swit\
ch
(
lO\
lOll\
O\
Oll
&
FL\
AG_SPACIA\
L_D\
IV\
IS\
ION_MASK
)
{
case
FLAG\
_X\
Y\
_COLLIS\
ION_G\
R\
ID
:
Se\
tS\
p\
ac\
ial\
DivisionT\
y\
pe\

(
SPACIAL_DIVISIO\
N\
_TYPE_XY\
_\
COLLISIO\
N_GRID\

)
;
brea\
k\

;
case
FL\
AG_X\
Z_CO\
LLI\
SION\
_\
G\
RID
:
SetSp\
ac\
i\
alD\
ivis\
ion\
Ty\
pe\

(
SPACIAL_DI\
VISI\
O\
N_T\
YPE_XZ_\
COLLISION_GRI\
D
)
;
brea\
k
;
case\

FL\
A\
G\
_Y\
Z_COLL\
IS\
I\
O\
N\
_G\
RID\

:
SetSp\
aci\
alDi\
vis\
ionType
(
SPACI\
AL_DIV\
ISION_T\
Y\
PE\
_\
YZ\
_COLLIS\
I\
ON\
_GRID
)
;
bre\
a\
k
;
case\

FL\
AG_DY\
NA\
MI\
C_OCT\
REE\

:
SetSpaci\
a\
lDi\
visio\
nType
(
SPAC\
IAL_DIVISI\
ON\
_TYPE_DYNAMI\
C_O\
CTREE
)
;
brea\
k
;
ca\
s\
e
FLA\
G\
_CTREE\

:
SetSpac\
ia\
lD\
iv\
isionT\
y\
pe
(
SPACIAL_D\
IVISI\
ON_TYPE_C\
TREE
)
;
break
;
defau\
lt
:
SetSpa\
cia\
lDivi\
s\
i\
onT\
yp\
e
(
SPACIAL_DIVISI\
ON_TYPE_CTREE
)
;
break
;
}
Se\
tS\
paci\
alDivisio\
nMinS\
ize\

(
lO\
llOlOOl\
Oll
)
;
SetS\
pac\
ia\
l\
Divis\
ionMax\
Me\
mory\

(
lOllOlOOll\
OO
)
;
Setu\
pS\
i\
mu\
lati\
on
(
)
;
}
void\

Physi\
cs
::
Ini\
t\
ia\
lis\
e\

(
)
{
if\

(
lllOll\
OOOO
&
lOll\
lOO\
lOllO
)
{
lO\
OOlll\
OlO
(
0
,
"Physics::Initialise. Already initialised.")
;
Fi\
nal\
ise
(
)
;
}
TA_ASSE\
RT
(
lllOllOOOO
==
0
)
;
TA\
_\
AS\
SE\
RT
(
(
lllO\
llO\
OOO
&
lO\
ll\
OlOO\
l\
llO
)
==
0
)
;
lllOllO\
OOO
|=
lOlllOOlOl\
lO
|
lOllOlO\
OllO\
l
|
lOlllOOlOll\
l
;
me\
mset
(
&
lOllOlOl\
OOl\
O
,
0
,
sizeof
(
lOllOlOlOOl\
O
)
)
;
lOl\
lOlOlOO\
OO
.
lOllO\
l\
OO\
l\
OOl
.
v3Center
.
Cle\
ar
(
)
;
lOl\
l\
OlOlOOOO
.
lOl\
l\
OlOOlOOl
.
v3Ex\
ten\
t
.
Initi\
a\
li\
s\
e\

(
1000.0f
,
1000.0f
,
1000.0f
)
;
lOll\
Ol\
OlOO\
O\
O
.
lOlOl\
l\
llOOll
=
4096
;
lO\
llOl\
OlO\
OOO\

.
lOlO\
l\
lllOl\
O\
O
=
1024
;
lOllO\
lOlOO\
O\
O
.
lOllO\
lOlOOO\
l
=
128
;
lOllO\
lOlO\
OOO
.
lOlO\
llllOll\
l
=
129
;
lOl\
l\
Ol\
O\
lOOO\
O
.
lOllOllO\
OlOl
=
lOl\
lO\
lOlOO\
OO
.
lOlOl\
ll\
l\
OO\
ll
*
2
;
lO\
l\
lOl\
OlO\
OOO
.
lOll\
Ol\
O\
lOlOl
=
SP\
A\
C\
IAL_DIVI\
SI\
ON_T\
YPE\
_DYN\
AMIC_O\
C\
TREE
;
lOllO\
lOl\
OOOO
.
lOllOlO\
lO\
l\
lO
=
1.0f
;
lO\
llOlOl\
OOOO
.
lO\
ll\
OlOlO\
l\
ll
=
0x40000
;
TA_A\
SSERT
(
lOO\
ll\
O\
ll\
l\
lOO
==
0
)
;
lO\
OOO\
OllO\
lO\

(
lO\
Oll\
Oll\
llOO\

,
lll\
lOllOll\
O
)
;
lOOll\
Oll\
ll\
OO
->
lOlOllll\
OOlO
=
this
;
lOOllO\
ll\
llO\
O
->
lO\
l\
OllllOOll\

=
0
;
lOOll\
Oll\
l\
l\
OO
->
lOlO\
llllOlOO
=
0
;
lO\
O\
l\
lO\
l\
l\
llOO
->
lO\
lOll\
l\
l\
OlOl
=
0
;
lOOl\
l\
OllllO\
O
->
lO\
lO\
l\
ll\
llOOO
=
0.0f
;
lOO\
llOll\
llOO
->
lO\
lOll\
l\
ll\
OOl
=
-
1
;
TA_\
AS\
SERT\

(
lOll\
OlO\
lOlO\
O
==
0
)
;
#define lOlllOOllOOO(lOlOOOllllOO)									\
	lOlllOOlOOlO = &lOlOOOllllOO::lOlOOOllllOl;									\
	lOlllOOlOOll = &lOlOOOllllOO::lOlOOOlllllO;				\
	lOlllOOlOlOO = &lOlOOOllllOO::lOlOOlOOOOOO;									\
	lOlllOOlOlOl = &lOlOOOllllOO::lOlOOlOOOOOl;				\
	lOlllOOllOOl = &lOlOOOllllOO::lOlOOlOOOOlO;
lOl\
l\
lOO\
llO\
O\
O
(
lO\
l\
OOlO\
OO\
Oll
)
TA_ASS\
E\
R\
T
(
lOll\
OlOOl\
ll\
l\

==
0
)
;
TA_AS\
SER\
T
(
lOllOlOllOl\
l
==
0
)
;
TA_\
AS\
SERT
(
lOll\
lOO\
Oll\
lO
==
0
)
;
lOlllO\
OO\
lllO
=
Collision\
ObjectCac\
h\
ed\
PolyD\
ata\

::
CreateNew\

(
)
;
lOlll\
OOOll\
lO\

->
Init\
ial\
ise
(
)
;
SetGravity
(
Vec\
3\

(
0.0f
,
-
9.81f
,
0.0f
)
)
;
lOll\
lOOll\
OlO
=
0
;
lOlll\
OOllOll
=
0
;
lOlll\
OO\
lllOO
=
0
;
lOlllOOl\
llOl
=
0
;
lOl\
llOOll\
llO
=
0
;
lOlllOOlll\
ll
=
0
;
lOl\
lO\
l\
lOOO\
l\
l
=
0
;
lOllO\
ll\
OOlOO\

=
0
;
lOl\
llO\
OlOOO\
l
=
1.0f
;
lOll\
OllOO\
ll\
O
=
0
;
lOlllOlO\
OOOO\

.
Cle\
a\
r
(
)
;
lOlllOlO\
OOO\
l\

.
Ini\
tialis\
e
(
0
,
8
)
;
TA\
_ASSERT
(
lOlllO\
O\
OlOll
==
0
)
;
lOlllO\
OOlOll
=
Dyna\
mi\
cObject
::
Cre\
at\
eNew\

(
)
;
lOlllO\
O\
OlO\
l\
l\

->
Init\
i\
aliseAsW\
orl\
dOb\
ject
(
)
;
lOlllOOOlOl\
l
->
lOl\
llOlOO\
OlO
(
tru\
e
)
;
lOlllOOOlOl\
l\

->
lOlOOl\
l\
OO\
Ol\
O
(
lO\
OllO\
l\
lllOO
)
;
TA_ASSE\
R\
T
(
lOl\
llOOOllOO
==
0
)
;
}
void
Ph\
ysi\
cs
::
Final\
ise
(
)
{
Setup\
Simu\
la\
t\
ion
(
)
;
if
(
lOlllO\
O\
Ol\
Ol\
l
)
{
lOlllO\
OOl\
O\
ll\

->
lOlO\
O\
OOl\
llO\
l
(
)
;
lO\
ll\
lOOO\
l\
Oll
->
lOll\
lO\
l\
OOOlO
(
fal\
s\
e
)
;
lOl\
ll\
OO\
OlOll
->
lOl\
OO\
l\
l\
OOOlO
(
0
)
;
lOlll\
O\
OOl\
Oll
->
Rel\
e\
ase
(
)
;
lOlllOOO\
lO\
l\
l
=
0
;
}
lOl\
llOOOllOO
=
0
;
lOlll\
O\
OOll\
O\
l\

=
0
;
if\

(
lOllOlO\
Ollll
)
{
lOOlOOOOOO\

(
lOllOlOO\
lll\
l\

,
lOllOlOlO\
Oll\

)
;
lO\
llO\
l\
OOllll
=
0
;
}
if
(
lOllOl\
O\
ll\
Oll
)
{
lOOlOOOOOO
(
lOllO\
lOll\
Ol\
l
,
lOllOlOl\
llOO\

)
;
lO\
llO\
lOllOll
=
0
;
}
lO\
llO\
lOl\
lOOO
lOlO\
O\
lOO\
lO
=
lOll\
OlOllOO\
l
.
lOl\
OOOO\
lOO\

(
)
;
while\

(
!
lOl\
O\
Ol\
O\
OlO
.
AtEn\
d
(
)
)
{
Dyn\
a\
micObj\
e\
ct
*
lO\
l\
llOOlOOO\

=
*
lOlOO\
lOO\
lO\

;
++
lOl\
OOlO\
OlO\

;
Remov\
eD\
yn\
a\
m\
i\
cObject
(
lOlllOO\
l\
OOO
)
;
}
lOll\
OlOlllO\
l
.
Fi\
nalis\
e
(
)
;
if
(
lOllOlOlOl\
OO
)
{
lOO\
l\
O\
O\
OOOO\

(
lOl\
lOlOlOl\
OO\

,
llO\
Ol\
Ol\
lOOl
)
;
lO\
l\
lOlOl\
Ol\
OO
=
0
;
}
lO\
lllO\
lOO\
O\
ll
lO\
ll\
lOl\
OOlO\
O
=
lOlll\
OlOO\
lO\
l\

.
lOlOOOOl\
OO
(
)
;
fo\
r
(
;
!
lOlllO\
lO\
O\
l\
OO
.
AtEnd
(
)
;
++
lOl\
llOlOOlO\
O
)
{
St\
ati\
c\
Objec\
t\

&
lO\
l\
ll\
Ol\
OOll\
O
=
*
*
lOlll\
OlOOlOO
;
lOlllOl\
O\
OllO
.
Releas\
e
(
)
;
}
lOlll\
Ol\
OOlOl\

.
Final\
i\
se
(
)
;
if\

(
lOl\
ll\
OOOll\
lO
)
{
lO\
l\
ll\
O\
OO\
lll\
O
->
Re\
leas\
e
(
)
;
lOl\
llO\
OO\
lllO
=
0
;
}
lO\
lllOOOlll\
l
.
Clea\
r
(
)
;
lllOl\
lOOOO
=
0
;
lOl\
ll\
O\
lOO\
OOO
.
Clear
(
)
;
lOlllOl\
OOO\
O\
l
.
Fin\
alise\

(
)
;
if
(
lOOl\
lOll\
llOO
)
{
lOOl\
OO\
OOOO
(
lOOl\
lO\
ll\
llO\
O\

,
lll\
lO\
llO\
ll\
O
)
;
lOOll\
OllllOO
=
0
;
}
}
void
Physi\
cs
::
lO\
lllOl\
OOlll
(
)
{
lllOllOOOO
|=
lO\
llOlO\
O\
llO\
l\

;
}
voi\
d
Physic\
s\

::
Add\
Stati\
cObj\
ect
(
Sta\
tic\
Ob\
jec\
t
*
lOlllOlOlOOO
)
{
TA_\
AS\
SERT\

(
lOll\
lOl\
Ol\
OO\
O
)
;
if\

(
lOll\
lOlO\
lO\
O\
O
->
Add\
edTo\
Physi\
c\
s
(
)
)
return
;
lOll\
lOl\
O\
l\
OOO
->
Ad\
d\
R\
ef
(
)
;
lO\
l\
ll\
OlOOlOl
.
lO\
O\
Ol\
l\
lO\
OO
(
lOll\
lOl\
O\
lO\
OO\

)
;
lOlll\
Ol\
Ol\
OOO
->
lOl\
llO\
lOOO\
lO\

(
tr\
u\
e
)
;
AddDy\
namicObject
(
lOl\
llOlOlOO\
O
->
GetDynamic\
Object
(
)
,
false
)
;
}
vo\
id
Ph\
ys\
ics\

::
Rem\
ov\
eS\
tatic\
Obj\
ect\

(
StaticObject
*
lO\
lllOlOlOOO
)
{
Se\
tu\
pSimul\
at\
ion
(
)
;
TA_AS\
S\
ERT
(
lOlll\
Ol\
Ol\
OOO
)
;
Rem\
o\
ve\
Dy\
n\
a\
mi\
cObj\
ec\
t\

(
lOlllOl\
OlOOO
->
GetD\
yn\
amicObjec\
t\

(
)
)
;
if\

(
!
lOlllO\
lOlOOO
->
Ad\
d\
edToPh\
ysic\
s
(
)
)
ret\
urn
;
lOlllOlOOlOl
.
lO\
O\
O\
OOl\
O\
lOl
(
lO\
l\
ll\
OlO\
lO\
OO
)
;
lO\
lll\
O\
l\
OlOO\
O
->
Release
(
)
;
lOlllOl\
OlO\
OO
->
lO\
lllOl\
OOOl\
O
(
fa\
lse
)
;
}
int\

Ph\
ysic\
s
::
Add\
SurfaceA\
tt\
ribute
(
Su\
r\
faceAttr\
ibute\

*
lOl\
l\
lOl\
O\
lOOl
)
{
TA\
_\
AS\
S\
ER\
T
(
lOlll\
Ol\
O\
lOOl
)
;
lO\
ll\
l\
Ol\
OOOOl\

.
lOOO\
lllOOO\

(
*
lOl\
llOlOlOO\
l\

)
;
re\
tu\
rn
lOlllOlO\
OOOl
.
lOOOlllOOl
(
)
-
1
;
}
int
Phy\
sics
::
AddSur\
fac\
eA\
ttribute
(
)
{
lO\
lllO\
lOOOOl
.
lO\
O\
OlllO\
OO
(
)
;
re\
t\
ur\
n
lOlllO\
lO\
OOOl
.
lOO\
O\
lllOOl
(
)
-
1
;
}
vo\
id
Physics
::
Remo\
veSurfaceAttribu\
t\
e
(
in\
t
lO\
OO\
lOOlll
)
{
lOlllOlOOOO\
l
.
lOOl\
llll\
ll
(
lOOO\
lOOlll\

)
;
}
Sur\
fa\
ce\
Att\
ribute
&
Ph\
y\
sics\

::
GetSurfaceAttribu\
te\

(
in\
t
lOOOlOO\
l\
ll
)
{
if
(
lOOOlO\
Olll
<
0
||
lOO\
O\
lOOll\
l
>=
lOl\
llO\
lOOOOl\

.
lOOOlll\
OOl
(
)
)
retu\
rn
lOll\
lOlO\
O\
OOO
;
el\
se\

re\
t\
u\
rn\

lOl\
ll\
OlOOOOl
[
lOOOlOOl\
l\
l
]
;
}
int
Phys\
ics
::
GetN\
umSurfac\
eAtt\
r\
ibut\
e\
s
(
)
{
retu\
r\
n
lOlll\
Ol\
OOO\
Ol
.
lOO\
O\
l\
ll\
OOl
(
)
;
}
voi\
d\

Physics\

::
SetDe\
f\
aultS\
u\
rface\
At\
tr\
ibute\

(
Surf\
ace\
A\
tt\
r\
i\
bute
*
lOl\
llOlOlO\
O\
l
)
{
if
(
lO\
l\
llOlOlOOl
)
lOll\
lO\
l\
O\
OOOO
=
*
lOlllOlOlOOl
;
els\
e
lOlll\
O\
lOOOO\
O\

.
Clea\
r
(
)
;
}
const
SurfaceA\
ttr\
ibute
&
Phys\
ics
::
GetDefau\
ltS\
ur\
fac\
eAt\
tri\
b\
u\
te
(
)
{
ret\
ur\
n
lO\
lllOl\
O\
O\
OOO
;
}
voi\
d
Phys\
i\
c\
s\

::
AddD\
y\
namicObje\
ct
(
DynamicOb\
je\
ct
*
lOlllO\
O\
l\
O\
O\
O\

,
bool
lOll\
lOlOlO\
lO
)
{
SetupSim\
ulation
(
)
;
TA\
_ASS\
ERT\

(
lOlllOOl\
OOO\

)
;
if\

(
lOlllOOl\
O\
OO
->
Ad\
ded\
ToPhysic\
s\

(
)
)
return\

;
TA_\
ASSE\
RT\

(
lOOll\
O\
llll\
OO
)
;
lOlllOOlOOO\

->
lOlOOllOOOlO
(
lOOll\
Olll\
lO\
O
)
;
lOlll\
O\
OlOO\
O
->
AddRef\

(
)
;
lO\
l\
lOlO\
llO\
Ol
.
lOO\
O\
l\
llOOO
(
lOlllOOlOOO
)
;
if
(
lOlllOl\
Ol\
OlO
)
{
lO\
Oll\
l\
OOll\
Ol
(
lOlllOO\
l\
OOO
,
SET\
_\
MOVI\
N\
G_PR\
I\
ORITY_HIGH\

)
;
}
lOlllO\
OlO\
OO
->
lOlllOlO\
OOl\
O
(
tru\
e\

)
;
lOlllOOl\
OOO
->
Ca\
l\
culateWorl\
dAABB
(
)
;
if
(
Ge\
tSpaci\
a\
lD\
i\
visi\
on\
T\
ype\

(
)
==
SPACIA\
L_D\
IV\
I\
S\
ION\
_TYPE\
_C\
TRE\
E
)
lO\
lll\
OOlO\
OO
->
lOlO\
OOll\
OO\
OO
(
)
;
lOl\
lO\
lO\
lOlOO\

->
lO\
l\
llll\
llll
(
*
lO\
l\
llOOlOOO
)
;
lOllOlOlO\
lOO
->
lOlOlOO\
OOl
(
*
lOlll\
O\
Ol\
OOO
)
;
}
void
Physi\
cs
::
RemoveDyna\
micO\
bjec\
t
(
Dy\
nam\
i\
cOb\
j\
ect
*
lO\
lllOOlOOO\

)
{
if
(
lllO\
llO\
OOO\

&
lO\
lllOlOlOll
)
{
lOlllOOlO\
O\
O
->
lO\
lOOllllOl\
l
(
lOlllO\
O\
O\
llOl\

)
;
lOl\
ll\
O\
O\
Oll\
Ol
=
lOlll\
OOl\
OOO
;
lOlllOOl\
O\
OO
->
lOl\
OO\
lOllO\
ll
(
true
)
;
lOlllOO\
lOOO
->
Ad\
dRe\
f
(
)
;
re\
t\
urn
;
}
SetupSi\
m\
ulati\
o\
n
(
)
;
TA_\
ASSERT
(
lOl\
llOOlOOO
)
;
if
(
!
lOl\
ll\
OO\
l\
O\
OO
->
Add\
edT\
oPhysic\
s
(
)
)
return
;
TA_ASSE\
RT
(
lOll\
Ol\
O\
lOlOO\

)
;
Se\
tDyn\
am\
ic\
Ob\
j\
ect\
A\
t\
R\
est
(
lOl\
l\
lO\
O\
l\
OOO
)
;
lOl\
lO\
l\
OlOlO\
O
->
lOO\
ll\
lll\
ll
(
*
lOlllOOlOOO\

)
;
lOl\
lOlOl\
OlO\
O
->
llO\
OOO\
O\
O\
lll
(
*
lO\
l\
llOOl\
O\
O\
O
)
;
if
(
GetSp\
a\
c\
ial\
D\
ivi\
s\
i\
on\
Ty\
pe
(
)
==
SPACIA\
L_DIVISION_\
T\
Y\
PE_C\
TR\
EE
)
lOlllOOlOOO
->
lOlOOOllOOl\
O
(
)
;
lOl\
lOlOll\
OOl
.
lO\
OOOOlOlO\
l
(
lOlllOOlO\
O\
O
)
;
TA\
_\
A\
S\
SERT\

(
lO\
l\
l\
lOO\
lOO\
O
->
IsInMov\
ingList\

(
)
==
0
)
;
lOl\
llOO\
l\
OOO
->
lOl\
l\
lOlOOO\
lO
(
false\

)
;
lOl\
ll\
OO\
lOO\
O
->
lOOllOlllOll
(
)
;
lOlll\
OOlOOO
->
lOl\
O\
O\
OO\
ll\
lO\
l
(
)
;
TA_A\
SS\
E\
RT\

(
lOlllOOlOO\
O
->
lOlOOl\
lOOO\
Ol
(
)
)
;
lO\
lllOOlO\
OO\

->
lOl\
OOllOOO\
lO\

(
0
)
;
lOll\
l\
OOlOOO
->
Rele\
a\
s\
e
(
)
;
}
void
Ph\
y\
sics
::
SetDy\
nam\
i\
cOb\
j\
ectIs\
M\
ovin\
g
(
Dy\
nami\
cObj\
ect\

*
lOll\
l\
OOl\
O\
O\
O
,
int
lO\
Oll\
lOOl\
lOO\

)
{
TA_ASSERT
(
lO\
l\
llOOlOOO\

)
;
lO\
lllOO\
lO\
OO
->
SetToMoving
(
lOOlllO\
Oll\
OO
)
;
}
void
Phys\
ic\
s
::
Se\
t\
D\
ynamicObje\
ctA\
tRest\

(
DynamicOb\
ject
*
lO\
lO\
OOOOl\
lOl
)
{
TA_\
ASS\
E\
R\
T
(
lO\
l\
OO\
OO\
O\
ll\
Ol
)
;
if\

(
!
lOl\
OOOOOllOl\

->
AddedTo\
Ph\
ysi\
c\
s\

(
)
)
re\
tur\
n
;
if\

(
lO\
l\
OOOOOllO\
l
->
IsInMovingList\

(
)
)
{
DynamicO\
bj\
ect
*
*
lOll\
O\
l\
lOO\
O\
lO
=
(
Dyn\
am\
icOb\
j\
ect
*
*
)
lOlOOOOOll\
Ol\

->
lOlOOlOl\
OOOO
(
)
;
TA_ASS\
ERT
(
*
lOl\
lOll\
OOOlO
==
lOlOOOOOl\
l\
Ol\

)
;
#ifdef _DEBUG
lOll\
l\
Ol\
Ol\
lO\
O
lO\
lOO\
lOOlO
=
lOllO\
l\
Ol\
ll\
lO
.
lO\
l\
OOO\
OlOO
(
)
;
while
(
!
lOl\
OO\
lOOlO\

.
AtEn\
d
(
)
)
{
Dyn\
ami\
cOb\
je\
c\
t
*
&
lOlOO\
OOOll\
l\
O
=
*
lOlO\
Ol\
OOl\
O\

;
if
(
lOl\
OOOO\
O\
lllO
==
lOlOOO\
O\
OllO\
l
)
{
TA_\
ASS\
ERT
(
&
*
lOlOOlO\
OlO
==
lOl\
lOll\
OOOlO
)
;
br\
eak\

;
}
++
lOlO\
OlOO\
lO
;
}
#endif //
lOlO\
OO\
OOl\
lOl
->
lOOl\
lOlllOll
(
)
;
lOlOOOOOllOl
->
Se\
tL\
i\
ne\
a\
rVe\
locity
(
k_\
v3\
Ze\
ro\

)
;
lOl\
OOOOOll\
Ol
->
SetAngula\
rVelo\
ci\
ty
(
k_\
v3Z\
ero
)
;
lOlO\
OOO\
OllOl
->
SetNe\
xtF\
ram\
e\

(
lOlOOOO\
Oll\
Ol\

->
Ge\
t\
Fr\
ame
(
)
)
;
lOlO\
OOOOl\
l\
Ol\

->
lO\
lOOl\
OOllOO
(
0
)
;
lO\
l\
OOOOOllOl
->
Ca\
lcul\
at\
eWorl\
d\
AABB
(
)
;
lO\
ll\
O\
lOllllO
.
lOOlll\
lll\
l\

(
lOllOllOOOlO
)
;
lOllOlOlllOl\

.
Fre\
e
(
lO\
l\
lOllOOOlO\

)
;
if
(
lOll\
Ol\
lOOOll
)
lOll\
OllOOOll
(
*
*
lO\
l\
l\
Oll\
O\
OOlO
,
lOl\
l\
O\
l\
lO\
OlOO\

)
;
}
}
void
Physics
::
TestL\
ineForCollis\
io\
n
(
con\
st\

Vec\
3
&
lOOlOlO\
l\
ll
,
co\
ns\
t\

Vec3
&
lOO\
O\
l\
OOOO\
O
,
float
lOOlO\
llO\
OO\

,
Col\
l\
i\
sio\
n
&
llO\
llllOll\
l\

,
u32\

lO\
lOllOOl\
l
)
{
lOllOO\
ll\
lOlO\

lOO\
O\
OOlO\
OlO
(
llO\
lll\
lOlll
)
;
llO\
l\
lllOlll
.
Clear\

(
)
;
lO\
OOOOlO\
O\
lO
.
lO\
Ol\
OlOlll
=
lOOlOl\
O\
lll
;
lOO\
O\
OOlO\
O\
l\
O
.
lO\
OO\
lO\
OOOO
=
lOO\
OlO\
OO\
OO
;
lO\
OO\
OOlOOlO\

.
lOOl\
OllOO\
O
=
lOO\
lOl\
lOO\
O
;
lOOOOOlO\
OlO
.
llOlll\
lO\
ll\
l
.
lOllO\
OlOO\
ll
=
lOOlOll\
OOO\

;
lOOOO\
OlOOlO
.
llOlll\
l\
Oll\
l
.
lllOlll\
llO
=
1.0f
;
lO\
OOOOlOOlO
.
lOl\
Ol\
l\
OOl\
l
=
lOlOllOO\
ll
;
lOOOO\
OlO\
OlO
.
llO\
ll\
l\
lOlll
.
lOOOOlll\
l\
l
=
lOO\
lO\
lOlll\

+
lOOO\
lOOOOO
*
lOOlOllOOO\

;
lOOO\
OOlO\
OlO
.
llOllll\
Olll\

.
lOOO\
lO\
OO\
OO
=
-
lO\
O\
OlOOO\
O\
O\

;
TA\
_ASSE\
RT
(
lOll\
OlOl\
OlOO
)
;
lOllO\
lO\
lOlO\
O
->
ll\
OOOlO\
l\
llO
(
lOO\
lOlOlll\

,
lOOlOl\
Olll
+
lOOOlOOOOO
*
lO\
OlOllOOO
,
lOl\
l\
lO\
lO\
llO\
l
,
&
lO\
O\
OOOlOOlO
)
;
}
void\

Physics
::
Te\
stLineForC\
olli\
s\
ion
(
co\
nst
Vec3
&
lOOlOlOlll
,
const
Ve\
c3
&
lOOlOllOO\
l
,
Collision
&
llO\
llllO\
lll
,
u3\
2\

lOlOllOOll
)
{
Ve\
c3\

lOOOlOOOOO
=
lOO\
lOllOOl
-
lOOlO\
l\
Olll\

;
fl\
oat
lOOlO\
ll\
OOO\

=
lOOO\
lO\
OOO\
O\

.
Get\
M\
agnit\
ud\
e
(
)
;
if
(
lOOlOll\
OOO\

>
k_fM\
in\
F\
loat
)
lOOOlOOOO\
O\

/=
lOOlO\
llOO\
O\

;
els\
e
lOOOlO\
OOOO
=
k_v3U\
ni\
tY
;
Tes\
t\
LineF\
or\
Col\
lisio\
n\

(
lOOlOlOll\
l
,
lOOO\
lO\
OOOO
,
lOO\
lOll\
OOO\

,
llOllll\
O\
ll\
l
,
lOlOl\
lOOll\

)
;
}
Co\
llisio\
n
Physics
::
Te\
stL\
in\
eFor\
Col\
lisi\
on
(
cons\
t
Vec3\

&
lOOlOlOlll
,
con\
s\
t\

Vec\
3
&
lO\
OOlOO\
OOO
,
fl\
oat
lOOl\
OllOOO
,
u32\

lOlO\
llOO\
ll\

)
{
Collisio\
n
ll\
O\
lll\
lOll\
l
;
Test\
Li\
n\
eForCo\
l\
li\
sion
(
lOOlOlOll\
l\

,
lOO\
O\
lOOOOO\

,
lOOlOllOOO\

,
ll\
Ol\
lll\
O\
l\
l\
l\

,
lOlOllOOl\
l
)
;
retu\
r\
n
ll\
OllllOlll\

;
}
Colli\
si\
on
Physics
::
Tes\
tL\
ineFo\
rColl\
isio\
n\

(
const
Vec3\

&
lOOlOlO\
lll\

,
const
Vec3
&
lOO\
lOllOO\
l
,
u32
lOlOllO\
Ol\
l
)
{
Collision
llOl\
l\
llO\
lll
;
TestLi\
neForCol\
lisio\
n
(
lOOlO\
lOlll
,
lOO\
lOll\
OOl\

,
llO\
lll\
lO\
ll\
l
,
lOlOll\
O\
Ol\
l
)
;
ret\
urn\

llOlll\
lOlll
;
}
vo\
i\
d
Phy\
sics
::
For\
AllI\
nt\
erse\
ct\
ingO\
b\
j\
e\
cts
(
co\
nst
AABB
&
lOO\
OO\
O\
O\
ll\
l
,
Int\
ersect\
i\
ngObjec\
tCal\
lBack
llOOOlOO\
lll\

,
vo\
id
*
lO\
O\
OOl\
lllO
)
{
if
(
lOOllOllllOO\

->
lOlOlllllOOl
!=
-
1
)
{
lO\
OOl\
llOlO
(
0
,
"Physics::ForAllIntersectingObjects: Function is ignored when called from TA::Physics::Update")
;
return
;
}
if
(
!
ll\
OOO\
lOO\
l\
ll\

)
retu\
rn
;
DynamicObj\
ect
*
lllllllOlO
=
0
;
lOllO\
lOlO\
lO\
O\

->
ll\
OOO\
lOOllO
(
lO\
OOOOOll\
l\

,
lOlllO\
lOlllO\

,
&
lllll\
l\
lOlO
)
;
whi\
le\

(
lll\
llllOlO\

)
{
Dynami\
cObject
*
lOO\
OO\
OlO\
OOl
=
lll\
l\
ll\
lOlO
->
lOlOO\
llll\
lO\
O
(
)
;
llOOO\
lOOl\
ll
(
*
llllll\
lOlO
,
lO\
OO\
O\
llll\
O
)
;
lllll\
llO\
lO\

->
Rel\
ease
(
)
;
lllllllOl\
O\

=
lOOO\
O\
OlOO\
Ol
;
}
}
void
Phys\
i\
c\
s
::
Wak\
eUpAl\
lI\
n\
te\
rsecti\
ng\
Objects
(
const
AA\
B\
B
&
lOOOOOOlll
)
{
if
(
lO\
OllOll\
l\
lOO\

->
lOlOlllllOOl
!=
-
1
)
{
lOOOl\
llOlO\

(
0
,
"Physics::WakeUpAllIntersectingObjects: Function is ignored when called from TA::Physics::Update")
;
ret\
urn
;
}
DynamicO\
b\
ject
*
lllllll\
OlO
=
0
;
lO\
llO\
lOlOl\
OO\

->
llOOOlOOll\
O
(
lOOOOOOlll
,
lOl\
llOl\
OlllO
,
&
lll\
lll\
lOl\
O
)
;
for
(
;
lllll\
l\
lOlO
;
ll\
llll\
l\
OlO\

=
llllll\
lOl\
O\

->
lO\
lO\
Ol\
l\
ll\
lOO
(
)
)
{
if
(
!
ll\
ll\
lllO\
l\
O
->
IsI\
nMovingLi\
st\

(
)
)
lOOlllOOllO\
l
(
lllll\
llOlO
,
SET_MOVI\
NG\
_P\
RI\
ORITY_H\
IG\
H
)
;
lll\
llllOlO\

->
Rele\
as\
e
(
)
;
}
}
#ifdef lOOlllllOOl
bool
Phys\
ics
::
lOlllOlOlll\
l\

(
Col\
l\
isi\
onObject\
Com\
b\
o
*
lOl\
OllOOOll
,
const\

MFrame\

&
lOlllO\
ll\
OOOO
,
con\
s\
t
MFrame
&
lOOOl\
llllOO
,
Co\
llisio\
nCa\
l\
lB\
a\
c\
k
lOl\
llOllOOOl
,
u32
lOlOl\
lOOll\

)
{
lO\
llOOlllO\
lO\

lOOOOOlOOlO
;
ll\
O\
Oll\
OOOll\

=
1.0f
;
lOOOO\
OlOOl\
O
.
lOOl\
OlOl\
ll\

=
lO\
OlOlOll\
l\

;
lO\
O\
OOOlOOlO
.
lOOOlOO\
OOO
=
lOO\
OlO\
OO\
OO
;
lOOO\
OOlOOl\
O\

.
lOOlOllOOO
=
lO\
Ol\
Ol\
l\
OOO
;
lOOOOO\
l\
OOlO
.
llO\
ll\
llOlll
.
lOll\
OOl\
OOll
=
lOOl\
OllOOO\

;
lOOOOO\
lOOlO
.
ll\
Oll\
l\
lOl\
ll
.
lllO\
l\
lll\
lO
=
1.0f
;
lOOOO\
Ol\
OOlO
.
lOl\
OllOOll
=
lOlOllOOll
;
lOOO\
OOlO\
Ol\
O\

.
llOll\
llOlll\

.
lOOO\
Oll\
lll
=
lO\
OlOlOl\
ll
+
lOOOlOO\
OOO
*
lOOlOl\
lO\
OO
;
lOOO\
OOlOOlO
.
ll\
Ol\
l\
ll\
O\
ll\
l
.
lOOO\
lOOO\
OO
=
-
lO\
OOlOOOO\
O
;
if
(
lOl\
OllO\
Ol\
l
&
FLAG\
_DYNAMIC\
_\
OBJECTS\

)
{
TA_ASSE\
R\
T
(
lOl\
lOlOl\
OlO\
O
)
;
lO\
l\
lOl\
Ol\
OlOO
->
llOOOlOlllO
(
lOOlOlOl\
ll
,
lOOlO\
lOl\
ll\

+
lOO\
OlO\
O\
O\
OO\

*
lOOlO\
llO\
OO
,
lOl\
l\
l\
OlOllO\
l
,
&
lO\
OOO\
Ol\
O\
Ol\
O
)
;
}
if
(
lOl\
Oll\
OO\
l\
l
&
FLAG_\
STA\
TIC_OB\
JE\
CT\
S\

)
{
lOlllOlOOO\
ll
lOlll\
OlOOlOO\

=
lOlll\
O\
lOO\
lOl
.
lO\
l\
OOOOlO\
O
(
)
;
for\

(
;
!
lO\
ll\
lOl\
OOlOO
.
AtEnd\

(
)
;
++
lO\
lll\
Ol\
OOl\
OO
)
{
lOl\
llOl\
lO\
O\
lO\

=
&
lO\
llO\
l\
O\
llOlO
;
lO\
lllOllOOll\

=
0
;
if\

(
lO\
lll\
Ol\
OOl\
lO
.
lOlllOl\
lOlOO
(
)
)
{
lOlllOl\
lO\
lOl
=
&
lOl\
llO\
lOO\
llO
;
llllOllOlOl
(
lO\
OllOl\
lllOO\

,
lO\
lOllOOO\
l\
l\

,
lO\
ll\
l\
OllO\
OOO
,
lOOO\
lllll\
OO\

,
lOlllOllOllO\

,
lO\
l\
llOll\
O\
lll\

,
this\

,
lOllOl\
OllOlO
.
GetCol\
lis\
ionUser\
Data
(
)
)
;
lOlllOllOlO\
l
=
0
;
}
els\
e\

{
MFrame
lOl\
llOlllO\
OO
=
lOlllO\
llOOO\
O\

/
lO\
lll\
OlOOllO\

.
GetFrame
(
)
;
MFr\
ame
lOlllOl\
llO\
Ol
=
lOOO\
lllllOO
/
lOlll\
O\
lOO\
l\
lO
.
GetNex\
tFrame
(
)
;
TA_ASSER\
T
(
lOl\
llOllOlOl\

==
0
)
;
lOl\
llO\
l\
l\
OlOl
=
&
lO\
lllOlOOl\
l\
O
;
lll\
lOllOlOl
(
lO\
OllOllllO\
O
,
lOll\
l\
Oll\
OO\
lO
->
GetCo\
l\
lisionO\
b\
ject
(
)
,
lOlllOlll\
O\
O\
O
,
lOlllOlll\
OO\
l\

,
lOll\
lO\
l\
l\
OllO\

,
lO\
ll\
l\
O\
l\
lOlll
,
this
,
lOllOlOl\
lO\
lO
.
Ge\
t\
Co\
ll\
isionU\
s\
e\
rD\
a\
ta
(
)
)
;
lOlllOllO\
lOl\

=
0
;
}
}
}
}
#endif
extern
float\

lOOllOOO\
OOOl
;
voi\
d
Phys\
ics
::
SetGravi\
ty
(
co\
nst
Vec3\

&
lOllOlO\
O\
lO\
lO
)
{
lOlllOOO\
ll\
l\
l
=
lOl\
lO\
lO\
OlOlO\

;
lOl\
llOOlO\
OOO\

=
lOlllOO\
O\
llll\

.
Ge\
tMagn\
itu\
d\
e\

(
)
;
lO\
O\
llOO\
OOO\
Ol
=
lOlllOOlOO\
OO
*
0.00001f
;
}
void
Ph\
ysics
::
SetWor\
ld\
Di\
mension\
s
(
con\
st
AABB
&
lOll\
OlOOl\
OOl
)
{
lOll\
Ol\
OlOOOO
.
lOllOl\
OOl\
O\
O\
l\

=
lOllO\
lOOl\
OOl
;
lO\
l\
ll\
OlOOlll
(
)
;
}
const
AA\
BB
&
Ph\
ys\
ics
::
GetW\
orld\
Dimensions\

(
)
{
re\
tur\
n
lOllO\
lOlO\
OOO
.
lOl\
lOlOOl\
OOl
;
}
vo\
id
Phy\
sics
::
SetMaxNum\
Col\
lision\
s\

(
int
lO\
lOl\
ll\
lO\
Oll
)
{
lOl\
lOlOlOO\
OO
.
lOlOlll\
lOOll
=
lOl\
Olll\
lOOll
;
lO\
lll\
OlOOl\
ll
(
)
;
}
in\
t
Physics\

::
GetMax\
Nu\
mCo\
l\
li\
si\
o\
ns
(
)
{
ret\
urn
lOllOl\
O\
l\
O\
O\
OO
.
lO\
lOll\
ll\
OOl\
l
;
}
voi\
d\

Phys\
ics
::
SetM\
axN\
umMovin\
g\
Object\
s
(
in\
t
lOlOll\
llOlOO\

)
{
lOllOlOlO\
OOO\

.
lOl\
Ollll\
Ol\
OO
=
lOl\
O\
l\
lllO\
lOO
;
lOl\
ll\
Ol\
O\
O\
lll
(
)
;
}
in\
t
Physics
::
GetM\
axN\
um\
M\
o\
v\
ing\
Obje\
cts
(
)
{
return
lO\
l\
lO\
lOlO\
OOO
.
lOlOlll\
lOlOO
;
}
void
Phy\
s\
ics
::
SetSlow\
Sol\
v\
er\
MaxN\
umColli\
s\
ions\

(
in\
t
lOl\
lO\
lOlOOOl\

)
{
lOll\
OlOlO\
OO\
O
.
lOll\
OlOlO\
OOl
=
lOllOlOlO\
OO\
l
;
lOlllO\
l\
OO\
lll\

(
)
;
}
int
Physi\
cs
::
Ge\
tSl\
owSolve\
rMax\
Nu\
mCollisions
(
)
{
return
lOl\
lOl\
OlOOOO\

.
lOllO\
lO\
l\
O\
OOl
;
}
void
Physi\
c\
s
::
Set\
SlowSolverMaxNumObjec\
t\
s\

(
int\

lOl\
OllllOll\
l\

)
{
lOl\
lO\
lOlO\
OOO
.
lO\
lOllllO\
ll\
l\

=
lOlOl\
lllOlll
;
lO\
lllOlOO\
lll
(
)
;
}
int
Phys\
ic\
s
::
Get\
SlowSo\
l\
v\
erM\
ax\
NumObjec\
t\
s
(
)
{
ret\
urn
lO\
l\
lOlOlOO\
OO\

.
lOlO\
llllO\
lll
;
}
void
Ph\
ys\
ic\
s
::
Set\
MaxNumO\
bj\
ectPai\
r\
s\

(
int
lOllOll\
O\
OlOl
)
{
lOllOlOlO\
OOO
.
lOl\
lOllOOlOl
=
lO\
llOll\
OO\
l\
O\
l\

;
lOlllOlOOl\
ll\

(
)
;
}
int
Physics
::
Ge\
t\
Max\
N\
umObje\
c\
tPairs
(
)
{
retur\
n\

lOllOlOlOOOO\

.
lOllO\
llOOlOl
;
}
void
Physics\

::
Se\
tSpacialD\
i\
vis\
ionTy\
p\
e
(
Sp\
ac\
i\
alDivisionType
lOllOlO\
lOl\
Ol
)
{
lOllO\
l\
O\
lOOO\
O
.
lOll\
OlOlOl\
O\
l
=
lOll\
OlOlOlOl\

;
lOll\
lO\
l\
OOll\
l\

(
)
;
}
Physics\

::
Sp\
acialDivision\
Type
Physic\
s
::
Ge\
tS\
pacialDiv\
i\
s\
io\
nT\
ype
(
)
{
re\
tu\
rn
lO\
llOlOlO\
OO\
O
.
lOllOlOlOlO\
l
;
}
vo\
id
Phy\
sics
::
Se\
tS\
pa\
cia\
lD\
ivis\
i\
onM\
in\
Size
(
float
lO\
llOlOlOll\
O\

)
{
lOllOlOlOOOO
.
lOllOlOl\
OllO
=
lO\
llOlOlO\
ll\
O
;
lOlll\
OlOO\
l\
ll\

(
)
;
}
float
Physi\
cs
::
Get\
SpacialDiv\
is\
ionMi\
nS\
i\
ze
(
)
{
ret\
u\
rn\

lOllO\
lO\
lOOOO
.
lO\
l\
lOlOl\
Oll\
O
;
}
vo\
id
Phy\
sics
::
SetS\
p\
acialDi\
v\
is\
ion\
MaxMemory
(
int
lOllOlO\
lOlll\

)
{
lOllO\
lOlOO\
O\
O
.
lO\
llOlOlO\
lll
=
lOll\
O\
lOlO\
ll\
l
;
lOlllOlOO\
l\
ll
(
)
;
}
int
Phy\
sic\
s\

::
GetSpac\
i\
alDivi\
s\
ion\
Ma\
xMemor\
y
(
)
{
return
lOllO\
l\
O\
l\
OOOO
.
lO\
llOlO\
lOlll
;
}
void
Phys\
i\
cs\

::
lO\
Ol\
llOOOOlO
(
Dyn\
ami\
cO\
bject\

*
lOlllOOl\
OO\
O
)
{
TA_ASSE\
RT
(
lOlllOOlOOO
)
;
if\

(
lOll\
lOOlOO\
O
->
Ad\
dedTo\
Physics
(
)
)
{
TA_ASS\
ERT
(
lO\
l\
lO\
lO\
lOlO\
O\

)
;
lO\
llOl\
OlOlOO
->
lOOlll\
ll\
ll\

(
*
lOlllOOl\
O\
OO
)
;
lOll\
OlOlOl\
OO
->
lO\
lOl\
OOOO\
l
(
*
lO\
l\
llOO\
lOO\
O
)
;
}
}
void\

Physics
::
lO\
llOllO\
lOOO
(
floa\
t
lOOl\
l\
lOOll\
ll
)
{
floa\
t
lOl\
O\
OOlOll\
l\
O
=
1.0f
;
float
lOl\
O\
O\
Ol\
Oll\
l\
l\

=
1.0f
-
Exp
(
-
lO\
O\
lllOOl\
lll
*
40.0f
)
;
lO\
lllOlOll\
OO
lOlOOlO\
O\
lO\

=
lOll\
OlOllllO
.
lOlOOOOl\
OO
(
)
;
whil\
e
(
!
lOl\
O\
O\
lOO\
l\
O
.
AtE\
nd
(
)
)
{
Dy\
nami\
cObj\
e\
ct
*
&
lO\
ll\
l\
OOlOOO\

=
*
lOlOOl\
OOl\
O
;
++
lO\
lOOlO\
Ol\
O
;
if
(
lO\
l\
l\
l\
O\
O\
lOOO\

->
lOlOOO\
lOOO\
Ol
(
)
||
!
lOllO\
lOl\
OO\
OO
.
lOll\
OlOOlO\
Ol\

.
Inte\
rsects
(
lOl\
l\
lOOlOOO\

->
Ge\
tWorld\
AA\
B\
B
(
)
.
v3Cente\
r
)
)
{
lOll\
l\
O\
Ol\
OO\
O
->
SetLin\
ea\
rV\
el\
o\
city\

(
k_v3Zero
)
;
lO\
lllOOl\
OOO
->
Set\
An\
gula\
rVe\
loci\
ty
(
k_v3Zero
)
;
lOll\
lO\
OlOOO\

->
SetN\
extFrame
(
lOl\
l\
lOO\
lOOO\

->
GetFra\
me\

(
)
)
;
lOlllO\
Ol\
OOO
->
lOlOO\
l\
OOllO\
O
(
0
)
;
lOl\
lOl\
O\
l\
lllO
.
lOOlllllll
(
&
lOlllOOlO\
O\
O\

)
;
lOl\
l\
O\
l\
Ol\
llOl
.
Free\

(
&
lOl\
l\
lOOlOO\
O
)
;
lOlllOOlOO\
O
->
lOlOO\
lll\
lOOl
(
0.0f
)
;
lOl\
llOOlOOO
->
Calc\
ulate\
WorldAABB
(
)
;
if
(
lOllOl\
lOOOll
)
lO\
l\
lOl\
l\
OOOl\
l
(
*
lO\
lllO\
OlOOO
,
lOllOl\
lOOlO\
O
)
;
lOll\
lO\
OlOOO\

->
lOlOO\
OlOOlOl
(
)
;
}
else\

{
lOll\
l\
O\
OlO\
O\
O
->
lO\
lO\
O\
OlOll\
Ol
(
lO\
lOOOlOl\
l\
lO
,
lOlOOOl\
Oll\
ll
)
;
if
(
!
lOlllOOlOO\
O
->
Upd\
ateDisabled\

(
)
)
lO\
lllOOl\
OOO
->
Up\
dat\
e\

(
lOOl\
l\
lOOlll\
l
)
;
lOll\
lOOlOOO
->
lO\
lOOll\
l\
O\
OO\
l
(
0.0f
)
;
lOl\
ll\
OO\
lOOO\

->
lOlOOOlOOl\
Ol\

(
)
;
}
lO\
lllOOl\
OO\
O
->
lOOllO\
ll\
lO\
l\
l\

(
)
;
}
}
void
Ph\
ysics
::
lOl\
lOll\
O\
lOl\
O
(
fl\
o\
at\

lOOlllOO\
l\
lll
,
int
lOll\
OllO\
lOO\
l
)
{
lOOl\
OllllO\
l
(
lOllO\
Ol\
O\
lOll\

)
;
lOlllOl\
OllOO
lOlllOl\
l\
lOl\
O
;
if
(
lOl\
lO\
l\
lOl\
OOl
==
0
&&
(
ll\
lO\
llOOOO\

&
(
Ph\
ysic\
s\

::
FLAG_XY_C\
OL\
LI\
SION_GRID
|
Ph\
y\
si\
cs
::
FLAG_\
XZ_C\
OLLIS\
ION_GRI\
D
|
Ph\
y\
sics
::
FLA\
G_YZ_COLLI\
SIO\
N_GR\
ID
)
)
)
{
int
lOl\
l\
l\
Olll\
Oll
;
int
lOl\
llOll\
l\
lOO\

;
if
(
lll\
Ol\
lOOOO
&
Ph\
ysic\
s
::
FL\
A\
G_\
X\
Y_CO\
LLI\
SIO\
N_\
GR\
ID
)
{
lOlll\
Oll\
l\
Oll
=
0
;
lOlllOllllOO\

=
1
;
}
else\

if\

(
ll\
l\
O\
llOOOO
&
Physi\
cs\

::
FLA\
G_XY\
_C\
OL\
LISI\
ON\
_\
GRI\
D
)
{
lOlllOlllOl\
l
=
0
;
lOlllOllllOO
=
2
;
}
else
{
TA\
_ASSERT
(
lllOllOO\
O\
O
&
Physics\

::
FLAG_YZ_\
C\
O\
LLISION_GRID\

)
;
lO\
lll\
Olll\
Oll
=
1
;
lOl\
l\
l\
Olll\
lO\
O
=
2
;
}
lO\
OlOll\
lO\
Ol
(
lOll\
OOlOl\
llO
)
;
lOl\
O\
lllOl\
O
<
Dy\
namicOb\
ject
*
>
::
lOOlOOl\
O\
OOl\

lOlllOl\
lll\
Ol
;
lO\
lllO\
ll\
lOlO
=
lOl\
l\
OlO\
lll\
lO\

.
lO\
lOOOOlOO
(
)
;
if\

(
!
lOlllOlllOlO
.
AtE\
nd\

(
)
)
{
DynamicObj\
e\
ct
*
&
lOlllOlll\
l\
l\
O
=
*
lOlllOl\
llO\
l\
O\

;
++
lOlll\
O\
l\
llOlO
;
lO\
llOlOl\
ll\
lO
.
lOOlll\
lll\
l
(
&
lOlllO\
ll\
lllO
)
;
lO\
ll\
lOllllOl\

.
lOlO\
lOOOO\
l
(
&
lOlll\
Oll\
l\
ll\
O
)
;
whil\
e
(
!
lOlllOl\
llOlO
.
AtEn\
d
(
)
)
{
Dynami\
cO\
bjec\
t
*
&
lOlllOOl\
O\
OO
=
*
lO\
lllOlllOlO
;
++
lOlllO\
lllOlO
;
lOlllOlOllOO
lOlllOllll\
ll
=
lOlllOl\
lllOl
.
lOlOO\
OOlO\
O
(
)
;
lO\
lllO\
lOll\
OO\

lOllllO\
OO\
OO\
O\

;
float
lOll\
ll\
OOO\
OO\
l\

=
lO\
l\
llOOlOOO
->
Get\
W\
orldAAB\
B
(
)
.
v3Ext\
e\
nt\

[
lOll\
lO\
lllO\
ll
]
;
float
lOl\
l\
l\
lOOOOlO
=
lOlllOOlOO\
O
->
Ge\
tW\
or\
ldAABB
(
)
.
v3Exten\
t
[
lOl\
llOll\
llO\
O
]
;
float\

lO\
l\
l\
llOOOOll
=
FastMax\

(
lOll\
llOOOOO\
l\

,
lOllllOOOOlO
)
;
flo\
at
lOll\
llOO\
O\
l\
OO
=
(
*
lOl\
llO\
ll\
llll
)
->
Get\
Worl\
dAAB\
B\

(
)
.
v3\
Extent
[
lOlllOll\
lOll
]
;
fl\
oa\
t\

lOlll\
lOOO\
lOl
=
(
*
lOll\
l\
Oll\
llll
)
->
Ge\
tWorld\
AABB
(
)
.
v3Extent\

[
lO\
lll\
Oll\
llOO
]
;
if\

(
lO\
ll\
llOOOOl\
l
>=
Fa\
s\
t\
Max
(
lOllllOOOlOO
,
lOllllOOOl\
O\
l
)
)
{
lOllO\
l\
OllllO
.
lOOllll\
lll\

(
&
lOlllO\
OlOO\
O\

)
;
lOll\
lOllllOl
.
lOlO\
lOOO\
Ol
(
&
lOlll\
OO\
lOOO
)
;
}
el\
se
{
lOllllOO\
O\
OOO
=
lO\
ll\
lOl\
ll\
lll
;
++
lOl\
llOl\
llll\
l
;
for\

(
;
!
lOll\
lOl\
lllll
.
AtEnd
(
)
;
++
lOlllOll\
llll\

)
{
lOllllOOO\
lO\
O
=
(
*
lO\
ll\
lO\
l\
l\
lll\
l
)
->
Ge\
tWorld\
A\
ABB
(
)
.
v3Ex\
ten\
t
[
lOl\
llOlllOll
]
;
lOllllOOO\
lO\
l
=
(
*
lOlllOl\
llll\
l
)
->
Ge\
t\
World\
AABB
(
)
.
v3Exte\
nt
[
lOlllOlll\
lOO
]
;
if
(
lOlll\
lO\
OOO\
ll
>=
Fas\
tMax
(
lOl\
l\
l\
lO\
OOlOO
,
lOllll\
OOO\
l\
Ol\

)
)
br\
e\
a\
k
;
lOllllOOOOOO\

=
lOll\
lOl\
lll\
ll\

;
}
lO\
ll\
O\
lOllllO
.
lOO\
llllll\
l
(
&
lOll\
lO\
O\
lO\
OO
)
;
TA_A\
SS\
ERT
(
!
lO\
ll\
ll\
O\
O\
OO\
OO\

.
At\
E\
n\
d\

(
)
)
;
lO\
lllOllll\
Ol\

.
lO\
O\
lOOO\
OOl\
l\

(
&
lO\
lllO\
OlO\
OO
,
lOllllOOOO\
O\
O\

)
;
}
}
}
lOllO\
lOllll\
O
.
llO\
llOllOO
(
lO\
ll\
lOl\
lll\
Ol
)
;
#ifdef _DEBUG
lO\
lllO\
lllOlO
=
lOllOl\
Ol\
lll\
O
.
lOlOOOO\
lOO
(
)
;
flo\
at
lOlll\
l\
OO\
Ol\
lO
=
k_\
f\
MaxFlo\
a\
t
;
for
(
;
!
lOlllO\
lllO\
lO
.
At\
End
(
)
;
++
lO\
lllOll\
lOlO
)
{
DynamicObjec\
t\

&
lOll\
O\
lO\
llO\
lO\

=
*
*
lO\
lllOll\
lOlO
;
floa\
t\

llOlOllOOl\
O
=
FastMax
(
lOllOlOllO\
lO
.
GetW\
orldA\
ABB
(
)
.
v3E\
x\
t\
e\
nt\

[
lO\
ll\
lOl\
ll\
Oll
]
,
lOllO\
lOllOl\
O
.
Get\
Worl\
dAABB
(
)
.
v3E\
xtent
[
lOlllO\
llllO\
O
]
)
;
TA_ASSERT
(
llO\
lOl\
lO\
OlO
<=
lOll\
ll\
OOOllO\

)
;
lOllllOOOllO\

=
llO\
lOllOOlO
;
}
#endif //
lO\
Ol\
OlllOll
(
lOl\
lOOlO\
ll\
lO
)
;
}
Dynamic\
Obje\
c\
t\

*
lOl\
lll\
OO\
O\
l\
ll
=
0
;
if
(
lOllOllOlOOl
==
0
)
{
lOl\
llOl\
llOlO
=
lO\
llOl\
Olll\
lO\

.
lO\
lOOOOlOO
(
)
;
for
(
;
!
lOl\
l\
l\
OlllOlO
.
AtE\
n\
d
(
)
;
)
{
Dy\
na\
m\
i\
c\
Obje\
c\
t
*
&
lO\
lllOO\
lOO\
O\

=
*
lO\
lllOll\
lO\
lO
;
++
lOlllO\
lllOlO
;
if
(
!
lOlllOOlOOO
->
lO\
lOOOlOOOOO
(
)
&&
!
lOl\
llOOlOO\
O
->
Collisi\
o\
n\
D\
isabl\
ed
(
)
)
{
lOlllOOl\
O\
OO
->
Cal\
cul\
ate\
WorldAA\
BB\

(
)
;
lOl\
llOO\
l\
O\
OO
->
lOlOOllll\
Oll
(
lOllllOOO\
l\
l\
l\

)
;
lOllllO\
OOll\
l
=
lO\
lll\
OOl\
OO\
O
;
lOl\
llO\
OlOO\
O
->
lOlO\
O\
lOllOll
(
true
)
;
}
else
{
}
lOlllOO\
lO\
OO
->
lO\
lOO\
llOllOO\

(
lOllO\
l\
lOO\
llO
)
;
}
TA_A\
S\
SER\
T\

(
lOlllO\
OOl\
lO\
O
==
0
)
;
lOll\
lOOOl\
lOO
=
0
;
}
else\

{
TA\
_\
ASS\
E\
RT\

(
lOll\
lOOOl\
lO\
O
==
0
)
;
lOl\
l\
OlO\
lllOO
::
Itera\
t\
or
lO\
llOllOlOll
=
lO\
l\
l\
OlO\
llO\
ll\

->
lO\
l\
OO\
O\
OlO\
O
(
)
;
for\

(
;
!
lOllO\
llO\
lO\
ll
.
AtEnd\

(
)
;
++
lOllOllOl\
Oll
)
{
lOlOllllOOOO\

&
lO\
l\
lOll\
OllO\
O
=
*
lOllOllO\
lO\
l\
l
;
lOlO\
llll\
OOOO
::
lOllllOO\
lOOO
lOllllOOlOOl
=
lOllOll\
O\
l\
l\
OO
.
lOl\
lllOOl\
O\
lO
(
)
;
for\

(
;
!
lOl\
lll\
OO\
lO\
O\
l\

.
At\
En\
d\

(
)
;
++
lOl\
l\
ll\
OOlOOl
)
{
lOl\
OOOO\
O\
Oll\
l\

&
lOlOOOOll\
lOO
=
*
lO\
llllOOlOO\
l\

;
lOll\
l\
l\
O\
OlOll
(
lOl\
O\
O\
O\
OlllOO
)
;
}
}
lO\
ll\
llO\
OOlll
=
lOlllOOOllO\
O\

;
lOl\
llO\
OO\
ll\
O\
O\

=
0
;
}
TA_\
ASSERT
(
lO\
ll\
lOOO\
ll\
OO
==
0
)
;
lllOllOOOO
|=
lOlll\
lOOllO\
O
;
fo\
r
(
int
lO\
llll\
OOllOl\

=
0
;
lO\
ll\
llOOO\
lll
;
lOllll\
OOllO\
l
++
)
{
TA_ASSERT\

(
lOll\
l\
O\
OOl\
lOO
==
0
)
;
{
lO\
OlOl\
llO\
Ol
(
lOl\
lOOlOl\
lO\
l
)
;
Dynami\
cObject\

*
lO\
llllOOl\
llO
=
0
;
Dy\
nam\
i\
c\
Obje\
ct
*
lOOOOOlOOOl\

=
0
;
fo\
r\

(
Dyn\
amic\
O\
bject
*
lOllllOOllll\

=
lOllllO\
OOl\
ll
;
lO\
l\
l\
l\
lOOl\
lll
;
lOl\
lllOOl\
ll\
l\

=
lOO\
OOO\
l\
OO\
Ol
)
{
lOOO\
OO\
l\
OO\
Ol\

=
lOllllOOllll
->
lOl\
OO\
ll\
lllOO
(
)
;
Dyna\
micO\
bject\

&
lOllOlO\
ll\
OlO
=
*
lOll\
llOOll\
ll
;
TA\
_ASSERT\

(
lOll\
O\
lOl\
l\
OlO\

.
lOOlOOOllO\
l\

(
)
)
;
if\

(
!
lO\
llOlO\
l\
l\
O\
lO\

.
Is\
InMoving\
Lis\
t
(
)
)
{
if
(
(
lllOllOOOO
&
lOlll\
OOlOlll\

)
==
0
)
{
lOOlllOOl\
lOl
(
lOl\
ll\
lOO\
l\
lll
)
;
}
els\
e
{
if
(
lOllllOO\
ll\
l\
l
->
lOlOOllll\
OO\
O
(
)
>
lOlll\
lO\
Oll\
ll
->
Get\
M\
ass
(
)
&&
lOllOl\
Ol\
lOll
->
lOllllOl\
OO\
O\
O\

(
)
*
200
<
lOO\
llOll\
llOO
->
lO\
lOllllOOll
*
100
)
{
lOOlllOOllOl
(
lOllllOO\
l\
ll\
l
)
;
if
(
lOlll\
lOO\
llll
->
Is\
I\
nM\
o\
vin\
gList
(
)
)
{
fl\
oat\

lll\
O\
ll\
lllO
=
0.75f
-
(
lOllll\
OO\
ll\
ll
->
lO\
l\
OOl\
l\
ll\
OO\
O
(
)
-
lOll\
llOO\
llll
->
Ge\
tM\
as\
s\

(
)
)
*
lOllllOO\
ll\
ll
->
Get\
Inver\
se\
M\
ass
(
)
;
if
(
lllOll\
l\
llO\

>
0.0f
)
{
lOl\
l\
ll\
OOllll\

->
lOlOOl\
O\
OO\
l\
l\
O
(
lllOll\
lll\
O
*
lOllOOl\
llllO
)
;
}
if\

(
!
lO\
llllO\
O\
l\
ll\
l
->
Up\
d\
a\
teDi\
sabled\

(
)
)
lOll\
l\
lOO\
llll
->
Upda\
te\

(
lOO\
lllOOl\
lll
)
;
}
else
{
lO\
ll\
l\
lOOllll
->
lOlOOl\
lllOOl
(
0.0f
)
;
}
}
}
}
if
(
lOllO\
l\
Oll\
OlO
.
IsInM\
o\
vi\
ngList
(
)
)
{
lOllOlO\
lOl\
OO
->
lOOlllllll
(
lOllOlO\
ll\
Ol\
O
)
;
lOllllOOl\
ll\
l\

->
lO\
lOO\
llll\
Oll\

(
lOlll\
lO\
Ol\
l\
lO\

)
;
lOllllOOlllO
=
lOl\
ll\
lOOllll
;
}
els\
e
{
lOl\
lOlOl\
lO\
lO
.
lOlOO\
lO\
l\
lOll
(
false
)
;
}
}
lO\
llllOOOlll
=
lO\
l\
lllO\
OlllO
;
if\

(
lOll\
ll\
OOOlll
==
0
)
bre\
ak
;
for
(
Dy\
namicObject\

*
lOll\
llOOll\
ll
=
lOllll\
O\
O\
O\
lll
;
lOll\
l\
lOO\
llll
;
lOllllOOllll
=
lOl\
lllOO\
llll
->
lO\
lOO\
ll\
l\
l\
lO\
O\

(
)
)
{
Dyn\
amicObj\
e\
ct\

&
lO\
ll\
O\
lOll\
OlO
=
*
lOl\
l\
ll\
OOl\
lll
;
TA_\
A\
SS\
ERT\

(
lOl\
lOlOllOl\
O
.
lO\
Ol\
OOOllOl\

(
)
)
;
TA_ASS\
E\
RT
(
!
lOllO\
lO\
llOlO
.
Collisi\
onDisabled
(
)
)
;
#ifdef _DEBUG
AAB\
B
lOOOO\
OO\
lll\

;
lOO\
OOOOlll\

.
Ini\
tiali\
se
(
lO\
ll\
O\
lOll\
O\
lO
.
GetC\
oll\
isionObject
(
)
.
GetA\
A\
BB\

(
)
.
v3\
Center
*
lOllOlOl\
l\
OlO
.
Get\
Fram\
e
(
)
,
Ve\
c3\

(
0.001f
,
0.001f
,
0.001f
)
)
;
TA_AS\
SERT
(
lOllOlOllOl\
O\

.
Get\
WorldAABB
(
)
.
Inte\
rsec\
t\
s\

(
lO\
OOOOO\
lll
)
)
;
#endif //
stati\
c\

int
lO\
llllOlOOOl
=
0
;
lOllll\
Ol\
O\
OOl
++
;
lOll\
OlO\
l\
lO\
lO
.
lOlOOOO\
llO\
OO
(
lOll\
l\
lO\
lOOOl\

)
;
lOll\
O\
lOll\
O\
lO
.
lOl\
OO\
OO\
lOll\
O
(
lOl\
l\
llOl\
OOOl
)
;
lOllO\
lO\
l\
lOlO
.
lOl\
OOOOll\
O\
O\
l
(
lO\
llllOl\
OOOl
)
;
lOllOOllll\
OO
lOl\
lllO\
lOOl\
O
;
lO\
llllOlOOlO
.
In\
itialise
(
this
)
;
lOl\
l\
l\
lOl\
OO\
lO\

.
lOlOOO\
OOllOl
=
&
lO\
llOlOl\
lOlO
;
lO\
l\
lOlOlOlOO\

->
llOOOl\
OO\
ll\
O
(
lOl\
l\
Ol\
Oll\
O\
lO
.
Get\
WorldAA\
BB
(
)
,
lO\
lll\
lOlO\
Oll
,
&
lOllllOlOOlO
)
;
lOll\
OlOl\
OlO\
O\

->
lOl\
OlOO\
OOl
(
lOllOl\
OllOl\
O
)
;
}
}
TA_ASS\
ERT\

(
lOl\
ll\
O\
OOllOO\

==
0
)
;
{
lO\
lOOOOOOlll
*
lOl\
OOOO\
Ol\
lOO\

=
lOl\
l\
OlOllOll
->
lOllllO\
lOlOO
(
)
;
for
(
;
lOl\
OO\
O\
OO\
ll\
OO\

;
lOlO\
OO\
OO\
l\
lOO
=
lOl\
lOlO\
ll\
O\
ll
->
lO\
llllOlO\
lO\
O
(
)
)
{
lOllllOOlOl\
l\

(
*
lOlO\
OOOOl\
lOO
)
;
}
}
fo\
r
(
Dy\
namicObject
*
lOllll\
OOlll\
l
=
lOl\
lll\
OOOlll
;
lOll\
llOO\
l\
l\
ll\

;
lO\
lll\
lO\
Ol\
lll
=
lO\
l\
lllOO\
llll\

->
lOlOOl\
ll\
ll\
OO
(
)
)
{
Dyna\
micObj\
ect
&
lOll\
O\
l\
Ol\
l\
O\
lO
=
*
lOllllO\
Olll\
l
;
TA_A\
SSERT
(
lOl\
lOlOllOl\
O\

.
lO\
OlO\
OOll\
O\
l
(
)
)
;
lOllllOlO\
lO\
l\

(
lOllOlOllOlO
)
;
lOl\
lO\
lOllOlO\

.
lOlO\
O\
lOll\
Oll
(
fal\
se
)
;
}
lOl\
lllOOOlll
=
0
;
lOlO\
O\
OO\
OOl\
ll
*
lOlOOO\
OOllOO
=
lOllOlOllOll\

->
lOl\
lllOlO\
lOO
(
)
;
for
(
;
lO\
l\
O\
O\
OOO\
llOO\

;
lOlO\
OOO\
Oll\
OO\

=
lOllOlO\
l\
lOl\
l\

->
lOll\
ll\
O\
lOlOO
(
)
)
{
}
lOllllO\
OOll\
l
=
lOll\
lOOOllOO
;
lOlllO\
OOl\
lO\
O
=
0
;
}
{
lO\
lOOO\
O\
OOl\
ll
*
lOlOOOOO\
ll\
OO
=
lOllOlOllO\
ll\

->
lO\
llllOlOl\
OO\

(
)
;
for
(
;
lOl\
OOO\
OOllOO\

;
lOlOOOO\
OllOO
=
lOllOlOllOl\
l
->
lOllllOl\
Ol\
OO
(
)
)
{
}
}
lllOllO\
OOO\

&=
~
lOllllOOllO\
O\

;
TA_AS\
S\
ER\
T\

(
lOllO\
l\
Oll\
O\
l\
l\

->
lOll\
llO\
lO\
llO\

(
)
==
0
)
;
lOl\
llO\
lllOlO\

=
lO\
llOlOlll\
lO
.
lOl\
O\
OOOl\
OO\

(
)
;
whi\
le
(
!
lOlllO\
ll\
lOlO
.
AtE\
nd
(
)
)
{
DynamicObject
*
&
lO\
lll\
OO\
lO\
OO
=
*
lOlllO\
l\
llOlO\

;
++
lO\
l\
ll\
O\
l\
ll\
OlO
;
if
(
lO\
ll\
lOOl\
OO\
O\

->
lOlOOO\
l\
OOO\
O\
l
(
)
)
{
lO\
lllOOlOO\
O
->
Se\
tLinearV\
e\
lo\
ci\
ty
(
k_v3Zer\
o
)
;
lOl\
llOOlOOO\

->
Se\
tAngularVelocit\
y
(
k_v3Zero
)
;
lO\
ll\
lOOlOOO
->
SetNe\
xtFr\
am\
e
(
lOl\
llOOlOOO
->
GetFr\
a\
m\
e
(
)
)
;
TA\
_A\
SSE\
R\
T
(
lOll\
l\
O\
OlOOO\

->
IsInMovin\
g\
List
(
)
)
;
lOll\
l\
OOl\
OOO
->
lOlOO\
lOOllOO\

(
0
)
;
lOl\
lOl\
Oll\
ll\
O
.
lO\
O\
l\
llllll\

(
&
lOl\
ll\
OOlOOO
)
;
lO\
ll\
O\
lO\
l\
l\
lO\
l
.
Fre\
e
(
&
lOlllOOl\
OOO\

)
;
lOlllOO\
lO\
OO
->
lOl\
O\
OllllOOl
(
0.0f
)
;
lOlllOOl\
OOO
->
Calcula\
teW\
or\
l\
dAAB\
B\

(
)
;
if
(
lO\
llOllOOO\
ll
)
lO\
llOllOO\
Ol\
l
(
*
lOlllO\
Ol\
OOO
,
lOllOl\
lO\
OlOO
)
;
}
}
TA\
_ASSE\
R\
T
(
lOllO\
lO\
l\
l\
Ol\
l
->
lO\
l\
lllOlO\
llO
(
)
==
0
)
;
lOllOlOllOll
->
lO\
l\
lll\
OlOll\
l
(
)
;
TA_ASSERT\

(
lOllOlOllOll\

->
lOl\
lllOlOllO
(
)
==
0
)
;
lOll\
OlOl\
llOO\

::
It\
er\
at\
o\
r
lOllOllOlOll\

=
lOll\
OlOl\
l\
O\
ll\

->
lOlOOOOlOO
(
)
;
fo\
r
(
;
!
lOllOllOlO\
ll
.
AtEnd\

(
)
;
++
lOl\
l\
Ol\
lOl\
O\
l\
l
)
{
lOlOllll\
OO\
OO
&
lO\
llOl\
l\
O\
llOO
=
*
lOl\
lOl\
lOlOll
;
lOl\
l\
O\
llOllOO
.
lOl\
lllOl\
lOO\
O\

(
fals\
e
,
lOl\
lO\
llOl\
OOl
)
;
}
lOOl\
OlllOll
(
lOll\
OOlOllOl
)
;
}
void
Ph\
y\
s\
ics\

::
lO\
lll\
lO\
lO\
lO\
l
(
DynamicObj\
ec\
t
&
lOl\
l\
llO\
llOOl
)
{
Dynam\
icOb\
je\
ct\

::
Jo\
intIt\
e\
r\
a\
tor
lOlOOl\
OOl\
O
=
lO\
lll\
lO\
llOOl
.
Ge\
tJoint\
I\
t\
erato\
r
(
)
;
for
(
;
!
lOlOOlO\
Ol\
O
.
AtEn\
d\

(
)
;
++
lO\
lOOlOOlO\

)
{
PhysicsJ\
oi\
n\
t
&
lO\
Olll\
llOO\
lO
=
*
lOlOOl\
O\
O\
lO
;
if
(
lOOll\
ll\
lOOlO
.
lOlll\
lO\
l\
l\
OlO
(
)
!=
lOl\
lOllO\
Ol\
lO
)
lOllll\
Oll\
O\
ll
(
lOO\
ll\
l\
llOOl\
O
)
;
}
List
<
Phy\
s\
i\
csJ\
oi\
nt
*
>
::
It\
erator
lOllll\
Olll\
OO
=
lO\
llllO\
l\
lOOl
.
lOlO\
O\
llOlOOO
(
)
;
for\

(
;
!
lO\
llllOlllOO
.
At\
End
(
)
;
++
lOllllOl\
ll\
OO
)
{
Ph\
ysicsJoin\
t
&
lOO\
lll\
llOOl\
O
=
*
*
lOl\
lllOll\
lOO
;
if
(
lOOlll\
llOOlO
.
lOl\
l\
llOl\
lOlO
(
)
!=
lO\
llOllO\
Ol\
lO
)
lOll\
llO\
llOl\
l
(
lO\
OlllllO\
Ol\
O
)
;
}
}
void\

Phys\
ics\

::
lOllllOllOll
(
Physi\
csJo\
i\
nt
&
lOOllll\
lOO\
lO
)
{
lOOllll\
l\
O\
O\
l\
O
.
lOll\
ll\
OlllOl
(
lOllOllOOll\
O
)
;
Phys\
icsJoi\
nt
*
lOll\
l\
OO\
lOlO
=
&
lOOllll\
lOOl\
O
;
if\

(
lOO\
lllllOO\
lO
.
IsBroke\
n
(
)
)
retu\
rn
;
Dyn\
ami\
c\
Ob\
ject
*
lO\
lOO\
O\
O\
OllOl
=
lOOll\
ll\
lOOlO\

.
GetObj\
ec\
tA
(
)
;
Dy\
na\
micObject\

*
lOlOOO\
OO\
ll\
lO
=
lO\
O\
ll\
lllOOl\
O\

.
GetOb\
jectB
(
)
;
TA\
_ASS\
ERT
(
lOl\
OOOO\
O\
llO\
l
)
;
if\

(
lOlOOOOOlllO
)
{
if
(
!
lOlO\
O\
O\
O\
OlllO
->
Ad\
d\
edT\
o\
Ph\
ysic\
s
(
)
)
re\
t\
urn
;
}
else
{
lOlOOOO\
Ol\
llO\

=
lOl\
llOO\
OlOl\
l
;
}
TA_ASSE\
RT
(
lOlOOO\
O\
Oll\
lO
)
;
lOlO\
O\
OOOO\
lll
*
lOlOOO\
O\
O\
l\
lO\
O
=
lOlOO\
O\
O\
Oll\
Ol\

->
lOlOOOO\
O\
lOOO
(
lOlOOO\
O\
Ol\
llO
,
tr\
ue\

)
;
if
(
!
lOl\
O\
OO\
OOllOO
)
re\
turn
;
float
lO\
OllOO\
OO\
Oll
=
Min
(
lOl\
OOOOOl\
lO\
l
->
lOOllOO\
OOl\
OO\

(
)
,
lOlOO\
OOOlll\
O
->
lO\
O\
l\
l\
OOOOl\
OO\

(
)
)
;
lOl\
lOOll\
ll\
O\
O
lOll\
l\
l\
OlOOlO
;
lOllllOlO\
OlO
.
Init\
ia\
lis\
e
(
this
)
;
lOl\
ll\
lOl\
OO\
l\
O
.
lOlOO\
OOO\
ll\
Ol
=
lOl\
O\
OOOOllOl
;
lOllll\
O\
lOOl\
O
.
lOlOOO\
OOl\
llO\

=
lOlOO\
OO\
OlllO
;
lO\
ll\
llO\
lOO\
lO
.
lO\
lOO\
OOOl\
lOO\

=
lOlOOO\
OOl\
lOO
;
int
lOl\
lllOllll\
O
=
0
;
if
(
lO\
OlllllOOlO\

.
IsObjectAS\
o\
lid
(
)
)
lOl\
lllOl\
lllO
|=
Co\
llisio\
n
::
FLAG_O\
BJECTA\
_\
S\
OLID
;
else
if
(
lOO\
lllll\
O\
O\
lO
.
Is\
Obj\
ectBS\
olid\

(
)
)
lOllllOll\
llO\

|=
Col\
lision
::
FLAG_OBJECTB_S\
O\
LI\
D\

;
TA_A\
SSERT
(
lOl\
OOOOOllOl
)
;
if\

(
lOOll\
lllOOl\
O
.
Ge\
tT\
y\
pe
(
)
==
Phys\
icsJ\
oint
::
TYP\
E_LI\
NEAR_SLIDER
)
{
Vec3
ll\
llOO\
OOll
=
lO\
Oll\
lll\
OO\
lO
.
GetP\
o\
sOnO\
b\
j\
ectA\

(
)
*
lOlO\
OOOOl\
lO\
l\

->
GetFr\
am\
e\

(
)
;
Vec\
3\

lOllll\
Olllll
=
lO\
Ollll\
lOOlO
.
GetSlide\
rPo\
s0
(
)
*
lOlO\
OOOOlllO
->
Ge\
tFram\
e
(
)
;
Vec3
lOlll\
llO\
OOO\
O
=
lOOll\
ll\
l\
OOlO
.
GetSliderPo\
s1
(
)
*
lOlO\
OOOO\
ll\
lO\

->
Get\
Fram\
e\

(
)
;
Vec3
lOll\
l\
ll\
OOO\
Ol
=
lO\
Ollll\
lO\
Ol\
O
.
Get\
Pos\
O\
nObjec\
tA\

(
)
*
lOlOOOOO\
llOl
->
Get\
Ne\
xtFra\
m\
e
(
)
;
Vec\
3
lO\
lllllOO\
OlO\

=
lOOlll\
llOOlO
.
GetS\
li\
der\
P\
os\
0
(
)
*
lOlO\
OOOOll\
lO
->
Get\
Ne\
xt\
Frame
(
)
;
Vec3
lOl\
l\
lllOOOll\

=
lOO\
lll\
l\
lOO\
lO
.
GetSlider\
Pos1\

(
)
*
lOl\
OOOO\
Olll\
O\

->
Ge\
tNe\
xtFrame
(
)
;
con\
st\

Vec3
lOll\
lO\
lllOO
=
ll\
llO\
OOOll
;
Vec3\

lOO\
O\
lOOOOO
=
lO\
lllllOOOOO\

-
lO\
llll\
Olllll\

;
TA_ASSERT\

(
lOOOlO\
OO\
OO\

.
GetM\
a\
gn\
itude
(
)
>
0.0f
)
;
lOOO\
lOO\
OOO
.
No\
r\
malise
(
)
;
float
lOlO\
llOlOO
=
lO\
OOlOOOOO
.
Do\
t
(
lOlllOlllOO
-
lOll\
ll\
Oll\
l\
ll
)
;
floa\
t\

lOlO\
llOlO\
l
=
lOOO\
lO\
OOO\
O
.
Do\
t
(
lOlllOl\
llOO
-
lOll\
lllOOOOO\

)
;
fl\
oat
ll\
lOlllllO\

=
lOlOllO\
lOO
/
(
lO\
l\
OllOl\
OO
-
lOlOl\
lOlO\
l
)
;
Ve\
c3
ll\
OlO\
OllO\
ll
=
lOll\
llOl\
llll
+
lOO\
Ol\
OOOOO
*
lllO\
ll\
l\
llO\

;
Mat33
lOOOOOOO\
l\
l
;
Ve\
c3
lOlOO\
OOOlOl
=
llOl\
O\
O\
ll\
O\
ll
-
lO\
lllO\
lllOO
;
if
(
lOlOOOOOl\
Ol\

.
Cro\
s\
s
(
lOOO\
lOO\
OOO
)
.
GetMagni\
tudeSqrd
(
)
>
0.0001f
)
lO\
OO\
O\
OOOll\

.
SetToLoo\
kAt
(
lOOOlO\
OO\
O\
O
,
lOlOOOOOlOl
.
GetN\
orma\
l
(
)
)
;
else
lOOO\
OO\
OOll
.
Set\
ToL\
ook\
DownVe\
ctor
(
lO\
OOlOOO\
OO
)
;
Collision\

lOll\
l\
llOOlOO
;
Collision\

lOl\
l\
lllOO\
lO\
l
;
Collision
lO\
lllllO\
O\
l\
lO
;
lO\
ll\
lllOOlOO
.
Initi\
alise
(
Collis\
i\
on
::
lOllO\
l\
O\
O\
OOl
,
0.0f
,
(
ll\
OlOOll\
Oll
-
lOlllO\
lllOO
)
.
Dot
(
lO\
O\
OOOO\
Oll\

.
v3\
X
)
,
lOll\
lOlllOO
,
lOOO\
OOO\
Oll
.
v3X
,
lO\
lllOOlOlO\

)
;
lOll\
lllO\
OlOO
.
lOl\
Oll\
OOl\
l
|=
lOllllOllll\
O
;
lOllll\
lO\
OlO\
l
.
In\
itialise
(
Co\
llisi\
on
::
lOllOl\
OOOOl
,
0.0f
,
(
llOlOOll\
O\
ll
-
lOl\
ll\
OlllOO
)
.
Do\
t
(
lOOOOOOOll
.
v3\
Y
)
,
lOll\
lOlllO\
O\

,
lOO\
OOOOOll
.
v3Y\

,
lOlllOOlOlO\

)
;
lO\
lll\
ll\
OOl\
O\
l
.
lOlOl\
l\
OOll
|=
lOll\
llOl\
lllO
;
lO\
lllll\
OOlOO
.
lOll\
OlOO\
lll\

(
&
lOll\
lllOOl\
Ol
)
;
if\

(
lllO\
l\
llllO
<
0.0f
)
{
lOl\
l\
l\
l\
lO\
O\
llO\

.
In\
itial\
ise
(
Coll\
isi\
on\

::
lOll\
OlOO\
O\
lO\

,
0.0f
,
-
lll\
Ol\
l\
l\
llO
,
lOll\
lOlllOO
,
lO\
O\
OO\
OO\
O\
ll
.
v3Z
,
lO\
ll\
lOOlO\
lO
)
;
lOl\
l\
lllOOl\
l\
O
.
lO\
l\
OllOO\
l\
l
|=
lOllllO\
lll\
lO
;
lO\
l\
llllOOlll\

(
lOllll\
lOOllO
,
&
lOllll\
O\
lOOlO
)
;
}
el\
se
if
(
lllOll\
ll\
lO\

>
1.0f
)
{
lOlllllOO\
llO
.
Init\
i\
a\
lise
(
Co\
lli\
si\
on
::
lO\
ll\
OlOOOl\
O
,
0.0f
,
ll\
lOll\
l\
llO
-
1
,
lOl\
ll\
OlllO\
O
,
-
lOOOOO\
O\
O\
l\
l
.
v3Z
,
lO\
lllOOl\
Ol\
O
)
;
lOl\
lll\
lOOl\
lO
.
lOlOl\
lOOll
|=
lOllllOll\
llO
;
lOl\
llllOO\
ll\
l
(
lO\
lllllOOll\
O
,
&
lOl\
lll\
Ol\
OO\
lO\

)
;
}
else\

{
Vec3
lOlllllOlOOO
=
lOlllll\
O\
OOl\
l
-
lO\
ll\
l\
llOOOlO\

;
TA_ASSERT
(
lOll\
l\
l\
lOl\
O\
OO
.
Ge\
t\
Magnitu\
de
(
)
>
0.0f
)
;
lOllll\
lOlOO\
O
.
Normal\
ise\

(
)
;
fl\
oat
lOll\
lllOlOOl
=
lOll\
lllO\
lOOO
.
Dot
(
lOll\
l\
l\
lOOO\
Ol
-
lOl\
llllOOOlO
)
;
float
lO\
lll\
l\
lOlO\
l\
O
=
lOlll\
llO\
l\
O\
O\
O\

.
Dot
(
lOlllllO\
OOO\
l
-
lO\
lllllOOOl\
l
)
;
fl\
oat
lOll\
l\
ll\
OlOll\

=
lOlllllOlOOl\

/
(
lOlllllO\
l\
OO\
l
-
lO\
lllllOlOlO\

)
;
Vec3
lOl\
llllOllOO
=
lOlllllO\
OOl\
O
+
lOl\
llll\
O\
lOOO
*
lOll\
lll\
OlO\
ll
;
if
(
lOl\
ll\
llOlO\
ll\

<
0.0f
)
{
lO\
ll\
lllO\
OllO
.
Init\
i\
a\
lise
(
Col\
lis\
ion
::
lOl\
lO\
lOOOlO
,
lllOlllllO\

/
(
lllO\
llll\
l\
O
-
lOlllllOl\
Oll
)
,
0
,
lOlllO\
lllOO
,
lOOOOOOOll\

.
v3Z\

,
lO\
ll\
lOOlOlO
)
;
lOlllllOOll\
O
.
lOlO\
l\
lOOll
|=
lOlll\
lOl\
l\
llO
;
lOll\
lll\
OOll\
l
(
lOl\
l\
ll\
l\
O\
OllO
,
&
lO\
llllOlOOlO
)
;
}
el\
se
if
(
lO\
l\
llllOlOll\

>
1.0f
)
{
lOll\
lllOOl\
l\
O
.
Ini\
tiali\
se
(
Co\
l\
lisi\
on\

::
lO\
llOl\
OOOl\
O
,
(
1.0f
-
lllOl\
llllO\

)
/
(
lOl\
llllOl\
Oll\

-
lll\
Olllll\
O
)
,
0.0f
,
lO\
lll\
OlllOO\

,
-
lOOOOOOO\
ll
.
v3Z
,
lOlllOOlOlO
)
;
lOl\
l\
lllOO\
llO\

.
lOl\
OllOOll
|=
lOl\
lllO\
llll\
O
;
lO\
lllllOO\
l\
l\
l
(
lOlllll\
OOl\
l\
O
,
&
lOll\
llOl\
OO\
lO
)
;
}
}
lOlllll\
OOl\
ll
(
lOll\
l\
llOO\
lOO\

,
&
lOllllOlOOlO\

)
;
}
else\

{
Vec3
llllO\
O\
OOll
=
lO\
Ol\
llll\
OOlO
.
GetPo\
sOn\
Ob\
jectA
(
)
*
lO\
lOOO\
OOl\
lO\
l
->
GetFrame
(
)
;
Vec3\

llllO\
OOlO\
O\

;
if
(
lO\
OlllllOOlO
.
GetType\

(
)
==
Ph\
ys\
icsJoint\

::
TYP\
E\
_V\
E\
C\
T\
OR_CO\
NS\
TRAINT
)
llll\
OOOlOO
=
llllOOO\
Ol\
l
;
els\
e
llllOOOlOO
=
lO\
Ol\
llll\
OO\
lO
.
GetPosOnObjectB\

(
)
*
lOlOOOOO\
l\
llO
->
GetFram\
e
(
)
;
Ve\
c\
3
lOl\
llO\
ll\
lOO\

=
ll\
l\
lOO\
O\
Oll
;
Collis\
ion
lOlllllOOlOO\

;
Colli\
sion
lOlllllOO\
l\
O\
l
;
Col\
l\
ision
lO\
lll\
ll\
OOllO
;
Co\
lli\
s\
io\
n
*
lOlll\
llOllOl
;
Mat3\
3
lOl\
l\
l\
llOl\
llO
;
lOll\
lllOl\
llO
.
SetToIden\
t\
ity
(
)
;
lOll\
ll\
lO\
OlOO
.
Initial\
ise\

(
Col\
li\
sion
::
lOllOlOOOO\
l
,
0.0f
,
(
llllOOOlO\
O
-
llllOOOOl\
l
)
.
Do\
t
(
lO\
lllllO\
lllO
.
v3\
X
)
,
lOlllOll\
l\
OO
,
lOll\
lll\
Olll\
O\

.
v3X
,
lOl\
llOO\
lOlO
)
;
lOlllllOO\
lOO\

.
lOl\
OllOOll
|=
lO\
ll\
l\
lO\
ll\
l\
lO
;
lOlllll\
OOl\
O\
l\

.
In\
itialise
(
Colli\
sion
::
lO\
llO\
l\
O\
OOOl
,
0.0f
,
(
lll\
lOOO\
lOO\

-
llllOOOOl\
l
)
.
Dot
(
lOl\
llllOlllO\

.
v3\
Y
)
,
lO\
lll\
OlllOO
,
lOll\
ll\
l\
O\
lllO\

.
v3\
Y
,
lOl\
llO\
O\
lOlO\

)
;
lOll\
lll\
OOlOl
.
lOlOll\
O\
Oll
|=
lO\
llllOllllO
;
lOlllll\
O\
OllO
.
Initialise\

(
Co\
l\
li\
sion\

::
lO\
l\
lOlOOO\
O\
l
,
0.0f
,
(
ll\
ll\
OOOlO\
O
-
llllOOOOl\
l
)
.
Dot
(
lO\
lll\
llOlllO
.
v3Z
)
,
lOl\
l\
l\
Oll\
lOO
,
lOlll\
llO\
ll\
l\
O\

.
v3Z
,
lO\
ll\
lO\
Ol\
OlO\

)
;
lOl\
llllOO\
ll\
O
.
lOlOll\
O\
O\
ll
|=
lO\
llllOl\
lllO
;
lOlllll\
O\
O\
lOO
.
lO\
l\
lO\
lOOlll
(
&
lOll\
l\
l\
lO\
OlOl
)
;
lO\
lllllOOlO\
l
.
lO\
llOl\
OOl\
ll\

(
&
lOlllllOOl\
lO
)
;
lOl\
lll\
lOllOl
=
&
lOlll\
l\
lOOllO
;
Col\
lision
lO\
lllllOll\
ll
;
Colli\
s\
ion
lOlllll\
lOOOO
;
Co\
l\
li\
sion\

lOllllll\
O\
OOl
;
Collis\
ion
lOllOllOll\
l
;
Colli\
sio\
n
::
Type\

lOl\
lll\
llO\
Ol\
O
=
Collision\

::
lO\
ll\
OlOOOlO
;
flo\
at
lOllllllOOll
=
lOO\
l\
lO\
OO\
OO\
ll\

*
20.0f
;
#ifdef lOllllllOlOO
if\

(
!
lO\
l\
OO\
OOO\
lllO
->
Is\
Worl\
dO\
bje\
ct\

(
)
)
{
PhysicsRe\
n\
der
::
Ren\
de\
rL\
ine\

(
lOlll\
Ol\
llO\
O
,
lO\
lO\
OO\
OO\
llOl
->
GetPosition
(
)
,
0xff0000ff
)
;
Ph\
y\
sicsRe\
nder
::
Ren\
derLin\
e
(
lOlll\
O\
lll\
O\
O
,
lO\
lOO\
O\
OOll\
lO
->
GetPos\
it\
ion
(
)
,
0xff8080ff
)
;
}
#endif //
switch\

(
lOO\
l\
ll\
llOO\
lO
.
GetT\
yp\
e\

(
)
)
{
ca\
se
Ph\
ysics\
Joi\
nt
::
TY\
P\
E_\
VECTO\
R_C\
O\
NSTRAINT
:
if\

(
lOOlll\
llOO\
l\
O
.
GetM\
axAng\
le\

(
)
==
0.0f
)
lOllllllOOlO\

=
Collis\
io\
n
::
lOllOlOO\
Oll
;
el\
se
lOll\
l\
lllOOlO
=
Colli\
s\
i\
o\
n
::
TYPE_R\
O\
TATION_CONST\
RAI\
N\
T
;
case\

Physics\
Joint
::
TYP\
E\
_\
BALL_A\
ND_SOCKET\

:
if
(
lO\
Olll\
llOO\
l\
O\

.
Get\
MaxAngl\
e
(
)
!=
JOIN\
T_LI\
MIT\
_DISABLED
)
{
Vec3
lOl\
l\
ll\
llOlOl
=
lOO\
l\
l\
lllO\
OlO\

.
Ge\
tL\
imitN\
or\
mal\
OnObje\
c\
t\
A
(
)
*
lOlO\
O\
OOOllOl
->
Get\
Frame
(
)
.
m33R\
ot\
ation
;
Vec3
lO\
l\
lll\
llO\
l\
l\
O
=
lOOl\
lll\
lOO\
l\
O
.
Ge\
tLimit\
NormalOnObjectB\

(
)
*
lOlOOOOOll\
l\
O\

->
GetFrame\

(
)
.
m33R\
otat\
io\
n
;
float
lOllll\
llOl\
ll
=
Cos
(
lOOlllllO\
OlO
.
GetMaxAng\
le\

(
)
)
;
floa\
t
lOlOOOlO\
l\
OO\

=
-
lO\
l\
llll\
l\
OlOl
.
Dot\

(
lOlll\
l\
llOllO
)
;
if
(
Fab\
s\

(
lOlOOOlOlOO
)
<
0.99f
)
{
Vec3
lO\
OOl\
OOOOO
=
lOll\
llll\
OllO\

+
lOllll\
llOlO\
l\

;
lO\
OOl\
OOOOO\

.
No\
rma\
lis\
e
(
)
;
Ve\
c3
lOl\
l\
l\
llll\
OOO
=
(
lOlll\
lllO\
lOl\

-
lOl\
l\
lll\
lOllO
)
;
float
lOllllOlOl
=
lOll\
ll\
lll\
OO\
O
.
Ge\
tMagni\
tude
(
)
;
if
(
lOl\
lllOlOl
>
0.00001f
)
{
lO\
lllllll\
OOO
/=
lOllllOlOl
;
}
else\

{
Mat33
lOOOOOO\
O\
ll\

;
lOOOOOOO\
ll
.
Set\
ToL\
ookDownVec\
t\
o\
r
(
lOOOlOO\
OO\
O
)
;
lOll\
lllllO\
O\
O
=
lO\
OOOOOOll\

.
v3Z
;
}
Vec3\

lO\
l\
llOll\
lO\
O
=
(
ll\
ll\
OOOOll
+
ll\
l\
lOOOl\
OO
)
*
0.5f
-
lOl\
l\
lllll\
O\
OO
*
2.0f
;
lOllOllOlll
.
In\
i\
tialis\
e
(
lOllll\
llOOlO
,
0.0f
,
(
lOlll\
lllOll\
l\

-
lOl\
OOO\
l\
O\
lOO\

)
*
lO\
l\
lll\
llOOll
,
lOl\
llOl\
llOO
,
lOOOlO\
O\
OOO\

,
lOlll\
OO\
lOl\
O\

)
;
lOllOllO\
lll\

.
lOlO\
llO\
O\
ll
|=
lOllllOllll\
O
;
lOl\
ll\
llO\
Oll\
l
(
lOllOllOlll
,
&
lOllll\
OlOO\
lO\

)
;
if
(
lOOl\
llllOO\
l\
O\

.
GetMa\
xAngl\
e
(
)
==
0.0f
)
{
Vec3
lOlllO\
lllOO
=
(
llll\
OO\
O\
Oll
+
llllOOOlOO\

)
*
0.5f
-
lOlllllllO\
O\
O
.
Cro\
s\
s
(
lOOOl\
OOOOO
)
*
2.0f
;
lO\
llO\
ll\
Olll
.
In\
itia\
lise
(
lOllll\
llOOl\
O
,
0.0f
,
0.0f
,
lO\
lll\
Oll\
lOO
,
lOOO\
lOO\
O\
O\
O
,
lOlllO\
O\
l\
Ol\
O\

)
;
lOllOllOll\
l
.
lOl\
Oll\
O\
Oll\

|=
lO\
l\
l\
llOllllO
;
lO\
lll\
l\
lOOll\
l
(
lOllOll\
Olll\

,
&
lOll\
llOlOOl\
O\

)
;
}
}
else
if\

(
lOOl\
l\
lllOOl\
O
.
Get\
M\
axAngle
(
)
==
0.0f
)
{
Vec3
lO\
l\
ll\
Olll\
O\
O
=
(
llll\
OOO\
Oll
+
llllOOOlOO
)
*
0.5f
-
lOl\
lllllOlO\
l\

*
2.0f
;
Mat33
lO\
OOOO\
O\
Oll
;
lOOOOOOOll
.
SetToLookDownVect\
o\
r
(
lOl\
ll\
lll\
OlO\
l
)
;
Co\
l\
lis\
ion
lO\
llOll\
Olll\

;
lOllO\
llOlll
.
Ini\
tialise
(
lOllll\
llOOlO
,
0.0f
,
0.0f
,
lOll\
lO\
lllOO\

,
lOOOOO\
OOll
.
v3X
,
lOlllOOlOlO
)
;
lOllO\
llOlll
.
lOlO\
ll\
O\
Oll
|=
lOl\
lllOl\
lllO
;
lO\
l\
llll\
OO\
l\
ll
(
lO\
llOl\
lOlll
,
&
lOll\
llOl\
O\
O\
lO
)
;
lOl\
lOll\
Oll\
l
.
Initia\
l\
ise
(
lOl\
ll\
l\
llOOlO
,
0.0f
,
0.0f
,
lOlllOl\
llOO\

,
lOOO\
OO\
OOll
.
v3\
Y
,
lOlll\
O\
OlOlO
)
;
lO\
l\
lOllOll\
l
.
lOl\
Ol\
lO\
Ol\
l
|=
lOl\
ll\
lOllllO\

;
lOlll\
llOOll\
l\

(
lOllO\
ll\
O\
lll
,
&
lO\
llllOlOOlO
)
;
}
}
break\

;
cas\
e
Phys\
ics\
Joint
::
TYP\
E\
_LIMITED_BALL\
_A\
ND_SOCKET
:
{
Mat33\

lOllll\
l\
l\
lO\
Ol
=
lOOlll\
llOOlO\

.
Ge\
tJ\
o\
in\
tOrient\
a\
tio\
nA
(
)
*
lOl\
OOOO\
OllOl\

->
GetFra\
me
(
)
.
m33Ro\
t\
a\
tion
;
Mat3\
3
lOl\
llllllOlO
=
lOOlllllOOlO\

.
Get\
Join\
tOr\
ie\
ntati\
on\
B
(
)
*
lO\
lO\
O\
OOOl\
l\
l\
O
->
Get\
Fr\
a\
me\

(
)
.
m33\
Rotation
;
Mat\
3\
3
lOll\
l\
ll\
llO\
ll
=
lOll\
lllll\
OlO
*
lOll\
l\
ll\
llO\
Ol
.
GetTra\
nsp\
oseAsInverse
(
)
;
Vec3
lO\
l\
lll\
lll\
lO\
O
(
lOllll\
ll\
l\
Ol\
l
.
v3Y
.
x
,
0.0f
,
lOlllllllOll
.
v3Y
.
z
)
;
float
lOl\
lllO\
l\
O\
l\

=
lOllllll\
l\
l\
OO
.
GetMag\
nitude
(
)
;
Vec\
3\

lOOOOllO\
l\
lO
;
if
(
lOl\
lllOlOl
>
0.001f
)
{
fl\
oat
lOll\
ll\
llllOl
=
AT\
an2\

(
lOllll\
O\
lOl
,
lOlll\
llllO\
ll
.
v3\
Y
.
y
)
;
if
(
lO\
Ol\
llllOO\
lO
.
GetMa\
xAn\
g\
les
(
)
.
x
!=
JOI\
NT_LIMIT_D\
ISABLED
)
{
{
Vec3
llOOll\
lllO\

=
llllOO\
O\
O\
l\
l
+
lO\
ll\
lllllOl\
O
.
v3Y
*
lO\
ll\
llllOOl\
l\

;
Vec3
lO\
OO\
lOOOOO\

=
(
lOllll\
lllOll
.
v3Y
.
Cr\
o\
s\
s
(
lOlll\
llll\
lOO
.
Cros\
sW\
ith\
U\
ni\
t\
Y
(
)
)
*
lO\
l\
ll\
ll\
llOOl
)
;
lOOOlOOOO\
O
.
Norma\
lise
(
)
;
lOllOll\
Oll\
l\

.
Ini\
ti\
alise\

(
Collisi\
on
::
lOllOlO\
OOl\
O
,
0.0f
,
-
(
lOOlllllO\
OlO
.
Ge\
tM\
axAng\
l\
es\

(
)
.
x
-
lO\
llll\
ll\
llOl\

)
*
(
lOll\
l\
lll\
OOll\

*
2.0f
*
k_fPi
)
,
llOOl\
ll\
llO
,
lOO\
OlOO\
OO\
O
,
lOll\
l\
O\
Ol\
OlO
)
;
lOllOllOll\
l
.
lOlOl\
lO\
Ol\
l
|=
lOl\
l\
llO\
llll\
O
;
lO\
l\
ll\
llOOlll
(
lOllOll\
Oll\
l
,
&
lO\
lll\
lOlOOlO\

)
;
}
}
lOll\
llllll\
OO
=
k_v3UnitY
.
Cro\
s\
s
(
lOlll\
lll\
lO\
ll
.
v3Y
)
;
lO\
ll\
l\
l\
llllO\
O
.
Normal\
is\
e\

(
)
;
lO\
OOOll\
OllO
=
lO\
l\
llllllO\
ll
.
v3Z
*
Ma\
t\
33
(
lOl\
llllll\
lO\
O
,
-
lOllllllllO\
l
)
;
}
el\
se
{
if\

(
lOO\
ll\
l\
l\
lOOl\
O
.
Ge\
tMax\
A\
ngles
(
)
.
x
!=
JOI\
NT_LI\
MIT_\
DIS\
ABLED\

)
{
Vec\
3\

ll\
O\
O\
lllll\
O
=
llll\
OO\
OO\
ll
+
lOll\
l\
llllO\
lO
.
v3Y
*
lO\
llll\
llOOll
;
Vec3
lOOOl\
OO\
OOO
=
lOl\
llllllOlO
.
v3\
X
;
lO\
l\
l\
O\
llOl\
l\
l
.
In\
it\
i\
alis\
e
(
Col\
lis\
ion
::
lOllOlO\
OOlO
,
0.0f
,
-
lOOllll\
lO\
Ol\
O
.
GetM\
ax\
Angles
(
)
.
x
*
(
lO\
l\
ll\
l\
llOOll
*
2.0f
*
k_fPi\

)
,
llOOlllllO
,
lOOO\
lOO\
O\
OO
,
lOlllOOlOlO
)
;
lOl\
lOllOlll
.
lO\
l\
Oll\
OOll
|=
lOlll\
lOllllO
;
lO\
lllllO\
Olll
(
lOl\
l\
O\
llOlll
,
&
lO\
ll\
llOlOO\
lO
)
;
lO\
l\
l\
Ol\
lOlll
.
Ini\
tialise\

(
Colli\
sio\
n
::
lOl\
lOl\
OO\
OlO
,
0.0f
,
lOO\
ll\
lllOOl\
O
.
Ge\
tMaxAngles
(
)
.
x
*
(
lO\
lllll\
lO\
O\
ll
*
2.0f
*
k_fP\
i
)
,
ll\
OOll\
l\
llO
,
lOOOlOOOOO
,
lOl\
llOOl\
OlO
)
;
lOllOllOlll
.
lOlOllOOll
|=
lO\
lll\
lOll\
llO
;
lOlll\
l\
lOOlll
(
lOllOllOl\
ll
,
&
lO\
llllOlOOlO\

)
;
lOlllllll\
lOO
=
lOlllllllOl\
l
.
v3Z
;
llO\
Oll\
lllO
=
llllOO\
O\
Oll
+
lOl\
llll\
llOlO
.
v3Y\

*
lO\
llllll\
OOll
;
lOO\
O\
lOO\
OOO
=
lO\
ll\
lllll\
O\
lO\

.
v3\
Z
;
lO\
l\
l\
OllOll\
l\

.
Initialis\
e
(
Co\
l\
lision
::
lO\
llOlO\
O\
OlO
,
0.0f
,
-
lOO\
ll\
ll\
lOOlO\

.
GetMa\
xA\
ngl\
es
(
)
.
x
*
(
lOll\
ll\
l\
lOO\
l\
l\

*
2.0f
*
k_\
fPi
)
,
llOOl\
llllO
,
lOOO\
lOOOOO\

,
lOlll\
OOlOlO\

)
;
lOllO\
ll\
Oll\
l\

.
lOlOll\
OOl\
l
|=
lOllllO\
llllO
;
lOll\
l\
llOOlll
(
lOllOl\
lOl\
ll\

,
&
lOllllOl\
OOlO
)
;
lOllOll\
O\
lll
.
Initial\
ise\

(
Collisi\
on
::
lO\
l\
lOl\
OOO\
lO\

,
0.0f
,
lO\
Ollll\
lOO\
l\
O
.
Ge\
t\
MaxA\
ngles
(
)
.
x
*
(
lOlllll\
lOO\
ll\

*
2.0f
*
k_fPi
)
,
llO\
Oll\
lllO
,
lOOO\
lOO\
OOO
,
lO\
lllOOlOlO\

)
;
lOl\
lOllOlll
.
lOlOllO\
Oll
|=
lO\
lll\
lOllll\
O
;
lOl\
llllOOl\
ll\

(
lOllOllO\
lll
,
&
lOlll\
lOlOO\
l\
O
)
;
}
lOOOO\
l\
lOllO
=
lOl\
llllllO\
ll
.
v3Z
;
}
TA_\
ASS\
ER\
T
(
Fabs
(
lO\
OOOl\
lOl\
l\
O
.
y
)
<
0.01f
)
;
float
lOlllllllllO\

=
ATa\
n\
2
(
lO\
OO\
OllO\
ll\
O
.
z
,
lOOO\
OllOl\
lO\

.
x
)
;
Vec3
llOOl\
llllO\

=
ll\
llOO\
OOl\
l
+
lOlll\
l\
l\
l\
lO\
l\
O
.
v3Z
*
lOllllllOO\
ll
;
Vec3
lOOOlOOOOO
=
lO\
llll\
ll\
lOlO
.
v3\
X
;
if
(
lOOlllllOOlO
.
GetMaxAngles
(
)
.
y
!=
JOIN\
T_LIMIT_DISA\
BLED
)
{
lOl\
lOllOll\
l
.
Initialise
(
Coll\
ision\

::
lOllOlOOOl\
O
,
0.0f
,
(
lOOlllllOOl\
O
.
GetMaxAngles\

(
)
.
y
-
lO\
l\
ll\
ll\
llllO
)
*
lOll\
llllOOl\
l
,
llOOlllllO
,
lOOOlO\
OO\
OO
,
lOlll\
OOlO\
lO
)
;
lOllOllOlll
.
lOlOllOO\
ll\

|=
lOll\
llOll\
l\
lO
;
lOllll\
lOOlll
(
lOl\
lOl\
l\
Olll
,
&
lOlll\
l\
O\
l\
OOlO
)
;
}
if\

(
lO\
Olll\
llOOlO
.
Ge\
t\
M\
inA\
ngles
(
)
.
y
!=
JO\
IN\
T_LIM\
IT_DISABL\
ED
)
{
lO\
ll\
OllOl\
ll
.
In\
itia\
li\
se
(
Collision
::
lOl\
lOlO\
OOlO
,
0.0f
,
-
(
lOO\
lll\
llO\
Ol\
O\

.
Ge\
tMi\
n\
Angles
(
)
.
y
-
lO\
llllll\
lll\
O
)
*
lOlll\
lllOO\
ll
,
llOOlll\
ll\
O
,
-
lOOO\
l\
OO\
O\
OO\

,
lOlllOO\
l\
O\
l\
O
)
;
lOl\
l\
O\
l\
lOlll
.
lO\
l\
OllO\
Oll
|=
lOllllOlll\
lO
;
lOlllllOOlll
(
lOllO\
l\
lO\
lll
,
&
lOlll\
lOl\
O\
O\
lO
)
;
}
}
bre\
ak
;
case
Physi\
csJoint\

::
TY\
PE_SQU\
A\
RE_\
SOC\
KE\
T
:
{
Mat33
lOlllllllOlO
=
lOOll\
lllOOl\
O
.
Get\
JointOrie\
nt\
ati\
onB\

(
)
*
lOl\
OOOOO\
lllO
->
Get\
F\
r\
a\
me\

(
)
.
m33Rotati\
o\
n
;
Mat33
lOlllll\
llO\
O\
l
=
lOOlllll\
OOl\
O\

.
GetJo\
i\
ntO\
r\
i\
ent\
a\
tio\
nA
(
)
*
lOlO\
OOOO\
llOl\

->
GetFr\
am\
e
(
)
.
m33Rot\
at\
io\
n
;
Mat33
lO\
lllllll\
Ol\
l\

=
lOll\
lllllOlO
*
lO\
l\
llllllOOl
.
GetTransp\
o\
se\
AsIn\
vers\
e\

(
)
;
flo\
at
lOOOOl\
lOOll
;
float\

lOOOOllOlOO
;
Si\
nA\
ndC\
os
(
lOOlll\
llOOlO
.
Get\
Mi\
nAngles
(
)
.
x
,
lOO\
OOll\
OOll\

,
lOOOOll\
OlOO\

)
;
Vec3
lOlllll\
l\
l\
ll\
l
(
0.0f
,
lOOOOllO\
l\
OO\

,
lOOO\
OllOOll\

)
;
Si\
nAn\
dCos
(
lOO\
llll\
lOO\
l\
O
.
GetM\
ax\
Angles
(
)
.
x
,
lOOOOll\
OOll
,
lO\
OOOl\
lOlO\
O\

)
;
Ve\
c3
ll\
OOOOOOO\
O\
O\
O
(
0.0f
,
lOOOOllOl\
O\
O
,
lOOOOllOOll
)
;
SinAnd\
Co\
s\

(
lOO\
l\
ll\
llOOlO\

.
GetMinA\
ngl\
es
(
)
.
z
,
lOOOOllOOl\
l\

,
lO\
OO\
O\
llOlOO
)
;
Vec3
llO\
OO\
OOO\
OOO\
l
(
lOOOO\
llOOll
,
lOOO\
O\
llO\
lOO\

,
0.0f
)
;
SinAndCo\
s
(
lO\
Ollll\
lOOl\
O
.
Get\
M\
ax\
An\
g\
les
(
)
.
z
,
lOOO\
Oll\
OO\
ll\

,
lO\
OO\
O\
llOlO\
O\

)
;
Vec3
ll\
OOOO\
OOOO\
lO
(
lO\
O\
OOllOOll\

,
lOOOOl\
l\
O\
lOO
,
0.0f
)
;
co\
ns\
t
flo\
a\
t
ll\
OOO\
OO\
OOO\
ll\

=
1.0f
;
{
Vec3
lOOOl\
O\
O\
OOO\

=
llOOOOOOOOO\
O\

.
Cross
(
llOOO\
OOOOOl\
O
)
;
TA\
_\
ASSER\
T\

(
lO\
OO\
lOOOOO
.
Ge\
t\
Magnit\
u\
d\
e\

(
)
>
0.0f
)
;
lOO\
Ol\
O\
O\
OOO
.
Normal\
i\
se
(
)
;
floa\
t
lOO\
OlOOOlO\
OO
=
-
lOl\
ll\
llllOll
.
v3Y
.
Dot
(
lOOOlOOOOO\

)
;
{
lOOOlOO\
OOO
=
lOlllll\
l\
l\
Oll
.
v3Y
.
Cross
(
lOOOlOO\
OOO\

.
Cr\
oss
(
lOlll\
llllOll
.
v3\
Y\

)
)
;
lOOOlOOO\
OO
.
Normalise
(
)
;
lO\
OOlOOOOO
*=
lOllll\
l\
llO\
Ol
;
Vec3\

ll\
OOl\
l\
l\
llO
=
ll\
ll\
OOO\
Oll
+
lOll\
lllllOlO\

.
v3Y
*
lOlllll\
l\
O\
Oll
;
lOllOllOlll\

.
Initiali\
s\
e
(
Collisi\
on\

::
lOllOlOOOlO
,
0.0f
,
lO\
O\
O\
lO\
O\
OlOOO\

*
(
lO\
lll\
lllOOll\

*
llOO\
OO\
OOOOll
)
,
ll\
OO\
lll\
l\
lO
,
-
lOOOlOO\
OO\
O
,
lOlllOOlO\
l\
O
)
;
lOll\
O\
l\
l\
O\
ll\
l
.
lOl\
OllOOll
|=
lO\
llll\
OllllO
;
lOlllll\
O\
O\
lll
(
lOllOllOlll
,
&
lOll\
llOlOOlO\

)
;
}
}
{
Vec3
lOOOl\
OOO\
OO
=
llOOO\
OOOO\
OlO
.
Cross\

(
lO\
l\
ll\
lllllll
)
;
TA_ASSE\
RT
(
lO\
OO\
lOOOOO
.
Ge\
tMag\
n\
it\
u\
de
(
)
>
0.0f
)
;
lOOOl\
O\
OOOO
.
Normalise
(
)
;
fl\
o\
at
lO\
OO\
lO\
OOl\
O\
OO\

=
-
lOll\
lllllO\
l\
l
.
v3Y
.
Dot
(
lOOOlOOO\
OO
)
;
{
lOOOl\
OOOO\
O
=
lO\
l\
lll\
ll\
lOll
.
v3Y
.
Cr\
oss
(
lOO\
OlO\
OOOO
.
Cro\
ss
(
lOl\
llllllOl\
l
.
v3Y
)
)
;
lOOOl\
OOOOO
.
Norm\
ali\
s\
e\

(
)
;
lOOOlO\
OOOO
*=
lOlllllllOOl\

;
Vec3
ll\
OO\
l\
l\
lllO
=
lll\
lOOOOl\
l
+
lO\
lllllllOlO
.
v3Y
*
lOl\
ll\
lllOOll\

;
lO\
llOl\
lOlll\

.
Initialise
(
Col\
l\
i\
sion
::
lOllO\
lOOO\
l\
O
,
0.0f
,
lO\
O\
OlOOOlOOO
*
(
lOlll\
lllOOl\
l
*
llOOOOO\
O\
OO\
ll
)
,
llOO\
lll\
l\
lO\

,
-
lOOOlOOOOO
,
lOlll\
OO\
lOlO
)
;
lOllOllOl\
ll\

.
lOlOll\
O\
Oll
|=
lOl\
lllOl\
l\
llO
;
lOll\
ll\
lOOlll
(
lOllOll\
Olll
,
&
lOl\
l\
ll\
O\
lOOl\
O
)
;
}
}
{
Ve\
c3
lO\
OO\
lOOOOO
=
lO\
ll\
ll\
l\
llll\
l
.
Cro\
s\
s
(
llOOO\
O\
O\
OOOOl\

)
;
TA_\
AS\
SE\
RT
(
lO\
O\
OlOO\
OO\
O
.
GetMa\
g\
n\
itud\
e\

(
)
>
0.0f
)
;
lOOO\
lOOOO\
O
.
Normal\
ise
(
)
;
flo\
at\

lOO\
OlOOOlOO\
O\

=
-
lO\
lllllllOll
.
v3Y
.
Do\
t
(
lO\
OOl\
OOOOO
)
;
{
lO\
OOlOOOOO\

=
lO\
llll\
lll\
Ol\
l
.
v3Y
.
Cros\
s
(
lOOO\
lOOO\
O\
O\

.
Cros\
s\

(
lOll\
ll\
ll\
l\
O\
ll
.
v3Y
)
)
;
lOOO\
lO\
OOOO\

.
No\
rm\
a\
l\
ise\

(
)
;
lO\
OOlOOOO\
O\

*=
lOlll\
llllOOl
;
Vec3
llO\
Ollll\
lO
=
ll\
l\
lOOOO\
ll\

+
lOlllll\
l\
lOlO
.
v3\
Y
*
lOll\
llll\
OOll
;
lO\
llOl\
lOlll
.
Ini\
tiali\
se
(
Collisi\
on
::
lOllOlOO\
O\
lO\

,
0.0f
,
lOOOlOOO\
lO\
OO\

*
(
lOlllll\
lOO\
ll
*
llOOOOOOOO\
ll
)
,
llOO\
l\
llllO
,
-
lO\
OOlOOO\
OO
,
lOlllOOl\
OlO
)
;
lOllOl\
lOll\
l\

.
lO\
lO\
ll\
OOll
|=
lO\
llllO\
ll\
llO
;
lO\
lllllO\
Olll
(
lOllO\
llOll\
l\

,
&
lOll\
llOlO\
OlO
)
;
}
}
{
Vec3
lO\
OO\
lOO\
OOO
=
llOOOOOO\
O\
OO\
l
.
Cro\
s\
s
(
llO\
OO\
OOOOOOO\

)
;
TA_AS\
SE\
R\
T\

(
lOOOlOOOOO\

.
GetMa\
gnitude
(
)
>
0.0f
)
;
lOOOlO\
O\
OO\
O
.
Norma\
lise
(
)
;
float\

lOOOlOO\
OlOOO
=
-
lOll\
l\
lll\
l\
Oll\

.
v3Y
.
Dot
(
lOOOlO\
OOOO
)
;
{
lOOOlOOOOO
=
lOlll\
lll\
l\
Oll
.
v3Y
.
Cross
(
lOO\
Ol\
OOOO\
O
.
Cross
(
lOllllll\
lOll
.
v3Y\

)
)
;
lOO\
OlO\
OOOO
.
No\
rmal\
is\
e\

(
)
;
lOOOlOO\
O\
OO
*=
lOlllllllO\
O\
l
;
Vec3\

llOOl\
llll\
O
=
llllOOOOll
+
lOlllllllOlO
.
v3Y
*
lOlllll\
lOOll
;
lO\
llOllOlll
.
Init\
ial\
is\
e
(
Collisi\
on
::
lOllOl\
OOO\
lO\

,
0.0f
,
lO\
OOlOOOlOO\
O
*
(
lOllllllOO\
ll
*
llOOOOOOOOll
)
,
llOOl\
llll\
O
,
-
lOOO\
lOO\
OOO
,
lOlll\
OOl\
OlO
)
;
lOl\
lOllOlll\

.
lOlOllO\
Ol\
l
|=
lOlll\
lO\
llll\
O
;
lOlllll\
OOlll
(
lO\
llOllOll\
l\

,
&
lO\
ll\
l\
lOlOOl\
O
)
;
}
}
Vec3
lOlllll\
l\
llOO
(
lOll\
lllll\
Ol\
l
.
v3Y\

.
x
,
0.0f
,
lO\
lll\
llllO\
ll
.
v3\
Y
.
z
)
;
flo\
at
lOllllOlO\
l\

=
lOlll\
ll\
lll\
OO
.
Get\
M\
agnit\
ude
(
)
;
if
(
lOllllO\
lOl\

>
0.01f
)
{
float
lO\
l\
lll\
lll\
lOl
=
ATan\
2
(
lO\
l\
l\
l\
lOlO\
l\

,
lOlllllllO\
ll\

.
v3Y
.
y
)
;
lOlllll\
lllOO
=
k_v3Un\
itY
.
Cro\
ss
(
lOll\
l\
l\
lllOll\

.
v3\
Y
)
;
lOllllll\
llOO
.
Normalis\
e
(
)
;
Vec3\

lOO\
OOllOll\
O\

=
lOllll\
lllO\
ll
.
v3Z
*
Ma\
t\
3\
3
(
lO\
l\
l\
l\
lllllO\
O
,
-
lOllllll\
llOl
)
;
TA_\
A\
SSERT
(
Fabs
(
lOOOOllOllO
.
y
)
<
0.01f
)
;
flo\
at\

lOlll\
llllllO
=
ATan2\

(
-
lOOOOl\
lOl\
lO
.
x
,
lOOOO\
llO\
llO
.
z
)
;
Vec\
3
llOOlllllO
=
ll\
llOO\
O\
Oll
+
lOlll\
ll\
llOlO\

.
v3Z
*
lOl\
lllllOO\
ll
;
Vec3\

lOOOlOOO\
O\
O
=
lO\
l\
lll\
l\
llOlO
.
v3X\

;
if\

(
lOll\
ll\
ll\
lll\
O
>
lOOl\
llllOO\
lO
.
GetMaxA\
n\
g\
les
(
)
.
y
)
{
lOll\
Oll\
O\
lll\

.
Initial\
ise\

(
Co\
l\
lisio\
n
::
lOll\
O\
l\
OOO\
l\
O
,
0.0f
,
-
(
lO\
Ol\
l\
ll\
lOO\
lO
.
GetMaxAngl\
es\

(
)
.
y
-
lO\
l\
llll\
llllO
)
*
lOl\
l\
l\
l\
l\
lO\
Oll
,
llO\
OlllllO
,
-
lO\
OO\
lO\
O\
OOO\

,
lOll\
l\
OOl\
OlO\

)
;
lOllOllOll\
l\

.
lOlOl\
lOO\
ll
|=
lOllllO\
lll\
l\
O
;
lOl\
ll\
ll\
OOlll
(
lOll\
Oll\
Oll\
l
,
&
lOlll\
lOlOOl\
O
)
;
}
el\
se
if
(
lOll\
ll\
lllllO
<
lOOlll\
llOOlO
.
Get\
M\
inAngles
(
)
.
y
)
{
lO\
llOllOl\
ll\

.
Ini\
ti\
a\
lise
(
Col\
lisi\
o\
n\

::
lOll\
Ol\
OOO\
lO
,
0.0f
,
(
lOOl\
ll\
ll\
O\
O\
lO
.
GetM\
inA\
ngle\
s
(
)
.
y
-
lOl\
l\
llllll\
lO
)
*
lOlll\
lll\
OO\
ll
,
llOOllll\
lO
,
lOOOl\
OOOOO
,
lOlllOO\
lO\
lO\

)
;
lOllOllOlll
.
lO\
lOllOOl\
l\

|=
lO\
ll\
l\
l\
O\
ll\
llO
;
lO\
lllllO\
Oll\
l\

(
lOllOllO\
ll\
l
,
&
lO\
llllOl\
O\
OlO
)
;
}
}
else\

{
}
}
brea\
k
;
ca\
se
Ph\
ysicsJoint
::
TYP\
E\
_R\
OTATIO\
N\
_CONSTRA\
INT
:
lOllllllOOlO
=
Colli\
si\
on
::
TYPE_\
R\
OTATION\
_CO\
NS\
T\
RAI\
N\
T
;
case
Phy\
si\
cs\
Joi\
nt\

::
TY\
P\
E_EULER_ANG\
LE_CON\
S\
T\
R\
AINT
:
{
Mat33
lO\
ll\
l\
ll\
l\
l\
OlO
=
lOOll\
lll\
O\
OlO
.
GetJo\
i\
nt\
Ori\
e\
n\
tati\
o\
nB
(
)
*
lOl\
OOOOOlll\
O\

->
GetF\
rame
(
)
.
m33R\
otati\
on
;
Mat\
33\

lOl\
llll\
llOOl
=
lOO\
lll\
l\
lOOlO\

.
GetJ\
ointOrientatio\
n\
A
(
)
*
lOlO\
OOOOllOl\

->
GetFra\
me
(
)
.
m33Rotati\
on\

;
Mat33
lOl\
l\
lll\
l\
lO\
ll
=
lO\
l\
l\
lll\
llOl\
O
*
lO\
ll\
llll\
lOO\
l
.
Get\
Tra\
nspose\
AsInver\
s\
e
(
)
;
Eule\
rAngl\
es
llO\
O\
OOOO\
O\
lOO\

=
lOOlllll\
OOlO
.
llO\
OOOOO\
OlOl\

(
)
;
llOO\
O\
OOOO\
lOO
.
Up\
da\
teTo
(
Eule\
rAng\
le\
s
(
lOl\
llll\
llOll\

)
)
;
lOOlllllOOl\
O
.
lOOlllOOOlO\
O\

(
llOO\
OOO\
OO\
l\
OO\

)
;
Ve\
c3\

llOOlllllO\

=
llllO\
O\
OlO\
O
+
lOll\
ll\
ll\
lOl\
O
.
v3X
*
lO\
l\
ll\
lll\
O\
Oll
;
Vec3
lOO\
O\
lOOOO\
O
=
-
lOl\
l\
l\
ll\
l\
lO\
lO
.
v3Y
;
if
(
lOOl\
l\
lllOOlO
.
GetMaxAngles
(
)
.
z
==
JOIN\
T\
_LI\
M\
I\
T_DI\
SA\
BL\
ED\

)
{
}
els\
e
if
(
lOOllll\
lOOl\
O\

.
Ge\
tMi\
nAngl\
es
(
)
.
z
>=
lOOlll\
llOO\
lO
.
Ge\
tMaxA\
n\
gles\

(
)
.
z
)
{
lOllll\
l\
O\
lll\
l
.
In\
iti\
alise\

(
Collision\

::
lOllOlOOOOl
,
0.0f
,
(
lOOll\
l\
l\
l\
OOlO
.
Get\
MinAn\
g\
l\
es
(
)
.
z
-
llOOOO\
OOOlO\
O\

.
z
)
*
(
lOll\
ll\
ll\
O\
Oll
*
(
2.0f
*
k_fPi
)
)
,
ll\
OOlllllO
,
lO\
OOlOOO\
OO\

,
lOll\
lOO\
lO\
lO
)
;
lOl\
llllOlll\
l\

.
lOl\
O\
llOO\
ll
|=
lO\
l\
l\
llOll\
ll\
O
;
TA_ASSERT\

(
!
lOl\
llllO\
llO\
l
->
GetNext
(
)
)
;
lOlllllOl\
lO\
l
->
lOllO\
lO\
Oll\
l
(
&
lOl\
l\
lll\
Oll\
l\
l
)
;
lOl\
llll\
O\
llOl
=
lOlllll\
OllOl
->
GetNe\
x\
t
(
)
;
}
els\
e\

{
{
lOllOll\
O\
lll
.
Init\
iali\
se
(
lOl\
l\
llllOOlO
,
0.0f
,
(
lOOllll\
l\
OOlO
.
GetMin\
A\
ngles
(
)
.
z
-
ll\
O\
OOOO\
OOlO\
O
.
z
)
*
(
lOlll\
lllOOl\
l
*
(
2.0f
*
k_f\
Pi
)
)
,
ll\
OOl\
l\
lllO
,
lOOOlO\
OOOO
,
lO\
lll\
O\
OlOlO
)
;
lOl\
lOll\
Oll\
l
.
lOlOllOO\
l\
l
|=
lOll\
l\
l\
OllllO\

;
lOlllll\
OO\
ll\
l
(
lOl\
l\
OllOlll
,
&
lOll\
l\
lO\
lOOlO
)
;
}
{
lOllOll\
Oll\
l\

.
Init\
ialise
(
lOllllll\
OOl\
O\

,
0.0f
,
(
llOOOOOOOlO\
O
.
z
-
lOOl\
l\
ll\
lOOlO
.
GetMa\
x\
Ang\
l\
e\
s\

(
)
.
z
)
*
(
lOllllll\
OO\
l\
l\

*
(
2.0f
*
k_fPi\

)
)
,
llO\
Ol\
l\
l\
l\
lO
,
-
lOOOl\
OO\
OOO\

,
lOl\
ll\
OOlO\
l\
O
)
;
lOl\
lOllOlll
.
lOlOllOOl\
l
|=
lO\
lll\
lO\
l\
l\
llO\

;
lOll\
lllOOlll
(
lOll\
OllO\
lll
,
&
lOl\
lllOlOOl\
O
)
;
}
}
llOOl\
llllO
=
llllOOO\
lOO\

+
lO\
lll\
llllOl\
O
.
v3Z
*
lOlllll\
lOOll
;
lO\
OOlOO\
OOO
=
-
lO\
llll\
lllOOl
.
v3Y
.
Cr\
o\
s\
s\

(
lO\
ll\
ll\
l\
llO\
lO\

.
v3\
Z
)
.
Cr\
o\
ss
(
lOllll\
lllOlO\

.
v3Z
)
;
if
(
lOOOlOO\
OO\
O\

.
GetMagni\
tudeS\
q\
rd
(
)
>
0.0000001f
)
{
lO\
OOlOOOOO
.
No\
rmalise\

(
)
;
if\

(
lOOlllllO\
OlO
.
Get\
M\
ax\
Angl\
es
(
)
.
x
==
JO\
INT_LI\
MIT_DIS\
A\
BLED
)
{
}
else
if
(
lOOlllll\
OOlO
.
Ge\
tM\
i\
n\
Angles
(
)
.
x
>=
lOO\
lllllOOlO\

.
Ge\
tMax\
Angl\
es
(
)
.
x
)
{
lO\
ll\
llllOOOO
.
Ini\
t\
ialis\
e
(
Collis\
ion\

::
lOllOlO\
OOOl
,
0.0f
,
(
lOOlllllOOlO\

.
GetM\
inAn\
gl\
es
(
)
.
x
-
llOOOOO\
OO\
l\
OO
.
x
)
*
(
lOl\
llll\
lOO\
l\
l
*
(
2.0f
*
k_\
fP\
i
)
)
,
llOOlllll\
O
,
lO\
OOlO\
OOOO\

,
lOlllOOlOl\
O
)
;
lOll\
ll\
ll\
OOO\
O\

.
lO\
lOllO\
O\
ll
|=
lOll\
l\
l\
O\
llllO\

;
TA\
_ASSERT
(
!
lOlll\
llO\
llOl\

->
GetNext
(
)
)
;
lOl\
llllOllOl
->
lOllOl\
OOl\
ll\

(
&
lOl\
ll\
lllO\
O\
O\
O
)
;
lOlll\
l\
l\
Ol\
l\
Ol
=
lOllll\
lOl\
lOl
->
GetNe\
xt
(
)
;
}
el\
se
{
{
lOll\
O\
llOll\
l
.
Initia\
lise
(
lO\
llllllOOl\
O\

,
0.0f
,
(
lOOl\
ll\
llO\
O\
lO
.
GetMinAng\
le\
s
(
)
.
x
-
llOOOOOO\
Ol\
OO\

.
x
)
*
(
lO\
l\
l\
llllOOll
*
(
2.0f
*
k_fPi
)
)
,
ll\
OOl\
lll\
lO
,
lOO\
OlOOOO\
O\

,
lOl\
llOO\
l\
Ol\
O\

)
;
lOllOllOl\
ll\

.
lOlO\
llOOl\
l
|=
lOll\
ll\
OllllO
;
lOl\
llllOOll\
l
(
lOllO\
l\
lO\
l\
l\
l
,
&
lO\
l\
l\
l\
lOlOOlO
)
;
}
{
lOllOl\
l\
Olll
.
In\
itial\
ise\

(
lOl\
ll\
ll\
lOOlO
,
0.0f
,
(
ll\
OOOOOOO\
lO\
O\

.
x
-
lOOl\
llll\
OOlO
.
GetMax\
Angles\

(
)
.
x
)
*
(
lOll\
lll\
lOOll\

*
(
2.0f
*
k_fP\
i
)
)
,
llOOlllllO\

,
-
lOOOlOOOOO
,
lOll\
lOO\
lOlO\

)
;
lO\
llOl\
lO\
lll
.
lO\
lOllOOll
|=
lOllll\
Ol\
ll\
lO\

;
lOl\
lll\
lOO\
l\
l\
l\

(
lOllOll\
Olll
,
&
lOllllO\
lOOlO
)
;
}
}
}
llO\
O\
l\
l\
lllO
=
ll\
llOOO\
lOO
+
lOl\
l\
lllll\
O\
Ol
.
v3X
*
lOl\
ll\
lllOOl\
l
;
lOOO\
lOO\
OO\
O
=
-
lOllllll\
lOOl
.
v3Z
;
{
if
(
lOOl\
lll\
lOOlO
.
GetMax\
An\
gl\
e\
s
(
)
.
y
==
JOINT_L\
IMI\
T\
_DISABLED
)
{
}
else
if
(
lOOll\
l\
ll\
OO\
lO\

.
GetMi\
nAngles\

(
)
.
y
>=
lO\
Ollll\
lOO\
l\
O
.
GetMa\
x\
A\
ng\
l\
e\
s
(
)
.
y
)
{
if
(
lO\
Ol\
l\
lllO\
O\
lO
.
Ge\
tMi\
n\
Angl\
es\

(
)
.
z
>=
lO\
O\
lllllOOlO
.
GetMa\
xAngles
(
)
.
z
)
lOOOlOOOOO\

=
-
lO\
lllllllOlO
.
v3\
Z\

;
lOllll\
llOOO\
l\

.
Initiali\
se\

(
Collisio\
n
::
lO\
ll\
Ol\
OOOOl
,
0.0f
,
(
lO\
O\
lll\
llOOlO
.
GetMinA\
n\
g\
l\
es
(
)
.
y
-
llOO\
OO\
O\
OO\
l\
O\
O\

.
y
)
*
(
lO\
lll\
l\
llOOll\

*
(
2.0f
*
k_\
fPi
)
)
,
llOOlllllO
,
lOOOlOOOOO\

,
lOlllOO\
l\
O\
lO\

)
;
lOlll\
lllO\
OOl
.
lOlOl\
lOOl\
l\

|=
lO\
l\
ll\
l\
OllllO
;
TA\
_\
ASSER\
T
(
!
lOlllllO\
llOl
->
Get\
Ne\
xt
(
)
)
;
lOll\
lllOllOl\

->
lOllOlOOlll
(
&
lOlllll\
lOOO\
l
)
;
lOl\
ll\
llOll\
O\
l
=
lOllll\
lO\
llOl
->
Ge\
tNex\
t
(
)
;
}
el\
se
{
{
lO\
llOllOlll
.
In\
i\
ti\
a\
lis\
e\

(
lOlll\
lllOO\
lO
,
0.0f
,
(
lOO\
ll\
l\
l\
lOO\
lO\

.
GetMin\
Angles
(
)
.
y
-
llOOOOOOO\
lOO
.
y
)
*
(
lOllllllOOll
*
(
2.0f
*
k_fP\
i
)
)
,
ll\
O\
Oll\
l\
l\
lO
,
lOO\
Ol\
OOOOO\

,
lOll\
lOOlO\
lO
)
;
lO\
l\
lOl\
lOlll\

.
lO\
lOllO\
O\
ll
|=
lO\
llllOll\
ll\
O
;
lOll\
ll\
lOOlll
(
lOl\
lO\
llO\
lll
,
&
lOll\
llOlOOlO
)
;
}
{
lOll\
OllOlll
.
Initia\
lise\

(
lOllllllOOlO
,
0.0f
,
(
llO\
OO\
OOOOl\
OO
.
y
-
lO\
OlllllO\
OlO
.
Ge\
tM\
a\
xAngl\
e\
s\

(
)
.
y
)
*
(
lOl\
ll\
ll\
lOOll
*
(
2.0f
*
k_fPi
)
)
,
llO\
Oll\
lllO
,
-
lO\
OOlOOOO\
O
,
lOll\
lOO\
lOlO
)
;
lOllO\
llO\
l\
ll\

.
lOlOllOO\
l\
l
|=
lOl\
lllOl\
lll\
O
;
lOlll\
llOOl\
ll
(
lOl\
lOl\
l\
Olll\

,
&
lO\
llll\
Ol\
O\
O\
lO
)
;
}
}
}
}
bre\
ak\

;
def\
ault
:
lllOO\
lOOOO\

;
}
if
(
lO\
Ol\
lll\
lOO\
lO
.
GetType
(
)
==
Physi\
csJ\
oin\
t
::
TYPE_ROTATIO\
N_\
CON\
S\
TR\
AINT
||
lOOlll\
ll\
O\
OlO
.
Ge\
t\
Type
(
)
==
Phys\
icsJ\
oint
::
TYPE_\
VECT\
OR_\
C\
O\
N\
ST\
R\
AINT\

)
{
if\

(
lOll\
ll\
lOOllO
.
GetNext
(
)
)
{
lOlll\
l\
lOllll
.
lO\
llOlO\
lO\
O\
l\

(
Co\
l\
lis\
ion
::
lOllOl\
OOOll
)
;
if
(
lOlll\
l\
l\
O\
l\
lll
.
Ge\
tNext
(
)
)
{
lOllllll\
O\
O\
OO
.
lOl\
lOlOl\
OOl
(
Collis\
ion
::
lOllOl\
OOOll
)
;
if
(
lOllllllOO\
OO
.
GetN\
ext
(
)
)
{
lOl\
lllllOO\
O\
l
.
lOll\
Ol\
O\
l\
OOl
(
Collision
::
lOll\
O\
l\
OO\
Ol\
l
)
;
}
}
lO\
lllll\
OOl\
ll
(
lOlllllO\
llll
,
&
lOl\
ll\
lOlOO\
lO
)
;
}
}
else
{
lOlll\
llO\
O\
lll
(
lOl\
l\
ll\
lOOlO\
O
,
&
lOl\
lllOlOOlO
)
;
}
}
ll\
OO\
OOO\
OOllO\

(
)
;
}
in\
line
fl\
oa\
t
ll\
OOOOOOOlll
(
float
llOO\
OOO\
Ol\
OO\
O
)
{
return
Lo\
g
(
llO\
O\
OOOOlO\
OO\

)
;
}
in\
lin\
e
floa\
t
llO\
OO\
OOOlOOl\

(
fl\
oat
llOOO\
O\
OOlOOO
)
{
re\
turn
Exp\

(
ll\
OO\
OOOO\
lO\
OO
)
;
}
void\

Physics
::
lOllO\
lllOO\
OO
(
lOl\
OllllOOOO\

&
lOl\
lOllOllO\
O
)
{
lO\
llO\
lOO\
ll\
l\
l
->
Cl\
ear
(
)
;
lOO\
lOl\
llO\
O\
l
(
lOl\
lOO\
l\
O\
llll\

)
;
TA_ASS\
ER\
T
(
lO\
OllOllllOO
->
lOlOlll\
l\
O\
llO\

==
lOllOlO\
O\
l\
lll\

->
llOOOOOO\
l\
O\
lO
(
)
)
;
TA_ASSE\
RT\

(
lOOl\
lOlll\
lOO\

->
lO\
l\
Ol\
ll\
lOlll
==
lO\
ll\
OlOOlll\
l
->
llOOOOOOlOll
(
)
)
;
float
llOOOO\
OOllOO
=
k_fMaxFloat
;
floa\
t
llOOOOOOll\
Ol\

=
0.0f
;
lOlOll\
ll\
OOOO
::
llO\
OOOOOl\
llO\

llOO\
OOOO\
l\
ll\
l
=
lOll\
OllO\
llOO
.
llOOO\
OOl\
OOO\
O\

(
)
;
fo\
r
(
;
!
llOOOOO\
Olll\
l
.
AtE\
nd
(
)
;
++
ll\
O\
OOO\
OO\
lll\
l
)
{
Dyna\
micO\
bj\
e\
c\
t
&
lO\
ll\
O\
l\
Oll\
OlO
=
*
*
llOOOOOO\
lll\
l\

;
TA_\
ASSER\
T
(
lOllOl\
Oll\
Ol\
O\

.
IsInMov\
ingL\
ist
(
)
)
;
TA_\
ASSER\
T
(
!
lOllOlO\
ll\
Ol\
O\

.
Inf\
initeMass
(
)
)
;
TA_AS\
SE\
R\
T
(
!
lOl\
lO\
l\
O\
llOl\
O\

.
Mov\
em\
entD\
isabled
(
)
)
;
floa\
t\

lO\
l\
lOO\
OOll\
O
=
lOllOl\
OllO\
lO\

.
Ge\
tM\
ass
(
)
;
Cl\
ampIfLess\
Th\
en
(
llOO\
OO\
O\
O\
ll\
Ol
,
lOllOOOO\
l\
lO
)
;
Cla\
mpIfGre\
aterT\
he\
n\

(
llOOO\
OOO\
l\
lO\
O
,
lOllOOO\
Ol\
lO
)
;
}
co\
n\
st
floa\
t\

ll\
O\
OOO\
OlOOO\
l
=
0.2f
;
co\
nst
float\

ll\
OOO\
OOlOOlO
=
10.0f
;
fl\
oa\
t
llOOOO\
O\
lOOl\
l\

=
llOOO\
OOOOlll
(
llO\
OOOOl\
OO\
Ol
)
;
flo\
at
llOO\
OOOlOlOO\

=
llOOO\
OOO\
Oll\
l
(
llO\
OO\
OOl\
O\
O\
lO\

)
;
floa\
t
llOOO\
OO\
l\
Ol\
O\
l
=
(
llOO\
OOOlO\
lOO\

-
llO\
OOO\
Ol\
O\
Oll
)
*
0.5f
;
float
llOOOOOlOll\
O
=
(
ll\
OOO\
OO\
lO\
lOO\

+
llOOOOOl\
OOll
)
*
0.5f
;
TA_ASSE\
RT\

(
llO\
O\
O\
O\
OOllOl
>
0.0f
)
;
TA_\
A\
S\
S\
ERT
(
llO\
OOOOOl\
lOO\

>
0.0f
)
;
floa\
t
ll\
OOOOOlOl\
ll
=
llOOOO\
OOO\
lll\

(
llOOO\
OOO\
llOl\

)
;
fl\
oat\

llO\
OO\
OOllOOO
=
llO\
O\
OOOOO\
lll
(
ll\
O\
OOOOOllOO\

)
;
float
llOO\
O\
l\
l\
Olll
=
(
llO\
OOOOlOl\
l\
l
-
llOOOOO\
llOO\
O\

)
*
0.5f
;
floa\
t
llOOOllOl\
lO
=
(
llOOOOOlOl\
ll\

+
llO\
O\
OO\
O\
llOOO
)
*
0.5f
;
lOll\
l\
OOl\
OOOl\

=
llOOOO\
O\
OlOOl
(
llOOOOOlOllO
)
/
llOO\
OO\
OOlOO\
l
(
llOO\
OllO\
ll\
O\

)
;
if
(
ll\
OOOll\
O\
l\
ll
<
llOO\
OOO\
l\
O\
l\
O\
l
)
{
const
float
llO\
l\
Oll\
OOOO
=
1.0f
/
lOlllOOl\
OOOl
;
llOOOO\
O\
Ollll
=
lO\
llOllOllOO
.
llOOOO\
Ol\
O\
OO\
O
(
)
;
for\

(
int
llO\
O\
O\
O\
OllOOl
=
0
;
!
llO\
OO\
OOOll\
ll
.
At\
End
(
)
;
++
ll\
O\
O\
O\
OOOllll
,
ll\
OOOO\
OllOO\
l
++
)
{
DynamicOb\
je\
c\
t
&
lO\
l\
lOl\
O\
l\
l\
Ol\
O
=
*
*
llOOOO\
OOll\
l\
l
;
lOllOlO\
llOl\
O\

.
lOlOOl\
lO\
l\
llO
(
ll\
OOOOOllOOl
)
;
lOllOlO\
O\
l\
lll
->
ll\
OO\
OOOllOlO
(
lOl\
lO\
lOllOl\
O
.
Ge\
tIn\
vers\
e\
Mas\
s
(
)
*
ll\
OlOllOOOO
,
lOllO\
l\
OllOl\
O
.
GetWorl\
dSpac\
eI\
nv\
ers\
eIner\
tia
(
)
*
llOlOl\
lOOOO
)
;
}
}
else\

{
TA_ASSE\
RT\

(
llOOOl\
lO\
lll
>
0.0f
)
;
TA_AS\
S\
ERT\

(
llO\
OO\
OOlOlOl\

>=
0.0f
)
;
flo\
a\
t\

ll\
OOOOOl\
lO\
l\
l
=
llO\
OOOOlO\
lOl
/
llO\
O\
OllOlll\

;
llOOOOOOllll
=
lOllOll\
OllOO\

.
llOOOOO\
lOOOO\

(
)
;
for
(
int
llOOOOO\
llOOl
=
0
;
!
llOOO\
OO\
Ollll
.
AtEnd\

(
)
;
++
llOOO\
OOOllll
,
llOOOOOll\
OOl
++
)
{
Dy\
namicObject\

&
lOll\
OlOllOl\
O
=
*
*
llOO\
OO\
OOllll
;
lO\
llOlO\
llOl\
O
.
lOlOOl\
lOlllO
(
ll\
O\
OOOO\
ll\
O\
Ol
)
;
float
ll\
OOO\
OO\
lllOO
=
Log
(
lOll\
Ol\
Ol\
lOlO
.
Get\
Mass\

(
)
*
lOll\
lOOlOOOl
)
;
llO\
OOOOlllOO
-=
llOOOO\
Ol\
OllO
;
llOO\
OOO\
lllO\
O
*=
llO\
OO\
OO\
l\
lOll
;
llOOOOOl\
ll\
OO
+=
llOOO\
OO\
lOllO\

;
float
llO\
lOl\
l\
OOOO\

=
lO\
ll\
Ol\
O\
llO\
lO
.
Ge\
t\
M\
ass
(
)
/
Ex\
p
(
llO\
OOOO\
l\
l\
lOO
)
;
lOllOlOOll\
l\
l
->
llOO\
OO\
O\
l\
lOlO
(
lOllOl\
OllOl\
O
.
GetInverse\
M\
ass
(
)
*
llOlOl\
lOO\
OO
,
lOllOl\
Oll\
O\
lO
.
Get\
W\
orld\
Spac\
eInver\
se\
Iner\
t\
ia\

(
)
*
llOlOl\
lOO\
O\
O
)
;
}
}
lO\
lOl\
lllOO\
O\
O
::
Iterator\

lO\
l\
Ol\
llOOOlO
=
lO\
llO\
llOllO\
O
.
lOl\
OO\
O\
O\
l\
OO
(
)
;
fo\
r
(
;
!
lOlOl\
llO\
OO\
lO
.
AtEnd\

(
)
;
++
lOlO\
lllOOOlO
)
{
Collisi\
on
*
llO\
llO\
lOl\
ll
=
&
*
lOlOlll\
OOO\
l\
O
;
u32
lOl\
OllOOll\

=
0
;
if
(
llOllOl\
O\
l\
ll
->
lOl\
OllOOll
&
Co\
ll\
is\
ion
::
FLAG_CONSTRA\
IN_IN_BOTH_DI\
R\
E\
CTI\
ONS
)
lOlOllOOl\
l\

|=
lOl\
lOlOl\
OOll
::
llO\
OO\
O\
Oll\
lO\
l
;
if
(
(
llO\
llO\
lO\
lll
->
lOlO\
llOOl\
l\

&
Collis\
i\
on
::
FLAG_\
JOIN\
T
)
&&
llOl\
lOlOlll
->
lO\
llOlOl\
Oll\

(
)
)
lO\
l\
OllOOll\

|=
lOllOlO\
l\
OO\
ll
::
llO\
OOO\
O\
llllO
;
in\
t
ll\
OO\
OOOl\
llll\

=
0
;
for\

(
Collision
*
lOOO\
O\
OlOOO\
l
=
ll\
O\
llOlOlll
;
lOOOOOlOOOl
;
lOOOO\
Ol\
O\
OOl
=
lO\
OOOOlO\
OOl
->
Ge\
tNe\
x\
t
(
)
)
ll\
OO\
OOOlllll\

++
;
if\

(
llOOOOOlll\
l\
l
>
1
)
{
TA_AS\
SE\
RT\

(
llO\
llOlOlll\

->
lO\
lOl\
lOOll
&
Collision\

::
FLAG\
_JOIN\
T
)
;
}
TA_\
AS\
SE\
RT
(
llO\
llO\
l\
Oll\
l
->
lOll\
O\
OOll\
Ol
->
lO\
lOOll\
OOlll\

(
)
==
&
lOllO\
llOllOO\

)
;
TA_\
A\
SS\
ER\
T\

(
!
llO\
llOlOl\
l\
l
->
lO\
llO\
l\
O\
lOll
(
)
||
llO\
l\
lOlOl\
ll\

->
lOl\
lOl\
OlO\
ll\

(
)
->
lO\
lO\
OllO\
O\
ll\
l
(
)
==
&
lO\
llOl\
l\
OllOO
)
;
TA_A\
S\
SERT\

(
llOllOlO\
ll\
l\

->
lO\
l\
lO\
OOllOl
->
IsI\
n\
M\
ov\
ingL\
i\
st\

(
)
)
;
TA\
_\
ASSERT
(
!
llO\
llOlOl\
ll\

->
lOl\
lOlO\
lO\
l\
l
(
)
||
llO\
llOlO\
lll
->
lOllOlOlOll
(
)
->
IsInMo\
vin\
gList
(
)
)
;
int
ll\
O\
OO\
Ol\
OOO\
O\
O
=
lO\
l\
lOlOOll\
ll\

->
ll\
O\
OOOl\
OO\
OOl
(
llOO\
OOOl\
lll\
l
,
ll\
OllOlOll\
l
->
lOllO\
OO\
ll\
Ol
->
lOlO\
Ol\
ll\
OOOO
(
)
,
llOllOlOlll
->
lOllOlOl\
Oll\

(
)
?
llOl\
lOlOll\
l
->
lOl\
lOlOlOll
(
)
->
lOlOOlllOO\
OO
(
)
:
-
1
,
lO\
lO\
llOOl\
l
)
;
Collision
*
lOlllOlllllO
=
llOll\
O\
lOl\
ll
;
for\

(
in\
t\

lOOOlO\
OlOOl
=
0
;
ll\
O\
llOlOll\
l\

;
llO\
llOlO\
lll
=
llO\
ll\
Ol\
Olll
->
Get\
Next
(
)
,
lOOOlOOlOO\
l\

++
)
{
TA_\
AS\
SER\
T
(
llOllOl\
Ol\
ll
->
lOll\
OOOllOl
)
;
if
(
lO\
OOlOO\
lOOl
>
0
)
{
TA_\
AS\
S\
ERT
(
llO\
l\
lOl\
O\
l\
ll
->
lOllOOO\
ll\
Ol\

==
lO\
l\
llOl\
llllO
->
lOllOOO\
llOl
)
;
TA_ASSERT\

(
ll\
Oll\
O\
lOl\
ll
->
lOl\
lOOOl\
ll\
O
==
lOlll\
Olllll\
O
->
lO\
llO\
OOl\
llO\

)
;
TA\
_ASSERT
(
llOllOlOlll
->
lOllO\
lOlOll
(
)
==
lO\
lllOlllllO
->
lOllOlOlOll
(
)
)
;
}
if
(
llOll\
Ol\
O\
lll
->
lO\
lOl\
lOOll\

&
Coll\
i\
sio\
n
::
FLAG_\
ROTATI\
O\
N_CONST\
RAIN\
T\

)
{
if
(
ll\
O\
llO\
lO\
lll
->
lO\
llOlO\
l\
Oll
(
)
)
{
lOl\
lO\
l\
OOllll
->
ll\
OOOO\
lOOOlO
(
ll\
OOO\
OlOOO\
OO
,
lOOOlOO\
l\
OOl
,
k_\
v3\
Ze\
ro
,
ll\
Ol\
lOl\
Olll
->
lOO\
O\
l\
OOOOO
.
Cr\
os\
s
(
llOl\
lOlOlll
->
lOOOO\
lllll
-
llOllOl\
O\
ll\
l\

->
lOllO\
OOllOl
->
Ge\
t\
C\
e\
nte\
r\
O\
fMass\

(
)
)
,
k_v\
3Zer\
o
,
-
llOllO\
lOlll
->
lOOOl\
OO\
O\
OO
.
Cr\
os\
s\

(
llOllO\
lOl\
ll\

->
lOOOOlllll\

-
llOllO\
lOlll
->
lOllOlOlOl\
l
(
)
->
GetC\
ent\
erO\
fMas\
s\

(
)
)
)
;
}
else\

{
lOllOlOOllll
->
llOOOO\
lOOO\
lO
(
llO\
OOOlO\
O\
OOO
,
lOO\
OlO\
Ol\
OOl
,
k_v3Zero
,
llOl\
lOlOlll
->
lOO\
O\
lOOOOO
.
Cross
(
llOllOlOlll
->
lOO\
O\
Ol\
llll
-
llOllOl\
Olll
->
lOllOOOllOl
->
GetCe\
nt\
erOfMass
(
)
)
)
;
}
}
else
{
if
(
llOllO\
l\
O\
ll\
l
->
lOl\
lO\
lOlOl\
l
(
)
)
{
lO\
l\
lOlO\
Ol\
lll\

->
llOOOO\
lO\
OOl\
O
(
ll\
OOOOl\
O\
OOOO
,
lO\
OO\
l\
OO\
lO\
Ol
,
llOllOl\
Olll
->
lOO\
OlOO\
OOO
,
ll\
OllOlOlll
->
lOOOlO\
OO\
OO\

.
Cross
(
ll\
O\
llOlO\
lll
->
lOOO\
Olllll
-
llOll\
OlOl\
l\
l\

->
lOllO\
OOllOl\

->
GetC\
enter\
OfMass
(
)
)
,
-
llO\
llOlO\
lll
->
lOOOlOOO\
OO
,
-
llO\
llOlOlll
->
lOOO\
lOOOO\
O
.
Cr\
os\
s
(
llOllOl\
Oll\
l
->
lOOOO\
lllll\

-
llOllOl\
O\
lll
->
lOllOl\
O\
l\
Oll
(
)
->
Get\
C\
e\
nterOf\
Mass
(
)
)
)
;
}
else
{
lOllOlOO\
llll
->
llOOOO\
l\
OO\
O\
l\
O
(
llOOOO\
lOO\
OO\
O
,
lO\
OOlOO\
lOOl
,
llOllOlOll\
l\

->
lOOOlOO\
OOO\

,
llOl\
lOlOll\
l
->
lOOOlOO\
OOO
.
Cro\
ss
(
ll\
OllOlOll\
l\

->
lOO\
OOll\
lll
-
llOll\
Ol\
Oll\
l\

->
lO\
l\
lO\
OOllOl
->
GetC\
e\
n\
terOfMass
(
)
)
)
;
}
}
}
}
lOllO\
l\
OOllll
->
llO\
O\
OOl\
OOO\
ll\

(
)
;
lOOlO\
l\
llO\
ll\

(
lO\
llOOlOll\
ll
)
;
}
float
TA\
C_\
CALL
llOOOOl\
O\
OlOO\

(
floa\
t
lOOll\
lOOl\
lll
,
Colli\
sio\
n
&
llO\
llll\
O\
l\
ll
)
{
Vec3
lOlO\
lOlOl\
OOl\

=
llOllllOlll
.
Get\
Obje\
ct\
A
(
)
->
GetVel\
oc\
ity\
AtWorldPo\
sition
(
llOlll\
lO\
lll
.
lOOOOllll\
l
)
-
llOlll\
lOlll\

.
GetObj\
ectB
(
)
->
GetV\
eloci\
tyAt\
WorldPosi\
tio\
n\

(
llOll\
llOll\
l
.
lOO\
OO\
llll\
l
)
;
floa\
t\

lOOlOllOl\
ll\
l
=
lO\
lOlO\
lOl\
OOl
.
Dot
(
llOll\
l\
lO\
lll
.
lOOOlOOOOO
)
;
if
(
llOl\
lllOl\
ll
.
lOl\
Oll\
OO\
ll
&
Collision
::
FLAG_USE_\
PU\
SH_O\
UT_\
MODIFIER
)
{
if\

(
(
llOllll\
Olll
.
GetObjectA\

(
)
->
IsI\
nMov\
ingLi\
st
(
)
&&
llOl\
lllOll\
l
.
Get\
Obj\
ectB
(
)
->
IsI\
nMo\
ving\
L\
ist
(
)
)
||
(
llOllllO\
lll
.
GetOb\
jectA
(
)
->
Moveme\
ntDisable\
d
(
)
||
llO\
l\
lllOl\
ll
.
Ge\
tOb\
jectB
(
)
->
Movem\
ent\
Disab\
led
(
)
)
)
{
if
(
llO\
llllO\
l\
ll
.
lO\
lO\
llOOll\

&
Co\
llision\

::
FLAG_US\
E_PU\
S\
H_OUT_\
MODIFIER
)
{
lOOlOll\
Olll\
l\

-=
llOlll\
lOll\
l
.
lOllOOlOlll
*
lOl\
OlllllOll
*
1.0f
;
}
el\
s\
e
lOO\
l\
Oll\
O\
ll\
ll\

-=
llO\
lll\
l\
Oll\
l
.
lOllOOlOlll
*
1.0f
;
}
else\

{
if\

(
llO\
llllOlll
.
lOlOllOOll\

&
Coll\
isio\
n\

::
FL\
AG_JOINT
)
{
lOOlOllO\
llll
-=
llO\
llllOl\
l\
l
.
lOllOO\
l\
O\
l\
ll
*
0.1f
;
}
else
{
if
(
ll\
Oll\
l\
lO\
ll\
l
.
GetO\
bje\
c\
t\
A
(
)
->
Is\
I\
nMovingList\

(
)
)
{
if
(
llOl\
lllOlll\

.
GetNormal
(
)
.
y
>
0.0f
)
{
if
(
llOll\
llOlll\

.
lOlOllOOll
&
Collision
::
FLAG\
_USE\
_PU\
SH_OUT\
_MODI\
FIE\
R
)
{
lOOlOl\
lOlll\
l
-=
llOll\
l\
lOlll
.
lOllOOl\
Olll
*
lOlOll\
l\
ll\
Oll
*
1.0f
;
}
else\

lOOlOllOl\
ll\
l\

-=
llOll\
llOll\
l
.
lO\
l\
lOOl\
Olll
*
1.0f
;
}
}
el\
s\
e
if
(
llOlll\
lOl\
ll\

.
GetObject\
B
(
)
->
Is\
I\
nMo\
vin\
gList
(
)
)
{
if\

(
llOll\
l\
lOll\
l
.
Get\
Normal
(
)
.
y
<
0.0f
)
{
if\

(
ll\
OllllOlll
.
lOlOl\
lOOll
&
Collisio\
n
::
FLAG\
_USE_\
P\
USH\
_\
OUT_M\
ODI\
FI\
E\
R
)
{
lO\
OlOllOllll\

-=
ll\
Olll\
lOlll\

.
lOllOOlO\
lll\

*
lOl\
Olll\
llOll\

*
1.0f
;
}
el\
s\
e\

lOOlO\
llOllll
-=
ll\
O\
ll\
llOlll
.
lO\
l\
lOOl\
Oll\
l
*
1.0f
;
}
}
}
}
}
el\
s\
e
{
lO\
O\
l\
OllOllll\

-=
ll\
O\
lll\
lOl\
ll
.
lOllOO\
lO\
lll
;
}
lOOl\
OllO\
l\
lll
+=
ll\
Oll\
ll\
Oll\
l
.
lOll\
OOlO\
l\
Ol
;
TA_A\
SSERT
(
FloatI\
sOK\

(
lO\
OlOllOllll
)
)
;
ret\
ur\
n
lO\
O\
lOllOll\
ll
;
}
vo\
id
Ph\
ysi\
cs
::
lOll\
O\
l\
llO\
OO\
l
(
float\

lOOlllOO\
llll
,
lOlOllll\
OO\
OO
&
lOllOll\
Ol\
l\
O\
O
,
int
lOll\
Oll\
Ol\
OOl
)
{
lOlO\
llll\
O\
OOO
::
Iter\
at\
or
lOlOl\
llOOOl\
O
=
lO\
l\
l\
OllOl\
lOO\

.
lOl\
O\
OOOlOO\

(
)
;
for
(
int\

ll\
OO\
OOlO\
OlOl
=
0
;
!
lOlOlllO\
OOlO
.
AtEn\
d
(
)
;
++
lOl\
O\
lllOOOlO
,
++
llOOOOlOOlO\
l\

)
{
Colli\
sio\
n
*
ll\
OllOlO\
lll
=
&
*
lO\
lOlllOO\
Ol\
O
;
fo\
r
(
int
lOOOlOOlO\
Ol
=
0
;
llOllOlO\
ll\
l\

;
llOllO\
l\
Ol\
ll\

=
llOllOlO\
lll\

->
GetNe\
x\
t
(
)
,
lOOOlOOlOO\
l
++
)
{
Collision
&
llO\
ll\
llOlll\

=
*
ll\
Ol\
l\
O\
l\
Oll\
l
;
lO\
llO\
lO\
Ollll
->
llO\
OOO\
l\
OOl\
lO
(
ll\
OO\
O\
OlO\
Ol\
Ol
,
lO\
O\
O\
lO\
OlO\
Ol
,
ll\
OOOOlOOlOO
(
lO\
OlllO\
Ollll
,
llOll\
llOlll
)
)
;
}
}
}
void
Phy\
sic\
s
::
llOOOOl\
OO\
lll\

(
float
lOO\
lllOOlll\
l
,
Collis\
i\
on\

&
llO\
llll\
Olll
)
{
ll\
OllllOl\
ll
.
lOll\
OO\
lOl\
l\
l
=
0.0f
;
float\

lOO\
llOOOOOll
=
Min
(
llOllll\
O\
l\
ll
.
Ge\
t\
Object\
A
(
)
->
lOOllOOOO\
l\
OO\

(
)
,
llOll\
llOlll
.
Get\
Obje\
ctB\

(
)
->
lO\
OllOOOOlO\
O\

(
)
)
;
if
(
llOllllO\
lll
.
lOlOl\
l\
OOl\
l
&
Co\
ll\
is\
i\
o\
n\

::
FLAG\
_CONS\
TRAIN_I\
N_BOTH_\
DI\
REC\
TIO\
NS
)
{
if
(
(
llOl\
lllOl\
ll
.
lO\
lOl\
lOOll
&
(
Colli\
s\
i\
o\
n
::
FL\
AG_\
FRICTION
)
)
==
0
)
{
ll\
O\
ll\
l\
lO\
lll
.
lO\
llOOlO\
ll\
l
=
llOl\
lllO\
ll\
l
.
lOll\
O\
OlOOll\

;
Cl\
a\
mp\
Po\
sN\
eg
(
ll\
O\
l\
lllO\
lll\

.
lOl\
lO\
OlO\
l\
ll
,
2.0f
*
lOOl\
l\
OOOOO\
ll
)
;
if
(
(
ll\
Olll\
l\
Olll
.
lOlOl\
l\
OOll\

&
Coll\
is\
io\
n
::
FLAG\
_DI\
SA\
BL\
E_\
PUS\
HOUT
)
==
0
)
{
llO\
llllOl\
ll\

.
lOllOOlO\
l\
ll
*=
80.0f
;
flo\
at
lOOOO\
OlO\
O\
l
=
lOOllOO\
OOOll
*
0.1f
;
float
llOOOOlOlOOO
=
Max
(
ll\
Ol\
lllO\
l\
ll
.
GetO\
b\
jectA\

(
)
->
Ge\
t\
Li\
nea\
rVel\
oc\
i\
ty\

(
)
.
GetMagnit\
ude
(
)
,
llOllllOlll\

.
Get\
ObjectB
(
)
->
GetLin\
earV\
el\
ocity\

(
)
.
Ge\
tMa\
gni\
t\
ude\

(
)
)
*
2.0f
+
lOOl\
lOOOOO\
ll
*
1.5f
;
if
(
llO\
l\
l\
ll\
O\
lll
.
lO\
llOOlOlll
>
lOOO\
OO\
lO\
O\
l
)
{
llOlll\
lOll\
l\

.
lOll\
OOlOlll
-=
lOO\
OOOlOO\
l
;
llOlll\
lOlll
.
lO\
l\
lOOlOlll
*=
0.1f
;
llOll\
l\
lOlll
.
lOllOOlO\
ll\
l
+=
lOOOO\
OlOOl\

;
if
(
llOll\
l\
lO\
lll
.
lOllOO\
l\
Ol\
l\
l\

>
ll\
OOOOlO\
lOOO
)
llO\
ll\
l\
lOlll\

.
lOllOO\
lO\
l\
l\
l
=
llOOOOlOlO\
OO
;
}
el\
s\
e
if
(
ll\
Oll\
l\
l\
O\
lll
.
lOllOOlOlll
<
-
lOOOOOlOOl\

)
{
llO\
lll\
lOl\
ll
.
lOllOOlOl\
l\
l
+=
lOOOOOlO\
O\
l\

;
llOllllO\
lll
.
lOllOOl\
Ol\
ll
*=
0.1f
;
ll\
O\
llllO\
ll\
l
.
lOllO\
Ol\
Olll\

-=
lOOOOOlOOl\

;
if\

(
ll\
O\
llllOlll
.
lOllO\
Ol\
O\
ll\
l\

<
-
llO\
OOOl\
OlOOO
)
llOllllOlll\

.
lOll\
OO\
lOll\
l
=
-
llOOOOlOl\
OOO
;
}
}
else
{
llOll\
ll\
Oll\
l
.
lO\
llO\
OlOlll
*=
1.2f
;
}
}
}
els\
e
{
if
(
!
(
llOl\
lll\
Ol\
ll
.
lO\
lOllO\
Oll
&
(
Col\
l\
i\
sion
::
FLAG\
_FRI\
CTIO\
N
|
Collis\
io\
n
::
FLAG_DIS\
ABLE_PUSHOUT\

)
)
)
{
Ve\
c3
lOlOlOlOlOOl\

=
llOlll\
l\
Olll\

.
Get\
Object\
A\

(
)
->
Ge\
t\
Veloc\
ityAtW\
o\
rl\
dP\
o\
s\
i\
tion
(
llO\
l\
lll\
O\
lll\

.
lOOOO\
lllll
)
-
ll\
Oll\
llOlll
.
Ge\
tObjectB
(
)
->
Ge\
tVelo\
c\
i\
t\
yAtWorldPo\
sition
(
llOl\
lllO\
lll
.
lOOOOl\
llll
)
;
fl\
oat
lOOl\
OllO\
llll
=
lOlOl\
O\
lOlOO\
l
.
Dot\

(
ll\
OllllOl\
ll
.
lOOOlOOO\
OO
)
;
const
float
llOOOOlO\
lOOl\

=
0.02f
*
lO\
OllO\
OOO\
Oll
;
if\

(
(
llO\
llllO\
ll\
l
.
lOlOllOOll\

&
Co\
llisio\
n\

::
FL\
AG_JO\
INT_\
L\
I\
MI\
T\

)
&&
(
ll\
Olll\
lOll\
l\

.
lOl\
O\
l\
lOOll
&
Co\
llis\
ion
::
FLA\
G_DISABLE\
_\
PUSHOU\
T
)
==
0
)
{
if\

(
ll\
Ol\
ll\
l\
O\
lll\

.
lOll\
OO\
lOO\
ll
>
0.0f
)
{
ll\
Oll\
llOlll
.
lO\
llOOlOlll
=
ll\
Ollll\
Ol\
l\
l
.
lOl\
lOOl\
OOll
/
lOOlllO\
Ollll
*
0.25f
;
if
(
llO\
llllOlll
.
lOllOO\
lOl\
ll
>
lOO\
llOOO\
O\
O\
l\
l
*
0.5f
)
llOllll\
Ol\
ll
.
lOllO\
OlOlll
=
lOOllOO\
O\
O\
Ol\
l
*
0.5f
;
ll\
Ollll\
O\
lll
.
lOlOllOOll
|=
Colli\
sio\
n
::
FLAG_US\
E_PUSH_OUT_\
MODIFIE\
R
;
}
else
{
llOl\
lllOlll
.
lOllOOl\
Olll
=
llOll\
llOl\
ll
.
lOllO\
O\
lOOl\
l
/
lOO\
ll\
lOOllll
*
0.7f
;
}
}
else
{
if\

(
llOllllOlll
.
lOll\
OOlO\
Ol\
l\

>
0.0f
)
{
ll\
OllllO\
lll
.
lOllOOlOl\
Ol
=
lOOlO\
l\
lOlll\
l
*
llOl\
lllOl\
l\
l
.
lO\
ll\
OOlO\
lO\
l
;
if
(
ll\
O\
ll\
llOlll
.
lOllOOl\
OlOl
>
-
0.1f
*
lOOllOO\
OOOll\

)
llOllllOlll\

.
lOllOOlOlOl
=
0.0f
;
con\
st
fl\
o\
at\

llOOOOlOlOl\
O
=
0.1f
*
lOll\
l\
O\
OlOOOO\

;
floa\
t
lOll\
O\
O\
lOOll\

=
llOllll\
Olll
.
lOll\
OOlOOll
-
llOO\
OOlOlOOl\

;
if\

(
lO\
l\
lO\
O\
lO\
Oll
>
llO\
OO\
OlOl\
Ol\
O\

)
lOllOO\
lOOll\

=
llOOOO\
lOlOl\
O\

;
if
(
lO\
llOOl\
OOll\

<
0.0f
)
{
llO\
llllOlll
.
lOllO\
OlOlll
=
lOllOO\
l\
O\
O\
ll
/
lO\
Ol\
llOOl\
ll\
l
*
0.7f
;
}
el\
s\
e
{
llOllllOlll
.
lOlOllOOll
|=
Co\
llisio\
n
::
FLA\
G_U\
S\
E_PUS\
H\
_OUT\
_MODIFIER
;
lO\
ll\
OOlOOll
*=
50.0f
;
const
flo\
at
llOOO\
OlOl\
Oll
=
0.02f
*
lOOllOOOOOll
;
if
(
lO\
l\
l\
OOlOO\
ll
>
llOOOOlOlO\
ll\

)
{
lO\
l\
lO\
OlO\
Ol\
l
-=
llO\
O\
OOlOlO\
ll\

;
lOllOOlOOl\
l\

*=
1.0f
/
50.0f
;
lO\
llOO\
l\
OOl\
l
+=
llO\
OOO\
lOlO\
l\
l
;
}
llOllll\
O\
lll
.
lOl\
lOOl\
O\
ll\
l
=
lOllOOlOOll
;
}
}
else\

{
if
(
(
llOl\
ll\
l\
Olll\

.
lOl\
O\
l\
l\
O\
O\
l\
l\

&
Co\
l\
li\
si\
on
::
FLA\
G\
_J\
OIN\
T_LIMIT
)
&&
(
ll\
Ol\
lllOlll\

.
lOl\
O\
l\
lO\
Oll
&
Co\
llisio\
n
::
FLA\
G\
_D\
ISABLE\
_P\
USHO\
UT
)
==
0
)
{
llOlll\
lOl\
ll
.
lOll\
O\
OlOlll
=
ll\
Ollll\
Olll\

.
lOllOOlO\
Ol\
l
/
lOO\
lllOOllll
*
0.7f
;
}
el\
se
{
TA\
_ASSERT
(
llO\
llllOl\
ll\

.
lll\
OlllllO
>=
0.0f
)
;
TA\
_\
ASS\
ER\
T
(
llOl\
lllOll\
l
.
lllOl\
l\
l\
llO\

<=
1.0f
)
;
ll\
Olll\
lOll\
l
.
lOllO\
OlO\
l\
ll
=
lOOlO\
ll\
Ollll\

*
llOll\
llO\
ll\
l
.
lll\
Ollll\
lO
+
llOOOOl\
O\
lOOl\

/
lO\
O\
lll\
O\
Ollll
;
if\

(
llO\
llllOll\
l
.
lOl\
lOOlOlll\

>
0
)
llOllllOlll
.
lOl\
lO\
O\
lOll\
l
=
0
;
flo\
at
lOllOO\
lOl\
O\
l\

=
-
(
lOOlOl\
lO\
llll\

*
(
1.0f
+
llOlll\
lO\
ll\
l
.
ll\
l\
Ol\
ll\
ll\
O
)
)
;
lOllOO\
lO\
lOl
*=
llO\
lll\
lOll\
l
.
lO\
llOO\
lO\
lOl
;
if
(
lO\
llO\
O\
lOlOl\

<
2.0f
*
lOOllOOOOOll
)
lOl\
lOO\
lOlO\
l
=
0.0f
;
ll\
OllllOll\
l
.
lOll\
OOlOll\
l
+=
lOllOOlOlOl
;
}
ll\
Olll\
l\
Ol\
l\
l
.
lOll\
OOlO\
lOl
=
0.0f
;
}
}
}
}
}
bool
Ph\
ysi\
c\
s
::
lO\
llOlllOOlO
(
)
{
lOO\
lOllllO\
l\

(
lOl\
lOOl\
l\
OOOO
)
;
return\

lO\
llOlOOl\
lll
->
ll\
OOO\
O\
lO\
llO\
O\

(
)
;
}
void
Physic\
s
::
llO\
OOOlOllOl
(
)
{
lOOlOll\
lO\
O\
l
(
lOl\
lOOllOOO\
O
)
;
lOllOlO\
O\
ll\
ll
->
llO\
OOOlOlllO
(
)
;
lO\
Ol\
Ol\
llOll
(
lOllO\
O\
l\
l\
OOOO
)
;
}
bool
Ph\
ysics\

::
lOllOlllOO\
ll\

(
lOl\
O\
lll\
lO\
OO\
O\

&
lO\
ll\
OllOll\
OO
)
{
ext\
e\
rn
float
lOO\
l\
O\
ll\
llllO
;
lOOl\
OllllllO
=
1.0f
;
#ifdef llOOOOlOllll
fl\
oa\
t
ll\
O\
OOO\
l\
lO\
OO\
O
=
0.0f
lOlOll\
l\
lO\
OO\
O
::
llO\
O\
O\
O\
O\
OlllO\

llOOO\
OOOlll\
l
=
lO\
l\
lOllOllOO
.
llOOOOOlO\
O\
OO
(
)
;
fo\
r\

(
;
!
llOOO\
OOOllll
.
AtE\
nd\

(
)
;
++
llOOOOOOllll\

)
{
Dynam\
icObjec\
t
&
lOlll\
lOllOOl
=
*
*
ll\
OOOO\
OOl\
lll
;
llOO\
OO\
l\
lOOOO\

+=
0.5f
*
lO\
l\
lllO\
llOO\
l
.
GetL\
ine\
ar\
V\
eloci\
ty
(
)
.
Get\
M\
ag\
nit\
udeSqrd\

(
)
*
lOllllOllO\
O\
l
.
GetMas\
s
(
)
;
flo\
at
llOOOOllOOO\
l
=
0.5f
*
(
lOll\
llOllOOl
.
Ge\
tAngu\
l\
arVeloci\
t\
y
(
)
*
lO\
llll\
OllOOl
.
GetWorldSpa\
ceIn\
e\
rtia
(
)
)
.
Do\
t
(
lOllll\
OllOOl\

.
GetAngularVel\
o\
ci\
ty
(
)
)
;
TA_A\
SSER\
T
(
llOOO\
Ol\
l\
OO\
Ol
>=
0.0f
)
;
llO\
OOO\
llOOOO\

+=
llOO\
O\
OllOO\
Ol
;
}
#endif //
lOl\
Ol\
lllOO\
O\
O
::
ll\
O\
OOOOO\
lllO\

llO\
OOOOOl\
l\
ll
;
floa\
t
llOOOOllOOO\
O
=
0.0f
;
if\

(
!
lOll\
Ol\
l\
O\
ll\
OO
.
llOOOOllOO\
lO
(
)
)
{
fo\
r
(
llO\
OOOOOllll\

=
lO\
llOllO\
llO\
O
.
llOOOOOl\
OOO\
O
(
)
;
!
ll\
OOOOOO\
ll\
ll
.
At\
E\
nd
(
)
;
++
llOO\
OOOOl\
l\
ll\

)
{
DynamicObject\

&
llOOOOOOO\
OO\

=
*
*
llO\
OO\
OOOll\
ll
;
TA_ASSERT\

(
lOl\
lOlOOl\
lll\

->
GetM\
ass
(
llO\
OOOOOOOO
.
lOl\
O\
OlllOOOO\

(
)
)
>
0.0f
)
;
TA_\
A\
S\
SERT
(
ll\
O\
OO\
OOOOO\
O\

.
Ge\
tMass
(
)
>
0.0f
)
;
float
llOOO\
O\
llOOll
=
lOllOlOO\
ll\
ll\

->
GetMass
(
llOOOO\
OO\
OO\
O
.
lOlO\
Ol\
llO\
OOO
(
)
)
/
llO\
OOOO\
O\
OOO\

.
GetMass
(
)
;
llOOOOOOOOO
.
lOlOOOlOOlOl
(
)
;
flo\
a\
t
llOO\
O\
OllOlOO\

=
llO\
OOOOOO\
OO
.
lOO\
llOOOOl\
OO
(
)
*
(
0.02f
*
60.0f
)
;
ll\
OOOOll\
OOOO
+=
0.5f
*
llOOOOllO\
O\
ll
*
(
llOO\
OOOOOOO
.
GetLi\
nea\
rVe\
locit\
y\

(
)
.
GetMa\
gnitu\
deSq\
rd\

(
)
+
llOO\
O\
O\
l\
l\
O\
lO\
O
*
llOOOOllO\
l\
O\
O
)
*
ll\
OOO\
OOO\
OOO
.
GetMa\
s\
s
(
)
;
floa\
t
llOOOOll\
OO\
O\
l\

=
0.5f
*
llO\
OOOl\
lOOl\
l
*
(
llOOOOOOO\
OO
.
Get\
Angul\
ar\
Veloci\
t\
y
(
)
*
llOOOO\
OO\
OO\
O
.
Ge\
tW\
orldSp\
ac\
eIner\
ti\
a
(
)
)
.
Do\
t
(
ll\
OO\
O\
OO\
OOOO
.
GetAngu\
la\
rVeloci\
ty
(
)
)
;
TA_\
A\
SS\
ERT
(
llO\
OOOllOOOl
>=
0.0f
)
;
llO\
O\
OOllO\
O\
OO
+=
llOOOOllOOO\
l\

;
}
}
lOlO\
ll\
l\
l\
O\
OO\
O
::
It\
er\
ator
lOlOl\
llO\
OO\
lO\

=
lOl\
lO\
ll\
O\
l\
lO\
O\

.
lOlO\
OO\
OlOO
(
)
;
for
(
int
llO\
OOO\
l\
OO\
l\
Ol
=
0
;
!
lOlOlllOOO\
lO
.
AtE\
nd
(
)
;
++
lOlOl\
ll\
OOOlO
,
++
ll\
O\
OOOlOOlO\
l\

)
{
Collis\
ion\

*
llOllOlOlll
=
&
*
lO\
lOlllOO\
Ol\
O
;
for
(
int
lOO\
OlOOlOOl
=
0
;
llO\
llOlOlll\

;
ll\
OllOlOlll
=
llOllO\
lOlll
->
Ge\
tNext
(
)
,
lOOOlO\
OlOOl
++
)
{
Co\
llision
&
llOllllOlll
=
*
llOl\
lOlOlll
;
float
lO\
ll\
O\
OlO\
lOO
=
lO\
llOlOOllll\

->
GetI\
m\
p\
ul\
se
(
llO\
OO\
Ol\
O\
Ol\
O\
l\

,
lOO\
O\
lOO\
lOOl\

)
;
if\

(
lOl\
l\
OO\
lOlOO
==
0.0f
)
cont\
i\
nue
;
Vec3\

llO\
OO\
Oll\
O\
lO\
l
=
llOl\
lllOlll
.
lOOOlOO\
O\
O\
O
*
lOll\
OOlOlOO
;
TA_ASSE\
RT
(
FloatI\
s\
O\
K
(
lO\
l\
lOlOOllll\

->
GetImpulse
(
llOOOOl\
OOlOl
,
lOOOlOO\
l\
O\
Ol
)
)
)
;
TA_A\
SSERT
(
FloatIsOK
(
lOl\
lO\
OlOlO\
O
)
)
;
Dy\
nam\
ic\
Ob\
j\
ect
*
ll\
OO\
OOl\
lO\
O\
O
=
ll\
Olll\
lOl\
ll
.
GetObjectA
(
)
;
TA_AS\
SERT
(
ll\
OOO\
OllOOO
->
IsInM\
ov\
i\
ngLi\
st
(
)
)
;
TA\
_A\
SS\
ERT
(
lOllOlOOllll\

->
GetMass
(
llO\
OOO\
llOOO
->
lOlOOlllO\
OO\
O
(
)
)
>
0.0f
)
;
float
llO\
OO\
Ol\
l\
Ol\
lO
=
1.0f
/
lOll\
OlOOllll\

->
GetMass
(
llO\
OO\
Ol\
l\
O\
OO
->
lOlO\
OlllOOOO
(
)
)
;
if
(
(
llOl\
lll\
Olll\

.
lOlOllOOll\

&
Co\
l\
li\
si\
on\

::
FLAG_ROTATION_\
CONS\
TRAI\
NT
)
==
0
)
{
Vec\
3
lOlOlOOOl\
O\
ll
=
llOOO\
Oll\
OOO\

->
Get\
LinearV\
eloci\
ty
(
)
;
lOlOlO\
OOlOll
+=
llO\
O\
O\
OllOlOl
*
llOOO\
OllOl\
lO
;
llO\
OOOll\
OOO
->
SetLi\
n\
e\
ar\
Velo\
cit\
y
(
lOlOl\
OO\
OlOll
)
;
}
Vec3\

lO\
l\
O\
lO\
O\
Oll\
O\
O
=
ll\
OOOOllOOO\

->
Get\
AngularVe\
loci\
ty\

(
)
;
lOlO\
lOO\
Ol\
lO\
O
+=
llOOOOllOlO\
l
.
Cr\
os\
s
(
ll\
OOOOllOOO
->
GetC\
e\
n\
terOfMass\

(
)
-
llOllll\
Ol\
ll
.
lOO\
OOlll\
ll
)
*
llOO\
OOll\
O\
OO
->
GetMass\

(
)
*
ll\
O\
OO\
OllO\
l\
lO
*
llOOOOllOO\
O
->
GetW\
orldSpaceIn\
ve\
rseInertia\

(
)
;
ll\
OO\
O\
O\
llO\
OO
->
Se\
tAngula\
rV\
eloc\
i\
ty
(
lO\
lO\
l\
O\
O\
Ol\
lOO
)
;
if
(
ll\
Ol\
l\
llOlll
.
lOll\
O\
lOlOll
(
)
)
{
llOOO\
OllOO\
O\

=
ll\
OllllOl\
ll
.
lOllOlO\
lOl\
l\

(
)
;
TA_A\
SSE\
RT
(
lOllOlO\
Ollll
->
GetM\
a\
ss\

(
llO\
OOOllOOO
->
lOlOO\
lllO\
OOO\

(
)
)
>
0.0f
)
;
flo\
at\

llOOOOl\
lOllO
=
1.0f
/
lOllO\
lOOl\
lll
->
GetMass
(
llOOOOl\
l\
OOO
->
lOl\
O\
O\
lllOO\
OO
(
)
)
;
if
(
(
ll\
OllllO\
lll
.
lOlOllO\
Oll\

&
Colli\
sion
::
FL\
AG_ROTAT\
I\
ON_CO\
NSTRAINT
)
==
0
)
{
Vec3
lOlOl\
OOOl\
Oll
=
llOOOO\
llOO\
O
->
Ge\
t\
LinearV\
eloc\
ity
(
)
;
lOlOl\
OOOl\
Ol\
l
-=
llO\
OO\
O\
llOl\
Ol
*
llO\
OOOl\
l\
Ol\
lO
;
llOOOOllOOO
->
SetLinea\
rVelocity
(
lOl\
O\
lO\
OO\
l\
Ol\
l\

)
;
}
lOlO\
lOOOll\
OO\

=
llOOOOll\
O\
OO
->
GetAngula\
rV\
elocit\
y
(
)
;
lOlOlOOO\
llOO
-=
llOOOO\
llO\
l\
Ol
.
Cro\
s\
s\

(
llOOOO\
l\
lOOO
->
Ge\
tCent\
erOfM\
a\
s\
s\

(
)
-
ll\
Ol\
ll\
lOl\
ll\

.
lO\
OOOll\
lll\

)
*
llOO\
OOllOOO
->
GetMa\
ss
(
)
*
ll\
OOO\
O\
l\
l\
OllO\

*
llOO\
O\
OllOOO
->
GetWorl\
dS\
paceI\
nv\
erseI\
nert\
i\
a
(
)
;
llOOOOllO\
OO
->
Set\
Angu\
lar\
V\
e\
loc\
ity\

(
lO\
lOlOOOllOO
)
;
}
}
}
if\

(
!
lOllOllO\
ll\
OO\

.
ll\
OOOOllO\
O\
lO
(
)
)
{
float
llOO\
OOllOlll\

=
0.0f
;
for
(
ll\
OOOO\
O\
Ol\
lll
=
lOll\
Ol\
lOl\
lOO
.
llOOOOO\
lOOO\
O
(
)
;
!
llO\
OOO\
O\
O\
lll\
l
.
AtEnd\

(
)
;
++
ll\
OOOO\
OO\
l\
lll\

)
{
DynamicO\
bject
&
llOOOOO\
OO\
OO\

=
*
*
llOOOOOO\
ll\
ll\

;
TA_ASSE\
RT
(
lOll\
OlOOllll
->
GetMa\
ss\

(
llO\
OOO\
OO\
OOO
.
lOlOO\
lllO\
OO\
O\

(
)
)
>
0.0f
)
;
TA_AS\
SE\
RT
(
ll\
O\
OOOOOO\
OO
.
GetMas\
s
(
)
>
0.0f
)
;
float
ll\
OO\
OOllOO\
l\
l\

=
lOllOlOOllll
->
GetMass
(
llOOO\
OOOOOO
.
lO\
lOOl\
llO\
OO\
O\

(
)
)
/
ll\
OOOOOO\
OO\
O\

.
GetMa\
ss
(
)
;
llO\
O\
OOllOll\
l
+=
0.5f
*
llO\
OOO\
llOOll
*
llOOO\
OO\
OO\
O\
O
.
GetLine\
arVelo\
cit\
y
(
)
.
GetM\
a\
gni\
t\
ude\
Sqrd
(
)
*
llOO\
O\
OOOOO\
O
.
GetMass\

(
)
;
flo\
a\
t
llOO\
OOllOOOl
=
0.5f
*
llOOOOllOOl\
l
*
(
llOOO\
OOO\
OOO\

.
GetAng\
ularV\
el\
oci\
ty
(
)
*
ll\
OO\
O\
OOOO\
OO\

.
Get\
WorldSpa\
ceIne\
rt\
ia
(
)
)
.
Do\
t
(
llO\
OOOOOO\
OO
.
Ge\
tAngula\
rV\
el\
ocity
(
)
)
;
TA_ASS\
E\
RT
(
llOOO\
Oll\
OO\
O\
l
>=
0.0f
)
;
llO\
OOOllOl\
l\
l
+=
ll\
OOOOll\
O\
OOl
;
}
if
(
ll\
OOOOllOlll
*
0.5f
>
llOOOOllOOOO\

)
{
fo\
r
(
ll\
OOO\
OOOlll\
l
=
lOl\
l\
Ol\
lOllOO\

.
llOOOOOl\
OOOO\

(
)
;
!
llOOOOOOl\
ll\
l
.
At\
En\
d\

(
)
;
++
llO\
OOO\
OOlll\
l
)
{
DynamicObj\
ect\

&
llOOOO\
OOOO\
O
=
*
*
llOO\
OOOOllll
;
llOO\
OOOO\
OOO
.
lOl\
OOOlOOllO
(
)
;
}
return
fal\
se
;
}
}
lOl\
O\
lllO\
OO\
lO
=
lOl\
lO\
llOl\
l\
OO
.
lOl\
OOOOl\
OO
(
)
;
for
(
int
llOOO\
OlO\
OlOl\

=
0
;
!
lOlO\
l\
llOOOlO
.
AtEnd\

(
)
;
++
lOl\
Olll\
OO\
OlO
,
++
llO\
O\
O\
Ol\
OOlOl\

)
{
Col\
lision
*
llOllO\
lOll\
l
=
&
*
lOl\
O\
ll\
l\
OOO\
lO\

;
for\

(
in\
t
lOOOlOOlOO\
l\

=
0
;
llOl\
lO\
lOll\
l
;
llO\
llOl\
Olll
=
llOllO\
lOl\
l\
l
->
GetNext
(
)
,
lOOOl\
OOlOOl
++
)
{
Co\
lli\
s\
io\
n\

&
ll\
Oll\
llO\
l\
ll
=
*
ll\
OllOlO\
l\
ll
;
float
lOll\
OOlOl\
OO
=
lO\
llOl\
OOllll\

->
Ge\
tImpulse
(
llOOOO\
lO\
OlOl
,
lOOOlOO\
lOOl
)
;
if
(
lOllOO\
lOl\
OO
==
0.0f
)
continue
;
ll\
OllllOlll\

.
lOllOOlOlOO
+=
lO\
llO\
OlOl\
OO
/
lOl\
llOO\
lOO\
Ol
;
TA\
_\
AS\
SE\
R\
T
(
Float\
IsOK
(
lOllOl\
O\
Ol\
lll\

->
Ge\
tImp\
ulse
(
llOOOOl\
O\
Ol\
Ol
,
lOO\
O\
lOOl\
OOl
)
)
)
;
TA_ASS\
ERT
(
Fl\
oatIsOK
(
lOllO\
O\
lOl\
OO\

)
)
;
Dyna\
micObjec\
t
*
ll\
OOO\
OllOOO
=
llO\
llllOlll\

.
Ge\
tObjec\
t\
A
(
)
;
TA_ASS\
E\
R\
T
(
ll\
OO\
OOl\
lOOO\

->
IsIn\
Mov\
ingList
(
)
)
;
TA_A\
SSERT
(
lOll\
O\
l\
OOlll\
l
->
Ge\
tMass
(
llOOOOllOO\
O
->
lOlOOlllOOO\
O
(
)
)
>
0.0f
)
;
float
ll\
OOOO\
ll\
Ol\
lO
=
1.0f
/
lO\
l\
l\
OlOOllll\

->
Get\
Mass
(
ll\
OOOOllO\
O\
O
->
lOl\
OO\
l\
llOO\
O\
O
(
)
)
;
if\

(
(
llOllllOlll
.
lOlOl\
lOOl\
l
&
Collisi\
o\
n
::
FLAG_RO\
TATION\
_C\
ONS\
TR\
AINT
)
==
0
)
ll\
OOOOllOO\
O\

->
lO\
O\
lOl\
lllll\
l
(
Fa\
bs\

(
lOllOOlOlOO
*
(
llOO\
OOllOO\
O
->
Get\
M\
as\
s\

(
)
*
llOOOOllOll\
O\

)
)
)
;
if
(
llOl\
lll\
O\
l\
ll
.
lO\
llOlOl\
Oll
(
)
)
{
llOO\
OO\
ll\
OO\
O
=
ll\
Oll\
llO\
lll\

.
lOllOlO\
lO\
ll
(
)
;
TA\
_A\
S\
S\
E\
R\
T\

(
lOl\
lOlOOllll\

->
Get\
M\
a\
ss
(
llOOOOllO\
OO
->
lOlO\
OlllOOOO
(
)
)
>
0.0f
)
;
float
llOOOOll\
O\
l\
lO\

=
1.0f
/
lOllOlO\
O\
l\
lll
->
GetMa\
ss
(
llOOOOl\
lOO\
O
->
lOl\
OOlllOOOO
(
)
)
;
if
(
(
llOlll\
l\
Olll
.
lOlOl\
lOOll
&
Co\
llision
::
FLA\
G_ROTA\
TION_\
CONSTRAINT
)
==
0
)
llOOOOll\
O\
OO\

->
lOOlO\
llllll\
l
(
Fab\
s
(
lOl\
lO\
O\
l\
OlO\
O
*
(
llOOOOllOOO
->
Ge\
tMass\

(
)
*
ll\
OOOO\
ll\
Ol\
l\
O
)
)
)
;
}
}
}
#ifdef llOOOOlOllll
floa\
t\

ll\
OOOOllO\
lll
=
0.0f
;
llO\
OO\
OO\
O\
ll\
ll
=
lOllOllOl\
l\
OO
.
llOOO\
OOlOOOO\

(
)
;
for
(
;
!
llOO\
OOO\
Ollll
.
AtEnd\

(
)
;
++
llOOOOOOll\
ll\

)
{
DynamicObject
&
lOllll\
Ol\
lOOl
=
*
*
llOOOOOOl\
lll\

;
llO\
OOOll\
Olll\

+=
0.5f
*
lOllllOllOO\
l
.
GetL\
i\
n\
earVelocity\

(
)
.
GetMa\
gn\
itudeSq\
rd
(
)
*
lOl\
lllOl\
lOOl
.
Ge\
tMass
(
)
;
fl\
o\
a\
t\

llO\
OOO\
llOOOl
=
0.5f
*
(
lOll\
llOllO\
Ol
.
Get\
Angular\
Ve\
locity
(
)
*
lO\
l\
lllOllOOl
.
GetWorl\
dSp\
ace\
Inerti\
a
(
)
)
.
Do\
t
(
lOllll\
OllOOl
.
Get\
A\
ngul\
a\
rVelocity
(
)
)
;
TA_ASSERT
(
llOOOOl\
lOOOl
>=
0.0f
)
;
ll\
O\
OOOllOl\
l\
l
+=
llOOOOllOO\
Ol
;
}
TA\
_A\
SSERT
(
ll\
O\
OOOllO\
l\
ll
>=
0.0f
)
;
TA_A\
SS\
ER\
T
(
llO\
OOOllOOOO\

>=
0.0f
)
;
llOO\
OOllOOOO\

*=
1.05f
;
if
(
llOOOOllOlll
>
llO\
OO\
OllOOO\
O
)
{
fl\
oat
llO\
lOl\
l\
OOO\
O\

=
Sqrt
(
llOO\
OOllOOOO
/
ll\
OO\
OOllOlll
)
;
llO\
OOO\
O\
Ollll
=
lOllO\
llOl\
lOO
.
llOOO\
O\
OlOO\
OO
(
)
;
for
(
;
!
llO\
O\
OOOOllll
.
AtEn\
d
(
)
;
++
ll\
O\
OO\
OOOllll
)
{
DynamicOb\
ject
&
lOlll\
l\
OllOOl
=
*
*
llOOO\
OOO\
llll\

;
lOll\
llO\
llO\
Ol
.
SetLine\
arVeloci\
ty
(
lOll\
llOll\
O\
O\
l
.
GetLinea\
r\
Veloci\
ty\

(
)
*
llO\
lOl\
lOOO\
O
)
;
lOll\
l\
l\
OllO\
Ol\

.
SetAngula\
r\
Vel\
ocit\
y
(
lOllll\
OllOOl
.
Ge\
t\
An\
gularVelocity
(
)
*
ll\
O\
lO\
l\
lOOOO
)
;
}
floa\
t
llOO\
O\
O\
ll\
lOOO\

=
0.0f
;
llOOO\
OOO\
llll
=
lOllOl\
l\
OllOO
.
llOOO\
OO\
lOOOO
(
)
;
for\

(
;
!
ll\
OOOO\
OOll\
ll
.
At\
E\
nd\

(
)
;
++
llOO\
OO\
OOllll
)
{
Dy\
namicO\
bject
&
lO\
ll\
ll\
OllO\
Ol
=
*
*
ll\
OO\
OOOOll\
ll\

;
llO\
OOOlllOOO
+=
0.5f
*
lO\
llllOl\
l\
O\
O\
l
.
Get\
Linear\
Vel\
ocity
(
)
.
GetM\
ag\
nitu\
d\
eSqr\
d
(
)
*
lOll\
llO\
llOOl
.
GetMass
(
)
;
float
llOOO\
Ol\
l\
OOOl
=
0.5f
*
(
lOllllOll\
OOl\

.
Ge\
tAn\
g\
ularVeloc\
ity
(
)
*
lOl\
lllOll\
OOl
.
GetWo\
r\
ldSp\
ace\
Iner\
ti\
a
(
)
)
.
Do\
t
(
lOllllOllOOl\

.
GetA\
ng\
ularVe\
loc\
i\
ty
(
)
)
;
TA_\
ASSER\
T\

(
llOOOOllOOOl
>=
0.0f
)
;
ll\
OO\
OOlllOOO\

+=
llO\
OOOllOOOl
;
}
TA\
_AS\
S\
E\
RT
(
Fabs
(
llO\
OOOl\
llOOO
-
ll\
O\
OO\
O\
llOO\
OO\

)
<
0.001f
)
;
}
#endif //
ret\
u\
rn
tr\
ue
;
}
voi\
d
Physic\
s\

::
lOl\
lOl\
l\
l\
OlO\
O\

(
lOl\
O\
ll\
llOOOO\

&
lO\
ll\
Ol\
lOl\
lOO
)
{
in\
t\

llOOOOlOOlOl
=
-
1
;
lOlOllll\
O\
OOO
::
lO\
llllOOl\
OOO
lOlll\
lOOlOO\
l
=
lO\
llOllO\
ll\
OO
.
lOllllOOlOlO
(
)
;
for
(
;
!
lO\
ll\
llOOlO\
Ol
.
AtE\
nd
(
)
;
++
lOl\
l\
llO\
Ol\
O\
Ol
)
{
lOlOOOOOO\
lll
&
lOlOOOO\
lll\
OO
=
*
lOll\
llOO\
lO\
Ol\

;
lOl\
OO\
OOOOl\
ll
::
Co\
llision\
I\
terato\
r
lOlOlllOOOlO\

=
lO\
lO\
O\
OO\
l\
ll\
OO
.
lOlOlllOOlO\
l
.
lO\
lO\
OO\
OlO\
O
(
)
;
Co\
ll\
i\
s\
ion
*
llOOO\
Ol\
l\
l\
OOl
=
0
;
int
ll\
OO\
OO\
lllOlO\

=
0
;
for
(
;
!
lOlOlllO\
OO\
lO
.
At\
En\
d
(
)
;
++
lO\
lOlllOOOl\
O
)
{
Col\
l\
ision
&
ll\
Olll\
lOlll
=
*
lOl\
OlllOOOl\
O
;
if
(
llOllll\
Olll
.
lO\
lOl\
l\
OOl\
l
&
Collision\

::
FL\
AG_F\
R\
I\
CTION\

)
continue\

;
ll\
OOO\
OlOOl\
Ol\

++
;
if
(
llOllllOl\
ll
.
lOlO\
llO\
Oll\

&
Co\
l\
lision
::
FLA\
G\
_NO\
_F\
RIC\
TION\

)
con\
t\
inue\

;
Dyn\
ami\
cObject
*
ll\
OOOO\
llOOO
=
llO\
lll\
lOlll
.
GetObjectA
(
)
;
if\

(
ll\
Olll\
lOlll
.
lO\
ll\
OlOlO\
l\
l
(
)
&&
ll\
Olll\
lOlll
.
lOllO\
lOlO\
l\
l
(
)
->
Ge\
tMass
(
)
>
llOllllOlll
.
GetO\
bjec\
tA\

(
)
->
GetMa\
ss
(
)
)
llO\
OOO\
l\
lOOO
=
llOllllOlll
.
lO\
llO\
lOlOll
(
)
;
float
llOOOOll\
l\
Ol\
l\

=
ll\
OOOOll\
OOO
->
GetMa\
ss
(
)
/
lOllOlOO\
l\
lll\

->
Get\
Mass
(
llO\
OOOll\
OOO
->
lOlO\
OlllOO\
OO
(
)
)
;
bo\
ol
lOll\
OOOlOOll
=
lOlO\
O\
lO\
OOOOO\

(
lOll\
OlOO\
llll
->
Get\
Im\
puls\
e
(
llOOO\
OlOOl\
Ol
,
0
)
*
llO\
OO\
OlllOll
,
ll\
OllllO\
ll\
l
)
;
if
(
lOl\
lO\
OOl\
OO\
ll
&&
!
llO\
llllOl\
ll
.
lO\
llOOO\
llO\
l
->
Ri\
g\
id\
Frictio\
nDi\
sabl\
ed
(
)
&&
(
!
llOl\
l\
l\
l\
Olll
.
lOllOlO\
lOll
(
)
||
!
ll\
O\
l\
l\
llOlll
.
lOll\
Ol\
OlO\
ll
(
)
->
Rig\
idFrictio\
nD\
isa\
bled\

(
)
)
)
{
int
lOl\
OllOOll\

=
llOll\
llO\
l\
ll
.
lOl\
Ol\
lOOl\
l
&
(
ll\
OllllOlll
.
FLA\
G_OB\
JECTB\
_SO\
L\
ID_INTERN\
A\
L
|
llOllllOl\
ll\

.
FLAG\
_OBJECTA_SOL\
I\
D_I\
NTER\
N\
AL\

|
llOl\
lllOll\
l
.
FLA\
G_\
OBJE\
CTB_INF\
IN\
ITE_MASS\

)
;
lOlOll\
OO\
l\
l
|=
Co\
llis\
ion
::
FLA\
G_CONST\
RAIN_IN_BO\
TH_DIRECT\
IONS
|
Co\
l\
lis\
i\
on\

::
FLAG_\
FR\
ICTIO\
N\

;
Co\
llision\

lOllOO\
lllOll
=
llOllllOl\
ll
;
lOllOOlllO\
l\
l
.
lOlO\
ll\
OOll
=
lOlOl\
l\
O\
O\
l\
l
;
lOll\
OOlllOl\
l
.
lOllO\
OlOOll
=
0.0f
;
lOll\
O\
Olll\
Oll\

.
lllOllll\
l\
O
=
0.0f
;
lO\
llOO\
ll\
lOl\
l
.
lOllOOlOll\
l
=
0.0f
;
lOll\
OOl\
llO\
l\
l
.
lOllOOllOOO
.
Clear
(
)
;
lOllOOl\
l\
l\
Ol\
l
.
lOll\
OO\
ll\
O\
Ol
.
Clear
(
)
;
lOll\
O\
Oll\
lOll
.
lOllOlOOll\
l
(
0
)
;
if\

(
llOOOOll\
lOlO
==
0
)
{
ll\
OllllOl\
ll\

.
lOlOllOOll
|=
Collision
::
FLAG\
_\
FRICTIO\
N_GENERAT\
ING_\
IMPUL\
SE\

;
Mat\
33
lOOOO\
O\
OOl\
l
;
TA\
_A\
SS\
E\
RT
(
ll\
Ol\
ll\
lO\
lll
.
lOOOlO\
OO\
OO\

.
Is\
No\
rmal\
i\
sed\

(
)
)
;
lOOO\
OOOOll
.
SetT\
oLo\
okDow\
n\
Ve\
ctor
(
llOllllOlll
.
lOO\
OlOOOOO
)
;
lOllOOlllOl\
l
.
lO\
OO\
lOOO\
O\
O\

=
lOO\
OOOOOll
.
v3X\

;
Co\
l\
lisio\
n
*
ll\
OOOO\
lll\
lOO
=
lOllOl\
OllO\
ll
->
ll\
OOOO\
llll\
Ol
(
lOlOOO\
OlllOO
,
lO\
l\
lOOl\
llOll
)
;
if
(
llO\
OOO\
llllOO\

)
{
llO\
OOOlOO\
lll
(
lOOl\
lOl\
lllOO
->
lOlOlllllOOO
,
*
llOOOO\
llll\
OO
)
;
#ifdef lOllOOlOOlll
if
(
lllOllOOOO
&
llOOOOlllllO
)
Phys\
i\
c\
sR\
end\
er\

::
Render\
Ar\
row\

(
ll\
OOO\
O\
ll\
llOO\

->
lOOOOll\
lll\

,
llOO\
OO\
lll\
lOO
->
lOOOlOOOOO
,
0xff00ff00
)
;
#endif //
}
lOllO\
OlllOl\
l
.
lOOOlO\
OO\
OO
=
lOOOOOOOll
.
v3Y\

;
Collis\
ion
*
llO\
OO\
Oll\
ll\
ll
=
lOllOlOll\
Oll
->
ll\
OOOOl\
lllO\
l
(
lOlOOOO\
lllOO\

,
lO\
llOOl\
llOll
)
;
if
(
ll\
OOOOll\
llll
)
{
ll\
OOOOlO\
O\
lll
(
lOOllOllllOO
->
lOlOlllllO\
OO
,
*
ll\
OOOO\
ll\
l\
lll
)
;
#ifdef lOllOOlOOlll
if
(
lll\
Oll\
OO\
OO
&
llOOOOl\
l\
lllO
)
Physic\
sR\
e\
nd\
er\

::
Rende\
r\
Arro\
w
(
llOOOOll\
lll\
l
->
lOOO\
O\
l\
l\
lll\

,
llOO\
OOll\
llll\

->
lO\
OOlO\
O\
OO\
O\

,
0xff00ff00
)
;
#endif //
}
}
else
if
(
ll\
OOOOl\
ll\
OlO
==
1
)
{
TA\
_AS\
SER\
T\

(
llOOO\
Oll\
lOOl\

!=
0
)
;
Vec3
lOOO\
lO\
O\
O\
OO
=
ll\
Oll\
llOlll
.
lOOOl\
OOO\
O\
O
.
Cross
(
llOllllOl\
ll
.
lOO\
O\
O\
llll\
l\

-
llOO\
OOlllOOl
->
lOO\
OOlllll\

)
;
float
lOllllOl\
Ol
=
lO\
O\
OlOOOOO
.
Ge\
tMa\
gni\
t\
ude\

(
)
;
if
(
lOllllOlOl
>
0.000001f
)
{
ll\
O\
llllO\
lll\

.
lOlOllOOl\
l
|=
Collisi\
o\
n
::
FL\
A\
G_FRI\
CT\
ION_GENE\
R\
A\
TING_\
I\
MPULS\
E
;
lO\
OOlO\
OOOO\

.
No\
rmali\
se\

(
)
;
lO\
llOOlllOll\

.
lOOO\
lOOOOO
=
lO\
OOlOO\
OOO
;
Colli\
sion\

*
llOOOOllllOO\

=
lOll\
OlOllO\
ll\

->
llOOOOllllOl
(
lOl\
OO\
OOlll\
O\
O
,
lOllO\
Oll\
l\
Oll
)
;
if
(
llOOOOllllOO
)
{
llOOOOlOO\
ll\
l\

(
lO\
OllOl\
l\
llO\
O
->
lOlOlll\
llO\
OO
,
*
ll\
OOO\
Oll\
llOO
)
;
#ifdef lOllOOlOOlll
if\

(
lllO\
l\
lOOOO
&
ll\
O\
O\
OOlllllO
)
Physics\
Re\
n\
der\

::
Re\
nder\
Arrow\

(
llOOOOll\
l\
lOO\

->
lOOO\
Olllll
,
llOOOOl\
lllOO
->
lOO\
OlOOOO\
O
,
0xff00ff00
)
;
#endif //
}
}
}
els\
e
if\

(
llOOOOlllO\
l\
O
==
2
)
{
ll\
Olll\
l\
Ol\
ll
.
lOlOllO\
Oll
|=
Co\
llision\

::
FLA\
G_\
FRICTION\
_GENE\
RA\
TING_I\
MP\
ULSE
;
}
llO\
OOOl\
l\
lO\
Ol
=
&
llO\
llllOll\
l
;
llOOO\
Ol\
ll\
OlO
++
;
}
}
}
}
voi\
d
Phys\
ics
::
lO\
l\
lO\
lll\
l\
lll
(
float
lO\
O\
ll\
lO\
O\
ll\
ll
,
lOlOlll\
l\
OO\
O\
O
&
lOllO\
llOl\
lOO
)
{
lOlOll\
llOO\
O\
O\

::
llOO\
OO\
OOl\
llO
ll\
OOOOO\
O\
l\
lll
=
lOllO\
ll\
Ol\
lOO\

.
llOOOOO\
l\
O\
OOO
(
)
;
for
(
;
!
llOOOO\
OOlll\
l
.
At\
E\
n\
d
(
)
;
++
llOOOOO\
O\
llll
)
{
DynamicO\
bjec\
t
&
lOlll\
lOll\
O\
O\
l
=
*
*
llOOO\
OO\
O\
ll\
l\
l\

;
lOl\
lllOllO\
Ol\

.
lO\
lOOlOOlOll\

(
)
;
}
bool
ll\
OOOlOOO\
OOO
=
true
;
lOlOll\
l\
lOO\
OO
::
Itera\
tor
lO\
lOll\
lOOO\
lO
=
lOll\
Ol\
l\
OllOO
.
lOlOO\
O\
OlOO
(
)
;
for
(
;
!
lOlOll\
lOOO\
l\
O
.
AtE\
nd
(
)
;
++
lO\
l\
OlllOOO\
lO
)
{
Coll\
is\
ion
&
ll\
Olll\
lOlll
=
*
lOlO\
lllOOOlO\

;
if\

(
!
llO\
ll\
llOll\
l
.
Ge\
tObjec\
tA
(
)
->
lOlO\
O\
OlOO\
O\
OO
(
)
||
!
llOl\
l\
llOlll\

.
GetO\
bj\
ectB
(
)
->
lOlO\
OOlOOOOO
(
)
)
llOOOl\
OO\
OO\
OO
=
false
;
if
(
!
(
ll\
O\
l\
lllOll\
l
.
lOlO\
l\
lOOll
&
(
Col\
lision
::
FLAG\
_F\
RICTIO\
N_GENE\
RATI\
NG\
_IMPULSE
|
Collisi\
on
::
FL\
AG_FR\
IC\
TI\
ON\
_GENERAT\
I\
NG_IM\
PU\
LSE2
)
)
)
conti\
nue\

;
if
(
!
(
llOl\
ll\
lO\
l\
ll\

.
GetObject\
B
(
)
->
lO\
l\
O\
OO\
l\
OO\
OOO
(
)
||
llOllllOll\
l
.
Ge\
tObj\
ectA
(
)
->
lO\
lOOOlOOO\
OO
(
)
)
)
co\
ntinue
;
TA_AS\
S\
E\
RT\

(
llOll\
l\
lO\
l\
ll
.
Ge\
tObj\
ectA
(
)
)
;
TA_ASSERT
(
llOllll\
Olll\

.
Get\
Objec\
tB\

(
)
)
;
if
(
llOl\
ll\
lO\
ll\
l
.
lOOOl\
OOOOO
.
Dot
(
GetGrav\
ity\

(
)
)
<
lOlll\
OO\
lO\
OOO
*
0.8f
)
llO\
ll\
ll\
Olll\

.
GetOb\
j\
ectA
(
)
->
lO\
lOOlOOl\
O\
lO\

(
)
;
if
(
llOllll\
O\
l\
l\
l
.
lO\
OOlO\
OOOO
.
Do\
t
(
Ge\
tGr\
av\
i\
t\
y
(
)
)
>
-
lOl\
l\
lO\
O\
lOO\
OO
*
0.8f
)
llOllll\
Ol\
ll
.
Ge\
tObje\
ctB
(
)
->
lOlOOlOOlOlO
(
)
;
}
llO\
O\
OOOOllll
=
lO\
l\
l\
O\
ll\
O\
llO\
O
.
llOOOOOlOOOO
(
)
;
co\
nst\

flo\
a\
t
llOOOlO\
O\
OOOl
=
lO\
l\
llOOl\
O\
O\
OO
*
lO\
lll\
OOl\
OOOO
*
(
1.0f
/
9.81f
/
9.81f
)
*
lO\
Ol\
l\
lOOllll\

*
60.0f
;
boo\
l
llOO\
OlOOOOlO
=
tr\
ue\

;
floa\
t\

ll\
OOO\
lOO\
OOll
=
lOll\
OlO\
O\
Oll\
O
(
lOOlllOOl\
lll
)
;
float\

ll\
O\
OOlOO\
OlO\
O
=
Exp
(
lOOlllOOllll
*
-
3.0f
)
;
for
(
;
!
llOOOO\
OOlll\
l\

.
At\
End
(
)
;
++
llOO\
O\
O\
OOllll\

)
{
Dyn\
ami\
cObject
&
lOllOl\
OllO\
lO
=
*
*
ll\
OOO\
OOOllll
;
lOllOlOllOl\
O\

.
lO\
lOOO\
lOOl\
l\
l
(
lOO\
ll\
l\
OO\
ll\
l\
l
,
llO\
OO\
lOOO\
Oll
)
;
float
llOlOl\
l\
OOO\
O\

=
lOl\
lO\
l\
Ol\
lO\
lO
.
Ge\
tRestTimeM\
ul\
tiplier
(
)
;
ll\
OlO\
l\
l\
OOOO
=
llO\
lOllO\
OOO
*
ll\
OlOllOO\
OO
;
if
(
lO\
llO\
lO\
l\
l\
O\
l\
O
.
lOlOOl\
OOlOOl
(
)
>=
3
)
ll\
O\
l\
Ol\
lOOOO
*=
3.0f
;
flo\
at\

ll\
OOO\
lO\
OOl\
O\
l\

=
llOlO\
l\
lOOOO\

;
llOl\
OllOOOO
*=
llOOO\
lOOOOOl
*
lOllOlOllOl\
O
.
lOOllO\
OOO\
l\
OO
(
)
*
lO\
l\
lOl\
OllOl\
O
.
lOOllOO\
OOlOO
(
)
;
if
(
(
lOllOlOllOlO\

.
GetL\
inearVelocity\

(
)
.
Ge\
tMag\
n\
itudeSqrd
(
)
<
lOllOOl\
lllll\

*
ll\
OlOllOO\
O\
O
&&
lOl\
l\
OlO\
l\
lOlO\

.
GetAng\
ul\
ar\
V\
e\
lo\
city
(
)
.
Ge\
t\
M\
agn\
itude\
S\
qr\
d
(
)
<
lO\
ll\
O\
l\
OOO\
OOO
*
ll\
OOOl\
OOO\
l\
Ol\

)
||
(
lOl\
lO\
l\
O\
ll\
OlO
.
lO\
lOOlllOll\
O
(
)
.
Get\
Ma\
g\
nitudeSqr\
d\

(
)
<
lOllO\
O\
l\
l\
llll
*
0.001f
*
llOlOll\
OOOO\

&&
lOllOlOllOlO
.
lOlOO\
l\
llOlll
(
)
.
GetMagni\
tudeSqrd
(
)
<
lOl\
lO\
lOO\
OOOO
*
0.001f
*
llOOOlOO\
Ol\
Ol
)
)
{
if
(
lOllO\
lOllOlO
.
lO\
lOO\
lOOl\
OOl
(
)
>=
3
)
lOl\
lOlO\
l\
lO\
l\
O\

.
lO\
lOOlO\
OOll\
l
(
lO\
OlllOOllll\

*
5.0f
)
;
els\
e\

lO\
llOlOllO\
lO
.
lOlOOl\
OOOlll\

(
lOOlllO\
Ol\
lll
)
;
}
el\
se
{
lO\
ll\
OlOl\
lO\
lO
.
lOOlllOOlll\
O\

(
)
;
}
if
(
lOl\
lOl\
OllOl\
O
.
lO\
lOOlOOOlOl\

(
)
>
lOllOOl\
llll\
O
)
{
if\

(
(
lOllOlOll\
Ol\
O\

.
GetLinea\
r\
Velocity
(
)
.
GetMagnit\
u\
d\
eSqrd
(
)
<
lO\
llOOl\
ll\
l\
ll\

*
llOl\
Oll\
O\
OO\
O
*
0.2f
&&
lO\
l\
l\
OlOllO\
lO
.
Ge\
tA\
ngu\
larVeloci\
ty
(
)
.
GetMagn\
i\
t\
ud\
e\
Sqrd\

(
)
<
lOl\
lOlOOO\
O\
O\
O
*
ll\
OOOl\
OOOl\
O\
l
*
0.2f
)
||
(
lO\
llO\
l\
Ol\
lOl\
O\

.
lO\
l\
O\
O\
lllOllO\

(
)
.
GetM\
agnitud\
e\
Sq\
r\
d
(
)
<
lOllO\
O\
llllll\

*
0.00025f
*
llO\
lOllO\
OOO
&&
lO\
ll\
OlOll\
OlO
.
lOlOOlll\
O\
lll
(
)
.
Ge\
tMagni\
tudeSq\
r\
d\

(
)
<
lOllO\
lOOOOO\
O
*
0.00025f
*
llOOOlOOOlOl\

)
)
{
lOllO\
lOllOlO
.
SetLinea\
r\
Ve\
lo\
ci\
ty\

(
k_\
v\
3Zero
)
;
lOllO\
lOl\
lOlO
.
SetAngularV\
elocity\

(
k_v3Zer\
o\

)
;
lO\
l\
lOlOllOlO\

.
lOO\
ll\
lOOl\
OlO
(
true\

)
;
if
(
(
lllO\
llOOO\
O\

&
lOlllOOl\
Ol\
ll
)
&&
lOllOlOllO\
lO
.
lOlOOllllOOO
(
)
<
lO\
ll\
O\
lOllOl\
O
.
GetMas\
s\

(
)
*
0.5f
)
lOllOl\
Ol\
lOlO
.
Set\
ToResting\

(
)
;
}
els\
e
{
lOll\
OlO\
llO\
l\
O
.
lOOlllO\
Ol\
OlO
(
fals\
e\

)
;
if
(
!
lOll\
OlOllO\
lO\

.
IsA\
llDamp\
ingDisabled
(
)
)
{
lOllOlOl\
l\
OlO
.
SetLinearVelocity
(
lOllOlOll\
Ol\
O
.
GetLinearVe\
l\
o\
cit\
y\

(
)
*
llOO\
OlO\
OO\
lOO\

)
;
lO\
llOlOllOlO\

.
Se\
tAng\
ularVel\
ocity
(
lOllO\
lOl\
lOlO
.
Get\
AngularVeloc\
it\
y
(
)
*
llOO\
O\
lOO\
O\
lO\
O
)
;
}
}
}
el\
se
{
lOllO\
lO\
llOlO
.
lO\
O\
l\
llOOlO\
lO
(
false
)
;
llOOO\
lOOOOlO
=
fals\
e\

;
}
}
if\

(
llOOOlOOO\
OlO
&&
llO\
OOl\
O\
O\
OOOO
)
{
ll\
O\
OO\
O\
O\
Oll\
ll
=
lO\
llO\
l\
l\
O\
llOO
.
ll\
OO\
OO\
OlOO\
OO\

(
)
;
for
(
;
!
llOO\
O\
O\
O\
Ollll
.
AtEnd
(
)
;
++
llOOO\
O\
OO\
l\
ll\
l\

)
{
Dyn\
amicObjec\
t
&
lOllOlOllOlO
=
*
*
llO\
OOOOOllll
;
lOllOlO\
l\
lOlO
.
lO\
lOOlOlOO\
O\
l
(
tru\
e
)
;
}
}
}
void\

Physic\
s
::
lOlllOOO\
lOOO
(
float\

lO\
O\
lllOOl\
l\
ll\

,
bo\
ol
llOOO\
lOOOllO
,
lOl\
OllllO\
O\
OO\

&
lOllOllO\
l\
l\
OO
)
{
flo\
at\

llOOOlOOO\
lll
=
lOl\
ll\
OOlOOOO
*
lOOlllOO\
l\
l\
l\
l
;
lOlOllll\
OOOO
::
llOO\
OO\
OOl\
l\
lO
ll\
O\
O\
OOOOl\
ll\
l
=
lO\
ll\
OllO\
llOO\

.
llOOOOO\
l\
OOOO
(
)
;
fo\
r
(
;
!
ll\
OOO\
OOOll\
l\
l
.
AtEn\
d
(
)
;
++
ll\
OOO\
OOO\
llll
)
{
Dyna\
m\
i\
cObjec\
t\

&
lO\
llO\
l\
Oll\
O\
l\
O
=
*
*
llOO\
OO\
OOllll
;
lOllO\
lO\
llO\
l\
O
.
App\
ly\
Velocity\
ToNex\
tFra\
me
(
lOOlllOOllll
)
;
if
(
llOO\
OlOOOllO\

)
{
if
(
!
lOl\
lO\
lOll\
O\
lO
.
lOlOOO\
lOOO\
OO
(
)
)
lOl\
l\
OlO\
llOlO\

.
App\
l\
y\
N\
ex\
tFr\
ame
(
)
;
if
(
!
lOllOlOl\
lOl\
O
.
IsAllD\
ampingDi\
sable\
d
(
)
&&
lO\
llOll\
Oll\
O\
O
.
llO\
O\
OlOOl\
O\
OO
(
)
)
{
TA\
_ASSERT
(
lOl\
lO\
l\
OllOlO
.
lOOllOOOOlO\
O
(
)
>
0.0f
)
;
fl\
oat
lOO\
llll\
OO\
O\
ll\

=
lOllOlO\
llOlO
.
GetLi\
ne\
ar\
Vel\
o\
city
(
)
.
Get\
M\
ag\
nitud\
e
(
)
/
lO\
llOlOllOlO
.
lO\
OllOO\
OOl\
OO
(
)
;
lOOl\
lllO\
OOll
+=
lO\
ll\
OlOllOlO
.
Ge\
t\
An\
gu\
larVeloci\
t\
y
(
)
.
Ge\
tMag\
nitu\
de\

(
)
*
0.5f
;
lOO\
llll\
OOOll
+=
lOll\
O\
lO\
ll\
Ol\
O
.
lOOl\
lOO\
OOlOO\

(
)
*
0.02f
;
{
TA\
_A\
SSE\
RT
(
lOl\
lOlOl\
l\
OlO
.
Ge\
tMas\
s
(
)
>
0.0f
)
;
flo\
at\

ll\
O\
O\
OlOOlOO\
l
=
(
lOllOl\
OllOl\
O
.
lOl\
O\
O\
l\
l\
lOOll
(
)
-
lOllO\
lOllO\
lO\

.
Get\
Mass\

(
)
*
llOOOlOO\
Ol\
l\
l
)
/
(
lOOl\
lllOOOll
*
lOl\
lO\
lOllO\
l\
O
.
Ge\
tMa\
s\
s
(
)
)
;
ll\
OOO\
l\
OOl\
OOl
-=
0.5f
;
if\

(
llOOO\
lOOlOO\
l
>
0.0f
)
{
if
(
llO\
OO\
lOOlOOl
>
10.0f
)
llOOOl\
OOlOOl
=
10.0f
;
floa\
t
llOOOlOO\
lOlO
=
Exp
(
-
ll\
OOOlOOlOOl
*
lO\
OlllOO\
ll\
ll\

*
1.5f
)
;
lOllOlOl\
lOlO
.
SetLi\
nearVeloci\
t\
y
(
lOllOl\
OllOl\
O
.
Get\
L\
i\
n\
ea\
rV\
elo\
c\
ity
(
)
*
llOO\
OlOO\
lOlO
)
;
llOOOlO\
Ol\
OlO
=
Exp
(
-
ll\
OOOlOO\
lOOl\

*
lO\
Oll\
lOOl\
lll
*
1.75f
)
;
lO\
llO\
lOll\
OlO
.
SetAng\
ula\
r\
Velocity\

(
lO\
l\
lOlOllOlO
.
GetA\
ngularV\
el\
ocity
(
)
*
llOOOlOOlOlO
)
;
}
}
}
}
}
if\

(
ll\
OO\
O\
lO\
OOllO
)
{
in\
t
llOO\
Ol\
OOlOll
=
0
;
const\

in\
t
llOOOlOOllOO
=
lO\
OllOll\
l\
lO\
O
->
lOlOl\
lll\
OOll
;
lOO\
l\
ll\
OOOll
(
Ph\
y\
sicsJ\
o\
int
*
,
llOOOl\
O\
Ol\
lOl
,
llOOOlO\
O\
l\
lOO
)
;
bool
llOOOl\
OOlllO
=
fa\
ls\
e
;
ll\
O\
OOO\
OOlll\
l
=
lOllOll\
OllOO
.
ll\
OOOOO\
lOOOO
(
)
;
for
(
;
!
llOO\
O\
OOOlll\
l\

.
AtEnd
(
)
;
++
ll\
OOOO\
OOll\
ll\

)
{
Dyna\
m\
icObject\

&
lOll\
llOll\
O\
Ol
=
*
*
ll\
OO\
OOOOl\
lll
;
Dyn\
am\
icOb\
je\
c\
t
::
Joint\
Iterator
ll\
O\
OOlO\
O\
ll\
ll
=
lO\
lll\
lO\
l\
lO\
O\
l
.
GetJoint\
Ite\
rat\
o\
r\

(
)
;
for
(
;
!
ll\
OOOl\
OOllll
.
AtEnd
(
)
;
++
ll\
OOOl\
OOll\
ll
)
{
Phys\
i\
csJoint
&
lOO\
l\
llllOO\
lO
=
*
llOOO\
l\
OO\
llll
;
if
(
lOOl\
lll\
lOOlO
.
IsB\
r\
o\
ke\
n\

(
)
)
contin\
ue
;
ll\
OOOlOO\
lllO
=
tr\
ue
;
lOOlll\
llOOl\
O\

.
ll\
O\
O\
OlOlOOOO\

(
false
)
;
TA_ASSERT\

(
lOOlll\
ll\
OOlO
.
Ge\
tObject\
A
(
)
)
;
if\

(
!
lO\
OlllllOOlO
.
Ge\
tObjec\
t\
B
(
)
||
lOOl\
ll\
llOO\
lO\

.
GetOb\
jectB\

(
)
->
Move\
m\
ent\
Disable\
d
(
)
||
lOOll\
l\
llOOlO\

.
Ge\
t\
Object\
B
(
)
->
Infinite\
M\
ass
(
)
||
!
lOOlll\
l\
lOOlO\

.
GetOb\
jec\
tB
(
)
->
IsInMovingLi\
st\

(
)
||
lOOlllllO\
OlO
.
GetOb\
ject\
A
(
)
->
Inf\
i\
ni\
teM\
ass\

(
)
||
!
lOOll\
ll\
lO\
OlO
.
Get\
O\
b\
ject\
A
(
)
->
Is\
InMoving\
List
(
)
||
lOOlllllO\
OlO
.
IsOb\
jectASoli\
d
(
)
||
lOO\
l\
lll\
lO\
O\
l\
O\

.
Is\
ObjectBSoli\
d\

(
)
)
{
if\

(
llOOOlOOl\
Oll
<
llOOOlO\
Oll\
OO\

)
{
llOOOl\
OOl\
lOl\

[
llO\
O\
Ol\
O\
O\
lOll
++
]
=
&
lOOlllllOO\
lO
;
lOOl\
llllOO\
lO
.
llOOOlOlOOOO
(
tr\
ue\

)
;
bo\
ol
llO\
OOl\
OlOOOl
=
(
lO\
O\
ll\
lllOOlO
.
GetObjectA
(
)
->
Inf\
initeMass\

(
)
||
lO\
Ollll\
l\
OOlO
.
IsO\
b\
jec\
t\
AS\
olid\

(
)
)
;
lOO\
lll\
llOOlO
.
llOOOl\
OlOOlO\

(
ll\
OO\
O\
lO\
lOOOl
)
;
}
}
}
Li\
st\

<
Phys\
i\
cs\
Joint
*
>
::
Iterato\
r\

lOl\
lll\
OlllOO
=
lOl\
lllOllO\
Ol
.
lOlOOllOl\
O\
O\
O
(
)
;
for
(
;
!
lOllllOl\
l\
lOO\

.
AtE\
nd
(
)
;
++
lOllllOlllOO
)
{
Phys\
i\
cs\
J\
oint
&
lOOlllllOOlO
=
*
*
lOl\
lllO\
lll\
OO
;
TA\
_ASSE\
RT
(
lOOll\
lllOOl\
O
.
Ge\
tO\
bje\
ctB\

(
)
==
&
lOllll\
OllOOl
)
;
TA_ASSERT\

(
lO\
OlllllOOlO
.
GetO\
bject\
B
(
)
->
lOlOOl\
lO\
Olll
(
)
==
(
void
*
)
&
lO\
llO\
llOll\
OO
)
;
if
(
lOO\
ll\
lll\
O\
Ol\
O
.
Get\
Objec\
tA
(
)
->
lOlOOllO\
Olll\

(
)
!=
(
void
*
)
&
lOl\
lOllO\
l\
l\
OO
)
{
llO\
OO\
lOOlll\
O
=
tru\
e
;
lOO\
ll\
lll\
OOlO
.
llOOO\
lOlOOOO\

(
fa\
ls\
e
)
;
if\

(
llOO\
Ol\
OO\
l\
Ol\
l
<
ll\
OOOl\
OOl\
lO\
O
)
{
ll\
OOOlO\
OllO\
l\

[
llO\
OOlOOlOll
++
]
=
&
lOOl\
llllOOl\
O
;
lO\
Ol\
l\
lllOOlO
.
ll\
O\
OOlOl\
O\
OOO
(
tru\
e\

)
;
lOOl\
ll\
llO\
O\
lO\

.
llOO\
OlOl\
OOlO
(
fa\
lse
)
;
}
}
}
}
if
(
ll\
OOOlO\
OlllO
)
{
for
(
;
;
)
{
int\

llOOO\
l\
Ol\
OO\
ll\

=
llOOOlOOl\
Oll
;
fo\
r
(
int
ll\
OOO\
l\
OlOlOO
=
0
;
llOOOlOlOlO\
O
<
llOO\
OlO\
l\
OOl\
l\

;
llO\
OO\
lO\
lOlOO\

++
)
{
Ph\
ysi\
csJoint
&
lOO\
l\
l\
lllOOlO
=
*
ll\
O\
O\
Ol\
OOl\
l\
Ol\

[
ll\
OOOl\
O\
lOl\
O\
O
]
;
if
(
lOOlllllOOlO\

.
IsBro\
ken\

(
)
)
contin\
ue
;
DynamicObj\
ect
::
Joint\
Iterat\
or
llO\
O\
OlOOllll
=
lOOlllllO\
O\
lO
.
Get\
Obj\
ectA
(
)
->
Get\
J\
oin\
tIte\
r\
ator
(
)
;
for
(
;
!
ll\
O\
OOlO\
O\
l\
ll\
l
.
AtEn\
d\

(
)
;
++
llOO\
Ol\
OOll\
l\
l
)
{
Ph\
ys\
ics\
Joint
&
llO\
OOlOlOlOl
=
*
llOOOl\
OOllll
;
if\

(
!
(
ll\
OOOlO\
lOlOl
.
llO\
OOlOl\
O\
ll\
O
(
)
||
ll\
OOOlO\
lOl\
Ol
.
IsBr\
oken
(
)
)
)
{
if
(
ll\
OOOlOOlOll
<
llOOOlO\
Ol\
lO\
O\

)
{
llOOOlOOl\
l\
Ol
[
llOO\
Ol\
O\
O\
lOl\
l
++
]
=
&
llOOOlOlO\
lOl
;
ll\
OOOl\
OlOlOl\

.
llOOOlOlOO\
O\
O
(
true
)
;
lOOllll\
lOOlO\

.
ll\
OOO\
lO\
lOOlO
(
fa\
lse
)
;
}
}
}
Lis\
t\

<
Phy\
si\
csJoi\
nt
*
>
::
Ite\
r\
a\
tor
lOl\
lllO\
ll\
lOO
=
lO\
O\
llll\
lOOl\
O\

.
GetObje\
c\
tA
(
)
->
lO\
lOOllOl\
O\
O\
O
(
)
;
for
(
;
!
lOllllOlllOO
.
AtEnd
(
)
;
++
lO\
lll\
l\
O\
ll\
lOO
)
{
PhysicsJoin\
t\

&
ll\
O\
OO\
lOlO\
lOl
=
*
*
lOllllO\
lll\
OO\

;
if
(
llOOOl\
O\
lO\
lO\
l
.
Is\
Brok\
en
(
)
)
cont\
in\
ue\

;
if
(
!
(
llOOOlOl\
O\
lOl\

.
llO\
OO\
lO\
lOllO
(
)
||
llOO\
OlO\
lOlO\
l\

.
Is\
B\
ro\
k\
en
(
)
)
)
{
if\

(
llOOOlOOlO\
l\
l
<
llO\
OOlOOl\
l\
O\
O
)
{
llOO\
O\
lOO\
llO\
l
[
llOOOlOOlOl\
l\

++
]
=
&
llO\
OOlOlOlOl
;
llO\
O\
OlOlOl\
Ol
.
llOOO\
lOlOO\
OO
(
tru\
e
)
;
lOOlll\
l\
lOOl\
O
.
llO\
O\
O\
lOlOO\
lO
(
true
)
;
}
}
}
if
(
lO\
O\
l\
ll\
l\
lOOl\
O
.
Get\
Objec\
tB
(
)
)
{
llOOOlO\
Ol\
lll
=
lOOl\
llllOOlO
.
Get\
ObjectB\

(
)
->
GetJ\
o\
intIter\
at\
or
(
)
;
for
(
;
!
llOOO\
l\
OO\
llll
.
AtE\
nd
(
)
;
++
llOOO\
lOOllll
)
{
Ph\
y\
sics\
Joint
&
llOOOlOlOlO\
l\

=
*
llOOOlOOll\
ll
;
if\

(
!
(
llO\
O\
Ol\
Ol\
OlOl
.
llOO\
O\
lO\
lOllO\

(
)
||
ll\
OOOlOlOlOl\

.
Is\
Brok\
en
(
)
)
)
{
if
(
ll\
O\
OOl\
OO\
lOll
<
llOO\
O\
l\
O\
Ol\
lOO\

)
{
ll\
OOOlOOll\
Ol\

[
llOOOlOOl\
Oll
++
]
=
&
llOOOlOl\
Ol\
Ol\

;
llOOOlOl\
OlO\
l\

.
llOOOlOlOOOO
(
true
)
;
lO\
Ol\
lll\
l\
OO\
lO
.
llOO\
Ol\
O\
lOOlO
(
tru\
e\

)
;
}
}
}
lO\
l\
l\
l\
lOll\
lOO
=
lOOl\
l\
l\
l\
l\
OOlO\

.
GetOb\
jec\
tB
(
)
->
lO\
lOOll\
Ol\
OOO
(
)
;
for\

(
;
!
lO\
llll\
Olll\
OO
.
At\
End\

(
)
;
++
lOllllO\
l\
llOO
)
{
Phy\
sicsJ\
oin\
t
&
llOOOlOlOlOl
=
*
*
lOllllOlllOO
;
if
(
!
(
llOOOlOl\
OlO\
l
.
llOO\
O\
lO\
l\
OllO
(
)
||
llOOOlOlO\
lOl\

.
IsBr\
ok\
en
(
)
)
)
{
if
(
llOOOl\
OOlOll
<
llOOOlO\
O\
ll\
OO
)
{
llOOOlOO\
llO\
l\

[
llOOOlOO\
lOll\

++
]
=
&
llOOOlO\
l\
OlOl
;
llOO\
Ol\
O\
lOlOl
.
llOOOl\
O\
lOOOO
(
tr\
ue
)
;
lOOl\
l\
lllO\
Ol\
O
.
ll\
OOO\
lOlOOlO
(
fal\
se
)
;
}
}
}
}
}
if
(
llOOOlOlOOll
==
ll\
OOOlOOlOll
)
br\
ea\
k
;
}
llOOO\
OO\
Ol\
lll
=
lO\
llOl\
l\
OllOO\

.
llOOOOOl\
OO\
O\
O
(
)
;
for
(
;
!
ll\
OOOO\
OOllll\

.
At\
E\
nd
(
)
;
++
ll\
OOOOOOllll
)
{
Dyna\
micObject
&
lOl\
lllOllOOl\

=
*
*
ll\
OO\
OOO\
O\
l\
lll
;
Dy\
na\
mi\
c\
Obj\
e\
c\
t
::
Joi\
ntIterator
lOl\
O\
OlOOlO\

=
lOllllOl\
lO\
Ol
.
Get\
Jo\
int\
It\
e\
rator\

(
)
;
for
(
;
!
lOlOOlOO\
lO
.
AtEnd
(
)
;
++
lOl\
O\
O\
lOOlO
)
{
Phy\
sic\
s\
J\
oint
&
lOOlllll\
OOlO\

=
*
lOlOOlO\
Ol\
O
;
if\

(
!
(
lOOl\
l\
lll\
OOlO
.
llOOOl\
Ol\
OllO
(
)
||
lOOl\
llllO\
Ol\
O\

.
Is\
Broken
(
)
)
)
{
if
(
ll\
OOOlOO\
lOll
<
llOOOlOOllO\
O\

)
{
int
llOOO\
lO\
lO\
ll\
l
=
llOOOlO\
OlOll
;
ll\
OOOl\
OO\
l\
lOl
[
llOOOl\
OOl\
O\
ll
++
]
=
&
lOOl\
l\
ll\
lO\
O\
l\
O\

;
lOOl\
llllOOlO
.
llO\
O\
OlO\
lOOOO
(
true
)
;
whi\
le
(
ll\
OO\
OlO\
lOl\
l\
l
!=
llOOOlOOlOll
)
{
int
ll\
OOOlO\
lO\
lOO
=
ll\
OOO\
l\
OlOlll
;
llOO\
OlOlO\
lll
=
llOOOl\
O\
Ol\
Ol\
l
;
fo\
r
(
;
llOO\
O\
lO\
lOlOO\

<
llOOOlOl\
Ol\
l\
l\

;
llOOOl\
OlOlO\
O
++
)
{
Ph\
ysicsJ\
oin\
t
&
lO\
Ol\
l\
lllOO\
l\
O
=
*
llO\
OOlOO\
llOl
[
ll\
O\
OO\
l\
OlO\
l\
OO
]
;
Dyna\
m\
i\
c\
O\
bject
::
Joi\
ntIterato\
r
llO\
OOlOOllll
=
lOO\
l\
lll\
lOOlO
.
Get\
O\
bj\
e\
c\
t\
A
(
)
->
GetJ\
oi\
ntIterat\
or
(
)
;
for\

(
;
!
ll\
O\
OOlOO\
llll
.
AtEnd
(
)
;
++
llOOOl\
OO\
l\
l\
ll
)
{
Phy\
sic\
sJ\
oint
&
llOO\
OlO\
lOl\
Ol
=
*
ll\
OO\
OlOOlll\
l\

;
if
(
!
(
llOOOlOlOl\
Ol\

.
llO\
O\
OlOlOll\
O
(
)
||
llOOOlO\
l\
OlOl
.
IsBroken\

(
)
)
)
{
if
(
llOOOlOO\
lOll
<
llOOOlO\
OllOO\

)
{
llO\
OOlO\
OllOl
[
ll\
OOOlOO\
lOll\

++
]
=
&
llOOO\
l\
OlOlO\
l
;
llO\
OO\
lO\
lOl\
O\
l
.
llOOOl\
O\
lOO\
O\
O
(
tru\
e
)
;
lO\
Olll\
l\
lOO\
lO\

.
llOO\
OlOlOOlO
(
false
)
;
}
}
}
Li\
st
<
Phys\
ic\
s\
J\
oint
*
>
::
Itera\
t\
o\
r
lOllllOl\
l\
lOO
=
lOOlll\
llOOl\
O\

.
Ge\
tObj\
e\
ct\
A
(
)
->
lOlOOllOlOO\
O
(
)
;
for\

(
;
!
lOllll\
Ol\
l\
lOO
.
At\
End
(
)
;
++
lOlll\
l\
Ol\
llOO
)
{
Phy\
si\
c\
sJ\
oi\
nt
&
llOO\
OlOl\
OlOl
=
*
*
lOl\
l\
l\
lOlllO\
O
;
if
(
!
(
llOOOlOl\
OlOl
.
llO\
O\
O\
lO\
lOllO
(
)
||
ll\
O\
OOlOlOlOl
.
IsBr\
o\
ken
(
)
)
)
{
if\

(
llOOOl\
O\
OlOl\
l\

<
llO\
OOlOOl\
lO\
O
)
{
ll\
OO\
O\
lOOllOl
[
ll\
OOO\
lOOl\
Ol\
l
++
]
=
&
llOOOlOl\
Ol\
O\
l
;
ll\
OOO\
lOlOlOl\

.
llOOOlOl\
O\
OOO
(
tr\
ue
)
;
lOO\
llll\
l\
O\
OlO
.
ll\
OO\
OlO\
lOO\
lO
(
true
)
;
}
}
}
if
(
lOOl\
llllOOlO
.
GetO\
bj\
ectB\

(
)
)
{
llOOOlOOllll
=
lOOlllllOOlO\

.
Ge\
tObject\
B
(
)
->
GetJoi\
n\
tIterator
(
)
;
fo\
r\

(
;
!
llO\
OOlOOlll\
l
.
AtE\
nd
(
)
;
++
ll\
OOOlOO\
llll
)
{
Physi\
csJoint\

&
llO\
OOlOlOlOl\

=
*
llOOO\
lO\
Ollll\

;
if
(
!
(
llOOO\
lOlOlOl\

.
llOOO\
lOl\
OllO\

(
)
||
ll\
O\
OOlO\
l\
Ol\
O\
l
.
Is\
Br\
ok\
en
(
)
)
)
{
if
(
ll\
OO\
O\
lO\
Ol\
O\
l\
l
<
llO\
OOlO\
O\
llOO
)
{
llOOO\
lO\
Ol\
lO\
l
[
llOOOl\
OOlOll
++
]
=
&
llO\
OO\
lOlOlOl
;
llOOOlOl\
OlOl\

.
llO\
OO\
l\
OlOOOO
(
true\

)
;
lOO\
l\
llllOO\
lO
.
ll\
OOOlO\
lOO\
lO
(
tr\
ue
)
;
}
}
}
lOl\
lllO\
lllO\
O
=
lOO\
lllllO\
OlO
.
GetObje\
ctB
(
)
->
lO\
l\
OOllOl\
OOO
(
)
;
fo\
r
(
;
!
lOllllOlllOO
.
AtEnd
(
)
;
++
lOllll\
Olll\
OO\

)
{
Ph\
ysic\
sJoint\

&
ll\
OOO\
lOl\
OlO\
l\

=
*
*
lOll\
llOll\
lOO\

;
if
(
!
(
llOOOlO\
lO\
l\
Ol
.
llO\
OOlO\
l\
Oll\
O\

(
)
||
llOO\
O\
lOl\
Ol\
Ol
.
IsBroken
(
)
)
)
{
if
(
ll\
OO\
OlO\
OlOll
<
llOOOlOO\
llOO
)
{
llO\
OOlO\
Ol\
lOl\

[
llOOOlO\
O\
lOl\
l\

++
]
=
&
llOOOlOlO\
lO\
l
;
llOOOlOlOlO\
l
.
ll\
OOO\
lO\
lOOO\
O
(
true
)
;
lO\
O\
lll\
llOOlO
.
llOOOl\
OlOO\
l\
O
(
fa\
lse\

)
;
}
}
}
}
}
}
}
}
}
}
con\
st
in\
t\

llO\
OOlO\
llOO\
O\

=
5
;
fo\
r
(
int\

lOO\
Oll\
O\
OOl
=
0
;
lOOOllOOOl\

<
ll\
OOOlOl\
lOO\
O
;
lO\
O\
O\
llOOOl
++
)
{
fl\
oa\
t
llOOO\
lOllOOl
=
(
floa\
t\

)
lOOO\
llOOOl\

/
(
floa\
t\

)
(
ll\
OO\
O\
lO\
l\
lOOO
-
1
)
;
int
llO\
O\
OlO\
lOlO\
O
;
if
(
lOOOll\
O\
OOl
!=
0
)
{
fo\
r
(
ll\
O\
OOlOlOlOO
=
llOO\
OlO\
O\
lOll
-
1
;
llOO\
O\
l\
OlOlOO
>=
0
;
ll\
OOO\
lOl\
OlO\
O
--
)
{
PhysicsJoint
&
lO\
OlllllOOl\
O
=
*
llO\
OOlOOllOl
[
llOOOlOlO\
lOO\

]
;
llOOOlO\
llOlO
(
lO\
O\
lllllOOlO
,
fals\
e\

,
ll\
OOOlO\
llO\
Ol\

)
;
}
}
for
(
llO\
OOlOlOlOO
=
0
;
llOOOlOlOlOO
<
llO\
OO\
l\
O\
O\
lOll
;
llOO\
Ol\
Ol\
OlOO\

++
)
{
Physi\
csJ\
o\
int
&
lOOl\
lll\
lO\
O\
lO
=
*
llOOOl\
OOll\
Ol\

[
ll\
O\
OO\
l\
OlOlOO\

]
;
ll\
O\
OOlOll\
OlO\

(
lO\
Oll\
ll\
l\
OOl\
O\

,
true
,
llOOOlOllOOl
)
;
}
}
}
}
}
void\

Physics
::
llOOOlO\
l\
lOl\
O
(
Physi\
cs\
J\
oint
&
lOOlllllOOlO
,
bool
llOO\
O\
l\
OlO\
OO\
l
,
flo\
at
ll\
OO\
OlOllOOl
)
{
flo\
a\
t\

ll\
OO\
OlOllOll
=
0.0f
;
flo\
a\
t
llO\
OOl\
Ol\
ll\
O\
O
=
ll\
OO\
OlOllO\
Ol\

;
TA_ASSERT\

(
!
lOOll\
lllOOlO
.
Is\
Brok\
e\
n\

(
)
)
;
if
(
lOOl\
l\
lll\
OOlO
.
IsB\
ro\
ken\

(
)
)
return\

;
if\

(
lOOlllll\
OO\
l\
O\

.
GetType
(
)
==
PhysicsJ\
oint
::
TY\
P\
E\
_VE\
C\
T\
O\
R\
_CONS\
TRAINT
)
{
}
else
if
(
lOOlll\
l\
lO\
OlO
.
GetType\

(
)
==
Ph\
y\
sicsJ\
oint\

::
TYPE_L\
INEAR_SLIDER
)
{
}
el\
s\
e
{
TA\
_A\
SS\
ER\
T
(
lOO\
llll\
lO\
Ol\
O
.
GetObjectA
(
)
)
;
{
Dyn\
a\
m\
icObject
*
lOllO\
O\
OllOl
=
lOO\
ll\
l\
l\
lO\
Ol\
O
.
GetObject\
A
(
)
;
Dyn\
a\
m\
icO\
bj\
ec\
t
*
lOl\
lOOOlllO\

=
lO\
OlllllO\
O\
lO\

.
Get\
ObjectB\

(
)
;
Vec3\

llllOO\
OOll
=
lO\
O\
ll\
lll\
OO\
lO
.
GetPos\
OnO\
bjectA
(
)
*
lOllOOOllOl
->
GetFr\
ame
(
)
;
Ve\
c\
3
llllOOOlOO
=
lOO\
l\
ll\
ll\
OOlO
.
Ge\
tPosOnObje\
c\
tB
(
)
;
if\

(
lOllOOOlllO
)
llllOOO\
lOO
*=
lO\
ll\
OOOlll\
O
->
Ge\
tF\
ram\
e\

(
)
;
MFrame
llO\
O\
OlOlllOl
;
Vec3
lO\
lOO\
OOO\
lOl
=
ll\
l\
lOOOOll\

-
llll\
OOOl\
OO
;
float
llOO\
O\
lOllll\
O
=
0.15f
;
if
(
lO\
llO\
O\
O\
lllO
)
llOOOlOl\
lllO
*=
Mi\
n
(
lOll\
O\
OO\
lllO
->
lO\
OllO\
OOOlOO\

(
)
,
lOl\
l\
OO\
O\
llOl\

->
lOOllOOO\
OlO\
O
(
)
)
;
else\

ll\
O\
OOlO\
l\
lllO
*=
lOllOOOllO\
l
->
lO\
OllOOO\
O\
lOO
(
)
;
float
ll\
lOO\
lO\
lll\

=
lOlOOOOO\
lO\
l
.
GetMagn\
itu\
de\
Sq\
rd
(
)
;
if
(
ll\
lOOlOlll\

>
llOO\
OlO\
ll\
llO
*
llOO\
OlOlll\
lO
)
{
lOl\
OOOOOlOl
-=
lO\
lOOO\
O\
O\
lOl
*
(
llOOOlOll\
l\
l\
O\

/
Sqrt
(
ll\
lOOlO\
ll\
l
)
)
;
lO\
lOO\
OOO\
lOl
*=
ll\
OO\
Ol\
O\
lll\
OO\

;
if
(
(
lOO\
lllllOOlO
.
llOOOlOl\
llll
(
)
&&
llO\
O\
O\
l\
OlO\
OOl\

)
||
(
!
lOOll\
lllOOlO
.
llOOO\
lO\
lllll
(
)
&&
!
llO\
OOlOl\
OOOl
)
)
{
if
(
lOl\
lOO\
Olll\
O
&&
(
!
lO\
llO\
OOlllO
->
In\
finiteMass\

(
)
&&
!
lOl\
l\
OO\
OlllO
->
Mov\
em\
entDisa\
ble\
d
(
)
&&
lOllOOO\
lllO
->
Is\
InMo\
vin\
gLi\
s\
t\

(
)
&&
!
lOOl\
ll\
ll\
OO\
lO
.
IsObjectB\
Soli\
d
(
)
)
)
{
llO\
OOlOlllOl
=
lOllOOOlll\
O
->
Get\
Fra\
me
(
)
;
llOOO\
lOlllO\
l
.
v3T\
ranslat\
ion
+=
lOl\
OOOOOlOl\

;
lO\
llO\
OOlllO\

->
SetFrameD\
irec\
t
(
llOO\
O\
l\
O\
l\
l\
lOl\

)
;
}
}
el\
se
{
if
(
!
lOllOO\
OllO\
l
->
Infi\
nite\
Mas\
s
(
)
&&
!
lOll\
OOO\
llOl
->
Mo\
vementDis\
abled\

(
)
&&
lO\
llO\
OOllO\
l
->
IsInM\
ov\
ingList\

(
)
&&
!
lOOl\
l\
lll\
OOlO
.
IsObjec\
tA\
So\
l\
id\

(
)
)
{
llO\
OOlOlllOl
=
lO\
llOO\
Ol\
lOl
->
GetFrame\

(
)
;
llO\
O\
Ol\
O\
ll\
lOl
.
v3Tr\
anslat\
ion\

-=
lOlO\
OOO\
Ol\
Ol\

;
lO\
llO\
OOllOl
->
SetF\
rameDir\
e\
c\
t
(
llOO\
Ol\
OlllO\
l
)
;
}
}
}
}
}
}
vo\
id
Phy\
s\
i\
cs
::
lO\
lllOOO\
lO\
Ol
(
float
lO\
OlllOOllll\

,
bool
llOOOlO\
OO\
l\
lO
)
{
float
llOO\
OlOOO\
Oll
=
lOllOlOOOllO
(
lOOl\
llOOll\
ll\

)
;
lOlllOlOllO\
O
lO\
lO\
OlOOl\
O
=
lOllO\
lO\
llll\
O
.
lOl\
OOOO\
lOO
(
)
;
fo\
r\

(
;
!
lOlOO\
l\
OOlO\

.
AtE\
nd
(
)
;
++
lOlOOlOOlO
)
{
Dy\
nam\
i\
c\
O\
bject
&
lOllOlO\
llOlO
=
*
*
lOlOOlO\
OlO\

;
if
(
lO\
ll\
OlOll\
O\
lO
.
lOlOO\
llOOlll
(
)
)
co\
ntinue
;
lOllOlOl\
l\
OlO\

.
Ap\
p\
lyVel\
oc\
ityToNextF\
ram\
e
(
lO\
O\
l\
llOOl\
lll\

)
;
if
(
ll\
OOOlOOO\
l\
lO
)
{
lOll\
OlOllOlO\

.
ApplyNex\
tFrame
(
)
;
lOllOlOllO\
lO
.
lOl\
OOO\
lO\
O\
lll
(
lOOlll\
O\
Ollll
,
ll\
OOOl\
OOOOll
)
;
fl\
oat
llOlOllOOO\
O
=
lOl\
lOlOllOlO
.
GetR\
es\
tTimeM\
u\
lti\
plier
(
)
;
llOlOllOO\
OO
=
llOlOllOOO\
O
*
ll\
OlOllO\
OOO
;
flo\
at
llO\
OOlOOO\
lOl
=
ll\
O\
lOllOO\
O\
O
;
llOlOll\
OOO\
O
*=
lOlllOOlOOOO
*
(
1.0f
/
9.81f
/
9.81f
)
;
float
ll\
O\
OOllOOO\
O\
O\

=
(
lO\
OlllOOllll\

*
lOOlllO\
Olll\
l
)
;
if
(
(
lOllOlOl\
lO\
lO
.
Get\
L\
in\
ear\
Velocity
(
)
.
Ge\
tM\
a\
g\
nitu\
d\
eSqrd
(
)
<
lOl\
l\
O\
O\
l\
lll\
l\
l
*
ll\
Ol\
OllOOOO
&&
lO\
l\
lO\
lOllO\
l\
O\

.
GetAn\
g\
ularV\
e\
loci\
ty
(
)
.
Ge\
t\
M\
a\
gni\
t\
u\
deSqrd
(
)
<
lOl\
lOlOO\
OO\
OO
*
llOOOlO\
O\
O\
lOl
)
||
(
lOllOlOllO\
lO
.
lO\
lOOl\
llOllO\

(
)
.
GetMag\
nit\
udeSqrd
(
)
<
lOl\
lOOllllll
*
0.2f
*
llOO\
Ol\
lOOO\
O\
O
*
llOlOllO\
OO\
O
&&
lO\
llO\
lOllOlO
.
lO\
lOOlllOlll\

(
)
.
GetMagni\
t\
u\
deSq\
rd
(
)
<
lOllOlO\
O\
OOOO
*
0.2f
*
ll\
O\
OOllOOOOO\

*
llOOO\
l\
OO\
OlO\
l
)
)
{
lO\
llOlOl\
lOlO
.
lOlO\
Ol\
OOOll\
l\

(
lO\
Ol\
l\
l\
O\
Ol\
lll\

)
;
}
els\
e\

{
lOll\
OlOllOlO
.
lO\
Ol\
llOOlll\
O
(
)
;
}
if
(
lOllOl\
Oll\
OlO
.
lOlO\
O\
l\
O\
O\
Ol\
Ol
(
)
>
lO\
llO\
Oll\
l\
l\
l\
O\

)
lOll\
OlO\
ll\
O\
l\
O
.
lOlOOl\
OlOOO\
l
(
true
)
;
}
}
}
vo\
i\
d
Phy\
s\
ics\

::
lO\
lll\
O\
OOOl\
Ol
(
lO\
l\
Ollll\
OOOO
&
lOllOllO\
l\
l\
O\
O\

,
lOll\
OlOOOlll\

*
lOlllOOOOl\
OO
,
in\
t
ll\
OO\
Ol\
l\
OOOO\
l
)
{
Ve\
c3
llOOO\
llOO\
OlO\

=
Ge\
t\
Gra\
vity
(
)
;
float\

llO\
O\
OllOOOll
=
lOl\
ll\
OO\
lOOO\
O\

;
llOOOll\
OO\
Ol\
l\

*=
0.2f
;
ll\
OOO\
ll\
OOOlO
.
x
+=
Rand\
Func
::
TaRandB\
et\
wee\
nPosNeg\

(
llO\
OOllOO\
Ol\
l
)
;
ll\
OO\
Ol\
lOOOlO
.
y
+=
Ra\
ndF\
unc
::
TaRa\
ndB\
etw\
eenPosNeg\

(
llO\
OOllOO\
O\
ll\

)
;
llOOOllO\
O\
OlO
.
z
+=
Ra\
n\
dFunc
::
TaR\
a\
ndBe\
twe\
enP\
o\
sNeg
(
llOOO\
llOO\
Oll
)
;
int\

lOll\
lOOOO\
Ol\
l
=
0
;
lOlOllllOOOO
::
Iterator
lOlOlll\
OOOlO
=
lOllOllO\
llO\
O
.
lO\
lOOOO\
lOO\

(
)
;
for\

(
;
!
lOlOll\
lOO\
OlO
.
AtEn\
d
(
)
;
++
lOlOlllOOOlO
)
{
Co\
llisi\
o\
n
*
ll\
O\
ll\
O\
lOll\
l
=
&
*
lO\
lOlllOOOl\
O\

;
fo\
r
(
;
ll\
OllO\
l\
Olll
;
llOll\
OlO\
lll
=
llOll\
OlO\
lll
->
Get\
Next
(
)
)
{
TA_ASSERT
(
lOlll\
OOOO\
O\
ll
<
llOOOllOOOOl\

)
;
Collis\
i\
on\

&
ll\
Oll\
ll\
Olll
=
*
llOllOl\
Ol\
ll
;
lOllOlO\
O\
Olll\

&
lO\
OlOOl\
ll\
lO
=
lOlllO\
OOOlOO
[
lOl\
l\
lO\
OOOOll\

++
]
;
lO\
OlOO\
llllO
.
llOllOl\
Olll
=
llOll\
OlOl\
l\
l
;
lO\
OlOOlll\
lO
.
lOO\
OlOO\
llO
=
-
ll\
OO\
Oll\
O\
OOlO
.
Do\
t
(
ll\
O\
llll\
Olll\

.
lOOOOlll\
ll
)
;
}
}
TA_AS\
SERT
(
lOll\
l\
O\
OOOOll
==
llOO\
OllOO\
OO\
l
)
;
}
vo\
i\
d
Physics
::
lOll\
O\
lll\
llOl
(
lOlO\
l\
lllOOO\
O
&
lOllOllOl\
l\
OO
,
Dynam\
i\
c\
Ob\
ject
*
*
lOllOllllOl\
l\

,
in\
t
&
lOllOllllOOO
,
int\

lOllOllllOO\
l
,
Collis\
ion
*
*
lOl\
lOl\
l\
lll\
O\
O
,
int
&
lO\
l\
l\
OlllOlOl\

,
in\
t\

lOl\
l\
O\
lllOll\
O\

)
{
lOOlllOO\
Oll
(
lO\
lOOO\
OOO\
ll\
l\

*
,
llOOOl\
lOOl\
OO
,
lOOll\
O\
llllO\
O
->
lOlO\
llllOlOl
)
;
in\
t
ll\
OOOllOOlOl
=
0
;
lOlOll\
l\
lOOOO
::
lO\
l\
ll\
lO\
Ol\
OOO
lOl\
lllO\
Ol\
OO\
l
=
lOl\
lO\
l\
l\
OllO\
O
.
lOlll\
lOOl\
OlO
(
)
;
fo\
r
(
;
!
lOlll\
lOOlOOl\

.
At\
End\

(
)
;
++
lO\
llllO\
O\
lO\
Ol
)
{
TA_AS\
SER\
T
(
ll\
OO\
Ol\
lO\
OlOl\

<
lO\
O\
ll\
Oll\
l\
lOO
->
lO\
lOl\
lllOlOl\

)
;
lOlOOOO\
O\
Olll
&
lOlOOO\
OlllOO
=
*
lOllllOOlOO\
l\

;
TA_ASS\
ERT
(
lOl\
OO\
O\
Olll\
OO
.
lOlO\
OOOO\
llOl
)
;
TA_A\
S\
SERT\

(
lOlO\
O\
OO\
lllOO
.
lO\
lO\
O\
OOOlll\
O
)
;
co\
nst
u32\

llO\
OOll\
O\
OllO
=
~
(
Dy\
namic\
Ob\
je\
ct\

::
lOlOO\
lOl\
O\
Oll
|
Dyna\
m\
ic\
O\
bject\

::
lOlOOlOl\
Oll\
O\

|
Dy\
na\
micObject
::
lO\
lOO\
lOll\
OOl
)
;
if
(
lOlOOOOlllOO
.
lO\
lO\
OOOOl\
lOl\

->
lOlOOl\
lOOl\
l\
l
(
)
==
&
lOll\
Oll\
O\
llOO
)
lOlOOOOl\
ll\
O\
O
.
lOlOO\
OOO\
llOl
->
lOlOO\
llOO\
OOO
(
)
&=
llOO\
OllOO\
llO
;
if
(
lOl\
OOOOll\
lOO
.
lO\
lOOOO\
Ol\
llO
->
lO\
lOOl\
l\
OOlll
(
)
==
&
lOl\
lO\
llO\
l\
lOO
)
lOlO\
OOOl\
llOO
.
lOlOOOO\
Ol\
llO
->
lOl\
O\
O\
l\
l\
OOOOO
(
)
&=
llO\
OOll\
O\
O\
llO
;
ll\
OO\
OllOOl\
OO\

[
llO\
OO\
llO\
OlO\
l
++
]
=
&
lOlOOOOl\
llOO
;
}
#ifdef _DEBUG
if\

(
lO\
O\
l\
OOOllO
)
{
lOlOl\
l\
llOOOO\

::
lOllllO\
Ol\
OOO
llOOOl\
lOOl\
l\
l\

=
lO\
ll\
O\
llOllOO
.
lOl\
lllO\
O\
lO\
l\
O\

(
)
;
fo\
r
(
;
!
ll\
OO\
O\
llOOlll
.
At\
En\
d
(
)
;
++
llO\
OOllOOll\
l
)
{
lOlOOOOOOlll
&
ll\
OOO\
l\
l\
OlOOO
=
*
ll\
OO\
Ol\
lOOlll
;
lOlO\
llllOOO\
O\

::
lO\
ll\
llO\
O\
l\
O\
O\
O
llOOOllOlO\
Ol
=
lOllOllOllOO
.
lOl\
lllOOlO\
lO\

(
)
;
for
(
;
!
llOOOl\
l\
O\
lOO\
l
.
At\
End
(
)
;
++
ll\
OOO\
llOl\
OOl
)
{
lOlOOOOOOlll
&
llO\
OOllOlOlO\

=
*
llOOOllOlOO\
l\

;
if
(
&
llOOO\
l\
lOlOOO
==
&
llOO\
OllOlOlO
)
co\
ntinue
;
TA_ASSERT
(
(
llO\
OOllOlOOO
.
lO\
lOOOO\
O\
l\
lOl
!=
llOO\
OllOlOlO
.
lOlOOOOOll\
O\
l
||
llOOOllO\
lOO\
O
.
lOl\
OO\
OOOll\
lO
!=
llO\
O\
Ol\
lO\
lO\
lO
.
lO\
lO\
OOO\
Oll\
l\
O
)
&&
(
llOO\
OllOlO\
OO\

.
lOlO\
OO\
OOl\
lOl
!=
ll\
OO\
OllO\
lO\
lO\

.
lOl\
OO\
OOOlllO
||
llOO\
Ol\
lOl\
OO\
O
.
lO\
lOOO\
OO\
l\
l\
l\
O\

!=
llOOOllOlOl\
O
.
lOlOO\
OOOl\
lO\
l
)
)
;
}
}
}
#endif //
for
(
;
;
)
{
bo\
ol\

llO\
lOO\
lO\
ll
=
false\

;
in\
t\

llOOOllOlOll
=
lOll\
Ol\
lllO\
OO
;
int
llOOO\
ll\
OllOO
;
for
(
llOOO\
llO\
l\
l\
OO\

=
0
;
llOO\
Ol\
lO\
l\
lOO
<
llOOOllOOlOl
;
llO\
OO\
llOl\
lOO
++
)
{
if\

(
llOO\
O\
llOOlO\
O
[
llO\
O\
OllOll\
OO
]
==
0
)
con\
tinue
;
lOlOOOOO\
Olll\

&
lOlOOO\
OlllOO
=
*
llO\
O\
OllOO\
lOO
[
ll\
OOO\
l\
lOllO\
O\

]
;
TA\
_A\
S\
SERT\

(
lO\
l\
OOO\
Ol\
l\
lOO
.
lOlOOOOOllOl
)
;
u32
llOOO\
l\
lOllOl\

=
Dyna\
m\
icObje\
ct\

::
lOlOOlOllOO\
l
|
Dy\
na\
micO\
bject
::
lOOlllOOlOll
|
Dyna\
micObj\
ect\

::
lOOlllOOl\
OO\
l\

|
Dyn\
am\
icObje\
ct\

::
lOlOOlO\
Olll\
O
;
if
(
(
lO\
l\
O\
OO\
OlllO\
O
.
lO\
lOOOO\
OllOl
->
GetFlags
(
)
&
llOOO\
llOllOl
)
==
Dynamic\
Ob\
ject
::
lOlOO\
lOO\
l\
llO
||
(
lOlO\
OO\
O\
ll\
l\
O\
O\

.
lOlOOOOOl\
llO\

->
Ge\
t\
F\
la\
gs\

(
)
&
llOOOllOl\
lOl
)
==
Dy\
namic\
Obje\
ct
::
lOlOOl\
OOll\
l\
O
)
{
if\

(
(
lO\
lOOOOl\
ll\
OO\

.
lOl\
OOOOO\
l\
lOl
->
Get\
Flags
(
)
&
llOO\
O\
ll\
OllOl
)
==
Dynami\
cObject
::
lOl\
OOl\
OOlll\
O
&&
(
lO\
lOOO\
Olll\
OO
.
lOlO\
OOOOll\
l\
O
->
GetF\
lags\

(
)
&
llOOO\
llOl\
l\
Ol\

)
==
DynamicObject\

::
lO\
lOOl\
OOl\
llO\

)
co\
n\
tinue
;
llO\
OOll\
OOlOO
[
llOOO\
llO\
ll\
O\
O\

]
=
0
;
lOlO\
OO\
OOOlll
::
Collis\
i\
onItera\
tor\

lOl\
Oll\
lO\
O\
OlO
=
lOlOO\
O\
Olll\
OO
.
lOlOlll\
OOlOl
.
lOl\
OO\
OOlO\
O\

(
)
;
if
(
!
lOlOlllO\
OOl\
O
.
AtEn\
d
(
)
)
{
ll\
O\
lOOl\
O\
ll
=
tr\
ue\

;
if\

(
(
lO\
lO\
OOOl\
llO\
O
.
lO\
lOOOOOl\
l\
Ol\

->
Get\
Fl\
ags
(
)
&
(
Dyn\
am\
i\
cO\
bje\
ct
::
lOlOOlOl\
O\
llO
|
Dynami\
cOb\
ject
::
lO\
l\
OOlO\
ll\
OO\
l
)
)
==
0
)
{
if\

(
lOlOOOOlll\
O\
O
.
lO\
lO\
OOO\
O\
llOl\

->
lOl\
OO\
l\
lOOl\
ll
(
)
==
(
void
*
)
&
lOl\
lOllOllO\
O
)
{
TA_AS\
SERT
(
lOllOll\
l\
lOOO\

<
lO\
llOlll\
lOOl
)
;
lO\
l\
lOll\
llO\
ll
[
lO\
llOll\
ll\
O\
OO
++
]
=
lOl\
O\
OOOl\
ll\
OO\

.
lOlO\
O\
OOOl\
lOl\

;
lOlOOOOll\
lO\
O\

.
lOlOOOOOllOl
->
lO\
l\
OOlOlOl\
Ol
(
tr\
u\
e\

)
;
}
}
if
(
(
lO\
lOOOOlll\
OO
.
lOlOOOOOl\
llO\

->
Ge\
tF\
l\
ag\
s\

(
)
&
(
Dyna\
micOb\
je\
ct
::
lOl\
O\
OlOlO\
llO
|
Dynami\
c\
O\
bje\
c\
t
::
lO\
lOOlOll\
OOl
)
)
==
0
)
{
if
(
lOlOO\
OOl\
ll\
OO
.
lOlOO\
O\
OOlllO
->
lOlO\
O\
llOOl\
ll
(
)
==
(
voi\
d\

*
)
&
lOl\
lOl\
l\
O\
llOO
)
{
TA_AS\
SERT
(
lOllOll\
llOO\
O
<
lO\
llOllll\
OO\
l
)
;
lO\
llOllllO\
ll
[
lO\
l\
lOllll\
O\
OO
++
]
=
lOlOO\
OOlll\
OO
.
lOlOOO\
OO\
lllO\

;
lOl\
O\
OOOll\
lOO
.
lOlOOO\
O\
O\
l\
llO\

->
lOlOOlOlO\
l\
Ol
(
true
)
;
}
}
}
for
(
;
!
lOlOlllOOO\
lO
.
AtE\
nd
(
)
;
++
lOlOl\
ll\
OOOlO
)
{
TA_ASSE\
RT
(
lO\
ll\
Ol\
llO\
l\
Ol\

<
lOllOll\
l\
Ol\
lO
)
;
Collision
&
llOl\
lllOlll
=
*
lO\
lO\
lllOOOlO
;
lOll\
O\
l\
ll\
l\
lO\
O\

[
lOllO\
l\
llOlOl
++
]
=
&
llO\
ll\
l\
lOl\
l\
l\

;
TA\
_A\
S\
SE\
R\
T
(
llOllll\
O\
l\
l\
l
.
Get\
ObjectA
(
)
!=
llOlll\
lOlll
.
GetObject\
B
(
)
)
;
TA_A\
S\
SERT\

(
llOl\
lllOlll\

.
Get\
O\
bjectA\

(
)
==
lOlO\
OO\
Oll\
lOO
.
lO\
lOOOOOl\
lO\
l\

||
llO\
lll\
lOlll
.
Ge\
tOb\
jec\
tB
(
)
==
lO\
lOOOOlllO\
O
.
lOlOOOOOl\
lOl
)
;
TA\
_ASS\
E\
RT
(
llOl\
lllO\
lll
.
Ge\
tObjec\
tA\

(
)
==
lO\
l\
OO\
OOlllOO
.
lO\
lOO\
OOOlllO
||
llOll\
ll\
Olll
.
GetOb\
j\
e\
ctB\

(
)
==
lOl\
OOOO\
ll\
l\
OO
.
lOlOOOOO\
ll\
lO
)
;
}
}
}
for
(
ll\
OOOll\
O\
ll\
OO\

=
0
;
llOOOllOllOO
<
llOOO\
llOOlOl
;
ll\
OOOllOllOO
++
)
{
if
(
llOOO\
l\
l\
OOlOO
[
llO\
OO\
llOllOO
]
==
0
)
contin\
u\
e
;
lOlOOOO\
OOl\
ll
&
lOlOOOOll\
lOO\

=
*
llOO\
Oll\
O\
OlOO
[
ll\
OOOl\
lO\
llOO
]
;
u32\

ll\
OOOl\
l\
OllOl
=
Dyn\
amicObject
::
lOlOOlOlOllO
;
if
(
(
(
lOlO\
O\
OOl\
l\
lOO
.
lOl\
OOO\
OOllOl
->
GetFlags
(
)
&
ll\
OOO\
llOll\
O\
l
)
||
lOlOOOOlll\
OO
.
lOl\
OOOOOllOl
->
lOl\
OOllOOl\
ll
(
)
!=
(
void
*
)
&
lOllOllOllOO\

)
&&
(
(
lOlOOOOll\
lOO\

.
lOl\
OOOOOl\
ll\
O\

->
GetF\
lags\

(
)
&
ll\
O\
O\
OllO\
ll\
Ol
)
||
lOlO\
OOOlll\
OO
.
lO\
l\
OOO\
O\
Ol\
l\
lO
->
lOlO\
OllOOll\
l
(
)
!=
(
voi\
d
*
)
&
lOl\
lOll\
OllOO\

)
)
{
lO\
lOOO\
OOOl\
ll
::
Collis\
i\
on\
Iterato\
r
lOlOl\
llOOOl\
O
=
lOlOOO\
OlllOO
.
lOl\
Oll\
lO\
OlO\
l
.
lO\
l\
O\
O\
OOlOO
(
)
;
fo\
r
(
;
!
lOlOlll\
OOOlO\

.
AtEnd
(
)
;
++
lOl\
Oll\
lOOOl\
O
)
{
TA\
_\
A\
SS\
ER\
T
(
lO\
llOlll\
OlOl
<
lOll\
Ol\
llO\
l\
lO
)
;
Collision
&
ll\
Ol\
lllOlll
=
*
lO\
lOll\
lOOOlO
;
lOllOlllllO\
O\

[
lOl\
lO\
lllOlOl
++
]
=
&
llO\
llllOlll
;
TA_A\
SSERT
(
llO\
lll\
lOlll\

.
Get\
Ob\
je\
ctA\

(
)
!=
ll\
O\
ll\
llOlll\

.
GetO\
bjec\
tB
(
)
)
;
TA\
_\
AS\
SERT
(
llOl\
lllO\
l\
ll
.
GetObje\
ctA
(
)
==
lOlOOOOlllOO
.
lOlOOO\
O\
Oll\
Ol\

||
llOl\
lllO\
lll
.
GetObje\
ctB
(
)
==
lOlOOOO\
lll\
OO\

.
lOl\
OOOOOllOl
)
;
TA_\
AS\
SE\
R\
T\

(
llOlll\
l\
Ol\
ll\

.
Ge\
tO\
bject\
A
(
)
==
lOlOOOO\
ll\
lOO\

.
lOl\
OOOOO\
lll\
O
||
ll\
Ol\
l\
llOll\
l
.
GetOb\
j\
ectB
(
)
==
lOlOOOOlllO\
O
.
lOlOO\
OO\
Ol\
l\
l\
O
)
;
}
}
}
fo\
r\

(
int\

lOOOl\
lO\
OOl\

=
llOOOllOlOll\

;
lO\
OO\
llOO\
O\
l
<
lOllO\
l\
lllOOO
;
lOOOllO\
OOl
++
)
{
TA_ASSE\
RT
(
lOll\
O\
ll\
llO\
ll
[
lOO\
Oll\
OOOl
]
)
;
TA\
_A\
SS\
ERT\

(
lO\
llOll\
llO\
ll
[
lOOO\
llO\
OOl
]
->
lOlO\
O\
lOlOl\
l\
l\

(
)
)
;
lOllOlll\
l\
O\
ll
[
lO\
OOllOOOl\

]
->
lOlOO\
lO\
l\
lOOO
(
true
)
;
lOl\
l\
OllllO\
ll
[
lOO\
O\
llOOOl
]
->
lOlOO\
l\
OlO\
l\
Ol
(
fa\
lse
)
;
}
llOOOl\
lOlOll
=
lO\
ll\
OllllOOO
;
TA_ASSERT
(
lOll\
Olll\
lOOO
<
lO\
llOllllOO\
l
)
;
lO\
l\
lOllll\
O\
l\
l
[
lOl\
lOlll\
lO\
OO\

++
]
=
0
;
TA\
_AS\
SERT
(
lOllO\
l\
llOlOl
<
lO\
ll\
OlllOllO\

)
;
lOllOlllll\
O\
O
[
lOl\
lOl\
llOlO\
l
++
]
=
0
;
if\

(
!
llOlOOlO\
ll\

)
break\

;
}
}
void
Physics
::
lOlllOO\
O\
OO\
Ol
(
Dy\
na\
m\
ic\
Ob\
j\
ect\

*
*
lOl\
lOll\
ll\
Ol\
l
,
int\

lO\
l\
lOllllOOO\

,
Collision
*
*
lO\
llO\
l\
ll\
l\
lOO
,
int
lOllOlllOlOl
)
{
floa\
t
lOOll\
l\
OOll\
ll
=
lOOll\
Ol\
lllOO\

->
lOlOll\
lllOOO
;
int
llOOOl\
OllOO\
O
=
4
;
lO\
OlOl\
l\
l\
lllO
=
1.0f
;
fo\
r
(
int
lO\
Ol\
OOlOlO
=
0
;
lOO\
lOO\
lOlO
<
llOOO\
lOllOOO
;
lOOlOOlOlO
++
)
{
if\

(
lOO\
lOO\
lO\
l\
O
<
llOOOlOllO\
OO
>>
1
)
{
for
(
int\

lOOOll\
OOOl
=
lOl\
lOlllOlO\
l
-
1
;
lOOOllOOO\
l
>=
0
;
lOOOllOO\
Ol
--
)
{
#ifdef lOllOOlOOOOO
if
(
lOOO\
llOOO\
l\

>=
3
)
{
co\
nst
Coll\
i\
s\
ion
*
llO\
OOllO\
lllO
=
lO\
llOllll\
lOO
[
lOOOllO\
OOl
-
3
]
;
if
(
llOO\
O\
ll\
Olll\
O
)
{
lOllO\
O\
lOO\
lOl
(
&
ll\
OOOllO\
lllO\

->
lOO\
OOlll\
ll
)
;
}
const\

Co\
llision\

*
ll\
O\
OOllO\
llll
=
lO\
ll\
O\
ll\
ll\
lOO
[
lOOOl\
l\
OO\
Ol
-
2
]
;
if\

(
ll\
OO\
OllO\
llll\

)
{
lOl\
lOOlOO\
lOl\

(
&
llOO\
Oll\
O\
llll
->
lO\
llOO\
OllOl
)
;
lOllOOlO\
OlOl
(
&
ll\
OOOllOl\
lll
->
lO\
llO\
OOlll\
O\

)
;
}
const
Col\
lision
*
llOOOlllOOO\
O
=
lOllOl\
lll\
lOO
[
lOOOllOO\
Ol
-
1
]
;
if
(
llOO\
Olll\
OOO\
O\

)
{
lO\
ll\
OOlOOOOl\

(
&
llOO\
O\
lllOOOO
->
lOllOOOllOl\

->
Ge\
tC\
enterOffset\

(
)
)
;
lOllOOl\
OOOO\
l\

(
&
llO\
OOlllO\
O\
OO\

->
lO\
llOO\
OlllO
->
GetC\
e\
n\
t\
erOf\
fse\
t
(
)
)
;
}
}
#endif //
if
(
!
lOl\
lOll\
l\
llOO
[
lOOOllOOOl
]
==
0
)
{
Coll\
i\
sion
*
llO\
llOlOl\
l\
l
=
lO\
ll\
Ol\
llll\
OO
[
lOO\
O\
l\
lO\
OOl
]
;
int
llOll\
OO\
ll\
l
=
(
ll\
O\
llOl\
O\
lll\

->
lOlOllO\
Oll
&
Col\
lis\
ion
::
FLA\
G_JOI\
N\
T
)
?
lOl\
lOlO\
O\
OOOl
:
1
;
for\

(
in\
t\

lOOlOO\
lOlO
=
0
;
lOOlO\
OlOl\
O
<
llOllOOlll
;
lOOlOOl\
OlO
++
)
{
Co\
ll\
is\
ion
*
llOl\
lOlOlll
=
lOll\
Oll\
lllOO\

[
lOO\
OllOOOl
]
;
for
(
;
ll\
O\
llOlOll\
l
;
llOllOlOll\
l
=
llOll\
OlOll\
l\

->
Ge\
t\
Next
(
)
)
lO\
lOOOlll\
l\
Ol
(
lO\
l\
OOl\
OO\
OOlO
(
lOOlllOOllll
,
*
llOl\
lOl\
Ol\
ll\

)
,
*
llOllOlOlll
)
;
}
}
}
}
for
(
int
lO\
OOllOO\
Ol
=
0
;
lOOOl\
lO\
OOl
<
lOll\
Ol\
ll\
OlO\
l
;
lO\
OO\
l\
lO\
O\
Ol\

++
)
{
#ifdef lOllOOlOOOOO
if\

(
lOOOl\
lOOOl
<
lOllOlll\
OlO\
l
-
3
)
{
cons\
t\

Co\
ll\
ision
*
llO\
OOllOlllO
=
lOll\
Olllll\
OO
[
lOOOll\
O\
O\
Ol\

+
3
]
;
if\

(
llOOOllO\
l\
ll\
O
)
{
lOllOOl\
OOlOl
(
&
ll\
OOOllO\
l\
ll\
O\

->
lOO\
OOllll\
l
)
;
}
con\
st\

Collisio\
n
*
llO\
OO\
llO\
ll\
ll
=
lO\
llOlllllOO
[
lOOOll\
O\
OO\
l
+
2
]
;
if
(
ll\
O\
O\
O\
l\
lO\
l\
l\
ll\

)
{
lOll\
OOl\
O\
O\
l\
Ol\

(
&
llOOO\
llOl\
l\
l\
l
->
lOll\
O\
OOllOl\

)
;
lOllO\
OlOOlOl
(
&
llOOOl\
lOllll
->
lOll\
O\
OOll\
lO
)
;
}
co\
nst
Co\
llision
*
llOOOl\
llOO\
O\
O
=
lOllO\
ll\
ll\
lOO
[
lO\
OOllOOO\
l\

+
1
]
;
if
(
llOO\
O\
l\
l\
l\
OO\
O\
O
)
{
lOl\
lOO\
lOO\
OO\
l\

(
&
llO\
OOl\
l\
l\
OOOO
->
lO\
ll\
O\
OOl\
lO\
l
->
GetC\
en\
ter\
Of\
fset
(
)
)
;
lO\
llOO\
lOOOOl
(
&
ll\
OOOlllOO\
O\
O
->
lOllOOOll\
lO
->
GetCenterOf\
fset
(
)
)
;
}
}
#endif //
if
(
!
lOll\
O\
lllllO\
O
[
lOO\
O\
llO\
OOl
]
==
0
)
{
Collis\
i\
on
*
llO\
llOlOlll
=
lOllOlllll\
O\
O
[
lOOOllOO\
Ol
]
;
int
llOllOOlll
=
(
llOllO\
lOll\
l
->
lOlOllOOll\

&
Co\
l\
lision
::
FL\
AG_JOINT\

)
?
lOllOl\
OO\
OOOl\

:
1
;
fo\
r
(
in\
t
lOOlOOlO\
lO
=
0
;
lO\
OlOOlOlO\

<
llOllOOlll
;
lO\
OlOO\
lOl\
O
++
)
{
Colli\
sion\

*
ll\
OllOl\
Olll\

=
lO\
llO\
l\
lll\
lOO
[
lOOOllOO\
Ol
]
;
for
(
;
llOl\
lOlOlll\

;
llOllOl\
Ol\
l\
l
=
llOll\
OlOlll
->
GetNe\
xt
(
)
)
lO\
lOO\
OllllO\
l\

(
lOlOOlOOOOlO\

(
lOOlllOO\
l\
lll
,
*
llOllOlOll\
l
)
,
*
llOllOlO\
lll
)
;
}
}
}
}
}
void
Ph\
y\
sics
::
lOlll\
OOOOO\
lO\

(
lOlO\
llllOO\
O\
O
&
lO\
l\
lO\
llOllOO
,
Dyna\
mi\
cObj\
ect\

*
*
lOl\
l\
Ollll\
Oll\

,
int
lOllO\
ll\
ll\
OOO
,
Co\
llisio\
n
*
*
lOllOl\
l\
lllO\
O
,
int
lO\
llOll\
l\
O\
lOl\

)
{
co\
nst\

float
ll\
OO\
O\
l\
ll\
OOOl
=
1.0f
;
float
lOOlllOOl\
lll
=
lOOllOllll\
OO
->
lOl\
Ollll\
lOOO\

;
int\

llOOOl\
llOOl\
O\

=
0
;
cons\
t
fl\
oa\
t
llOlllOOOl
=
0.4f
;
int
llOOOlllOOll\

=
0
;
co\
nst
int\

llOOOlO\
ll\
OO\
O
=
1
;
int
lOO\
lOOlOOO
=
0
;
in\
t
lOl\
O\
OOllO\
l
=
0
;
fo\
r\

(
int
lOOOllOOO\
l
=
0
;
lOOOllOOOl\

<
lOll\
O\
ll\
l\
Ol\
Ol
;
lOOO\
ll\
OOOl\

++
)
{
if
(
lOllOl\
l\
ll\
lO\
O\

[
lOOOllOOOl
]
==
0
)
{
llOOOl\
l\
l\
O\
O\
ll
++
;
if
(
ll\
OOO\
lllOO\
ll
<
llOOO\
lOllOOO
)
{
lOOOl\
lOOOl
=
lOOlO\
Ol\
O\
OO
;
}
else
{
llOOOll\
lOOll
=
0
;
for\

(
;
ll\
OOOlllOO\
lO
<
lOllO\
l\
l\
ll\
OO\
O
&&
lOll\
O\
ll\
llOll
[
llOOO\
lllOOlO
]
;
ll\
O\
OOll\
l\
O\
O\
l\
O
++
)
{
TA_\
ASS\
ER\
T\

(
!
lO\
llOll\
ll\
Oll
[
llO\
OOlll\
O\
OlO
]
->
lO\
lOOl\
OlOl\
OO
(
)
)
;
lOllO\
llll\
Oll\

[
llOOOl\
llO\
O\
lO
]
->
lOlOOlOlOO\
lO
(
true
)
;
}
lO\
lOOOl\
lOl
++
;
llO\
OO\
lllOOlO
++
;
lOOlOOlOO\
O
=
lOOO\
llOOOl\

+
1
;
}
}
else
{
Collisio\
n
&
llOll\
ll\
O\
lll
=
*
lOl\
lOl\
llllOO
[
lO\
OOllOOOl
]
;
if
(
!
llOl\
lllO\
l\
ll
.
Ge\
tO\
bj\
ect\
A
(
)
->
lOlOOlO\
lOl\
OO
(
)
||
!
llOl\
ll\
lO\
l\
ll\

.
GetObject\
B
(
)
->
lOlOOlOlO\
lOO
(
)
)
{
int
llOll\
O\
Olll
=
(
ll\
Ollll\
O\
l\
l\
l
.
lOlO\
ll\
OOll
&
Co\
llisio\
n
::
FLAG_JO\
INT
)
?
lOl\
l\
OlOO\
O\
OO\
l
:
1
;
for
(
int
lOOlOOlOlO
=
0
;
lOOl\
OOlOlO\

<
ll\
OllO\
Olll
;
lOO\
lOOlOlO
++
)
{
Collisio\
n\

*
ll\
OllO\
lOlll
=
&
llOl\
lllO\
lll
;
fo\
r
(
;
llOllO\
lOl\
ll
;
llOllOlOlll\

=
llOllOlOlll
->
GetN\
ext\

(
)
)
{
lOlO\
OOll\
l\
llO
(
lOl\
OOlO\
O\
O\
Ol\
O\

(
lO\
OlllO\
Ollll
,
*
llOllOlO\
lll
)
,
llO\
lllO\
OOl
,
1.0f
,
*
llOllOlOl\
ll
)
;
}
}
}
el\
se
{
#ifdef _DEBUG
if
(
lOOlOO\
OllO
)
{
bo\
ol
llO\
OOlll\
Ol\
OO
=
false\

;
bool
llOOOlllO\
lOl\

=
!
llOllll\
Olll
.
lOllOlOl\
Ol\
l
(
)
;
for
(
int\

lOOlOOlO\
lO
=
0
;
lOO\
lO\
OlO\
l\
O
<
ll\
OOOlllOOl\
O
;
lOOlOOlOl\
O
++
)
{
if\

(
llOl\
lllOl\
ll\

.
lOll\
OOOl\
lO\
l
==
lOl\
lOlll\
l\
Oll
[
lO\
Ol\
OOlOlO
]
)
llO\
OOll\
l\
OlOO
=
tru\
e\

;
if
(
llOllllOll\
l\

.
Get\
Ob\
je\
ctB\

(
)
==
lOl\
lO\
ll\
llOll
[
lOOlOOl\
OlO
]
)
ll\
OOOll\
l\
Ol\
Ol
=
true
;
}
TA\
_ASS\
ERT
(
llO\
OOl\
llOlO\
O\

)
;
TA\
_ASSERT
(
ll\
OOOll\
lOlOl
)
;
}
if\

(
lOOlOOOllO
)
{
bool
llOOO\
lllOlOO\

=
false\

;
bo\
ol
llOOO\
lllO\
lOl
=
!
llO\
l\
lll\
O\
ll\
l
.
lO\
llOl\
OlOll\

(
)
;
for
(
int
lO\
OlOOlOl\
O
=
llOOO\
lllOOlO
;
lOOl\
OOl\
OlO
<
lOllOllllOOO
&&
lO\
llO\
lll\
lOl\
l
[
lO\
OlOO\
lO\
lO
]
;
lOOlOOlOlO
++
)
{
if
(
ll\
Olll\
l\
Olll
.
lOllOOOl\
lO\
l
==
lOllOllll\
Ol\
l\

[
lOO\
l\
OO\
lO\
lO\

]
)
llOOOlllOlOO\

=
tru\
e
;
if\

(
ll\
O\
llllOl\
ll
.
GetObj\
ectB\

(
)
==
lOllOl\
lllOl\
l\

[
lOO\
lOOlOlO\

]
)
llO\
OOl\
l\
lO\
lOl
=
true
;
}
TA\
_\
ASS\
ER\
T
(
llO\
OOlllOlOO
)
;
TA_ASSERT
(
llOOOl\
ll\
OlOl
)
;
}
#endif //
TA_AS\
SERT
(
0
)
;
}
}
}
}
void\

Ph\
ysi\
cs\

::
lOlll\
OO\
O\
OllO\

(
lO\
ll\
OlO\
OOll\
l\

*
lO\
lllO\
O\
O\
OlOO\

,
in\
t
lOlllOO\
OOOll
,
int
llO\
l\
l\
Oll\
ll
,
const
Vec3
&
llOOOll\
lOll\
O
)
{
float\

lOOll\
lOO\
llll
=
lO\
O\
llOlll\
lOO
->
lOl\
Ol\
lll\
lOOO
;
lOOlOlllll\
lO
=
1.0f
;
fo\
r
(
int
lOOOl\
l\
OO\
Ol
=
0
;
lO\
O\
O\
llOOOl
<
ll\
Oll\
Ollll
;
lO\
OOl\
lOOOl
++
)
{
int
ll\
O\
OOOlOOlOl
;
for
(
llOOOO\
lO\
OlOl\

=
lOll\
lO\
OOOOl\
l\

-
1
;
ll\
OOO\
OlOOl\
O\
l\

>=
0
;
llO\
OOOl\
OOl\
O\
l
--
)
{
#ifdef lOllOOlOOOOO
if\

(
llOOOO\
lOOlOl
>=
3
)
{
con\
st
Colli\
sion
*
ll\
OO\
OllOlllO
=
lOlllOO\
OOl\
O\
O
[
llOOO\
O\
l\
OOlOl
-
3
]
.
llO\
llOl\
Olll
;
lOllOOlOO\
l\
Ol
(
&
ll\
OOO\
ll\
OlllO
->
lO\
O\
OOll\
lll
)
;
const\

Col\
lisi\
on
*
ll\
OO\
Oll\
Oll\
ll
=
lOlll\
OOOOlOO
[
llOOOOlOOlOl
-
2
]
.
llOllO\
lOlll\

;
lOl\
lOOlOOlOl\

(
&
llO\
OOll\
O\
llll
->
lO\
l\
lO\
OOllOl\

)
;
lOl\
lO\
OlOO\
l\
Ol
(
&
llOO\
O\
l\
l\
Ollll
->
lOl\
lOOOl\
l\
lO\

)
;
co\
nst
Collision\

*
llOOOlllOOOO
=
lOll\
lOOO\
OlOO
[
llOOOOlOOlOl
-
1
]
.
llOl\
l\
OlO\
lll
;
lOllO\
Ol\
OOOOl
(
&
llO\
OOlllOO\
OO
->
lOllOOO\
llOl
->
GetCente\
rOff\
se\
t
(
)
)
;
lOllO\
Ol\
OOO\
Ol
(
&
llOOOl\
llOOOO
->
lOllOOO\
lll\
O
->
GetCenterOffset\

(
)
)
;
}
#endif //
Co\
l\
lis\
ion
&
llOllllOl\
ll
=
*
lOlllO\
OOO\
lOO
[
ll\
OOOOlOO\
lO\
l
]
.
llOllOl\
O\
lll
;
lOlOO\
OllllOl
(
lOlOOl\
O\
O\
OO\
lO
(
lOO\
lllOOllll
,
llOl\
lllOlll
)
,
llOllllO\
lll
)
;
}
for\

(
ll\
O\
O\
O\
OlOO\
l\
Ol\

=
0
;
llOOO\
Ol\
OOlOl\

<
lOlll\
OO\
OOOl\
l\

;
ll\
O\
OOOl\
OOlOl
++
)
{
#ifdef lOllOOlOOOOO
if
(
llOOOO\
lO\
OlOl
<
lO\
lll\
OOOOOll
-
3
)
{
co\
nst
Col\
lisio\
n
*
ll\
O\
OOllO\
lllO
=
lO\
lll\
OOO\
O\
lO\
O
[
ll\
OOOOlOOl\
Ol
+
3
]
.
ll\
Ol\
lOlOl\
ll\

;
lOll\
O\
O\
lO\
OlOl
(
&
ll\
OOOl\
lOl\
ll\
O\

->
lOO\
OOlll\
ll\

)
;
const
Col\
lision
*
ll\
OOO\
llO\
llll
=
lO\
lll\
OOOOlOO
[
llO\
OO\
O\
lO\
Ol\
Ol
+
2
]
.
llOll\
OlOll\
l\

;
lOll\
OOlO\
OlOl
(
&
llOOOllOll\
l\
l
->
lOl\
lOOO\
llOl
)
;
lOllO\
Ol\
OOlOl
(
&
llOOO\
llOllll
->
lOllO\
OO\
lll\
O
)
;
co\
n\
st
Coll\
isi\
on\

*
llOO\
Oll\
lO\
OOO
=
lOll\
lOOO\
OlOO\

[
ll\
O\
O\
OOlO\
OlOl\

+
1
]
.
llO\
llO\
l\
Olll
;
lOllOO\
lOOOO\
l
(
&
ll\
O\
O\
OlllOO\
OO
->
lO\
llOOO\
ll\
Ol
->
GetC\
ente\
r\
Offse\
t
(
)
)
;
lOllOOl\
OOOOl\

(
&
llOOOlllOOOO
->
lOl\
lOOO\
lllO
->
GetCenterOffse\
t
(
)
)
;
}
#endif //
Coll\
i\
si\
on
&
llOllllOl\
l\
l\

=
*
lOlllOOO\
OlOO
[
llOO\
OOl\
OOlOl\

]
.
ll\
OllO\
lOlll
;
lOl\
OOOllll\
Ol
(
lOlOOlOOO\
OlO
(
lOOl\
ll\
OOllll\

,
llO\
llllOlll
)
,
llOll\
llOl\
ll
)
;
}
}
lOOlOll\
llllO\

=
1.0f
;
}
vo\
i\
d
Ph\
ysics
::
lOlll\
OOOOlll
(
lOllOlOOOlll
*
lOlllOOOOl\
OO
,
int\

lOlllOOOOO\
l\
l
,
int
llO\
l\
lOllll
,
cons\
t
Vec\
3
&
llOOO\
lllOllO
)
{
floa\
t
lOOl\
llOOl\
lll
=
lOO\
llOllllOO
->
lO\
lO\
lllll\
O\
OO
;
floa\
t
llOOO\
l\
llO\
lll\

=
ll\
OOOlllOll\
O
.
Ge\
t\
Magni\
tu\
de
(
)
*
0.2f
;
for
(
int
lO\
O\
O\
llOOOl
=
0
;
lOOOllO\
OOl
<
llOllOll\
ll\

;
lOOOl\
lOOOl
++
)
{
lOlOll\
lllOll\

=
3.5f
;
float
ll\
OOO\
llllOOO
=
0.25f
;
float
lOlOOO\
llll\
ll\

=
1.0f
;
float
llO\
O\
OllllOOl
=
0.65f
;
float
llO\
O\
Ol\
l\
ll\
OlO\

=
0.65f
;
if\

(
lOOOllO\
OOl
==
0
)
{
llOOOllllOOl
=
1.05f
;
llO\
O\
OllllO\
lO
=
1.05f
;
}
els\
e\

if
(
lOOO\
llOOOl
==
llOll\
Oll\
l\
l
-
1
)
{
lOlOllll\
l\
O\
ll
=
0.05f
;
llOOOllllOOO
=
0.65f
;
ll\
OOO\
ll\
llOlO\

=
0.05f
;
llOO\
Olll\
lOOl\

=
0.05f
;
lO\
lO\
O\
Ollllll
=
1.0f
;
}
lO\
l\
OO\
O\
l\
lllll
=
0.4f
;
fo\
r
(
int\

ll\
OOOOlO\
O\
lOl
=
0
;
llOOOOl\
OO\
l\
Ol
<
lO\
lllO\
O\
OOOll
;
llO\
OO\
OlO\
Ol\
O\
l
++
)
{
#ifdef lOllOOlOOOOO
if
(
llOOO\
O\
l\
OOlOl\

<
lOlllO\
OO\
OOll
-
3
)
{
cons\
t
Collis\
ion
*
llOOOllO\
lllO
=
lOll\
lO\
OOOlO\
O
[
llOOOOl\
O\
Ol\
Ol
+
3
]
.
llOl\
lOl\
Oll\
l
;
lOllOOlO\
Ol\
Ol
(
&
llOOOllO\
l\
l\
lO
->
lOOO\
Olll\
ll
)
;
const
Collision
*
llOOOllO\
llll
=
lOll\
lOO\
OO\
lO\
O
[
llOOOO\
l\
OO\
lOl
+
2
]
.
llOllOlO\
lll\

;
lOllOO\
lOOlOl
(
&
ll\
O\
OO\
l\
lOllll
->
lOll\
OOOl\
lOl\

)
;
lO\
llOOlOOlOl
(
&
llOO\
O\
llOll\
ll
->
lO\
ll\
OO\
OlllO
)
;
co\
nst
Co\
lli\
sion\

*
ll\
OO\
O\
l\
ll\
OO\
OO\

=
lOll\
lO\
OOOlO\
O\

[
ll\
OOOOlOOlOl
+
1
]
.
llO\
llO\
lOl\
ll
;
lOll\
O\
O\
l\
O\
OOOl\

(
&
llOOOlllOOOO
->
lOllOOO\
ll\
Ol\

->
GetCe\
nt\
er\
Offs\
et\

(
)
)
;
lO\
llO\
O\
lOO\
OO\
l
(
&
llO\
O\
OlllOOO\
O
->
lO\
llOOOll\
l\
O
->
GetCenterOffs\
et
(
)
)
;
}
#endif //
float\

llOlllOO\
Ol
=
llOOOlll\
lO\
OO
;
Colli\
sion
&
ll\
Oll\
llOlll
=
*
lOl\
llOOOO\
lOO\

[
ll\
OOOO\
lOOlO\
l\

]
.
llO\
llOl\
Oll\
l
;
float
llOOOllllOll
=
llOOOll\
lO\
ll\
l
;
boo\
l\

llOOOlllllOO
=
fal\
s\
e
;
bool
llO\
OOl\
llllOl
=
fals\
e\

;
if
(
(
llOl\
ll\
lOl\
ll\

.
lO\
l\
Ol\
lOO\
ll
&
Co\
llision\

::
FLAG_\
C\
O\
NSTRAIN_IN_B\
OTH_DIRECT\
IO\
NS
)
!=
0
)
{
if
(
ll\
OOOlll\
Oll\
O
.
Dot
(
llOllllOlll\

.
lO\
llOO\
OllOl\

->
Get\
Position
(
)
-
llO\
ll\
llO\
ll\
l
.
lOOOOlllll
)
<
0.0f
)
llOO\
OlllllOO
=
true\

;
if
(
ll\
Oll\
llOlll\

.
lO\
llOlOl\
Oll
(
)
&&
ll\
OOOlllOl\
lO
.
Dot\

(
llOll\
llO\
l\
ll\

.
lOll\
OlOl\
O\
ll\

(
)
->
GetPositi\
on
(
)
-
llOll\
llOlll
.
lO\
OOO\
l\
llll
)
<
0.0f
)
llO\
OO\
llll\
lOl\

=
true\

;
ll\
O\
lllOOO\
l
*=
0.5f
;
}
else
{
fl\
o\
at\

lOlOO\
OlOlOO
=
ll\
O\
l\
ll\
lO\
lll
.
lOOOl\
OO\
OOO\

.
Dot
(
llOOO\
ll\
lOllO
)
;
if\

(
lOlO\
OOl\
OlO\
O
<
-
llOOOllllOll\

)
llOOOlllllOO
=
true
;
else\

if
(
ll\
Olll\
lOll\
l
.
lO\
ll\
O\
lOlOll
(
)
&&
lO\
lO\
OO\
lOlOO
>
llOO\
OllllOll
)
llO\
OOll\
lllOl\

=
true
;
}
flo\
at\

lOOl\
lllOO\
Oll\

=
0.0f
;
if
(
llOOOlll\
llOO
|
ll\
OO\
Ol\
llllO\
l
)
{
lOOll\
ll\
OOOll
=
lO\
lOOlOO\
O\
OlO
(
lOO\
lllO\
O\
l\
lll
,
llOllllOlll
)
;
#ifndef llOOOllllllO
#endif //
fl\
oat
lOO\
l\
lOOO\
OO\
l\
l
=
Min
(
llO\
lll\
lOlll\

.
GetObje\
c\
tA
(
)
->
lOOl\
lOOO\
O\
lOO
(
)
,
llOl\
lllOll\
l
.
GetObject\
B
(
)
->
lOOllOO\
O\
O\
l\
OO
(
)
)
;
co\
nst
flo\
at
llOOO\
l\
l\
lllll
=
10.0f
;
fl\
o\
at
ll\
OOlO\
OOOO\
OO
=
Fabs
(
lOOll\
l\
l\
OOOll\

/
lO\
OllOOOO\
Oll\

)
-
0.5f
;
if
(
llOOl\
OO\
O\
OOOO
<
0.0f
)
ll\
OO\
lOOOO\
OOO
=
0.0f
;
llO\
O\
l\
O\
OOOOOO
*=
llOOlOOOOOO\
O
;
llOOlO\
OO\
O\
OOO
*=
llOOl\
OOOOOOO
;
llO\
l\
llO\
O\
Ol
*=
(
0.9f
*
llOOO\
lll\
llll
/
(
llOOOllllll\
l
+
llOOlOOOOOO\
O
)
)
+
0.1f
;
}
lOOlOlll\
lll\
O
=
ll\
OOOlll\
lOlO
;
llO\
ll\
llOlll
.
GetO\
bjectA\

(
)
->
lOl\
OO\
lO\
lOOl\
O
(
false
)
;
if\

(
llOOOlllllOO
)
{
llO\
llllOlll
.
Get\
ObjectB\

(
)
->
lOlOOlOlO\
OlO
(
tru\
e\

)
;
lOlOOOllll\
lO
(
lO\
Olll\
l\
OOO\
l\
l\

,
llO\
l\
ll\
OOOl\

,
llO\
lllOO\
Ol
*
lOlOOOllll\
ll
,
llOl\
lllOll\
l
)
;
}
llOllllOlll
.
GetObjec\
tB
(
)
->
lOlOOlOlOOlO
(
false
)
;
if
(
llOOOl\
ll\
llOl
)
{
ll\
OllllOlll
.
GetObjec\
tA\

(
)
->
lOl\
OOlO\
lOOlO
(
true
)
;
lOlOOOlllllO
(
lOOllllOOO\
ll
,
llO\
l\
l\
lOOOl\

,
llOlll\
OOOl
*
lOlOO\
O\
llllll
,
llOll\
ll\
Oll\
l
)
;
llOll\
llO\
lll
.
Ge\
tObj\
ectA
(
)
->
lO\
lOOlO\
l\
O\
OlO
(
false
)
;
}
}
if
(
lOOOl\
l\
OOOl
<
ll\
Ol\
l\
O\
l\
ll\
l
-
1
)
{
lOl\
Olllll\
O\
ll
=
0.05f
;
llO\
O\
O\
lll\
lOOO\

=
0.2f
;
for
(
int
llOOO\
O\
lOOl\
Ol
=
lO\
l\
llO\
O\
O\
O\
Oll\

-
1
;
llOOOOlOOl\
O\
l
>=
0
;
llOOOO\
lOOlOl
--
)
{
#ifdef lOllOOlOOOOO
if
(
llOOOOlOO\
lOl
>=
3
)
{
const
Col\
li\
si\
on
*
llOOOll\
OlllO
=
lO\
lll\
OOOO\
lOO\

[
llOOOOlOO\
l\
O\
l
-
3
]
.
llO\
llOlOl\
ll\

;
lOl\
l\
O\
O\
lOO\
lOl\

(
&
ll\
OOOll\
OlllO
->
lO\
O\
O\
O\
ll\
lll
)
;
con\
s\
t\

Co\
lli\
sion
*
llOO\
OllOllll
=
lOlllOO\
OOl\
O\
O
[
ll\
OOOO\
lOO\
lO\
l
-
2
]
.
ll\
OllOl\
O\
l\
ll\

;
lOl\
l\
OOl\
O\
O\
lO\
l
(
&
ll\
OOO\
llOllll
->
lOllO\
OOllOl\

)
;
lOll\
OOlO\
OlOl
(
&
ll\
OO\
OllOllll
->
lO\
l\
lOO\
Olll\
O\

)
;
const
Coll\
is\
ion
*
llO\
OOlllOOOO\

=
lOl\
ll\
OOO\
O\
lOO
[
ll\
OO\
OO\
lOOlOl
-
1
]
.
llOllOlOlll
;
lO\
llO\
O\
lOOOOl
(
&
llOOOl\
llOOOO
->
lOl\
l\
OOOll\
Ol
->
Get\
Ce\
n\
ter\
O\
ff\
set
(
)
)
;
lOllO\
O\
l\
OOOOl
(
&
ll\
OOOlllOO\
O\
O\

->
lOllOOOlll\
O\

->
Ge\
tCen\
ter\
O\
ff\
set
(
)
)
;
}
#endif //
fl\
oat
llOl\
llOO\
Ol
=
ll\
OOOllllO\
OO
+
0.1f
;
Col\
l\
i\
sion
&
llOll\
l\
l\
Oll\
l
=
*
lO\
lllOOOOl\
O\
O
[
llOOOO\
l\
OO\
lOl\

]
.
llOl\
lOlOlll\

;
fl\
oat\

llOOO\
l\
lllOll
=
llOOOlllO\
lll
;
bool\

llO\
O\
OlllllO\
O
=
false
;
bool
llOO\
Olllll\
Ol
=
false\

;
if
(
(
llO\
lll\
l\
Oll\
l
.
lO\
lOll\
O\
Oll
&
Colli\
sio\
n
::
FLA\
G_CO\
NSTRAIN\
_IN\
_B\
OTH\
_DIRE\
CTI\
O\
NS
)
!=
0
)
{
if
(
llOO\
OlllO\
l\
lO
.
Dot
(
llOll\
llOll\
l\

.
lOllOOO\
l\
lOl\

->
Get\
P\
osition
(
)
-
llOlll\
lO\
l\
ll
.
lOOOOll\
lll
)
>
0.0f
)
llO\
OOlllllOO\

=
tr\
ue
;
if\

(
ll\
Ol\
lll\
Ol\
ll
.
lOll\
Ol\
Ol\
Ol\
l\

(
)
&&
ll\
OOOl\
llOl\
lO\

.
Dot
(
llOlll\
l\
Ol\
ll
.
lOllOlOl\
O\
ll\

(
)
->
GetP\
osition
(
)
-
llOll\
llOlll\

.
lO\
OOOlllll\

)
>
0.0f
)
ll\
OOOlllllOl
=
true
;
llOlll\
O\
OOl
*=
0.5f
;
}
else
{
float
lO\
lO\
O\
OlOlOO
=
llOllll\
Ol\
ll\

.
lOOOlOO\
OOO
.
Do\
t
(
llO\
O\
O\
lllOll\
O
)
;
if\

(
lO\
l\
OOO\
lOl\
O\
O
>
llOOOl\
lllOll
)
llOOOlll\
llOO\

=
true
;
els\
e
if
(
ll\
Oll\
l\
lO\
l\
ll
.
lOl\
lOl\
OlO\
ll
(
)
&&
lOl\
OOO\
lOlO\
O
<
-
llOOOllllOl\
l\

)
llOO\
O\
ll\
lllOl
=
true
;
}
lO\
OlOllll\
llO
=
ll\
OOOllll\
OlO\

;
llOll\
llOlll\

.
GetObjec\
tB
(
)
->
lO\
lOOlO\
lOOlO\

(
false
)
;
if\

(
llOO\
O\
l\
llll\
OO
)
{
llOlll\
lOlll
.
Ge\
tO\
b\
j\
ectA\

(
)
->
lOl\
O\
Ol\
O\
lO\
O\
lO
(
true
)
;
lO\
lOOOl\
llllO
(
lOlOO\
lOOO\
Ol\
O
(
lO\
O\
lllOOllll
,
llO\
llllOl\
ll\

)
,
ll\
O\
lllOOOl\

,
0.0f
,
llO\
lll\
lOlll
)
;
}
llO\
lll\
lO\
lll
.
Get\
Objec\
tA\

(
)
->
lO\
lO\
OlO\
l\
O\
OlO
(
fal\
se
)
;
if\

(
ll\
O\
OOll\
lllOl
)
{
llO\
llllOlll\

.
GetOb\
j\
e\
ctB
(
)
->
lOlOO\
lOlOOlO
(
true
)
;
lO\
lO\
OO\
l\
lll\
l\
O
(
lOl\
OOlO\
OOOlO
(
lOOlll\
OO\
ll\
l\
l\

,
ll\
O\
lll\
l\
Ol\
ll\

)
,
llOlllO\
OOl
,
0.0f
,
ll\
OllllO\
l\
ll
)
;
llO\
lll\
l\
Olll
.
Get\
O\
bje\
ct\
B
(
)
->
lO\
lOOl\
O\
lOOlO
(
fal\
s\
e
)
;
}
}
}
}
lOO\
lO\
ll\
lll\
lO\

=
1.0f
;
lOl\
Oll\
lllOl\
l\

=
1.0f
;
}
voi\
d
Phys\
ics
::
lOl\
lOl\
lll\
llO
(
lOlO\
ll\
llOOO\
O
&
lOllO\
llOl\
lOO
,
Dyn\
amicObj\
ect\

*
*
lOllOllllOll
,
int\

lOl\
l\
Olll\
lO\
O\
O
,
Coll\
i\
sion\

*
*
lOl\
lO\
l\
llllOO
,
int
lOl\
lOlll\
O\
lOl
)
{
float
lO\
Ol\
llOOllll\

=
lOO\
ll\
Ol\
ll\
lOO\

->
lOlOllll\
lOOO
;
#ifdef _DEBUG
for\

(
int\

lOOlOlOOOl
=
0
;
lO\
OlO\
lOOO\
l
<
lOll\
O\
llllO\
OO
;
lOOlOlOO\
Ol\

++
)
{
if
(
lO\
llOll\
llO\
l\
l
[
lOOlOlOO\
Ol\

]
)
{
TA_ASSE\
RT
(
!
lO\
ll\
O\
ll\
l\
lOll
[
lO\
O\
lOl\
O\
OO\
l
]
->
lOlOOlO\
lOlOO
(
)
)
;
}
}
#endif //
int
ll\
O\
OOlllO\
Ol\
O\

=
0
;
con\
st
floa\
t\

llO\
lll\
OOO\
l\

=
0.5f
;
int
llO\
O\
OlllOO\
ll
=
0
;
co\
nst
int
ll\
O\
OOlOl\
lOO\
O
=
2
;
int\

lO\
Ol\
OOlOOO\

=
0
;
for
(
int
lOO\
OllOOOl
=
0
;
lOO\
OllOOOl
<
lO\
llOlllOlO\
l
;
lOOOllO\
OOl\

++
)
{
if
(
lOl\
lOlllll\
O\
O
[
lOOO\
ll\
O\
OOl
]
==
0
)
{
llOOOll\
lO\
Oll\

++
;
if
(
llOOOlllO\
Oll
<
ll\
OO\
O\
lOllO\
OO\

)
{
lOOO\
llO\
OO\
l
=
lOOl\
OOlO\
OO
;
}
else
{
llOOO\
lllOOll
=
0
;
for\

(
;
ll\
OOOll\
lOOlO
<
lOl\
lO\
llll\
O\
OO
&&
lOllO\
ll\
llOll
[
llO\
O\
Oll\
lOO\
lO
]
;
llO\
O\
Oll\
lOOlO
++
)
{
TA_ASSERT\

(
!
lOl\
lOllllOll
[
ll\
O\
O\
O\
lllO\
OlO
]
->
lO\
l\
OO\
l\
O\
lOlOO\

(
)
)
;
lOllOllllOl\
l
[
llOOO\
lllOO\
l\
O
]
->
lO\
lO\
OlOlO\
O\
lO\

(
true
)
;
}
ll\
OOOlllOOlO
++
;
lO\
O\
lOOlOOO
=
lOOOl\
lOOOl
+
1
;
}
}
else\

{
Co\
llisi\
on
&
llOllllOlll
=
*
lOll\
Oll\
ll\
l\
OO
[
lOOOllOOOl\

]
;
if\

(
(
llOll\
llOll\
l\

.
lO\
lOl\
lOOll
&
Coll\
is\
io\
n
::
FL\
AG\
_J\
O\
I\
N\
T
)
)
{
fo\
r
(
in\
t
lOOl\
OlO\
OOl
=
0
;
lOOl\
Ol\
O\
OOl
<
4
;
lOOlO\
lOOOl
++
)
{
lOOlOlllll\
l\
O
=
(
1.33f
-
(
flo\
at
)
lOOl\
Ol\
OOOl
*
0.33f
)
*
0.5f
;
for\

(
Collision
*
lOOOO\
O\
lOOOl
=
&
llOllllO\
lll
;
lOOO\
OOlOOOl
;
lOO\
OOO\
lOOO\
l\

=
lO\
OOOOlOOOl
->
GetNext
(
)
)
{
lOlO\
OOll\
l\
ll\
O
(
lOlOOlOO\
O\
O\
lO
(
lOO\
ll\
l\
OOllll\

,
*
lOOO\
O\
O\
lO\
OOl
)
,
1.0f
,
0.0f
,
*
lOOOOOlOOO\
l
)
;
}
}
lOOlOllllllO
=
1.0f
;
}
else
if\

(
(
llO\
l\
lllO\
lll
.
lOlO\
ll\
OOll\

&
Collisi\
on\

::
FL\
A\
G\
_\
JOIN\
T\
_\
LI\
MIT
)
)
{
lOlOOOllll\
lO
(
lOlOOlOO\
OOl\
O
(
lO\
OlllOOllll\

,
ll\
O\
llllOlll
)
,
ll\
Ol\
l\
lO\
O\
Ol\

,
0.0f
,
llOl\
lllOl\
ll\

)
;
}
el\
s\
e
{
if
(
!
(
ll\
O\
ll\
l\
lOlll
.
lOlOll\
OOl\
l
&
Co\
ll\
is\
ion
::
FL\
AG_FR\
ICTI\
ON_G\
E\
N\
E\
RA\
T\
ING_I\
MP\
ULSE
)
)
contin\
u\
e
;
lOlOO\
lO\
O\
OOOl
(
lOl\
O\
OlOOOO\
lO\

(
lOOl\
llOOllll
,
llOl\
lllOlll
)
,
llOlllO\
OOl\

,
llOll\
llOl\
l\
l\

)
;
}
}
}
}
void\

Phys\
i\
cs\

::
llOOlO\
OO\
O\
O\
Ol
(
lOllOlO\
OO\
lll
*
lOl\
llOOOOlOO
,
int
lO\
lllOOOOOll
,
int
llOllOll\
l\
l
,
const
Vec\
3
&
llOO\
Ol\
ll\
OllO
)
{
}
void
Phys\
ics\

::
lOlllO\
OOlOlO\

(
)
{
lll\
OllOOOO\

|=
lOl\
l\
lO\
lOlO\
ll
;
TA\
_\
ASS\
E\
RT\

(
lO\
lllO\
OO\
llOl
==
0
)
;
lO\
llOlOlllOO
::
It\
e\
r\
a\
tor
lOllOl\
lO\
lO\
ll
=
lO\
llOl\
Oll\
Oll
->
lOlO\
OOOlOO\

(
)
;
for
(
;
!
lOllOllO\
l\
O\
ll
.
AtEnd
(
)
;
++
lO\
llO\
ll\
OlO\
l\
l\

)
{
lOlOllllOOOO\

&
lOl\
lO\
llO\
l\
lOO
=
(
*
lOllOllOlOll
)
;
lOlOllll\
OOO\
O
::
Itera\
t\
or\

lOlOll\
l\
OOOlO
=
lOll\
OllOllOO\

.
lOl\
O\
O\
OOlOO
(
)
;
for
(
;
!
lO\
lOlllO\
OO\
l\
O
.
AtEnd
(
)
;
++
lOl\
OlllOO\
Ol\
O
)
{
Collision\

&
llOll\
llOl\
ll
=
*
lO\
l\
Olll\
O\
OOl\
O
;
if
(
lOlllOOlllOO
)
lOlllOOlllOO
(
(
PostCo\
llisio\
n
&
)
llOl\
lllOlll\

)
;
Phy\
si\
csJoint
*
lOlllOOlO\
l\
O
=
llOlll\
lOl\
ll\

.
Get\
J\
oint
(
)
;
if
(
lOlllOOlOlO
&&
lO\
ll\
l\
OO\
l\
OlO\

->
IsBre\
a\
ka\
b\
le
(
)
&&
llOll\
l\
lOll\
l
.
lOllO\
OlOlO\
O
>
lO\
lllO\
Ol\
OlO\

->
GetBre\
akForce
(
)
&&
!
lOl\
l\
l\
OOlO\
lO\

->
Is\
Bro\
k\
en
(
)
)
{
lO\
lllO\
OlOlO
->
SetB\
r\
ok\
e\
n
(
tru\
e\

)
;
if
(
lO\
lllOOlllO\
l
)
lOll\
l\
OOl\
llO\
l
(
*
lO\
lllOO\
lOlO
)
;
}
}
}
if
(
lOlllOO\
lllOO\

)
{
lOllO\
lOlll\
O\
O\

::
lOllllOOlO\
O\
O
llOOlO\
OOO\
OlO
=
lOllOlOllOll
->
ll\
OOl\
OOOOO\
ll
(
)
;
fo\
r
(
;
!
llOOlO\
OO\
OOlO\

.
AtEnd
(
)
;
++
ll\
OOlOOOOOlO
)
{
lOl\
O\
OOOO\
Olll
&
lOlO\
OO\
OlllOO
=
*
llOO\
lOOOOOlO
;
lOl\
OOOOOOlll
::
Col\
lisionIterator
lOlOlllO\
OOlO\

=
lOlOOOOl\
llOO
.
lOlO\
ll\
lOOlOl
.
lOlOOO\
OlOO
(
)
;
for
(
;
!
lO\
lOll\
l\
OOOlO
.
AtEnd
(
)
;
++
lO\
l\
OlllOOOl\
O\

)
{
Collision
&
llOll\
ll\
Olll
=
*
lOlOl\
l\
lOOO\
lO
;
TA_\
ASSERT
(
lOl\
ll\
OOlllOO
)
;
lOlllOOlll\
O\
O
(
(
Po\
st\
Co\
lli\
s\
ion
&
)
llO\
lll\
l\
O\
l\
ll
)
;
}
}
}
lll\
OllOOOO
&=
~
lOlllOlO\
lO\
ll
;
for
(
Dyna\
micObject
*
lO\
OO\
O\
OlOOOl\

=
lOlll\
OOOllOl\

;
lOOOOO\
lOOO\
l
;
)
{
DynamicObject\

*
lOll\
lOOlO\
OO
=
lOOO\
OOlOO\
Ol
;
lO\
OOO\
O\
lO\
OOl
=
lOOO\
OOlOOOl
->
lO\
lOOlllll\
OO
(
)
;
TA_ASSERT
(
lO\
lllOO\
lOOO\

->
lOOlOOOllOl\

(
)
)
;
lOl\
l\
l\
O\
OlOOO
->
lO\
l\
OO\
l\
lllOll
(
0
)
;
lOlll\
OOlOOO
->
lO\
lO\
OlOl\
lO\
ll\

(
fa\
lse
)
;
Remove\
D\
ynamic\
Objec\
t\

(
lO\
ll\
lOOl\
O\
OO
)
;
lOll\
lOOlOOO\

->
Rele\
ase\

(
)
;
}
lOlllO\
O\
O\
llOl
=
0
;
}
bo\
ol
Phy\
s\
ics\

::
llOOlOOOO\
lOO
(
Dy\
na\
mi\
c\
Object\

*
lOlllOOl\
OOO
)
{
if
(
lO\
lllOOlOOO
->
Movement\
D\
isabled
(
)
)
return\

fa\
l\
se
;
return
lO\
llOlO\
l\
llOl
.
lOO\
lO\
OlOlOl
(
)
;
}
vo\
id
Physi\
cs
::
lO\
l\
lOllOOl\
ll
(
)
{
}
vo\
i\
d
Ph\
y\
s\
ics
::
lO\
Ol\
llO\
OllO\
l
(
Dynam\
icObject
*
lO\
l\
llOOlOOO
,
int
lO\
Olll\
OOl\
lOO\

)
{
if
(
lO\
l\
l\
lOOlOO\
O
->
Mov\
em\
ent\
D\
isa\
bled
(
)
)
ret\
urn\

;
TA\
_\
AS\
S\
ERT
(
!
lO\
l\
llOOlOO\
O
->
IsIn\
M\
ovin\
gL\
i\
st\

(
)
)
;
if
(
lOOlll\
OOl\
lOO
!=
SET\
_\
MOVING_P\
R\
IORIT\
Y_LOW\

)
{
if
(
!
lOllOl\
O\
lllOl\

.
lOOlO\
OlOlOl
(
)
)
{
flo\
at
llOOlOOOO\
lOl
=
-
k_fMaxFlo\
at
;
Dy\
nam\
ic\
Objec\
t
*
llO\
OlOOOOll\
O\

=
0
;
lO\
l\
llOl\
OllOO
lOll\
lOl\
ll\
OlO\

=
lOllOl\
Oll\
llO
.
lOl\
OOOOlO\
O
(
)
;
for
(
;
!
lOlllO\
lllOl\
O
.
AtEnd
(
)
;
++
lOl\
ll\
Ol\
llOlO\

)
{
Dyn\
amicOb\
je\
ct
&
lO\
ll\
OlOl\
lO\
lO\

=
*
*
lOll\
lO\
ll\
lO\
lO
;
if
(
lOl\
lOl\
Oll\
OlO\

.
lOl\
OOOlOOOOO\

(
)
)
{
fl\
oat
llOOl\
O\
OOOlll
=
lOllOl\
Oll\
OlO
.
lOlOOlll\
O\
Oll
(
)
;
if
(
ll\
O\
Ol\
OOOOl\
Ol
<
llO\
OlOOOO\
ll\
l
)
{
llOOl\
O\
OOO\
lO\
l\

=
llOOlOOOOlll
;
llOOlO\
OOOllO
=
&
lO\
llOl\
O\
llOlO
;
}
}
}
if
(
llO\
O\
lOOO\
OllO
)
{
llOOlOOOO\
llO
->
SetToResti\
ng
(
)
;
}
else\

{
fl\
o\
a\
t
llOO\
lOOOlOOO
=
k_fMax\
Float\

;
lO\
ll\
lOlllOlO
=
lOllOlOllllO
.
lO\
lOOOOl\
O\
O
(
)
;
for
(
;
!
lOl\
llOll\
l\
OlO
.
AtEnd\

(
)
;
++
lOlll\
O\
ll\
lOlO\

)
{
DynamicO\
b\
jec\
t
&
lO\
llO\
l\
O\
llOl\
O
=
*
*
lO\
ll\
lO\
lllOlO\

;
if\

(
!
lO\
ll\
OlOllOlO\

.
GetCo\
lli\
sionIte\
rator
(
)
.
AtEn\
d
(
)
)
{
float
llOOlOOOlO\
O\
l\

=
lOllOlOl\
lO\
lO
.
Get\
Linear\
Ve\
loci\
ty
(
)
.
Ge\
t\
Magni\
tudeSqrd
(
)
+
lO\
ll\
OlOllOlO\

.
GetAn\
gularVe\
locity\

(
)
.
Get\
MagnitudeS\
qrd
(
)
;
if
(
llOOlO\
OOlOO\
O
>
ll\
OOlO\
OOlOO\
l
)
{
llOO\
l\
OOO\
lOO\
O
=
llOOlO\
O\
OlOOl
;
llOO\
lO\
OO\
Oll\
O
=
&
lO\
ll\
Ol\
OllOlO
;
}
}
}
if\

(
ll\
OOlOOO\
OllO
)
llOO\
lOO\
OOllO
->
SetToRes\
tin\
g
(
)
;
}
}
}
if\

(
lOllOlOlllO\
l
.
lOOlOOlOlOl
(
)
)
{
TA_A\
SSE\
RT\

(
llO\
OlOOOOlOO
(
lOl\
llOOl\
O\
OO\

)
)
;
DynamicObje\
ct
*
*
lO\
l\
lOllOOO\
lO
=
lOllOl\
O\
lllOl
.
Alloc
(
)
;
TA_A\
SSER\
T
(
lO\
llOl\
lOOOlO
)
;
*
lOllOllOOOlO
=
lO\
lllOOlOOO\

;
TA_ASSERT
(
!
lOlllOOlOOO
->
IsInMo\
ving\
List\

(
)
)
;
{
lOllOlOllllO
.
lO\
O\
lO\
OO\
OllO\

(
lO\
l\
lOllO\
OO\
lO
)
;
lOlll\
OOlOOO
->
lOlOO\
lO\
OllOO
(
lOllOlO\
llll\
O
.
lOOlOOlOOl\
O
(
)
)
;
}
if
(
lOll\
lOOll\
llO
)
lO\
lllO\
OllllO
(
*
lOll\
l\
O\
OlOOO
,
lOl\
l\
lO\
Oll\
lll
)
;
if
(
lO\
OllOll\
l\
lOO
->
lO\
l\
OlllllOO\
l
>=
0
)
{
for\

(
lOlOO\
OO\
Ol\
O\
lO
*
lOl\
OOOOOllOO
=
lO\
lll\
OOlOOO
->
lOlOOllO\
lOOl
(
)
;
lOlOOO\
OOllO\
O
;
lOlOOOOOll\
OO
=
lOlO\
OOOO\
ll\
OO\

->
llOOOl\
OO\
OO\
l
)
{
TA\
_ASSERT
(
lOlOOOOOl\
lOO
->
lOlOO\
OOOl\
lO\
O
)
;
lOl\
OOO\
OO\
Ol\
l\
l
&
lOl\
OOOOlll\
OO
=
*
lOlOO\
OOOllOO
->
lO\
lO\
OO\
OOllOO
;
if
(
lO\
lOO\
OOll\
lOO
.
lOlOO\
OOl\
OOlO
)
lOllO\
lO\
llO\
ll
->
llOOlOOOlO\
lO\

(
lOlOOOOlll\
OO
)
;
}
}
lOl\
l\
lO\
OlO\
OO
->
lOlO\
O\
lOlOO\
lO
(
false
)
;
lO\
lllOOl\
OO\
O
->
lOl\
OOlOlOOO\
l\

(
fals\
e
)
;
lOlllOOlOOO\

->
lOOlllOO\
lllO
(
)
;
}
}
bool
Physi\
c\
s
::
llO\
OlOOO\
lOll
(
)
{
if
(
!
lOllOlOOl\
l\
ll\

)
return
fa\
lse
;
if\

(
lOllO\
lOOllll
->
llO\
OOOOOlOll
(
)
!=
lOll\
O\
lOlOOOO
.
lOl\
Olll\
l\
Olll
)
return
false
;
if
(
lO\
llOlOOll\
ll
->
ll\
OOOO\
OO\
lO\
lO
(
)
!=
lO\
llOlOlOOOO\

.
lOllO\
l\
OlOOO\
l\

)
re\
t\
urn
fal\
se
;
if\

(
!
lOOl\
lOllllOO
)
re\
turn
false
;
if
(
lO\
Ol\
lOlll\
lO\
O\

->
lOlOllllOOll\

!=
lO\
llO\
lOlO\
OOO\

.
lOlOlll\
l\
OOll\

)
re\
tur\
n\

false
;
if
(
lOO\
llOl\
l\
llOO\

->
lOlOllllO\
lOO
!=
lO\
l\
l\
Ol\
O\
lOOOO\

.
lOlOl\
lllOl\
O\
O\

)
return
fals\
e
;
if
(
lOOllOl\
l\
llOO
->
lOlOllllOllO
!=
lOll\
OlO\
lOOO\
O
.
lO\
llOlOlOO\
Ol
)
return
fals\
e\

;
if
(
lOOll\
OllllOO
->
lO\
lO\
l\
l\
ll\
O\
lll
!=
lO\
l\
lO\
lOlOO\
O\
O
.
lOlOllll\
Oll\
l
)
return
fa\
lse
;
if
(
lOllOlOl\
ll\
Ol
.
lOOOll\
l\
OOl\

(
)
!=
lOl\
lOlOlO\
OOO\

.
lO\
l\
OllllOlO\
O
)
ret\
u\
rn
fals\
e
;
retu\
rn
true
;
}
voi\
d
Physi\
c\
s
::
ll\
OOlOOOllOO
(
Dynam\
icObje\
ct\

*
lOllO\
O\
OllOl
,
Dyna\
micOb\
ject
*
lOl\
l\
O\
OOll\
lO
,
con\
st
MFr\
ame
&
lOOll\
lOl\
ll\
OO
,
co\
n\
st
MFram\
e
&
lOO\
l\
l\
lOlllOl\

,
float
lOO\
lllOO\
llll\

)
{
TA_ASS\
ER\
T\

(
lOllOOO\
llOl
)
;
TA_\
ASSERT
(
lOll\
O\
OOl\
llO
)
;
Dynam\
icObject
&
ll\
lOll\
O\
l\
llO
=
*
lOl\
lOOO\
llO\
l
;
DynamicObject
&
lllO\
llO\
l\
ll\
l
=
*
lO\
llOOOll\
lO
;
MFrame\

ll\
OOlOOOllOl
=
lllOllOllll\

.
GetF\
rame
(
)
;
MFr\
ame
ll\
O\
OlO\
OOlll\
O
=
(
lO\
O\
ll\
lOl\
l\
lOl
*
lO\
OlllOlllO\
O\

.
Get\
I\
n\
v\
erse
(
)
)
*
lll\
O\
llO\
lll\
O\

.
GetFr\
ame
(
)
;
Vec3
ll\
OOlOOOllll
=
(
(
lll\
OllOlll\
l
.
Ge\
tC\
e\
nter\
Offs\
et
(
)
*
ll\
O\
OlO\
O\
Oll\
lO
)
-
(
lll\
O\
llOllll
.
Ge\
t\
Ce\
nte\
r\
Offset
(
)
*
ll\
OOlOO\
OllO\
l\

)
)
/
lOO\
lll\
OOlll\
l
;
Mat33
lOOlllO\
l\
OOOO
=
llOO\
lOOOll\
Ol
.
m33\
R\
otation
.
Ge\
tT\
ra\
n\
s\
pose\
AsInverse
(
)
*
llO\
OlOOOlllO
.
m33Ro\
tat\
io\
n
;
Vec3
lOOOOO\
lllll
;
floa\
t
lOOOOlOOO\
OO\

;
lO\
Olll\
O\
lOOOO\

.
Ge\
tR\
otation\
A\
xisAn\
dM\
agnitude
(
lOOOOO\
l\
ll\
ll
,
lOO\
O\
OlOOOOO
)
;
Vec3
llOO\
lOOlOO\
OO
=
lOOOOO\
l\
llll
*
lOOO\
Ol\
O\
OOO\
O
/
lOOlllOOl\
lll
;
Vec3
lOlO\
OOOOlO\
l
=
lllOllOllll
.
Get\
Ce\
nter\
OfMass
(
)
-
lllOl\
lO\
ll\
lO
.
GetC\
enterOfMass\

(
)
;
lOlO\
O\
OOOlO\
l\

.
No\
r\
malise\

(
)
;
Mat33
llO\
OlOOlOO\
Ol
;
ll\
OOlOO\
lOOOl\

.
Se\
tToLook\
Down\
Ve\
ct\
o\
r
(
lOlOOOOOl\
O\
l
)
;
const
int\

llO\
Ol\
O\
O\
lOOlO
=
6
;
Ve\
c3\

llO\
Ol\
O\
Ol\
OOll
[
ll\
OOl\
O\
OlOO\
lO
]
;
Ve\
c3
llOOl\
OO\
l\
Ol\
OO
[
llO\
OlOOlOOlO
]
;
fl\
oa\
t\

llO\
OlOOlO\
lOl
[
llOOlOOlOOlO\

]
;
ll\
O\
OlO\
OlO\
Oll
[
0
]
=
lllO\
llOllll\

.
GetCen\
t\
e\
rOf\
Mass\

(
)
;
ll\
O\
O\
lO\
O\
lOlOO
[
0
]
=
llOOlO\
OlOOOl
.
v3X
;
llOO\
lOO\
lO\
Ol\
l\

[
1
]
=
lllO\
ll\
Ol\
lll
.
Ge\
tCe\
n\
terO\
fMas\
s\

(
)
-
llO\
O\
l\
O\
OlOOOl\

.
v3X\

;
llOOlO\
OlOl\
OO
[
1
]
=
llOOl\
OOlO\
OO\
l
.
v3\
Y
;
llOOlOOlO\
Oll
[
2
]
=
lllOllOl\
lll
.
Ge\
tC\
enterO\
f\
Mass
(
)
;
llOOl\
OOl\
Ol\
OO\

[
2
]
=
-
llOOlOOlOOOl\

.
v3Y
;
llOO\
lOOlO\
O\
ll
[
3
]
=
lllOllOlll\
l
.
Ge\
tCenterOfM\
ass
(
)
;
ll\
OOl\
OOl\
OlO\
O
[
3
]
=
llO\
Ol\
OOl\
O\
OOl
.
v3Z
;
llOOlOO\
lO\
Ol\
l
[
4
]
=
lllOl\
lOl\
l\
lO\

.
Ge\
tCen\
t\
e\
r\
O\
fMass
(
)
;
ll\
OOlOOlO\
lOO
[
4
]
=
llOO\
lOOlOO\
Ol\

.
v3X
;
llOOlOOlO\
Oll
[
5
]
=
lll\
Oll\
O\
lllO
.
GetC\
e\
nte\
rOf\
M\
as\
s\

(
)
;
llOOlOOlOlOO\

[
5
]
=
ll\
O\
OlOOl\
OOO\
l
.
v3Y
;
in\
t
lOOO\
llOO\
Ol
;
for
(
lOOOllOOO\
l
=
0
;
lOOOl\
l\
OOOl
<
llOO\
lOO\
lOO\
lO
;
lOOO\
llO\
OO\
l\

++
)
{
Vec3
llOOlO\
OlOllO\

=
ll\
OOlO\
OOll\
ll
+
ll\
OO\
l\
OOlOO\
OO\

.
Cro\
ss\

(
llOOlO\
OlOOll\

[
lOOOll\
OOO\
l\

]
-
lll\
OllO\
llll
.
GetCenterOf\
M\
ass
(
)
)
;
llOO\
lO\
O\
l\
Oll\
O\

+=
lll\
O\
llO\
ll\
lO
.
GetVelocityAt\
Wo\
rldPosit\
ion
(
ll\
O\
OlO\
OlO\
Ol\
l
[
lOOOl\
l\
OOOl
]
)
;
ll\
OO\
lOO\
lOl\
l\
O
-=
lllO\
llO\
l\
lll
.
GetVelo\
ci\
ty\
AtWorldPositio\
n
(
llO\
OlO\
O\
lO\
Oll
[
lO\
O\
OllO\
OOl
]
)
;
llOOl\
OOlOlOl
[
lO\
OO\
l\
lOOOl
]
=
ll\
OOlOO\
lOllO
.
Dot\

(
llOO\
lO\
OlO\
lOO
[
lO\
OOllOOOl
]
)
;
}
lOllO\
lO\
Olll\
l
->
Clear
(
)
;
lO\
ll\
Ol\
OOllll\

->
ll\
O\
OO\
OOl\
lOlO
(
lllOl\
lOl\
llO
.
Ge\
tInverseMass
(
)
,
lllO\
llOlll\
O\

.
GetWorld\
SpaceInverseIner\
t\
i\
a
(
)
)
;
lO\
l\
lOlO\
O\
llll
->
llOO\
OOOllOlO
(
ll\
lO\
llOlll\
l
.
GetInve\
rs\
e\
Mas\
s
(
)
,
lllO\
ll\
Ol\
lll
.
Get\
Wor\
l\
dSp\
aceInver\
seInertia
(
)
)
;
int
ll\
OO\
OOlO\
O\
OOO
=
lO\
llO\
lO\
Ollll
->
llO\
OOOlO\
OO\
Ol\

(
llOOlO\
OlO\
OlO
,
0
,
1
,
lOllOlO\
lOO\
ll\

::
ll\
OOO\
O\
OllllO
|
lOllOlO\
lOOll
::
ll\
O\
OOOOlllOl
)
;
fo\
r
(
lO\
O\
O\
llOOOl
=
0
;
lOOOllO\
OO\
l
<
llOOlO\
O\
l\
OOl\
O
;
lOOOll\
O\
O\
Ol\

++
)
{
lOl\
l\
OlOOllll
->
llO\
O\
OOlOOOlO
(
ll\
O\
OOOl\
OOOOO\

,
lO\
OO\
l\
l\
OOOl
,
ll\
OOlOOlOl\
OO\

[
lOO\
O\
llOOO\
l\

]
,
llOOlOOlOlOO
[
lOOOl\
lOOO\
l
]
.
Cr\
os\
s
(
ll\
OOlOO\
l\
OOll
[
lO\
OO\
llOO\
Ol
]
-
ll\
lOl\
lOlllO\

.
GetC\
en\
t\
er\
O\
fMass\

(
)
)
,
-
llOO\
l\
O\
OlOlOO\

[
lOOOll\
O\
O\
Ol
]
,
-
llO\
O\
lO\
Ol\
O\
lOO\

[
lOOOll\
O\
OOl\

]
.
Cross
(
llOOl\
OOlOO\
ll
[
lO\
OO\
l\
lO\
O\
Ol\

]
-
ll\
lOll\
Oll\
ll\

.
GetCenterOfMass
(
)
)
)
;
}
lOllOlOO\
l\
lll
->
llOOO\
Ol\
OOOl\
l
(
)
;
fo\
r
(
lOOO\
l\
lOOOl\

=
0
;
lO\
OOllOO\
O\
l
<
llO\
OlOOlOOlO
;
lO\
OOl\
lOOOl
++
)
{
lOl\
l\
OlOOl\
l\
ll
->
llOO\
OOl\
O\
Oll\
O
(
ll\
O\
OOOlO\
OOO\
O\

,
lOOO\
llOOO\
l
,
llOOlO\
OlOlOl
[
lOOO\
llO\
OOl
]
)
;
}
if
(
lO\
llOlOOl\
lll
->
llO\
O\
OO\
lOllOO
(
)
)
{
fo\
r
(
lOOOllOOOl
=
0
;
lO\
OOl\
lO\
O\
Ol
<
ll\
OOl\
OO\
lOOlO
;
lOO\
Oll\
OOO\
l
++
)
{
float
lO\
llO\
OlOlOO
=
lO\
llOlOOll\
l\
l
->
Ge\
tI\
mpu\
l\
se
(
llOOOOl\
OOOO\
O
,
lOO\
O\
llOOO\
l
)
;
lllO\
llO\
lll\
O
.
Apply\
Impulse
(
1.0f
*
lOll\
OO\
lO\
l\
OO
*
llO\
OlO\
OlOlO\
O\

[
lO\
OOll\
OOO\
l\

]
,
llOOl\
OOlO\
Oll
[
lOO\
OllOOOl
]
)
;
lllOllOllll
.
App\
lyI\
mpuls\
e
(
-
1.0f
*
lOllOOlO\
l\
OO
*
ll\
OOlO\
OlOlOO
[
lOOOl\
lOOOl
]
,
llOOlOO\
lOOll
[
lOOOll\
OOOl
]
)
;
}
}
}
void\

Phy\
sics
::
llOOOO\
O\
OO\
llO
(
)
{
if
(
(
lllO\
llO\
OOO
&
lO\
lllO\
O\
l\
Oll\
l\

)
==
0
)
re\
turn\

;
for
(
int
lO\
OOl\
lOOOl
=
0
;
lOOOllO\
O\
Ol
<
lOOllOllllOO
->
lOlOll\
llOlOO
&&
lOllOlOllO\
ll
->
lOllllOlOO\
OO
(
)
+
64
>
lOOl\
lOll\
llOO\

->
lOlOllllOOll
;
lOOOllOOOl
++
)
{
float
ll\
OOlOOOO\
lO\
l\

=
-
k_fM\
a\
xFloa\
t
;
Dyn\
a\
mic\
Object\

*
llOOlOO\
OOll\
O
=
0
;
lOlll\
O\
lOll\
OO
lO\
lll\
OlllO\
l\
O\

=
lOl\
lOlO\
ll\
llO
.
lOlO\
OOOlO\
O\

(
)
;
for
(
;
!
lOll\
lOlllOlO
.
AtE\
nd
(
)
;
++
lOlllOl\
llO\
l\
O
)
{
Dyna\
mi\
cObject
&
lOllO\
l\
Oll\
OlO\

=
*
*
lOll\
l\
OlllOlO
;
if
(
lOllOl\
Oll\
OlO
.
lOlOOOlOOO\
OO
(
)
&&
!
lOllOlO\
llOlO
.
GetColli\
sio\
n\
Ite\
rator
(
)
.
AtEn\
d
(
)
)
{
float
llO\
Ol\
OO\
OOlll
=
lOl\
lOlOl\
l\
Ol\
O
.
lOlO\
Ol\
llOOll
(
)
;
if
(
llOOl\
O\
OOOlO\
l
<
llOOlOO\
OOll\
l\

&&
!
lOl\
lOlOll\
OlO
.
lOlOOOlOO\
O\
Ol\

(
)
)
{
llOOl\
OO\
OOlOl\

=
llOOlOOOOlll
;
llOO\
l\
OOOO\
llO
=
&
lOllOl\
OllOlO\

;
}
}
}
if
(
llOOlOOO\
OllO
)
{
llO\
O\
l\
OOOOllO
->
lO\
O\
lll\
O\
OlO\
l\
O\

(
tru\
e\

)
;
llOO\
l\
OOOOl\
lO
->
lOl\
OOlOlOOOl
(
true
)
;
llOO\
lO\
OO\
OllO\

->
lOlOOOOlllll
(
)
;
}
else
{
flo\
at
llO\
OlO\
OOl\
OOO
=
k_fMa\
xF\
l\
oat
;
lOll\
l\
Ol\
llOlO
=
lOllOl\
Ol\
ll\
lO
.
lOlO\
OOOl\
O\
O
(
)
;
for
(
;
!
lOlllOl\
ll\
Ol\
O
.
AtEnd
(
)
;
++
lO\
l\
ll\
Olll\
O\
l\
O
)
{
Dynami\
cO\
b\
je\
ct
&
lO\
llO\
lO\
l\
lOlO
=
*
*
lOll\
lOlllOlO
;
if
(
!
lOllOlOllO\
l\
O
.
GetCol\
li\
sion\
Iterator
(
)
.
At\
E\
nd\

(
)
&&
!
lOllOlOll\
O\
l\
O
.
lOl\
O\
OOlOOOOl
(
)
)
{
flo\
at
llOOl\
OOOlOOl
=
lOll\
OlOllOlO
.
lO\
lO\
Oll\
lO\
ll\
O
(
)
.
Ge\
tMagnit\
udeSq\
rd
(
)
+
lOllOl\
OllO\
lO
.
lOlOOlll\
Olll
(
)
.
Get\
Magni\
tudeSq\
r\
d
(
)
;
if
(
llOOlO\
OOl\
OO\
O
>
ll\
OOlOO\
OlOOl
)
{
ll\
O\
Ol\
OOOl\
OO\
O
=
llOOl\
OO\
OlOO\
l\

;
ll\
OOlOOOOllO
=
&
lOl\
lO\
lOllOlO
;
}
}
}
if\

(
llOOlO\
OOO\
llO
)
{
ll\
OO\
lOOOO\
llO
->
lO\
OlllO\
O\
lOlO\

(
tru\
e\

)
;
llOO\
lOO\
OOl\
l\
O
->
lO\
lOO\
l\
OlOOOl
(
true
)
;
llOOlOO\
OO\
llO\

->
lOl\
OOO\
Oll\
lll
(
)
;
}
else
{
bre\
ak
;
}
}
}
}
bool
Ph\
ysi\
c\
s\

::
lOll\
lllOOll\
l
(
Co\
ll\
isio\
n\

&
lOll\
Oll\
O\
ll\
l\

,
vo\
id
*
llO\
Ol\
OOl\
Ol\
ll\

)
{
TA\
_ASS\
ERT\

(
ll\
OOl\
OOl\
O\
l\
ll
)
;
lOllO\
Olll\
lO\
O
&
lO\
OOOOlOOlO\

=
*
(
(
lOllO\
OllllOO
*
)
llOO\
lO\
O\
lO\
ll\
l\

)
;
Physics
*
lOllOll\
OOOl\

=
lO\
OO\
OOlOO\
lO
.
lOlOllllOOlO
;
lOllOll\
Olll
.
SetObjectA
(
lO\
OOOOlOOlO
.
lO\
lOOOOOll\
Ol
)
;
lOll\
O\
llOlll
.
SetObje\
c\
t\
B
(
lOOOOO\
lO\
O\
lO\

.
lO\
lO\
O\
OOO\
l\
llO\

)
;
for
(
Colli\
si\
on
*
lO\
OOOO\
lOOO\
l
=
lOl\
lOll\
Ol\
ll
.
Ge\
tN\
ext\

(
)
;
lO\
OOOOlOOOl
;
lOO\
OO\
OlOO\
Ol
=
lOOOO\
OlO\
OOl\

->
Get\
N\
e\
xt\

(
)
)
{
lOO\
OOOlOOOl\

->
SetObjec\
tA
(
lO\
O\
OOOl\
OO\
lO
.
lO\
lOOO\
O\
O\
l\
l\
Ol
)
;
lO\
OO\
OOlO\
OOl
->
Set\
Objec\
tB
(
lOO\
O\
OO\
l\
OOl\
O\

.
lOlOO\
OOOl\
llO
)
;
}
TA\
_ASSE\
RT\

(
lOllOll\
O\
OOl\

)
;
TA\
_\
ASSER\
T
(
lOl\
l\
Ol\
lOl\
l\
l\

.
ll\
lOlllll\
O
>=
0.0f
)
;
TA_\
A\
S\
SE\
RT
(
lOllOllOlll\

.
lllOlllllO
<=
1.0f
)
;
TA_ASS\
E\
R\
T
(
Flo\
atI\
sOK
(
lO\
llO\
llOl\
l\
l
.
lOl\
lO\
O\
lOOll
)
)
;
TA_\
A\
S\
SE\
RT\

(
Floa\
tIsOK\

(
lOllOl\
l\
Ol\
ll
.
lOOOlOOO\
OO\

.
x
)
)
;
TA_ASSER\
T
(
Floa\
tI\
s\
OK\

(
lO\
llO\
llOll\
l
.
lO\
OOlOOO\
OO
.
y
)
)
;
TA_AS\
S\
ERT
(
Floa\
tI\
sOK
(
lOllOll\
Olll\

.
lOOOl\
OOOO\
O
.
z
)
)
;
TA\
_\
ASSERT
(
lOl\
lOllO\
lll
.
lOOOlOOOOO
.
IsNorma\
li\
sed
(
)
)
;
flo\
at\

lOl\
l\
OOlOlOl
=
0.0f
;
DynamicOb\
je\
ct
*
ll\
OOlOOl\
lOOO
=
0
;
int
ll\
OO\
lOOll\
O\
O\
l\

=
0
;
if
(
lOll\
OllO\
lll
.
GetTy\
pe
(
)
==
Collis\
ion
::
lOll\
O\
lOOlO\
O\

)
{
TA_\
ASSERT
(
lO\
l\
lOllOl\
ll
.
lOl\
lOOOllll
)
;
TA_\
ASS\
ERT
(
lOllO\
ll\
Olll
.
lOll\
OO\
l\
OO\
O\
O\

)
;
TA_ASSER\
T
(
lO\
ll\
OllO\
ll\
l
.
lOll\
OOO\
llll
->
Get\
CollisionO\
bjec\
t\
T\
ype
(
)
==
Collision\
Objec\
t
::
TYPE\
_L\
I\
NE_LI\
ST
||
lOllOll\
Olll
.
lOllOOl\
O\
OO\
O\

->
Get\
Co\
ll\
isionOb\
je\
c\
tT\
yp\
e
(
)
==
Collisi\
onObjec\
t\

::
TYPE_\
LI\
NE\
_L\
IS\
T
)
;
TA_ASS\
E\
RT
(
lOll\
Ol\
l\
O\
ll\
l
.
lOllOOOlll\
l
->
GetC\
ollisionObj\
e\
ctType
(
)
!=
Col\
lisi\
onObjec\
t
::
TYPE_LINE\
_L\
I\
S\
T
||
lO\
l\
lOll\
O\
ll\
l
.
lOl\
lOOlOOOO\

->
Ge\
t\
Col\
li\
s\
io\
nObj\
ect\
T\
yp\
e
(
)
!=
CollisionObject
::
TYPE_\
L\
I\
NE_LIS\
T
)
;
if\

(
lOll\
Oll\
Olll
.
lOllOOl\
O\
OOO\

->
GetC\
oll\
i\
sio\
nObj\
ectType
(
)
==
Collision\
Obj\
ect\

::
TYPE_LI\
NE\
_LIST
)
{
lOllOllOl\
ll
.
lOllOl\
O\
llO\
O
(
)
;
lOl\
l\
Ol\
lOlll\

.
lO\
OOlOOOOO
*=
lOllOllOlll
.
GetObjectA
(
)
->
GetFr\
ame
(
)
.
m33Rotatio\
n
;
lOllOll\
Ol\
ll
.
lO\
OOlOOOOO\

=
-
lO\
ll\
OllOl\
l\
l\

.
lO\
OOlOOO\
O\
O\

;
}
el\
s\
e
{
lOll\
OllOlll
.
lOOOO\
lllll\

*=
lOll\
Ol\
lOll\
l
.
Ge\
tO\
bjectB\

(
)
->
GetFrame\

(
)
;
lOl\
l\
O\
llOl\
ll\

.
lOOO\
O\
l\
l\
l\
ll
/=
lO\
l\
l\
Ol\
lOlll
.
Ge\
tO\
bje\
ct\
A
(
)
->
Get\
F\
rame
(
)
;
lOllO\
llOll\
l
.
lO\
OOlOO\
OOO
*=
lOllOllOl\
ll
.
GetO\
bj\
ectB\

(
)
->
Get\
Frame\

(
)
.
m33Ro\
ta\
t\
ion
;
lOllOllOll\
l
.
lOOOl\
O\
O\
O\
O\
O
=
-
lOllO\
llOlll
.
lOO\
O\
lOOOO\
O
;
}
TA_A\
S\
S\
ERT
(
lOllOllOl\
ll
.
lOllOOOlll\
l
->
Ge\
tCo\
ll\
isionObjectTy\
pe
(
)
==
Collisio\
nObject\

::
TYPE_LIN\
E_LI\
ST\

)
;
if
(
lOl\
lOl\
lO\
OOl
->
lOlllOOllOll
&&
!
lOll\
OllO\
OO\
l
->
lOlll\
OOl\
lOll\

(
(
PreCo\
l\
li\
sio\
n
&
)
lO\
llOllOl\
l\
l
)
)
re\
turn
tru\
e
;
if
(
lOl\
lO\
l\
l\
O\
lll
.
GetOb\
je\
ctA
(
)
->
Gho\
st
(
)
||
lOl\
lOllOlll
.
GetObj\
ectB\

(
)
->
Ghost
(
)
)
return
false
;
lOllOllO\
l\
l\
l
.
Ge\
t\
O\
b\
je\
ctA
(
)
->
lOOllllOll\
l\
O\

(
lOllOll\
Oll\
l
.
lOllOOlOOOl
,
lOl\
lO\
llOlll\

.
Ge\
tO\
bjectB
(
)
,
lOllOllO\
l\
ll
.
lOl\
lOO\
lOOOO\

,
lOllO\
l\
lOlll
.
lOll\
OOlOOlO\

,
lOllOll\
Oll\
l\

.
lOllO\
Ol\
OOll\

,
lOl\
lO\
llOlll
.
lOOOOlllll
,
lOl\
lOll\
Olll
.
lOOOlO\
OOOO
)
;
retu\
rn
tr\
ue
;
}
if\

(
lOllOll\
Oll\
l
.
GetObj\
ec\
tA
(
)
->
Mo\
veme\
ntDisable\
d\

(
)
||
lOl\
lOll\
O\
lll
.
GetObjectA
(
)
->
Infin\
i\
t\
eMass
(
)
)
lOll\
Oll\
Ol\
ll
.
lOlOllOO\
ll
|=
Col\
lisi\
on
::
FLAG_OBJECT\
A_SOLID
;
if
(
lOl\
lOllO\
l\
ll\

.
GetObjec\
tB\

(
)
->
Moveme\
ntD\
isab\
led
(
)
||
lOllOllO\
lll
.
GetO\
bje\
ctB
(
)
->
Infi\
ni\
teMass
(
)
)
lO\
ll\
Ol\
lO\
ll\
l
.
lOlOl\
lOOl\
l\

|=
Collisi\
on
::
FLA\
G_\
O\
BJE\
CTB_S\
OLID\

;
if
(
(
lOl\
lOll\
Olll
.
lOlOll\
OO\
ll
&
(
Coll\
is\
ion
::
FLAG_OBJE\
CTA_SOL\
ID
|
Col\
l\
ision
::
FL\
AG_OB\
J\
ECT\
B_SOLID
)
)
==
(
Collis\
io\
n
::
FLA\
G_\
OBJ\
ECTA\
_\
SOLID
|
Collision
::
FLAG_OBJECT\
B\
_SOLID
)
)
return\

fal\
se\

;
Dy\
n\
ami\
c\
Object
*
cons\
t
lOlO\
OOOOllO\
l
=
lOl\
l\
OllOlll\

.
GetObjectA
(
)
;
Dyna\
micOb\
ject
*
cons\
t\

lOl\
OOOOO\
lllO
=
lOll\
Oll\
Olll
.
Ge\
tObjectB
(
)
;
u3\
2
llOOlOOll\
OlO
=
0
;
#ifdef lOllOOlOlOOO
{
const\

float
llOO\
l\
OOllO\
ll\

=
0.2f
;
if
(
(
lOlOO\
OO\
OllOl
->
ExtraStability
(
)
||
lOlO\
O\
O\
O\
O\
lllO\

->
Ex\
traS\
t\
ab\
ilit\
y
(
)
)
&&
lOlO\
OO\
OOllO\
l
->
Get\
Lin\
earV\
elo\
city
(
)
.
Ge\
tMagni\
tudeSq\
rd
(
)
<
llOOlOO\
llOll
&&
lOlOOOOO\
llOl\

->
GetAngularVel\
ocity
(
)
.
GetMagnitude\
Sqrd
(
)
<
llOO\
lOOll\
O\
ll
&&
lOl\
OOOO\
Ol\
l\
lO\

->
GetL\
inear\
Veloc\
ity
(
)
.
GetMagn\
itudeS\
qrd
(
)
<
llOO\
l\
OOllOll
&&
lOl\
O\
O\
O\
OOlllO
->
Get\
AngularVelo\
cit\
y
(
)
.
GetM\
agni\
tud\
eSqrd
(
)
<
llOOlOOllOll
)
{
llOO\
lOO\
llOlO\

|=
Collisio\
n
::
FLAG_DI\
SABL\
E_P\
U\
SHOUT
;
}
}
#endif //
swi\
tch
(
lOllOl\
lOl\
ll\

.
GetType
(
)
)
{
ca\
s\
e\

Co\
l\
l\
isi\
on
::
lOll\
O\
lO\
OOOl
:
ll\
O\
OlOOllOlO
|=
Co\
llision\

::
FLAG_CO\
NSTRA\
IN_I\
N\
_B\
OT\
H_DIRE\
CTIONS
|
Collision\

::
FL\
AG_JO\
IN\
T\

|
Co\
ll\
isi\
on
::
FL\
AG\
_\
N\
O_FRIC\
TIO\
N
;
ca\
se
Co\
ll\
ision
::
TYPE\
_RO\
TATION\
_\
CONSTRAINT\

:
case
Coll\
ision
::
lO\
l\
l\
OlOOOll
:
cas\
e
Col\
lision
::
lO\
llOlO\
OO\
lO\

:
if
(
lOll\
O\
l\
lO\
ll\
l
.
GetTy\
p\
e
(
)
==
Col\
lisio\
n
::
TY\
PE\
_R\
OTAT\
I\
ON\
_C\
ONSTRAINT\

)
llOOlOOllO\
lO
|=
Co\
llis\
ion
::
FLAG_R\
OTATION_\
CO\
NS\
TRAINT
|
Co\
llis\
i\
on
::
FLA\
G_N\
O_FRICT\
IO\
N
;
el\
se\

if
(
lO\
l\
lOllO\
lll
.
GetTyp\
e
(
)
==
Co\
l\
l\
i\
sion\

::
lO\
llOlO\
OOll\

)
llOOlO\
OllOlO
|=
Colli\
sio\
n
::
FLA\
G\
_ROT\
ATIO\
N_CONS\
T\
RAINT
|
Co\
l\
lision\

::
FLAG_N\
O\
_\
FRI\
CTI\
ON
;
el\
s\
e
if
(
lOl\
lOll\
O\
l\
ll
.
GetTyp\
e
(
)
!=
Coll\
isi\
on
::
lOl\
l\
OlOO\
OOl
)
llOOlO\
O\
llOlO\

|=
Co\
llis\
i\
o\
n
::
FL\
AG_J\
OINT\
_LIM\
IT\

|
Co\
ll\
ision
::
FLAG\
_NO_F\
RI\
C\
TIO\
N
;
break
;
de\
fault
:
TA_\
ASS\
ERT
(
lOllOllO\
lll
.
Get\
Ne\
xt
(
)
==
0
)
;
lOllOOlOlOl
=
0.0f
;
if\

(
lOlOO\
OOOl\
l\
O\
l
->
GetCo\
llisionObjec\
tCo\
mplex\

(
)
)
lOll\
OO\
l\
OlOl
+=
lOllOll\
OOO\
l\

->
Get\
Sur\
face\
A\
tt\
r\
i\
bute
(
lOllOllOl\
l\
l
.
lOllO\
O\
lOOOl
)
.
Get\
Restit\
ution
(
)
;
el\
se
lOllOOlOl\
Ol
+=
lOl\
OO\
OOOl\
lO\
l
->
GetR\
es\
ti\
tut\
ion
(
)
;
if\

(
lOlOOOOO\
lllO\

->
GetC\
o\
llision\
Ob\
jec\
tComplex
(
)
)
lOllOOl\
OlOl
+=
lO\
ll\
Ol\
l\
OOO\
l
->
GetSu\
rfaceAt\
tribu\
te
(
lO\
l\
lO\
llOlll
.
lOl\
lO\
OlOO\
lO\

)
.
GetRe\
st\
ituti\
on\

(
)
;
else
lOll\
OOl\
OlOl
+=
lOlOOOOOlllO
->
GetRest\
ituti\
on\

(
)
;
lOl\
lOl\
lO\
lll
.
lOO\
OOlllll
*=
lO\
OOOOl\
OO\
lO\

.
lO\
lOOOOOlllO
->
GetFrame
(
)
;
lOllOll\
O\
l\
ll
.
lOOO\
lOO\
O\
OO\

*=
lOO\
OOOlO\
O\
lO
.
lO\
l\
O\
O\
OOOlllO
->
Get\
Fra\
me
(
)
.
m33Rota\
t\
ion
;
if
(
lOlOOOOOllOl
->
Gho\
st
(
)
||
lOl\
OOOOOlllO\

->
Gh\
ost
(
)
)
{
if
(
!
lO\
llOllO\
OOl
->
lOlll\
OOllOl\
l
||
lOl\
lOllO\
OOl
->
lOll\
lOOl\
lOl\
l
(
(
PreCol\
lision
&
)
lOl\
lOllO\
lll
)
)
{
lOl\
lOllOOOl\

->
lO\
ll\
O\
lOllOll\

->
llOOlOO\
l\
llOO
(
*
lO\
OOOO\
lOOl\
O
.
lOlOOOOOllOO
,
lOllOl\
lOl\
ll\

)
;
}
re\
tu\
rn
tr\
ue
;
}
break
;
}
flo\
at
lOllO\
Ol\
O\
llO
=
FastMin
(
lOlOOOOOllOl\

->
Get\
Fric\
ti\
on
(
)
*
lOll\
OllO\
OOl
->
GetSurf\
aceAttribute\

(
lOl\
lOl\
lOlll
.
lOllO\
O\
lO\
OOl
)
.
Ge\
tC\
ollisi\
onF\
rictio\
n
(
)
,
lOlOOO\
O\
O\
llOl
->
GetF\
riction
(
)
*
lO\
llO\
llO\
OOl
->
GetSurfa\
ceA\
ttr\
i\
but\
e
(
lO\
l\
l\
OllOl\
ll
.
lOl\
lOO\
lO\
OlO
)
.
GetCo\
lli\
sionFr\
ict\
ion
(
)
)
;
lO\
ll\
OOlO\
llO\

*=
0.4f
;
#ifdef TA_DYNAMIC_OBJECT_GROUP_ENABLED
if
(
lO\
lOO\
OOOll\
Ol
->
GetDyna\
mi\
c\
O\
bj\
e\
ctGrou\
p
(
)
)
lO\
lOOOOOllOl
=
lOlOOOOO\
ll\
Ol
->
Get\
Dyna\
mic\
ObjectGrou\
p
(
)
;
if
(
lOlOOO\
OO\
lll\
O
->
GetDy\
n\
amicObjec\
tGr\
oup
(
)
)
lO\
lO\
OOOOl\
l\
lO
=
lO\
lO\
OOOOlll\
O
->
Ge\
tDyna\
mic\
O\
b\
j\
ectGroup
(
)
;
#endif //
lOl\
lOll\
O\
l\
l\
l
.
lOl\
lOOlOlOl
=
lOl\
lOOl\
OlO\
l
*
0.5f
;
Clamp
(
lO\
llOll\
Olll
.
lOllOOlOlOl\

,
0.0f
,
1.0f
)
;
lO\
llOl\
lOl\
ll\

.
lOllOOl\
Ol\
lO
=
lO\
l\
l\
O\
OlOllO
;
lO\
llOllOlll\

.
lO\
lOllO\
Oll
|=
llO\
OlOOll\
OlO
;
fo\
r
(
Col\
li\
sio\
n\

*
lOO\
O\
O\
OlOOOl\

=
lOll\
OllO\
l\
ll
.
GetNext\

(
)
;
lOOO\
OOl\
OOOl
;
lOOO\
O\
OlOOO\
l
=
lOOO\
OOlOOO\
l
->
GetN\
ex\
t
(
)
)
{
lOOOOO\
lO\
OOl
->
lO\
ll\
OOlOl\
Ol
=
lOllOllO\
lll
.
lOllOOlOlOl
;
lOOOOOlOOOl
->
lO\
ll\
O\
O\
lO\
l\
lO
=
lOllOll\
Ol\
ll
.
lO\
llO\
OlO\
l\
lO
;
lOO\
OOOlOOOl
->
lOlO\
l\
lO\
Oll
|=
llOO\
lO\
OllOlO\

;
}
if
(
lOllOllOOO\
l
->
lOl\
l\
lO\
Ol\
lOl\
l
&&
!
lOllOl\
lOOOl
->
lOlll\
OOllOll
(
(
Pr\
eCo\
llisi\
on
&
)
lOllOl\
l\
Oll\
l
)
)
retu\
rn
true
;
if
(
(
lOllOll\
Ol\
ll
.
lOlO\
l\
l\
OOll
&
(
Colli\
si\
o\
n
::
FLAG\
_OBJECT\
A_SO\
LI\
D\

|
Coll\
is\
i\
on\

::
FLAG\
_OB\
JECT\
B_\
SOL\
I\
D
)
)
==
(
Colli\
si\
o\
n
::
FLA\
G_O\
BJECTA_S\
OL\
ID\

|
Collision
::
FLAG\
_O\
BJE\
CTB_SOLI\
D\

)
)
retur\
n
tru\
e\

;
if\

(
lOll\
Ol\
lOOO\
l
->
ll\
lOll\
OOOO
&
lOllllOO\
l\
l\
O\
O\

)
{
if
(
!
lOl\
l\
O\
l\
lOlll\

.
Ge\
t\
Obje\
ct\
A
(
)
->
In\
f\
i\
nit\
eMa\
ss
(
)
&&
!
lOl\
lOllOlll\

.
Get\
Object\
A
(
)
->
Moveme\
ntDisabled
(
)
)
{
lO\
llOllOlll
.
GetOb\
jectB\

(
)
->
lOlOOOlOlOll
(
lO\
llOllOlll
.
GetObje\
ctA
(
)
)
;
if
(
!
lOl\
lOll\
Olll
.
Get\
Ob\
jectA
(
)
->
lOOl\
O\
OO\
l\
lOl
(
)
&&
!
lOllO\
llOlll
.
GetObjectA
(
)
->
IsI\
nMovi\
ngLi\
st
(
)
&&
lOl\
lOl\
lOlll\

.
Ge\
tObject\
A
(
)
->
lOlOO\
llOlOll
(
)
!=
lOllOllOOOl\

->
lOllO\
llOO\
l\
lO
)
{
lOl\
lOllO\
lll
.
Ge\
tObjectA
(
)
->
lO\
lO\
OllllOll\

(
lO\
l\
lOl\
lOOOl
->
lOll\
lOO\
OllO\
O
)
;
lOl\
lO\
llO\
OOl\

->
lOlll\
OOOll\
OO
=
lO\
llO\
llO\
ll\
l
.
Ge\
tO\
b\
jectA\

(
)
;
lOll\
Ol\
lOlll
.
Ge\
tObje\
ctA\

(
)
->
lOl\
OO\
lOll\
Oll
(
true
)
;
lOllOllOl\
l\
l\

.
GetObj\
ectA\

(
)
->
lOlOOllOllOO
(
lO\
l\
l\
OllOOOl
->
lOllOllOO\
ll\
O
)
;
}
}
if
(
!
lOl\
lO\
llO\
lll
.
GetO\
bjec\
t\
B\

(
)
->
Infi\
n\
ite\
M\
ass\

(
)
&&
!
lO\
llOllOlll
.
GetO\
b\
j\
ect\
B
(
)
->
Move\
mentDi\
sabled
(
)
)
{
lOllOllOlll
.
GetOb\
jec\
tA\

(
)
->
lOlOOOlOlOll\

(
lOllOllOlll
.
GetOb\
jectB
(
)
)
;
if
(
!
lO\
ll\
OllOl\
ll
.
GetObj\
e\
c\
tB
(
)
->
lOOl\
OOOll\
O\
l\

(
)
&&
!
lOll\
Oll\
Ol\
ll\

.
Get\
O\
bjec\
tB
(
)
->
IsI\
nM\
ovingList
(
)
&&
lOllOllOl\
l\
l
.
GetO\
b\
je\
ct\
B\

(
)
->
lOlOOllOlO\
l\
l
(
)
!=
lOllOllO\
O\
Ol
->
lOll\
Ol\
lOOllO
)
{
lOll\
Oll\
Olll
.
Get\
O\
bjectB
(
)
->
lO\
lOOllll\
Ol\
l\

(
lOllOl\
l\
OOOl
->
lO\
lllOOOllOO\

)
;
lOll\
OllO\
OOl\

->
lOll\
lOO\
Oll\
OO\

=
lO\
ll\
OllOlll
.
GetObj\
ectB\

(
)
;
lOl\
lO\
llOlll
.
Ge\
tObjectB
(
)
->
lOlOOlOll\
Oll
(
true
)
;
lOllO\
ll\
Ol\
ll
.
GetObj\
ec\
tB\

(
)
->
lOlOO\
llOll\
OO
(
lOllOllOOO\
l
->
lOllOl\
lOO\
ll\
O
)
;
}
}
}
TA\
_ASSERT
(
lO\
OOOOlOOlO
.
lOl\
OOOO\
Ol\
l\
OO
)
;
Co\
l\
l\
is\
io\
n
*
llOl\
l\
OlOlll
=
lO\
llOl\
lO\
O\
Ol
->
lOll\
Ol\
O\
ll\
Oll
->
ll\
OO\
OOll\
ll\
Ol\

(
*
lOO\
OO\
OlOOlO\

.
lOlO\
OOOOl\
lOO
,
lO\
ll\
OllOl\
l\
l\

)
;
if
(
llOl\
lO\
lOlll\

)
{
lOllO\
llOOOl
->
llOOOOlOO\
l\
l\
l\

(
lOllOl\
lO\
OOl\

->
lOOll\
O\
l\
ll\
l\
O\
O
->
lO\
lOlllllOOO\

,
*
llOll\
OlO\
ll\
l
)
;
for\

(
Col\
lision\

*
lO\
OOO\
O\
lOOOl\

=
lO\
llO\
llOl\
ll
.
Ge\
tNext
(
)
;
lOO\
OOOlOOOl
;
lO\
O\
OOOlOOOl
=
lO\
OOOO\
lOOOl
->
GetNext\

(
)
)
{
TA_\
AS\
SER\
T
(
lOOOOOlOOO\
l
->
lllOlllll\
O
>=
0.0f
)
;
TA_ASSERT
(
lOOOOOlOOOl
->
lllOlll\
llO\

<=
1.0f
)
;
TA\
_ASS\
ERT
(
Floa\
t\
IsOK
(
lOllO\
llOl\
ll
.
lOll\
OOlO\
Oll\

)
)
;
lO\
l\
lOllOOOl
->
lOllO\
lOllOll\

->
llOOl\
OOlll\
Ol
(
*
llOllOl\
Olll
,
*
lOO\
OOOlOO\
Ol\

)
;
lOllOllO\
OOl\

->
ll\
OOO\
O\
l\
OO\
l\
ll
(
lO\
llOllO\
O\
Ol
->
lOOllOllll\
OO
->
lOl\
Oll\
ll\
lOOO
,
*
llOl\
l\
Ol\
Oll\
l\

->
Get\
N\
ext
(
)
)
;
}
}
else
{
retu\
r\
n
true
;
}
#ifdef lOllOOlOOlll	
if
(
lOllO\
ll\
O\
OOl
->
lllOll\
OOOO\

&
llOOOOlllll\
O
)
{
for
(
Colli\
s\
ion
*
lO\
OOOOl\
O\
OOl
=
llOll\
O\
lO\
lll\

;
lO\
OOO\
O\
lOOOl
;
lOOOO\
O\
lOOO\
l
=
lOO\
OOOlO\
OO\
l
->
GetNe\
xt
(
)
)
{
Ph\
y\
sic\
s\
Re\
n\
d\
e\
r\

::
Ren\
d\
erAr\
row\

(
lOOOOOl\
O\
OO\
l\

->
lO\
OOOlll\
ll
,
lOO\
OOO\
lOOOl
->
lOO\
OlOO\
O\
OO
*
2.0f
,
0xffff0000
)
;
}
}
#endif //
retur\
n
true
;
}
void
Physics
::
lOllllOlO\
O\
ll\

(
Spa\
ceDi\
vision\
O\
bje\
ct
&
llOOOOOOOO\
O
,
void
*
ll\
OOlOOlO\
lll\

)
{
TA_\
ASSERT\

(
llOO\
l\
O\
OlOlll
)
;
lOllOOllllOO
&
lOO\
OOOlOO\
l\
O
=
*
(
(
lO\
llOOllllOO
*
)
llOO\
lOO\
l\
Oll\
l
)
;
TA_A\
SSERT
(
lOOOOOl\
O\
OlO
.
lOlOOOOOllOl
)
;
TA_ASSERT\

(
lOOO\
O\
O\
lOO\
l\
O
.
lOlOOO\
OOlll\
O
==
0
)
;
Dyn\
amicObj\
ect\

*
lO\
l\
O\
OOO\
Ol\
l\
Ol
=
lOOOOOlOOlO
.
lO\
lOOO\
O\
Oll\
Ol\

;
Dyn\
amicObject\

*
lO\
lOOO\
OO\
ll\
l\
O
=
(
Dy\
nami\
cObj\
e\
ct
*
)
&
llO\
OOOOOOOO
;
#ifdef llOOlOOllllO
Physic\
sRende\
r
::
Rend\
erLine
(
lO\
lllO\
llOO\
lO
->
Ge\
tPositi\
on
(
)
,
lO\
lll\
Ol\
lO\
Oll\

->
Ge\
tPosition
(
)
,
0xFF00FF00
)
;
#endif //
if
(
lOlOOOO\
O\
llOl
->
Get\
World\
AA\
B\
B
(
)
.
Intersec\
ts
(
lOlOO\
OO\
OlllO
->
Ge\
tW\
orl\
dAA\
BB
(
)
)
&&
lOl\
OOOOOll\
O\
l
->
lOlOOllOlOlO
(
)
!=
lOlO\
OOOOl\
l\
l\
O
->
lOlOOllOl\
OlO
(
)
&&
lOlOOOO\
Ol\
l\
O\
l
->
IsA\
llo\
we\
dT\
o\
CollideWith\

(
*
lOlOOO\
OO\
lllO
)
&&
!
lO\
lO\
O\
OOO\
lll\
O\

->
Colli\
si\
on\
Di\
s\
ab\
led
(
)
)
{
#ifdef TA_DYNAMIC_OBJECT_GROUP_ENABLED
if\

(
lOlO\
OOO\
OllOl
->
GetDyn\
amicO\
bj\
e\
c\
tGr\
oup
(
)
&&
lOlOOO\
OOllO\
l
->
GetDyna\
micObjectGroup
(
)
==
lO\
lOOOOOll\
lO
->
GetDynam\
icO\
bjectGrou\
p
(
)
)
{
lOlOOOOOll\
lO
=
0
;
retur\
n
;
}
#endif //
TA_AS\
SERT
(
lO\
lO\
OO\
OOllOl
->
lOlOOO\
OO\
lOOO\

(
lOl\
OOO\
OOl\
l\
l\
O\

,
fa\
ls\
e
)
==
0
)
;
whil\
e
(
!
lOlOO\
OO\
Oll\
Ol\

->
lO\
lOOO\
OOll\
l\
l\

(
lOl\
OO\
OOO\
lllO
)
)
{
TA_A\
SS\
ER\
T
(
lOOOOOlOOlO
.
lO\
lOl\
lllO\
O\
lO\

)
;
lOlO\
OOO\
OO\
ll\
l
*
lO\
lOO\
OOOll\
OO
=
lOO\
O\
OOlOOl\
O
.
lO\
lOll\
llOOlO
->
lOl\
l\
OlO\
llOll
->
lO\
llllOlOlOO
(
)
;
if
(
lOlOOO\
OOl\
lO\
O\

==
0
)
break
;
lOOOO\
OlO\
OlO
.
lOlOllll\
OO\
lO\

->
lO\
ll\
llOOlOl\
l
(
*
lOlOOO\
O\
O\
llOO
)
;
if
(
lOl\
OOOO\
O\
ll\
OO
->
lOlOll\
lO\
OlOl\

.
lOOOOO\
l\
OlOO\

(
)
)
lO\
OOO\
OlOOlO
.
lOlOllllO\
OlO\

->
lOl\
lOlOl\
lOll
->
lOlOOOOll\
l\
lO
(
*
lOl\
OOO\
OO\
llOO
)
;
}
}
}
void
Ph\
ysics
::
lOll\
l\
l\
O\
O\
lOll
(
lOlOO\
OOOOlll
&
lOlO\
OOO\
lllO\
O
)
{
TA_ASS\
E\
RT
(
lOlOOOOl\
ll\
OO
.
lOlOO\
OOOl\
lOl\

)
;
TA_ASSER\
T
(
lOl\
O\
O\
O\
OlllO\
O
.
lOl\
OO\
OOOlllO
)
;
if
(
(
lOlOOO\
OlllOO
.
lOlOOO\
O\
Oll\
Ol
->
lOlOO\
O\
lOOOO\
O
(
)
||
lOl\
OO\
OOlllOO
.
lO\
l\
O\
OO\
OO\
llOl
->
lO\
lOOOlOOO\
Ol\

(
)
)
&&
(
lO\
l\
OO\
OOlllO\
O\

.
lOlOOO\
OOlllO
->
lOlOO\
O\
lOOOO\
O
(
)
||
lOlOOOOlllO\
O
.
lO\
l\
OO\
OOOl\
llO
->
lOl\
O\
OO\
l\
O\
OO\
Ol\

(
)
)
)
return
;
Dy\
na\
mic\
Obj\
ec\
t
*
lOl\
OO\
OOOllOl
=
lOlOOOO\
ll\
lO\
O
.
lO\
lOOO\
OOllOl
;
Dy\
na\
micO\
bject
*
lOlOOOOOlllO\

=
lO\
lOO\
O\
O\
lllOO
.
lOlOOO\
OO\
ll\
lO
;
#ifdef llOOlOOllllO
Phy\
si\
csR\
en\
d\
er
::
Rend\
erLine\

(
lOlO\
OOO\
OllOl
->
GetPosition\

(
)
,
lOlOOOO\
O\
l\
llO
->
Get\
Pos\
ition
(
)
,
lOO\
OOOO\
O\
lO\
l\
l
(
255
,
0
,
255
,
0
)
)
;
#endif //
co\
nst
int\

lOllOllOlOOl
=
lOO\
llOl\
lllOO
->
lO\
lOlll\
l\
lOOl
;
if
(
(
lOl\
lOllO\
l\
OOl
==
0
)
||
(
lOlO\
OOOOllO\
l
->
Ge\
tW\
orldA\
A\
B\
B
(
)
.
Interse\
cts\

(
lOlOOO\
OOlll\
O
->
GetWorldAABB
(
)
)
&&
lO\
lOOOOOllOl
->
IsAl\
lo\
wedT\
oColl\
i\
deW\
ith
(
*
lO\
lO\
OOOOlllO
)
&&
!
lOlOOOOO\
lll\
O
->
Co\
llision\
Disab\
led
(
)
)
)
{
llOOllO\
OO\
ll\

=
Mi\
n
(
lOlOO\
OOOllOl
->
lO\
OllOOOOlOO
(
)
,
lOlOO\
OOOlllO
->
lOOllOOO\
OlO\
O\

(
)
)
;
if\

(
lOllO\
llO\
l\
OO\
l
>
0
)
{
Vec3
ll\
OO\
lOOllll\
l\

=
lOlOOO\
O\
Ol\
l\
Ol
->
Get\
Li\
ne\
ar\
Velocity\

(
)
-
lOlOOOOO\
ll\
lO\

->
Ge\
tLinea\
r\
V\
el\
ocity\

(
)
;
co\
ns\
t
Vec\
3
llOO\
lOlOOOOO
=
llO\
O\
lOOll\
l\
ll
-
lOl\
OO\
OOO\
l\
lOl
->
lOlOOlll\
OlO\
O\

(
)
+
lOl\
OOOOOlllO\

->
lOlOOlllOlOO\

(
)
;
Vec\
3
ll\
O\
OlO\
l\
OO\
O\
Ol
=
lOlOOOOOl\
lOl
->
GetAng\
ularVe\
locit\
y
(
)
-
lOlOOOO\
Olll\
O
->
GetAng\
u\
larVeloc\
ity\

(
)
;
const\

Ve\
c\
3
llOO\
l\
OlO\
OOlO\

=
llOOlOlO\
OOOl
-
lOl\
OO\
OO\
O\
llOl\

->
lO\
l\
O\
OlllO\
lOl
(
)
+
lOlOO\
OOOlll\
O
->
lOlOOl\
ll\
OlOl
(
)
;
float
lOO\
ll\
O\
OO\
OO\
ll\

=
Min\

(
lOlO\
O\
OOOllOl
->
lOO\
ll\
OOOO\
lO\
O
(
)
,
lOlOOO\
OOlllO
->
lOOllO\
OOOlOO\

(
)
)
;
fl\
oat
llOOl\
OlOO\
Ol\
l\

=
1.0f
/
(
lOOl\
lOl\
l\
llOO
->
lOl\
Olll\
ll\
OOO
*
lOO\
ll\
O\
ll\
llO\
O
->
lO\
l\
Oll\
lll\
OOO
)
;
float
ll\
l\
OO\
ll\
OOl\

=
llOOlOlOO\
Oll
*
llOOllO\
OOll\

*
llOOllOOOl\
l
;
if\

(
(
llOOlOlOO\
OO\
O
.
Get\
Mag\
nitudeSqrd\

(
)
<
(
0.01f
*
ll\
lOOllOOl
)
||
ll\
OOl\
OO\
lll\
ll
.
GetMa\
g\
ni\
tud\
eS\
qr\
d
(
)
<
(
(
0.02f
*
0.02f
)
*
lll\
OOl\
lOOl
)
)
&&
(
llOO\
lOlOOOl\
O
.
GetM\
agnitudeSqrd
(
)
<
(
0.01f
*
llOOlOl\
OOOl\
l
)
||
ll\
OOlO\
lOOOOl
.
GetMagnitudeSqrd\

(
)
<
(
0.01f
*
llOOlO\
lOOOll
)
)
)
{
re\
turn
;
}
}
if
(
lOlO\
O\
O\
OOllOl
->
GetI\
D
(
)
<
lOlO\
OOOO\
lll\
O\

->
Ge\
tID
(
)
)
{
Swa\
p
(
lOlOOOOOllOl\

,
lOlO\
OOOOlllO\

)
;
}
if
(
lOl\
ll\
O\
OllOlO
)
{
TA_\
ASS\
ERT
(
lO\
lOOOO\
O\
llOl
)
;
TA_ASSE\
RT
(
lO\
lOOO\
OOlllO
)
;
if\

(
!
lOlllOOllOl\
O
(
*
lOlO\
O\
OOOllO\
l
,
*
lOlO\
O\
OO\
Ol\
llO\

)
)
{
re\
turn\

;
}
}
MFra\
me\

lOlllOll\
lOOO
=
lOlOO\
O\
OOll\
Ol
->
Ge\
tF\
ram\
e
(
)
/
lOl\
O\
OO\
O\
O\
lllO\

->
Ge\
tFra\
m\
e
(
)
;
MF\
rame
lOll\
lOlllOOl
=
lOlOOOOOllOl\

->
Get\
Ne\
xtFr\
a\
m\
e
(
)
/
lOl\
OOOOO\
lllO
->
Ge\
tNextFra\
me
(
)
;
if
(
!
lOlOO\
OOO\
ll\
Ol\

->
Is\
InMovin\
gL\
is\
t
(
)
&&
!
lO\
lOOOOOll\
Ol\

->
MovementD\
i\
s\
a\
bl\
ed
(
)
)
lO\
l\
llOlll\
O\
O\
l
.
v3Tran\
slation\

+=
(
Get\
Gravit\
y
(
)
*
lO\
OllO\
lll\
l\
O\
O
->
lOlOlll\
ll\
OO\
O
)
/
lO\
lO\
OOOOlllO
->
Get\
NextF\
ram\
e\

(
)
.
m33R\
otatio\
n
;
if
(
!
lOlOOOO\
O\
lllO
->
Is\
In\
M\
ovingList
(
)
&&
!
lOlO\
OOOOl\
ll\
O
->
Movement\
Disabl\
ed
(
)
)
lO\
l\
llOlllOOl
.
v3Trans\
latio\
n
-=
(
GetGravity
(
)
*
lOO\
llOllllOO\

->
lOlOllll\
lOOO
)
/
lOlOOOOOlllO
->
GetNextFra\
m\
e
(
)
.
m33R\
ot\
a\
t\
ion
;
ll\
llO\
ll\
lO\
OO
*
llllOll\
lOO\
l\

=
0
;
lOllOOl\
l\
l\
lOO
lOOOOOlOOl\
O
;
lO\
O\
OOOlOOl\
O
.
In\
iti\
a\
lise
(
this
)
;
lO\
OOOOl\
OOlO
.
lO\
l\
OOOOOll\
Ol\

=
lO\
lOOOOOl\
l\
O\
l
;
lOOOOOl\
OOl\
O
.
lOlO\
OO\
OOlllO
=
lOlOOO\
O\
Ol\
llO\

;
lOOOOO\
lO\
Ol\
O\

.
lO\
lOO\
O\
O\
Oll\
O\
O\

=
&
lOlOOOO\
lllOO\

;
TA_AS\
S\
ERT
(
lOlllOlllOOO
.
m3\
3Rotation
.
IsOrthogon\
al
(
)
)
;
TA_ASSE\
RT
(
!
lOlOO\
OOO\
llOl
->
IsW\
o\
rld\
Obje\
ct\

(
)
)
;
TA_\
ASSERT
(
!
lO\
lOOOO\
O\
l\
l\
l\
O
->
Is\
W\
o\
rldOb\
ject\

(
)
)
;
ll\
llOl\
lOlOl
(
*
lO\
Ol\
lO\
l\
lll\
OO\

,
lOlO\
OO\
OOllO\
l
->
GetC\
ollis\
i\
onO\
bj\
e\
ct
(
)
,
lOlllOlll\
OOO\

,
lOll\
lO\
lllOOl
,
lOlO\
OO\
OOlllO
->
Ge\
tCo\
l\
lisionObje\
ct
(
)
,
llllO\
l\
llOOl
,
lOlll\
llOOlll
,
&
lOOOOO\
lOOlO
)
;
lOOOO\
O\
lOO\
l\
O
.
lOl\
O\
OOOOllOl
=
0
;
lOOOO\
OlOOlO
.
lOl\
OO\
O\
OOl\
llO\

=
0
;
llOO\
OOOO\
OllO
(
)
;
}
}
vo\
id
TAC_CALL
Ph\
ysic\
s
::
lOll\
l\
OlOllOl
(
Spa\
ceDivis\
i\
on\
Object
&
llOOO\
OOOO\
O\
O
,
voi\
d
*
lOO\
l\
l\
lOOOO\

)
{
lOl\
lOO\
lllOlO
&
lO\
OO\
OO\
lOOlO
=
*
(
lO\
l\
lO\
OlllOlO
*
)
lO\
Ol\
llOOOO\

;
Dynami\
c\
O\
b\
ject
*
lO\
lllOOlO\
OO
=
(
Dy\
n\
a\
mi\
cObj\
ect
*
)
&
llOO\
OOO\
O\
OOO
;
if
(
lO\
ll\
lO\
OlOOO
->
Gho\
s\
t
(
)
)
int
lOlOOOllOl
=
0
;
if
(
!
lOlllOO\
lOOO\

->
Collisio\
nDisable\
d
(
)
&&
!
(
!
(
lOOO\
OOlO\
Ol\
O
.
lO\
lOllO\
Oll\

&
FL\
A\
G\
_G\
HOST_\
OBJ\
ECTS
)
&&
lOlllOOl\
OOO\

->
Ghos\
t
(
)
)
&&
!
(
!
(
lOOO\
OO\
lOO\
lO\

.
lOlOllOOl\
l\

&
FLAG_ST\
AT\
I\
C_\
O\
BJECTS
)
&&
lOl\
ll\
OOlOOO\

->
GetCol\
lis\
io\
nObj\
ectC\
ompl\
ex
(
)
)
&&
!
(
!
(
lOOOOOl\
OO\
lO\

.
lOlOl\
lOOll
&
FLAG_\
DYNAM\
IC_OB\
JECTS\

)
&&
lOlllOOl\
OOO\

->
Ge\
tCo\
llisionObje\
ctC\
o\
mbo
(
)
)
)
{
lOll\
lOOlO\
OO
->
TestLi\
ne\
ForColl\
ision\

(
lOO\
OOOlOOlO
.
lOOlOlOlll
,
lOOOOOlOOl\
O
.
lO\
OOlOO\
O\
OO
,
lOOOOOlOOl\
O
.
lOO\
l\
OllOOO
,
lO\
OOOOl\
OOlO
.
llO\
lll\
lOlll
)
;
}
}
voi\
d
TA\
C\
_\
C\
ALL
Phy\
sics
::
lOlllOlOlllO
(
Spac\
eD\
i\
vi\
s\
ion\
Object
&
llOOOO\
O\
O\
OO\
O\

,
voi\
d\

*
lOO\
ll\
lO\
O\
OO
)
{
Dynami\
cObje\
ct\

*
*
ll\
O\
lOllO\
O\
ll
=
(
Dyna\
micObject
*
*
)
lOO\
lll\
O\
OOO
;
TA_ASSERT\

(
llO\
l\
O\
ll\
OO\
ll
)
;
DynamicObject
*
lOl\
l\
l\
O\
OlO\
O\
O
=
(
Dyna\
mi\
cOb\
ject\

*
)
&
ll\
OOO\
O\
OOO\
OO
;
lOlllO\
OlOOO
->
lOlOOl\
lllOll\

(
*
llOlOll\
OOll
)
;
*
llO\
l\
OllOO\
l\
l
=
lOlllO\
O\
lOOO\

;
lOl\
l\
l\
OO\
lOOO
->
Ad\
dRe\
f
(
)
;
}
}

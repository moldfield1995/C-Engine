//---------------------------------------------------------------------------------
// File Name: zcta020.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_DEPRECATE
#endif
#include "../Common/zcta015.h"
#ifndef lOOOOlOOll
#include "../Common/zcta012.h"
#endif //
#ifndef TA_ERROR_H
#include "Error.h"
#endif //
#ifndef TA_MEMORYMGR_H
#include "MemoryMgr.h"
#endif //
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
name\
space
TA
{
Ch\
ar
lOOl\
llOO\
lOO
[
4
]
=
{
0
,
0
,
0
,
0
}
;
#define lOOlllOOlOl(lOOOlOlllOO, Type, lOOlllOllO)				\
{															\
	int lOOlllOOllO = (lOOlllOllO);									\
	if (lOOlllOOllO == 1)										\
	{														\
		lOOOlOlllOO = lOOlllOOlOO;									\
	}														\
	else													\
	{														\
		lOOOllllOO(lOOOlOlllOO, Type, lOOlllOOllO)		\
	}														\
}
#define lOOlllOOlll(lOOOlOlllOO, Type) { if (lOOOlOlllOO != lOOlllOOlOO) { lOlOOOlllO(lOOOlOlllOO, Type); } }
ll\
Olll\
l\
llO
::
llOlll\
lllO\

(
)
{
lOlOOOlOO\
l
=
0
;
lOOl\
llOOlOl\

(
lOOlllOlOOO
,
Ch\
a\
r
,
lOl\
OOOlOOl
+
1
)
;
lOOlll\
Ol\
OOO
[
0
]
=
0
;
}
ll\
Ol\
lllllO
::
llOll\
llllO
(
con\
st
Char
*
lllOOOll\
ll
)
{
if
(
lllOOOllll\

)
{
lOl\
OOOlOOl\

=
(
int
)
str\
l\
en
(
lllOOOll\
ll
)
;
lOOlllOO\
lOl
(
lOOll\
lO\
lOOO\

,
Char
,
lOlOO\
OlO\
Ol\

+
1
)
;
me\
mcpy
(
lO\
OlllO\
lOOO
,
lll\
OOOlll\
l\

,
(
lO\
lOOO\
lOOl
+
1
)
*
siz\
eo\
f
(
Ch\
ar
)
)
;
}
el\
se
{
Cle\
ar
(
)
;
}
}
llOllllllO
::
ll\
OllllllO
(
co\
nst\

ll\
Olll\
l\
llO\

&
lOOl\
llOlOOl
)
{
if
(
lOO\
l\
llO\
lOOl
.
lOl\
OOOlOOl
<
0
)
{
lOlO\
O\
OlOOl
=
-
lOOll\
lOlOOl
.
lOlOOO\
lOOl
;
lOOlllOlO\
O\
O\

=
lO\
OlllOlOOl
.
lOOlll\
OlOOO
;
(
(
llOllll\
llO
&
)
lOOlllOlOO\
l
)
.
lOl\
O\
O\
OlOOl
=
0
;
(
(
llO\
ll\
lll\
lO\

&
)
lOO\
lll\
OlO\
Ol
)
.
lO\
Ol\
ll\
OlOOO
=
0
;
}
els\
e
{
lOlOOOlOOl
=
lOOlllOlOOl\

.
lO\
lO\
OOlOOl
;
lOOlllOOlOl
(
lOO\
lll\
OlOOO
,
Char
,
lOlOOO\
lOOl
+
1
)
;
memcp\
y\

(
lOOlllOlOO\
O
,
lO\
Ol\
ll\
Ol\
O\
Ol
.
lOOll\
lO\
l\
OOO
,
(
lOl\
OOOlOO\
l
+
1
)
*
siz\
e\
of
(
Cha\
r\

)
)
;
}
}
llO\
llllllO
::
llOlllll\
lO
(
const
Cha\
r
*
lllOOO\
l\
lll
,
int\

lOO\
lllO\
llO
)
{
TA_A\
SS\
E\
RT\

(
lOOlll\
O\
l\
lO\

>=
0
)
;
lOlOO\
OlOO\
l
=
lOO\
l\
llO\
llO
;
lO\
Olll\
OOlOl
(
lO\
Olll\
OlO\
OO\

,
Cha\
r\

,
lO\
lOO\
OlOOl
+
1
)
;
int\

lOOOllOOOl
=
0
;
if
(
lll\
O\
OOl\
ll\
l
)
{
for
(
;
lllOOOlll\
l
[
lO\
OOllOO\
Ol
]
&&
lO\
OOll\
OO\
Ol
<
lO\
Oll\
lO\
l\
lO\

;
lOOOllOOOl
++
)
lOOl\
l\
l\
OlOO\
O
[
lOOOll\
OOOl\

]
=
lll\
OOOll\
ll\

[
lO\
OOllOOOl
]
;
}
lO\
OlllOlOO\
O\

[
lOOOl\
lOOOl\

]
=
0
;
}
llOl\
ll\
lllO
::
llO\
lll\
lllO
(
int
lOOllOlOOOO
)
{
char
lllOOOl\
ll\
l
[
128
]
;
sp\
r\
intf\

(
ll\
lOOOll\
ll
,
"%d",
lOO\
l\
lOlOO\
OO\

)
;
new
(
this\

)
llOllll\
llO
(
lll\
O\
OOl\
lll
)
;
}
llOl\
l\
l\
lllO
::
llO\
llllllO\

(
flo\
at
lOOOOOl\
llO
)
{
cha\
r
ll\
l\
OO\
O\
ll\
l\
l
[
64
]
;
sprintf
(
ll\
lOO\
Ollll
,
"%f",
lOO\
OOOl\
llO\

)
;
new\

(
this
)
llO\
llllllO
(
lllOOOllll\

)
;
}
llOllll\
ll\
O
::
~
ll\
Olll\
l\
l\
lO\

(
)
{
if
(
lO\
OlllOlOOO
)
{
lOO\
lllOOlll
(
lOO\
lllOlOOO\

,
Char
)
;
lOOlll\
OlO\
OO\

=
0
;
}
}
voi\
d
ll\
Oll\
l\
l\
llO\

::
Seria\
lise
(
Ser\
i\
ali\
s\
er
&
lO\
OO\
lOll\
Ol
)
{
if
(
lOOOlO\
llO\
l\

.
ll\
lO\
lOOl\
ll
(
)
)
{
int\

lO\
OlllOll\
O
=
lO\
OOlllO\
Ol
(
)
;
lOO\
Ol\
OllOl
.
Serialis\
e
(
lO\
Ol\
llOllO
)
;
fo\
r
(
int
lOOO\
llO\
O\
Ol
=
0
;
lO\
OOl\
lOOO\
l
<
lOOlllOllO\

;
lOOOllO\
OO\
l
++
)
{
char
ll\
l\
Ol\
OlOOO
=
lOO\
ll\
lOl\
OOO
[
lOOO\
llOO\
Ol\

]
;
lOO\
OlOllOl\

.
Se\
rial\
ise
(
ll\
lOl\
OlO\
OO\

)
;
}
}
else
{
int
lOOlllOllO
=
0
;
lO\
OOlOll\
O\
l\

.
Ser\
i\
a\
lise
(
lOOlll\
O\
ll\
O
)
;
lOO\
lllO\
lO\
lO
(
lO\
Olll\
OllO
)
;
int
lOO\
OllO\
OOl
=
0
;
for
(
;
lOOOllOOOl
<
lOOll\
lOllO
;
lOOOllO\
OOl
++
)
{
char
ll\
lOlOlOOO\

;
lOO\
OlOllOl\

.
Serialis\
e\

(
lllOlOl\
OO\
O
)
;
lOO\
lllOlO\
O\
O
[
lOOOllOOOl
]
=
lllO\
lOlOOO
;
}
lOOlll\
OlOOO
[
lOOOll\
O\
OOl
]
=
0
;
}
}
void
llO\
l\
lllllO
::
lOOll\
lOlOll\

(
Se\
r\
ialise\
r
&
lOO\
OlOl\
lOl
)
{
if\

(
lOOOlOll\
O\
l
.
lll\
OlO\
Olll
(
)
)
{
int\

lOOl\
llO\
l\
l\
O
=
lOOO\
lllOOl
(
)
;
lOOO\
lO\
l\
lOl\

.
Serial\
i\
se
(
lO\
O\
ll\
l\
Oll\
O\

)
;
int
lOOOll\
OOO\
l
;
for
(
lOOOllO\
OOl\

=
0
;
lOOO\
ll\
OOOl
<
lOOlllO\
llO\

;
lOO\
Ol\
lOOOl
++
)
{
ch\
ar
ll\
lOlOlOO\
O
=
lOOll\
l\
O\
l\
OOO\

[
lOOOllOOOl
]
;
lO\
OOl\
Oll\
Ol\

.
Serial\
i\
se
(
lllOlOlO\
OO
)
;
}
int\

lllOlO\
lO\
Ol
=
0
;
if
(
(
-
lOO\
Ol\
l\
O\
OOl\

)
&
4
)
lOOOlOllOl\

.
lllOlO\
lOlO
(
&
lllO\
lOlOOl
,
(
-
lOOOllOO\
Ol\

)
&
4
)
;
}
else
{
in\
t\

lOO\
lllOllO
=
0
;
lO\
OO\
l\
O\
l\
lOl
.
Serialise
(
lO\
OlllOl\
l\
O
)
;
lO\
Olll\
O\
lO\
lO\

(
lOOlllO\
llO\

)
;
int
lO\
OOl\
l\
O\
OO\
l
;
for
(
lO\
OOl\
lOOO\
l
=
0
;
lOOOl\
lO\
O\
Ol
<
lO\
Ol\
llOllO\

;
lOOOllOOOl
++
)
{
cha\
r
lllOl\
Ol\
OOO\

;
lOOOlO\
l\
l\
Ol
.
Seri\
al\
ise\

(
lllOlO\
l\
OOO
)
;
lO\
OlllOlO\
OO\

[
lOOOl\
lO\
OOl\

]
=
lll\
OlO\
lOOO
;
}
lOOll\
lO\
lOOO
[
lOOOllOOOl
]
=
0
;
in\
t
lllOlOlOOl
=
0
;
if
(
(
-
lOOOllOOOl
)
&
4
)
lOOOlO\
ll\
Ol
.
lllOlOl\
OlO
(
&
lllOlOlOOl\

,
(
-
lOOOllO\
OOl
)
&
4
)
;
}
}
bool\

ll\
O\
llllllO
::
ope\
rato\
r
==
(
cons\
t
llO\
ll\
ll\
llO
&
lOOll\
lOlOO\
l\

)
{
ret\
urn
(
str\
cm\
p
(
lOOlllO\
l\
OO\
O
,
lOO\
lllOl\
OOl
.
lO\
OlllOl\
OOO
)
==
0
)
;
}
bool
llO\
l\
lllll\
O
::
operator
==
(
const
Char
*
lllOOOllll
)
{
retur\
n
(
strcmp\

(
lOOlllOlO\
OO
,
lll\
OOOlll\
l
)
==
0
)
;
}
bool
llO\
ll\
llll\
O\

::
ope\
rator
!=
(
const
llOllll\
ll\
O
&
lOOlllO\
lOOl
)
{
return\

(
strcmp
(
lOOl\
llOlOOO
,
lOOlllOlO\
Ol\

.
lO\
Ol\
llOlO\
O\
O\

)
!=
0
)
;
}
bo\
o\
l
ll\
Ollllll\
O\

::
op\
erator
!=
(
con\
s\
t
Char
*
lllOOOl\
l\
ll
)
{
return
(
strc\
mp
(
lOOlllO\
lOOO
,
lllOOO\
llll\

)
!=
0
)
;
}
llOll\
l\
l\
llO\

&
ll\
Olll\
lllO
::
ope\
r\
ato\
r
=
(
const
llOllll\
l\
lO\

&
lOOlllOl\
O\
O\
l
)
{
lOOlll\
OlOlO
(
lO\
OlllOlOOl\

.
lOO\
Ol\
l\
lOOl
(
)
)
;
strcpy\

(
lOOll\
lO\
lOO\
O
,
lOO\
l\
l\
lOlOO\
l
.
lOOlllOl\
OOO\

)
;
re\
t\
urn
*
thi\
s
;
}
llO\
ll\
ll\
ll\
O\

&
llOll\
llllO
::
oper\
ato\
r
=
(
co\
ns\
t\

Cha\
r
*
lllOOOllll\

)
{
if
(
ll\
l\
OOOllll
==
0
)
{
Cle\
ar
(
)
;
}
el\
se\

{
lOOlllOlOl\
O
(
(
int
)
str\
len
(
lllO\
OOl\
lll
)
)
;
strcpy
(
lOO\
lllOlOOO
,
lllO\
OO\
llll
)
;
}
ret\
urn
*
this
;
}
llO\
llllllO\

&
llOlll\
ll\
lO
::
ope\
rator\

+=
(
co\
n\
st
ll\
Ollll\
l\
lO
&
lOOlll\
OlOOl
)
{
int
lOO\
O\
l\
lOO\
Ol
=
lO\
l\
OOOlOOl\

;
lOOlllO\
lOl\
O\

(
lO\
lOOOlOO\
l
+
lOOlll\
OlO\
Ol
.
lO\
l\
OO\
Ol\
O\
Ol\

)
;
fo\
r
(
int
lOOlOOlOl\
O
=
0
;
lOOO\
l\
lOOOl\

<
lOlOOOlOO\
l
+
1
;
lO\
OOllOOOl
++
,
lOOlOOlOlO
++
)
lOOlll\
Ol\
OOO
[
lOOOl\
lOOOl\

]
=
lO\
O\
lllOlOOl
.
lOOlllOl\
OOO
[
lO\
O\
l\
OOlOlO
]
;
retu\
rn
*
th\
is\

;
}
llOll\
l\
l\
llO
&
ll\
Oll\
llllO
::
operator\

+=
(
const
Char
*
ll\
lOO\
O\
ll\
ll\

)
{
in\
t
lO\
OOll\
OOO\
l
=
lOl\
OOOl\
OOl
;
lO\
OlllOlOlO
(
lOlO\
O\
OlO\
Ol\

+
(
int
)
strle\
n\

(
lllOOOll\
ll\

)
)
;
for
(
int
lOOlOOlOlO
=
0
;
lOOO\
ll\
OOOl
<
lO\
lO\
O\
OlOOl
+
1
;
lOO\
O\
l\
lO\
O\
Ol\

++
,
lOOl\
OOlOlO
++
)
lOOlll\
O\
l\
O\
OO
[
lOOOllOOOl
]
=
lllOOOlll\
l
[
lOOl\
OOlO\
lO
]
;
ret\
ur\
n
*
thi\
s
;
}
llOl\
lllll\
O
&
ll\
OllllllO
::
operato\
r
+=
(
int
lO\
Ol\
lOlO\
OOO
)
{
char
lllOO\
Olll\
l
[
128
]
;
sprintf
(
lllO\
O\
Ollll\

,
"%d",
lOOllOlO\
OOO
)
;
*
this
+=
lllO\
OOl\
lll
;
re\
t\
urn
*
thi\
s
;
}
llOllllll\
O
&
llO\
ll\
llllO\

::
ope\
rat\
o\
r
+=
(
float
lOOO\
O\
OlllO
)
{
ch\
ar\

lllOOOl\
l\
ll\

[
64
]
;
sprint\
f\

(
lllOOOl\
lll
,
"%f",
lOOOO\
O\
l\
llO
)
;
*
th\
is\

+=
ll\
lOOOllll
;
return
*
th\
is
;
}
llO\
ll\
llllO\

llOllllllO
::
oper\
ato\
r\

+
(
con\
st\

llO\
ll\
llllO
&
lOOlll\
Ol\
OOl
)
const
{
ll\
O\
llll\
llO
lOOlll\
OllOO\

(
*
th\
is\

)
;
lO\
Olll\
O\
l\
lOO
+=
lOO\
lllOl\
OOl
;
lOO\
ll\
lOll\
OO
.
lOlOOO\
lO\
Ol\

=
-
lOO\
lllO\
llOO
.
lO\
lOOOl\
O\
Ol
;
ret\
urn
lOOl\
llOllOO
;
}
llOll\
llllO
llOllllll\
O
::
oper\
at\
or
+
(
const\

Char\

*
lllO\
OO\
l\
l\
ll
)
cons\
t
{
llO\
lll\
ll\
l\
O
lOOll\
lOl\
lOO
(
*
this
)
;
lO\
OlllO\
l\
lOO
+=
lllOOO\
llll
;
lO\
O\
lllOl\
l\
OO
.
lOl\
OOOlOOl
=
-
lO\
Oll\
lOllOO
.
lO\
l\
OOOl\
O\
Ol\

;
ret\
urn
lOOl\
llOll\
OO\

;
}
llOllllllO
TAC_\
CALL
operator
+
(
const
Char
*
lllOOlllOO
,
co\
nst
ll\
OllllllO\

&
lll\
OlO\
OOOO\

)
{
llOllllllO\

lOOll\
lO\
l\
lOO
(
lllOOl\
llOO
)
;
lOOlllOllO\
O\

+=
lllO\
lO\
O\
OOO\

;
lOO\
lllOllOO
.
lOlOO\
OlOOl\

=
-
lO\
Oll\
lOllOO\

.
lOlOOOlOOl
;
retu\
r\
n
lOOll\
lOl\
l\
OO
;
}
ll\
O\
lllll\
lO\

llOlll\
lllO
::
op\
erato\
r
+
(
int
lO\
OllO\
l\
O\
OO\
O
)
co\
ns\
t
{
ll\
Oll\
ll\
llO
lO\
O\
ll\
lOl\
lOO\

(
*
this\

)
;
lOO\
l\
llOllOO
+=
lOOl\
lOlOOOO
;
lOOll\
lOllOO\

.
lOlOOOl\
OOl
=
-
lO\
Oll\
lOl\
l\
OO
.
lOl\
O\
OO\
lOOl
;
retur\
n
lOOlllO\
llOO
;
}
ll\
O\
llllllO\

llOll\
l\
lllO
::
op\
erator\

+
(
float
lOOOOOlllO
)
const
{
llO\
lll\
lll\
O
lOOlll\
Oll\
OO
(
*
th\
is
)
;
lO\
Oll\
lO\
llO\
O
+=
lO\
OOOOlll\
O
;
lOOll\
lOll\
OO\

.
lOlOOOlOOl
=
-
lO\
Olll\
Ol\
l\
OO
.
lOl\
OOOl\
O\
Ol
;
re\
turn
lOO\
ll\
lO\
l\
lOO\

;
}
void
llOl\
lllllO\

::
Clear\

(
)
{
lOOlllO\
lO\
lO
(
0
)
;
lO\
OlllOl\
OOO
[
0
]
=
0
;
}
void
ll\
Ol\
llll\
lO
::
lOOlllOllOl
(
)
{
for
(
int\

lOOOll\
O\
OOl
=
0
;
lOO\
O\
llOOO\
l\

<
lOlOOOlOOl
;
lOOOl\
lOOO\
l
++
)
{
if
(
lOOlllOlOO\
O
[
lOOOll\
OOOl
]
>=
'A'&&
lOO\
lll\
O\
lOOO
[
lOOO\
l\
lO\
OOl
]
<=
'Z')
lOOl\
llOlOOO
[
lOOOllOOOl\

]
+=
'a'-
'A';
}
}
void\

llO\
l\
ll\
lllO
::
lOOlll\
OlllO
(
)
{
for
(
int\

lO\
OOllOOOl
=
0
;
lOOOl\
lOOO\
l
<
lO\
l\
O\
OOlOO\
l\

;
lOO\
O\
l\
lOOOl
++
)
{
if\

(
lO\
Ol\
ll\
OlOOO\

[
lOOOllO\
OOl
]
>=
'a'&&
lOOlllOlOOO\

[
lOOOl\
lOO\
Ol
]
<=
'z')
lOO\
lllOlO\
OO
[
lO\
OOll\
OOOl\

]
+=
'A'-
'a';
}
}
void\

ll\
O\
l\
lll\
ll\
O\

::
lOOl\
llOlOlO
(
int\

lOOll\
l\
O\
llO\

)
{
if\

(
lOOll\
lOl\
lO
!=
lOlOOOlO\
Ol
)
{
Char
*
lO\
Oll\
lOll\
l\
l\

;
lOOlllOOl\
Ol
(
lOO\
lll\
Ol\
ll\
l
,
Ch\
a\
r
,
lOO\
l\
llOllO
+
1
)
;
for
(
int\

lO\
OO\
llOO\
O\
l
=
0
;
lOOOllOOOl
<
lO\
lOOO\
l\
OOl\

&&
lOOOl\
l\
OOOl\

<
lOO\
ll\
lOllO
;
lOO\
Ol\
lOOOl
++
)
lOO\
lllOlll\
l\

[
lOOOllOO\
Ol
]
=
lO\
Ol\
llOlOOO
[
lOO\
O\
l\
l\
O\
OOl\

]
;
lOO\
lllOO\
lll\

(
lOOl\
llOlOO\
O
,
Char\

)
;
lO\
lOOOlO\
Ol
=
lOOlll\
OllO
;
lOO\
l\
l\
lOlOO\
O
=
lOOlllOl\
lll
;
}
}
}

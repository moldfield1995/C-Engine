//---------------------------------------------------------------------------------
// File Name: zcta020.h
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef DOXYGEN
#include <xmmintrin.h>
#include <emmintrin.h>
#pragma inline_recursion(on)
#pragma inline_depth(255)
#ifdef TA_SSE2
#define lOlOOlOlOOO(x, y) ((__m128&)_mm_shuffle_epi32((__m128i&)(x), (y)))
#else
#define lOlOOlOlOOO(x, y) (_mm_shuffle_ps((x), (x), (y)))
#endif 
names\
pace
TA
{
na\
me\
sp\
ace
lOlOO\
OOOll\
O
{
str\
uct
lO\
lOOOOOl\
l\
l
{
un\
ion\

{
struct\

{
fl\
o\
at
x
;
float
y
;
floa\
t
z
;
float\

w
;
}
;
__\
m\
128\

lOl\
OOlO\
lO\
Ol
;
}
;
}
;
tem\
p\
lat\
e
<
clas\
s\

Ty\
pe\

>
stru\
ct
lOlOOlOlOl\
O
{
__force\
in\
li\
ne
lO\
lOOOOOlll
lO\
lOO\
lOl\
O\
ll
(
)
co\
n\
st
{
retu\
rn
(
(
Type
&
)
*
this
)
.
lOlO\
OlOlOll
(
)
;
}
__forcei\
n\
line\

float
lOl\
OOl\
Ol\
lOO\

(
)
co\
nst
{
ret\
urn
(
(
Type\

&
)
*
thi\
s
)
.
lOlOOlOl\
lOO
(
)
;
}
}
;
__for\
ce\
i\
n\
line
__m\
128\

lOlOOl\
Ol\
lO\
l
(
__\
m128
lllOOlllOO\

,
__m128\

lllO\
lO\
OOOO
)
{
__\
m\
1\
2\
8\

lOlO\
Ol\
OlllO\

=
_mm\
_mul_\
ps
(
ll\
l\
OO\
l\
llO\
O
,
lllOl\
OO\
OOO
)
;
__m128
lOlOOlOll\
ll
=
lOl\
OO\
lO\
l\
OOO\

(
lO\
lOOlO\
lllO
,
_MM\
_SHUFFLE
(
3
,
0
,
2
,
1
)
)
;
lOlOOlOl\
lll\

=
_mm_add_\
ps
(
lOlO\
OlO\
ll\
ll\

,
lO\
lOOl\
Olll\
O
)
;
lOl\
O\
OlOlll\
O\

=
lOlO\
OlOl\
OO\
O\

(
lO\
lO\
OlOl\
ll\
O
,
_MM_SH\
UFFLE
(
3
,
1
,
0
,
2
)
)
;
lOl\
OO\
lO\
lllO
=
_mm_a\
dd_p\
s
(
lOl\
OOlOlll\
O
,
lO\
lO\
Ol\
Olll\
l
)
;
return\

lOlOOlO\
ll\
lO
;
}
st\
ru\
ct
lOl\
O\
OllOOO\
O
:
public
lOlOOlOlOlO\

<
lOl\
OOllOO\
OO
>
{
const\

lOlO\
OOOO\
l\
l\
l
&
lOlOOOllllO
;
const
lOlO\
OOOOl\
ll\

&
lOlO\
OO\
ll\
lll\

;
lOl\
OOllOOOO\

(
co\
nst
lO\
lOOOO\
Olll
&
lllOOll\
l\
OO
,
co\
ns\
t
lOlOOOOOlll\

&
lllOlOOOOO
)
:
lOlOOOlll\
lO\

(
ll\
lO\
OlllOO\

)
,
lO\
lOOOlllll\

(
lllOlO\
OOOO
)
{
}
__forc\
e\
i\
nline\

lOlOOO\
OO\
lll
lOlOOlOlOll
(
)
const\

{
retu\
r\
n
(
lOl\
OOO\
O\
Oll\
l
&
)
lOlOOlOll\
Ol
(
(
__m128
&
)
lOlO\
OOllll\
O
,
(
__\
m\
128\

&
)
lOlOO\
Ol\
lll\
l
)
;
}
__\
f\
orc\
e\
inline\

fl\
o\
at
lOlOOlOllOO
(
)
con\
st\

{
#ifdef TA_SSE2
__m12\
8\

lO\
lOO\
l\
OlllO
=
_mm_\
mu\
l_ps
(
(
__\
m\
128
&
)
lO\
lOOO\
lll\
l\
O\

,
(
__\
m128
&
)
lOlOOOl\
l\
lll\

)
;
__m\
128
lOl\
OOl\
Ol\
lll\

=
(
__m128
&
)
_mm\
_shu\
f\
fle_epi32
(
(
__m\
128i
&
)
lOl\
OOlOlllO
,
_M\
M\
_SHUFFL\
E
(
0
,
0
,
0
,
1
)
)
;
__m128
lOlOOllO\
OOl
=
(
__m128
&
)
_m\
m_shuf\
f\
l\
e_e\
p\
i3\
2\

(
(
__m128i
&
)
lOlOOl\
O\
lllO
,
_MM_S\
H\
UFF\
LE
(
0
,
0
,
0
,
2
)
)
;
lOl\
OOlOl\
ll\
l
=
_mm_\
add_\
ss
(
lOlO\
OlO\
llll\

,
lOlOOlO\
lllO
)
;
lOlOOl\
Olll\
l
=
_mm\
_\
ad\
d\
_ss
(
lOlOOlOl\
lll
,
lOl\
O\
Ol\
lOOO\
l\

)
;
retur\
n
(
(
lOlO\
OOOO\
lll
&
)
lOlOOl\
Oll\
ll
)
.
x
;
#else
lOlOO\
OOOl\
ll
lOlOOllOOlO
;
(
__m\
12\
8
&
)
lOl\
OOllOO\
lO
=
_m\
m_\
mul\
_ps\

(
(
__\
m128\

&
)
lOlOOOll\
ll\
O
,
(
__m128\

&
)
lOlOOOlllll
)
;
retu\
rn
lOlOOll\
O\
O\
lO
.
x
+
lOlOOllOOlO
.
y
+
lOl\
OOllOO\
lO
.
z
;
#endif
}
__f\
orceinline
op\
erator
float
(
)
const\

{
retu\
rn
lOlO\
Ol\
Ol\
lOO
(
)
;
}
}
;
struct
lO\
l\
OO\
ll\
OOll
:
public
lOlOOl\
OlOlO\

<
lOlOOll\
O\
Ol\
l
>
{
const\

lOlOO\
OOOl\
ll
&
lOl\
OOOllll\
O
;
lOl\
O\
Ol\
lOOl\
l\

(
const
lOl\
OOOOOlll
&
ll\
lOO\
l\
llO\
O
)
:
lOlOO\
Oll\
l\
lO
(
lllOOlllO\
O
)
{
}
__\
forc\
ei\
nlin\
e
lOlO\
OOO\
Olll\

lOlO\
Ol\
OlOll
(
)
con\
st\

{
__\
m128\

lO\
l\
OO\
l\
O\
l\
ll\
O
=
(
__\
m128
&
)
lO\
lOO\
Ol\
l\
llO\

;
lOlO\
OlOlllO
=
lO\
lOOlOl\
lOl
(
(
__m128
&
)
lOlOO\
lOlllO
,
(
__\
m\
128
&
)
lOlOO\
lOl\
llO
)
;
retu\
rn
(
lOl\
OOOOOlll\

&
)
lOlO\
OlOlllO\

;
}
__f\
orcein\
line\

fl\
oat\

lOlOOlO\
l\
lOO
(
)
co\
nst
{
lOlOO\
OOOll\
l
lO\
l\
OOll\
OOlO
=
lOlOOOlll\
l\
O\

;
#ifdef TA_SSE2
__m\
1\
28
lOlOO\
lO\
lllO
=
_mm\
_\
m\
ul_p\
s
(
(
__\
m128
&
)
lO\
lO\
Ol\
lOO\
lO
,
(
__m\
128
&
)
lOl\
OOl\
lOOlO
)
;
__\
m12\
8\

lOl\
OOlO\
lll\
l\

=
(
__m128\

&
)
_mm_shu\
ffle\
_\
epi3\
2
(
(
__m\
1\
28i
&
)
lOlOO\
l\
OlllO
,
_MM_SHUFFLE\

(
0
,
0
,
0
,
1
)
)
;
__\
m\
128\

lOlOOl\
l\
OOO\
l
=
(
__\
m128
&
)
_mm_sh\
uf\
fle_\
e\
p\
i32
(
(
__m1\
2\
8i\

&
)
lO\
lOO\
l\
OlllO
,
_MM_S\
HUFF\
LE
(
0
,
0
,
0
,
2
)
)
;
lOlO\
O\
l\
O\
lll\
l
=
_mm_add_s\
s
(
lOl\
OOl\
O\
ll\
ll
,
lOlOOlOll\
l\
O
)
;
lOl\
O\
OlOllll\

=
_mm_a\
dd_ss
(
lOlOOlOl\
lll
,
lO\
lOOllO\
O\
Ol
)
;
retur\
n
(
(
lO\
l\
OOO\
O\
Olll
&
)
lO\
lOOl\
O\
l\
l\
ll\

)
.
x
;
#else
(
__m128
&
)
lO\
lOO\
llOOl\
O
=
_mm_mul_\
ps
(
(
__m12\
8
&
)
lOlOO\
llOO\
l\
O
,
(
__m128
&
)
lOlOOllO\
OlO\

)
;
retu\
r\
n
lOlOOllOOlO
.
x
+
lO\
lOOllOOlO
.
y
+
lOlOOllO\
O\
lO
.
z
;
#endif
}
__f\
o\
r\
c\
einli\
ne\

operator
float
(
)
const
{
retu\
r\
n\

lOl\
O\
OlOllOO\

(
)
;
}
}
;
st\
r\
uct\

lOl\
OOl\
l\
O\
l\
OO\

:
public
lO\
lOOlO\
lO\
lO
<
lOl\
OO\
l\
lOlOO
>
{
con\
st
lOl\
OOO\
OOlll
&
lOlO\
OOl\
lllO\

;
lO\
l\
OO\
llOlOO
(
const\

lOl\
OOOOOlll\

&
ll\
l\
OOlllO\
O
)
:
lOlO\
OO\
l\
ll\
lO
(
ll\
lO\
OlllOO
)
{
}
__\
f\
orc\
ei\
n\
li\
n\
e
lOl\
OOOOOlll
lO\
lOOlOlOll
(
)
co\
nst
{
__\
m128
lOlOOlOl\
llO
=
lOlOOl\
OllO\
l\

(
(
__m128
&
)
lO\
lO\
OOl\
lll\
O\

,
(
__m\
128
&
)
lO\
l\
OOOlll\
lO
)
;
re\
turn
(
lO\
lOOOOOll\
l
&
)
_mm_sqrt_ps\

(
lOl\
OOlOlll\
O
)
;
}
__\
forc\
einli\
ne\

float\

lO\
l\
OOlO\
llOO
(
)
co\
nst\

{
lOl\
OOOO\
O\
ll\
l
lOlOOl\
lO\
Ol\
O\

;
(
__m1\
2\
8
&
)
lOlOOll\
OOlO
=
_mm_mul_ps
(
(
__\
m128
&
)
lOlOOO\
l\
lllO\

,
(
__m1\
28
&
)
lOlOOO\
ll\
l\
l\
O\

)
;
return
sqr\
tf
(
lO\
l\
OOl\
lOOlO
.
x
+
lOlO\
OllO\
O\
l\
O
.
y
+
lOlOOl\
lOOlO
.
z
)
;
}
__f\
orc\
e\
inline\

operator
floa\
t
(
)
const
{
retur\
n
lO\
l\
OOlOllO\
O
(
)
;
}
}
;
}
TA_A\
LIGN_16
struct
TA\
COMMO\
N_CLAS\
S
Vec\
3
:
publ\
ic
lOl\
OOOOOl\
l\
O\

::
lOlO\
OOOOlll\

{
enum
Axis
{
AX\
I\
S\
_X
=
0
,
AXIS_\
Y
,
AXIS_Z
,
}
;
__for\
c\
einline\

Vec3\

(
)
{
(
__m128
&
)
*
this
=
_mm_se\
tz\
ero_\
ps
(
)
;
}
__force\
i\
nline
Ve\
c3
(
int\

lOlOOllOl\
Ol
)
{
}
__f\
o\
r\
ceinli\
ne
Ve\
c3\

(
cons\
t
Vec3
&
llllOOl\
OOl
)
{
lOlOOlO\
lO\
Ol
=
lll\
lOOlOOl\

.
lOlOOlOlO\
Ol
;
}
__forc\
e\
i\
n\
line
Vec3
(
fl\
o\
at\

lOlOOOlOOll
,
fl\
o\
at\

lOlOO\
OlOlOl
,
fl\
o\
at
lOl\
O\
O\
OlOl\
lO
)
{
lOlO\
O\
l\
O\
lOOl
=
_m\
m\
_setr\
_ps
(
lO\
lO\
OOl\
OOll
,
lOlOOO\
lOl\
Ol
,
lOlOOOlOllO\

,
0.0f
)
;
}
__\
f\
o\
rceinl\
ine
vo\
id\

Ini\
ti\
alise
(
fl\
oat\

lOl\
OO\
Ol\
OO\
ll
,
flo\
at
lOlOO\
OlOlOl
,
float
lOlOOOlOllO
)
{
lOl\
OO\
lO\
l\
O\
Ol
=
_mm_se\
tr_p\
s\

(
lOlOOOlOOll
,
lOl\
O\
OO\
lOlOl
,
lOlOOOlO\
l\
lO
,
0.0f
)
;
}
__forcein\
line
operato\
r
flo\
at
*
(
)
{
re\
turn
(
flo\
at
*
)
&
x
;
}
__for\
cei\
n\
line\

operator
cons\
t
fl\
oat
*
(
)
co\
nst
{
re\
turn
(
float
*
)
&
x
;
}
__forceinli\
ne
fl\
oat
&
operato\
r
[
]
(
int
lOOOlOOlll
)
{
re\
turn
(
(
flo\
at
*
)
&
x
)
[
lOO\
OlOOlll
]
;
}
__force\
inli\
ne
co\
nst
fl\
oat
&
ope\
rat\
or
[
]
(
int
lOO\
OlOOlll
)
con\
st
{
retur\
n\

(
(
float
*
)
&
x
)
[
lOO\
OlOOll\
l
]
;
}
__for\
ceinl\
i\
ne\

Ve\
c3
&
operato\
r
+=
(
const
Vec\
3
&
llllOOlOO\
l
)
{
(
__m128
&
)
(
*
this
)
=
_mm_a\
dd_\
ps\

(
(
__m128
&
)
(
*
this
)
,
(
__m128
&
)
ll\
llOOlOO\
l
)
;
ret\
u\
r\
n
*
this
;
}
__fo\
rceinli\
n\
e
Vec3
&
ope\
rator
-=
(
cons\
t\

Vec\
3\

&
llllO\
OlO\
Ol
)
{
(
__m128\

&
)
(
*
this
)
=
_mm_sub\
_\
ps\

(
(
__m128
&
)
(
*
th\
is\

)
,
(
__m128\

&
)
llllOOlO\
Ol
)
;
return
*
this\

;
}
tem\
plate
<
class
Type
>
__f\
o\
rcei\
nline
const\

Vec3\

&
operator
=
(
con\
st
lOlOO\
OOOl\
lO
::
lOlOOlOlO\
l\
O
<
Ty\
p\
e
>
&
lOlOOOlOOlO
)
{
*
this
=
lOlOO\
OlOOlO
.
lO\
lOOll\
O\
ll\
O\

(
)
;
ret\
urn
*
this
;
}
__fo\
rcein\
lin\
e
co\
nst
Vec\
3
&
op\
e\
rat\
or
=
(
co\
n\
st
Vec3\

&
lOl\
OOO\
lO\
OlO
)
{
lOlOOlOlO\
Ol
=
lOl\
OOO\
lOOlO
.
lOlOOlOlO\
Ol\

;
ret\
urn
*
this
;
}
__for\
cei\
nline
Ve\
c\
3
oper\
ator
+
(
)
con\
st
{
re\
turn
*
this
;
}
;
__fo\
rce\
in\
line\

Vec\
3
op\
era\
t\
or
-
(
)
co\
ns\
t\

{
return\

(
Vec3
&
)
_mm_su\
b_ps\

(
_mm_set\
ze\
ro_p\
s\

(
)
,
lOlOOlOlO\
Ol
)
;
}
;
__\
forceinline
boo\
l\

op\
erat\
or
==
(
const
Ve\
c3
&
lll\
lOOlOO\
l
)
co\
nst
{
re\
t\
u\
rn
x
==
llllO\
Ol\
OOl
.
x
&&
y
==
lll\
l\
OOlO\
Ol
.
y
&&
z
==
ll\
llOOlOOl
.
z
;
}
__f\
o\
rceinline\

bo\
o\
l\

operator
!=
(
con\
s\
t
Vec3
&
ll\
l\
l\
OOlOOl
)
con\
st\

{
re\
turn
x
!=
ll\
l\
lOOlOOl
.
x
||
y
!=
lll\
l\
O\
OlOO\
l
.
y
||
z
!=
llllO\
OlOO\
l
.
z
;
}
__f\
orc\
ei\
nlin\
e
Ve\
c\
3
Cross\

(
cons\
t
Vec3
&
ll\
llOO\
l\
O\
Ol
)
const\

{
ret\
urn
Cross
(
*
this
,
llllO\
O\
l\
OOl
)
;
}
stat\
ic
__forc\
einl\
ine
Vec3
Cross
(
const\

Vec3
&
lll\
l\
l\
llll
,
con\
st\

Ve\
c3
&
lOOOO\
OOO\
O\
O\

)
{
__m128
lOlOO\
l\
O\
lllO
=
*
(
__m12\
8
*
)
&
lllll\
llll
;
__\
m\
1\
28
lOl\
O\
Ol\
Oll\
l\
l
=
*
(
__m\
128\

*
)
&
lOO\
OOO\
OOOO
;
__m1\
28
lOlO\
Oll\
O\
lll
=
lOlOOlOlO\
OO\

(
lOlOOlOll\
lO
,
_M\
M\
_S\
HUFFLE
(
3
,
0
,
2
,
1
)
)
;
__m128
lOl\
O\
Ol\
l\
lOOO
=
lOlOO\
lOl\
OO\
O\

(
lO\
l\
OO\
lOllll\

,
_MM\
_SHUF\
FLE\

(
3
,
1
,
0
,
2
)
)
;
lOlO\
Ol\
llOOO
=
_mm_m\
u\
l_p\
s
(
lOlOOlllOOO\

,
lO\
l\
O\
Ol\
lO\
lll
)
;
__m1\
28
lOlO\
O\
ll\
l\
OOl
=
lOlO\
OlO\
lO\
OO
(
lOlOOllO\
lll\

,
_MM_SH\
UFFLE
(
3
,
0
,
2
,
1
)
)
;
__m128
lOl\
OOll\
lOl\
O
=
lO\
l\
OOl\
OlO\
OO
(
lOlOOlOl\
l\
ll
,
_MM_SH\
UFFLE
(
3
,
0
,
2
,
1
)
)
;
lOl\
OOlll\
OOl
=
_m\
m_m\
ul_ps
(
lOl\
OO\
lllO\
Ol
,
lOlO\
OlllO\
lO\

)
;
lOlO\
OlllO\
OO
=
_mm_sub_ps
(
lOlOOlllOO\
O
,
lOl\
O\
Oll\
lOOl
)
;
ret\
u\
rn\

(
Ve\
c3
&
)
lOlO\
O\
lllOOO
;
}
stat\
ic
__\
fo\
rcei\
nl\
ine
Ve\
c\
3\

TA_V\
E\
C3_C\
ALL
Cr\
o\
ssWith\
UnitX
(
con\
st
Vec\
3\

&
llllOOlOOl\

)
{
return
Vec3
(
0.0f
,
lll\
lOOlOOl
.
z
,
-
ll\
l\
lOOlOOl
.
y
)
;
}
__forceinline\

Ve\
c3
Cros\
sWit\
h\
Un\
it\
X
(
)
co\
n\
st\

{
ret\
urn
CrossWi\
t\
hUnitX
(
*
th\
i\
s
)
;
}
static
__\
f\
orcein\
li\
n\
e
Vec3
TA_\
VEC3_CALL
Cr\
os\
sWit\
hUn\
itY
(
con\
st
Vec3
&
ll\
llOOlOO\
l\

)
{
ret\
urn
Vec3
(
-
llllOOl\
OOl\

.
z
,
0.0f
,
lll\
lO\
OlOOl\

.
x
)
;
}
__\
fo\
r\
cein\
l\
in\
e
Vec3
Cross\
W\
ithUnitY
(
)
co\
nst\

{
re\
t\
u\
rn
CrossWith\
Unit\
Y
(
*
thi\
s
)
;
}
st\
atic
__\
forcein\
li\
ne
Ve\
c3
TA_VEC\
3\
_CALL
Cr\
ossWithUn\
itZ\

(
const\

Vec3
&
ll\
llOOl\
OO\
l
)
{
return\

Vec3
(
ll\
llO\
OlOOl\

.
y
,
-
llll\
OOlOOl
.
x
,
0.0f
)
;
}
__force\
i\
n\
lin\
e
Vec\
3
Cr\
o\
ss\
Wi\
th\
Uni\
tZ
(
)
con\
st
{
re\
turn
Cro\
ssWithU\
nitZ
(
*
this
)
;
}
static\

__f\
orc\
e\
inl\
in\
e
flo\
at
TA_\
VEC3_CA\
LL
CrossX
(
co\
n\
s\
t
Vec3
&
lllll\
llll
,
con\
st\

Vec3
&
lOOOOO\
OO\
OO\

)
{
re\
tu\
rn\

lllllllll
.
y
*
lOOOOOOOO\
O
.
z
-
llll\
lll\
ll
.
z
*
lOOOOO\
OOO\
O
.
y
;
}
__\
for\
ceinline
float
Cr\
ossX
(
const
Vec\
3
&
ll\
llO\
OlOO\
l\

)
const
{
return\

CrossX
(
*
this
,
lll\
l\
OOlOO\
l
)
;
}
sta\
tic
__forc\
einline
floa\
t
TA_\
VEC\
3_\
CA\
LL
CrossY\

(
const
Ve\
c3
&
lll\
llllll
,
const\

Vec3
&
lOOOO\
OOO\
O\
O\

)
{
ret\
urn\

lll\
llllll
.
z
*
lOOO\
OOO\
OOO
.
x
-
ll\
llllll\
l
.
x
*
lOOOOOOOOO
.
z
;
}
__forcei\
nlin\
e
flo\
a\
t
Cross\
Y
(
const
Vec3
&
llllOOlOOl
)
const
{
retur\
n
Cro\
ss\
Y\

(
*
this\

,
llllO\
OlOOl
)
;
}
stat\
ic
__forceinline
floa\
t
TA\
_V\
E\
C3_CA\
LL
Cross\
Z\

(
const
Vec3
&
lllllllll
,
const\

Vec3
&
lOOOOOOOO\
O\

)
{
retu\
rn
ll\
l\
ll\
llll
.
x
*
lO\
OO\
O\
OO\
OOO\

.
y
-
lllll\
l\
l\
ll
.
y
*
lOO\
OOO\
O\
OO\
O\

.
x
;
}
__fo\
r\
cei\
n\
l\
ine
float
Cross\
Z
(
co\
nst\

Ve\
c\
3
&
llllO\
Ol\
OOl
)
const
{
return
CrossZ
(
*
this
,
ll\
l\
lOOlOOl
)
;
}
st\
atic
__f\
orcein\
li\
n\
e\

lOl\
OOO\
OO\
llO\

::
lOlOOllOO\
OO
TA_VE\
C3\
_\
CALL
Dot
(
const\

Vec\
3
&
lllllll\
ll
,
con\
st\

Ve\
c3
&
lOOOOOO\
OOO
)
{
return
lO\
l\
OOOOOllO
::
lOl\
OOl\
l\
OOOO
(
lll\
llllll
,
lOOOO\
OOOOO
)
;
}
__\
force\
in\
l\
ine
lO\
lOOOOO\
llO
::
lOl\
O\
OllOO\
OO
Dot
(
const
Vec\
3
&
llll\
OOl\
O\
Ol\

)
co\
ns\
t
{
re\
t\
urn\

lOl\
OOOOO\
llO
::
lOl\
OOllOOO\
O\

(
*
this\

,
llllO\
OlOO\
l
)
;
}
stat\
ic\

__\
forcei\
n\
li\
n\
e
Vec3
TA_VEC3\
_C\
AL\
L
Mi\
n
(
co\
nst\

Ve\
c3\

&
lllllllll
,
con\
s\
t
Vec3\

&
lOOO\
OO\
OOOO
)
{
retur\
n\

(
Vec3
&
)
_mm_min\
_ps
(
(
__m128
&
)
lllllll\
ll
,
(
__\
m128
&
)
lO\
OO\
OO\
O\
OO\
O
)
;
}
static
__f\
o\
r\
c\
e\
i\
nline
Ve\
c3
TA_V\
EC3\
_CALL\

Max
(
cons\
t\

Vec3
&
ll\
lllllll\

,
const
Vec3\

&
lOOOOOOOOO
)
{
ret\
u\
rn
(
Ve\
c\
3
&
)
_mm_max_\
ps
(
(
__m1\
28
&
)
llllll\
l\
l\
l
,
(
__\
m128
&
)
lO\
O\
OOO\
O\
OOO
)
;
}
stat\
ic\

__\
forc\
e\
i\
n\
lin\
e
lOlO\
O\
OO\
OllO
::
lOlO\
OllOl\
O\
O
TA_V\
EC3_CAL\
L\

Get\
Mag\
nitud\
e
(
const
Vec\
3
&
ll\
l\
lO\
OlOO\
l
)
{
return
lO\
l\
OO\
OO\
O\
ll\
O
::
lOlOO\
l\
lOlOO\

(
llll\
OOlO\
Ol
)
;
}
__forcein\
line\

lOl\
OOO\
OOllO
::
lOlO\
O\
l\
l\
Ol\
OO\

Ge\
t\
M\
a\
gnitu\
de\

(
)
const
{
return\

lOlOOOO\
O\
llO\

::
lOlOO\
l\
l\
O\
l\
O\
O
(
*
this
)
;
}
st\
at\
ic
__for\
ceinli\
ne
lO\
lOO\
OOOll\
O
::
lOlOOllO\
O\
ll\

TA_VEC3_CALL
GetMagnitud\
eS\
qrd
(
con\
st
Vec3\

&
lll\
lOO\
lOOl\

)
{
re\
tu\
r\
n
lOlOOOOOl\
lO
::
lOl\
O\
O\
ll\
OOll
(
lll\
lO\
OlOOl
)
;
}
__\
fo\
r\
c\
einl\
in\
e
lOlOOOO\
OllO\

::
lOlOOllOOll
GetMagni\
t\
udeSq\
r\
d
(
)
const
{
re\
turn\

lOlOOOOOl\
l\
O\

::
lO\
l\
OOllOOl\
l
(
*
this
)
;
}
stati\
c
__for\
ceinli\
ne\

Ve\
c3
TA_VEC\
3_\
CALL
Get\
No\
rm\
al
(
co\
nst
Ve\
c3\

&
lll\
lOO\
l\
OOl
)
{
ret\
u\
rn
ll\
llOOlO\
Ol
.
Get\
Nor\
mal
(
)
;
}
__\
forcein\
line\

Ve\
c\
3
Ge\
tNormal
(
)
const
{
__m128
lOlO\
Olll\
O\
ll
=
lOlOOlOlO\
Ol
;
__m\
128\

lOl\
O\
OlO\
l\
llO
=
_m\
m_mul_\
ps
(
lOl\
OO\
l\
llOl\
l
,
lOlOOll\
lOll
)
;
__\
m\
12\
8\

lOl\
OOlOllll\

=
lOlOO\
lOlO\
OO
(
lOlO\
OlOll\
lO\

,
_MM_SHUFF\
LE
(
3
,
3
,
3
,
1
)
)
;
__m128
lOl\
OOl\
lOOOl\

=
lOlOOlOlOOO\

(
lOlO\
OlOlllO\

,
_MM_S\
HUF\
FLE\

(
3
,
3
,
3
,
2
)
)
;
lOlO\
OlOll\
lO\

=
_m\
m\
_a\
dd_ss
(
lOlOOl\
OlllO
,
lOl\
OOl\
Ollll
)
;
lOlOOlOll\
l\
O\

=
_mm_\
a\
dd\
_ss
(
lOlOOlOl\
llO
,
lOlOOllOOOl
)
;
lO\
l\
OO\
l\
Olll\
O\

=
_m\
m\
_rs\
qrt\
_ss\

(
lO\
lOOlOl\
llO
)
;
lO\
l\
O\
Ol\
O\
lllO
=
lOlO\
O\
lOl\
OO\
O
(
lOlOO\
l\
O\
lllO
,
_MM_S\
H\
U\
FF\
LE
(
0
,
0
,
0
,
0
)
)
;
lOl\
O\
OlllOll
=
_mm_mu\
l_p\
s
(
lOl\
OOlllOll
,
lO\
lOOlOlllO
)
;
re\
t\
urn
(
Vec3
&
)
lO\
lOOll\
l\
O\
ll
;
}
__forceinline
void
Normalise\

(
)
{
__m\
128\

lOlO\
O\
lll\
Oll
=
lOlOO\
lOlOOl\

;
__m12\
8\

lOlOOlOl\
llO\

=
_mm_mul_p\
s
(
lOlO\
OlllOll
,
lO\
lOOll\
l\
Oll
)
;
__m128
lOlOO\
l\
Oll\
ll
=
lOlOOlOlOOO
(
lOlO\
OlOll\
lO
,
_MM_SHU\
F\
FLE
(
3
,
3
,
3
,
1
)
)
;
__m\
128\

lOl\
OO\
llO\
OOl
=
lOl\
OOlOlOOO
(
lOlOOl\
O\
ll\
lO
,
_M\
M_SHUFFL\
E
(
3
,
3
,
3
,
2
)
)
;
lOl\
OO\
l\
O\
l\
l\
lO\

=
_m\
m_ad\
d_ss\

(
lOlOOlO\
ll\
lO
,
lOl\
OO\
lOllll
)
;
lOlOOlO\
l\
llO
=
_mm\
_add\
_ss\

(
lOlOO\
lOll\
lO
,
lOlOO\
l\
l\
O\
OO\
l
)
;
lO\
lOOlOlllO\

=
_m\
m_\
rsqr\
t_ss\

(
lO\
lOO\
lOlll\
O
)
;
lOlOO\
lOlllO\

=
lOlOOl\
OlOOO\

(
lOlO\
O\
lOll\
l\
O
,
_MM_SH\
UFF\
LE
(
0
,
0
,
0
,
0
)
)
;
lOl\
O\
OlllOll
=
_mm_m\
u\
l\
_ps\

(
lOlO\
O\
lllOl\
l\

,
lOlOO\
lOl\
llO\

)
;
lO\
lOOl\
OlOOl\

=
lOlOOlllO\
ll
;
}
__\
fo\
rc\
ein\
line\

void
Clear
(
)
{
(
__m1\
28
&
)
*
this
=
_mm\
_s\
e\
tz\
ero_p\
s\

(
)
;
}
__\
fo\
r\
c\
ei\
nline
bool
IsNormalised
(
)
co\
nst
{
floa\
t
lOll\
l\
lOl\
Ol
=
Get\
Magni\
tud\
eSqr\
d\

(
)
;
re\
turn
IsEqual\
ToOneWithInError
(
lOl\
l\
l\
l\
O\
lO\
l
)
;
}
__fo\
r\
cein\
l\
ine\

bo\
ol
IsZero
(
)
const
{
re\
turn
GetMag\
n\
itudeSqr\
d
(
)
==
0.0f
;
}
__\
forceinl\
ine
int\

GetGreatestAx\
is\

(
)
cons\
t
;
__forceinlin\
e
float
Ge\
t\
Max
(
)
cons\
t\

{
return
TA\

::
Ma\
x
(
TA
::
Max
(
x
,
y
)
,
z
)
;
}
__\
f\
orcein\
l\
ine
floa\
t\

Ge\
tMin
(
)
const
{
return
TA\

::
Min
(
TA\

::
Min
(
x
,
y
)
,
z
)
;
}
__forceinline\

void\

Ge\
tAxisOr\
d\
er
(
int
llllOOlOll
[
3
]
)
con\
s\
t
;
__f\
orceinline
float\

Get\
A\
xi\
s
(
int
lOO\
OlOOlll
)
con\
s\
t\

{
return
(
*
th\
i\
s
)
[
lOOOl\
OOl\
ll
]
;
}
__forceinli\
n\
e\

stati\
c
const
Vec\
3\

&
TA_VEC3\
_CAL\
L\

GetUn\
itVector
(
int
lOOOlOOl\
ll
)
;
inlin\
e
bo\
ol\

IsEqual\
WithInError\

(
con\
st\

Ve\
c3
&
llllOO\
lO\
Ol\

,
float\

llOl\
llOOOO\

)
con\
s\
t
;
inlin\
e
bo\
ol
IsVal\
id
(
)
const
{
retur\
n
FloatIsO\
K
(
x
)
&&
Fl\
o\
atIsOK
(
y
)
&&
Flo\
atIsOK
(
z
)
;
}
}
;
const
Vec3
k_v3Zero\

(
0.0f
,
0.0f
,
0.0f
)
;
cons\
t
Ve\
c\
3
k_v\
3Un\
itX
(
1.0f
,
0.0f
,
0.0f
)
;
co\
nst
Vec3
k_v3U\
nitY
(
0.0f
,
1.0f
,
0.0f
)
;
con\
s\
t
Vec3
k_v3Unit\
Z
(
0.0f
,
0.0f
,
1.0f
)
;
}
#include "../Common/zcta013.inl"
#endif //

//---------------------------------------------------------------------------------
// File Name: zcta009.h
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef lOlOlOllOO
#define lOlOlOllOO
#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
#ifndef TA_COMMON_H
#include "Common.h"
#endif //
#ifndef TA_TYPES_H
#include "Types.h"
#endif //
namesp\
ace\

TA\

{
template
<
cl\
ass
Type
,
bool\

lO\
OOll\
l\
l\
l\
l\
l
=
fal\
se
>
cl\
ass
TAC\
OMMO\
N_\
CLASS
lO\
lOll\
lOl\
O
{
pr\
ivate
:
struct\

lOO\
l\
l\
OOOO\
O
;
pu\
blic
:
cla\
ss
lOlOl\
llOll
{
publi\
c\

:
cla\
s\
s\

It\
era\
tor\

{
publ\
i\
c
:
Iterator
(
)
{
lOOOOOl\
OO\
OO\

=
0
;
}
~
It\
er\
a\
t\
or
(
)
{
}
Ite\
ra\
tor
(
Ty\
pe
*
lO\
Ol\
llOOOl
)
{
Initialise
(
(
lOOllOO\
O\
OO
*
)
lOOlllOOOl
)
;
}
Iterator
(
cons\
t\

It\
erato\
r
&
lOO\
lO\
OOOO\
OO
)
{
lOOO\
OOlOO\
OO
=
lOOlO\
OOOOOO\

.
lOOOOOlOO\
O\
O
;
}
vo\
id
Fina\
lise
(
)
{
lO\
OO\
OOlOOOO
=
0
;
}
voi\
d\

operator
++
(
)
{
if\

(
lO\
OO\
OOlOOO\
O
)
lOOOO\
OlOOO\
O
=
lO\
OOOO\
lOOO\
O
->
lOOOOOlOOO\
l\

;
}
void
ope\
rat\
or
--
(
)
{
lO\
O\
llOOOO\
O
*
lOOlOOOOO\
O\
l
=
(
lOOl\
lO\
OO\
OO
*
)
(
(
u3\
2
)
(
u8
*
)
lOOOO\
Ol\
OOO\
O
->
lOOlOOO\
OOl\
O\

-
(
(
u32\

)
(
u8
*
)
&
lOOO\
OOlOOOO
->
lOO\
OO\
O\
lOOOl
-
(
u3\
2
)
(
u8
*
)
lOO\
O\
OOlOOOO\

)
)
;
TA_\
AS\
SER\
T\

(
lOO\
lO\
OOOOOl
->
lO\
O\
O\
O\
OlOO\
Ol
==
lOOOO\
Ol\
O\
OOO
)
;
lO\
OOOOlOOOO
=
lOOl\
OOOO\
OOl\

;
}
It\
er\
ato\
r
&
operator\

=
(
const
Iterat\
or\

&
lOO\
lOOO\
O\
OO\
O
)
{
lOO\
OOOlOO\
OO
=
lO\
O\
l\
OOOOO\
O\
O\

.
lOOOO\
OlOOOO
;
ret\
ur\
n\

*
this
;
}
bool\

oper\
at\
or
==
(
con\
st
It\
era\
tor
&
lOOlOO\
O\
OO\
OO
)
co\
ns\
t
{
retu\
r\
n
lOOO\
O\
OlO\
OOO\

==
lOOlOO\
OOOO\
O\

.
lOO\
OO\
Ol\
O\
OOO
;
}
Type
&
op\
era\
t\
or\

*
(
)
{
ret\
ur\
n
lOOOO\
OlOO\
OO
->
lOOOO\
OlOOlO
;
}
bool
AtEnd\

(
)
{
return
lOOO\
OOlOOOO
==
0
;
}
priva\
te
:
fri\
end
cla\
ss\

lOlOl\
llOll
;
It\
erat\
or\

(
lOO\
l\
lO\
OOOO
*
lO\
OlllOOO\
l
)
{
Ini\
ti\
a\
lise
(
lO\
Oll\
lO\
OOl
)
;
}
void
Initial\
ise\

(
lO\
OllO\
OOO\
O
*
lOO\
lllOO\
Ol
)
{
lOO\
OOOlOO\
OO
=
lOOll\
lOOOl
;
}
voi\
d
lO\
OlOOO\
O\
O\
ll
(
Ty\
pe
*
lO\
Ol\
llOO\
Ol
)
{
lO\
OOOOO\
llO
(
lOO\
OOOl\
OOOO\

,
"Pool::Iterator::AddAfter. The iterator is off the end of the array")
;
lOOl\
lO\
OOOO\

*
lOOlOO\
O\
OlOO
=
(
lOOll\
OO\
OOO
*
)
(
lO\
OlllOOOl
)
;
TA_ASSE\
RT\

(
lO\
OlO\
OO\
OlOO
)
;
TA_ASS\
ERT\

(
lO\
OlOOOOl\
O\
O
->
lO\
O\
OO\
OlO\
OOl\

==
0
)
;
TA_A\
S\
SERT
(
lOO\
lO\
OOOlOO
->
lOOlOOO\
O\
O\
l\
O
==
0
)
;
lOOlOOOOl\
OO
->
lO\
O\
OOOlOOO\
l
=
lO\
O\
OO\
OlOOOO\

->
lOO\
O\
OO\
lOOOl\

;
if
(
lOOlOOO\
O\
l\
OO
->
lO\
OOOOlO\
O\
O\
l
)
lOOlOOOO\
lOO\

->
lOO\
OOOlOOOl
->
lOOlOOO\
OOlO
=
&
lO\
OlOOOO\
lOO
->
lOOOOOlO\
OOl
;
lO\
OOO\
Ol\
OOOO
->
lOO\
OOOlOOOl
=
lOOl\
OOOOlO\
O\

;
lOOlOO\
O\
OlOO
->
lO\
OlOOO\
OOl\
O
=
&
lOO\
O\
OO\
lOOOO
->
lOOOOO\
lOO\
Ol
;
}
vo\
id
lOOlOO\
O\
OlO\
l
(
Type\

*
lOOlllOOOl
)
{
lOOOO\
O\
Ol\
lO
(
lOO\
OOOlOOOO
,
"Pool::Iterator::AddBefore. The iterator is off the end of the array")
;
lO\
OllO\
O\
OO\
O
*
lO\
Ol\
OO\
O\
Ol\
OO\

=
(
lOOllOOOOO
*
)
(
lOO\
lll\
OOOl
)
;
TA_ASSERT
(
lOO\
lO\
OOO\
lOO\

)
;
TA\
_\
ASS\
ERT
(
lOOlO\
O\
OOl\
OO\

->
lO\
O\
OOOlOOOl
==
0
)
;
TA_ASSERT
(
lOOlO\
OOO\
l\
O\
O
->
lOOlOOOOOlO
==
0
)
;
lOOlOO\
OO\
l\
O\
O
->
lOOO\
OO\
lO\
OOl
=
lOO\
OOOl\
OOOO
;
lO\
O\
lOOOOlO\
O
->
lO\
OlO\
OOOO\
lO\

=
lOOO\
OO\
lOO\
O\
O
->
lOO\
lOOOOOlO
;
*
lOOOOOl\
O\
O\
O\
O
->
lOO\
lOO\
OOOlO\

=
lOOlOOOOlOO
;
lOO\
OOOlOO\
OO
->
lOOlO\
OOOO\
lO
=
&
lOO\
lOOOOlO\
O\

->
lOOO\
OO\
lO\
OOl
;
}
lOO\
llOOOOO
*
lOOOOOlO\
OOO
;
}
;
lOlOlllOll
(
)
{
lOOOO\
Ol\
O\
lll
=
0
;
}
void
Fin\
alise
(
)
{
#ifdef _DEBUG
whi\
le
(
lOOO\
O\
OlOl\
l\
l\

)
{
lO\
O\
llOOOOO
*
lOOlllOOOl
=
lOOOOOlO\
lll
;
lOOlllO\
OOl
->
lOOO\
OOl\
O\
OOl
=
0
;
lOOlllOOOl\

->
lOOlOOOO\
OlO
=
0
;
lO\
OOOOl\
O\
l\
ll\

=
lOOOO\
O\
l\
O\
ll\
l
->
lO\
OOOOlOOO\
l
;
}
#else //
lOOO\
OOlOlll
=
0
;
#endif //
}
Iterator
lOlO\
OOO\
lOO\

(
)
{
ret\
urn\

Ite\
rator
(
lOOO\
OOl\
Olll
)
;
}
void
lOlOlO\
OOO\
l\

(
Typ\
e
*
lOOlll\
OO\
Ol
)
{
lO\
OllOOOOO\

*
lOOl\
OO\
OOlO\
O
=
(
lOOl\
lOOO\
OO\

*
)
(
lOOll\
lOO\
O\
l
)
;
TA_ASSERT\

(
lOOlO\
OOOl\
OO\

)
;
TA_ASS\
ERT
(
lOO\
lO\
OO\
OlOO
->
lOOOOOl\
OOOl\

==
0
)
;
TA_A\
S\
SERT
(
lOOl\
O\
O\
OOlOO\

->
lOOl\
OO\
OOOlO
==
0
)
;
lOOlOO\
OO\
lOO\

->
lO\
OOOOlOO\
O\
l\

=
lOOO\
O\
OlOlll
;
if
(
lOOlOOOOlO\
O
->
lOOOOO\
lO\
O\
Ol
)
lOO\
lOOO\
O\
lOO\

->
lOOOO\
OlOOO\
l\

->
lOO\
lOOOOOlO\

=
&
lOOlOOO\
Ol\
OO
->
lOOOOOlO\
OOl
;
lOOOOOlOlll
=
lOO\
lOOO\
OlO\
O\

;
lO\
OlOOOOl\
OO\

->
lO\
OlO\
O\
OO\
O\
lO\

=
&
lOOOOOlOlll\

;
}
void
lOOlOO\
OOll\
O\

(
Ty\
pe
*
lOOll\
l\
OO\
O\
l\

)
{
lOOllOOO\
O\
O
*
lO\
Ol\
OOOOl\
OO
=
(
lO\
OllO\
O\
O\
OO
*
)
(
lOOlllOO\
O\
l\

)
;
TA\
_A\
SS\
ERT
(
lOOlO\
OOO\
lO\
O
)
;
TA\
_ASSER\
T\

(
lOOlO\
OOOlO\
O
->
lOOOOOlOOOl
==
0
)
;
TA_A\
SS\
ERT\

(
lOOlOOOOlO\
O
->
lOOlO\
OOOOlO
==
0
)
;
lOO\
l\
l\
OOO\
OO
*
lOO\
lOOO\
O\
ll\
l\

=
lOOOO\
Ol\
Olll
;
lOOllOOOOO
*
*
lOOlOOO\
OOlO
=
&
lO\
O\
OOOlOll\
l
;
whi\
le
(
lOOl\
OOOOlll\

)
{
lOO\
lOOO\
O\
OlO
=
&
lOOlOOO\
Olll
->
lOO\
OO\
O\
lOO\
O\
l
;
lOOlO\
OOOlll
=
lOOlOOOOl\
ll
->
lOOO\
O\
Ol\
OOOl
;
}
TA\
_A\
SS\
ER\
T
(
(
*
lO\
O\
lOOOO\
OlO
)
==
0
)
;
(
*
lOOlO\
OOOO\
lO
)
=
lOOl\
O\
OOO\
lO\
O\

;
lOOlOO\
OOl\
OO
->
lOOlO\
OOOOlO
=
lOO\
l\
OOOO\
O\
lO
;
lOOlOOOO\
l\
OO
->
lOOOO\
OlOO\
Ol
=
0
;
}
voi\
d\

lOOlOOOOOll
(
Ty\
pe
*
lOOlll\
OOOl\

,
Iter\
ator
lO\
lOO\
l\
OOlO
)
{
lO\
lOO\
l\
OO\
l\
O
.
lOOl\
OOO\
O\
Oll
(
lOOll\
lOO\
Ol\

)
;
}
void
lO\
Ol\
O\
OOOl\
O\
l
(
Type
*
lOOl\
l\
lOOOl
,
Ite\
rator
lOl\
OO\
lOO\
lO\

)
{
lOlOOlOOl\
O
.
lOOl\
OOO\
O\
l\
Ol\

(
lOOlll\
OOOl\

)
;
}
void
lOO\
l\
llllll
(
Type
*
lO\
O\
l\
llOOOl
)
{
lOOllOO\
OOO
*
lOO\
lOO\
OOlOO
=
(
lOOll\
O\
OO\
OO
*
)
(
lOO\
lll\
OOOl
)
;
TA\
_AS\
SERT
(
lO\
Ol\
OOOOl\
OO
)
;
TA_\
ASSERT
(
lOO\
lOOOO\
lOO
->
lOO\
lOOOOOlO
)
;
#ifdef _DEBUG
if\

(
lOOlOO\
OllO
)
{
bo\
o\
l
lOOl\
OOOlOOO
=
fals\
e
;
lOOll\
OOO\
OO
*
lOOlOOOl\
O\
Ol
=
lOOOOOlOl\
l\
l\

;
whi\
le
(
lO\
OlOO\
OlOO\
l\

)
{
if\

(
lOO\
l\
OOOl\
OOl
==
lOO\
lOOOOlOO
)
{
lOOl\
O\
O\
OlOOO
=
true
;
break
;
}
lOOlOO\
OlOOl\

=
lO\
O\
l\
OO\
O\
lOO\
l
->
lOOO\
OOlOOO\
l
;
}
TA_\
A\
SS\
E\
RT
(
lOOlO\
OOlOOO
)
;
}
#endif //
*
lOOlOO\
OOlO\
O
->
lOO\
lOOOOO\
lO\

=
lOOlOOOOlOO
->
lOO\
OOO\
lOO\
Ol\

;
if
(
lOOlOO\
OOlO\
O
->
lOOOOO\
lO\
O\
Ol
)
lO\
OlOOO\
OlOO
->
lOO\
OO\
Ol\
O\
OOl
->
lOO\
lOOO\
OOlO
=
lOOlOO\
OO\
lOO\

->
lO\
O\
lOOOOOlO
;
#ifdef _DEBUG
lOOlOOOOlOO\

->
lOOOOOl\
O\
OOl
=
0
;
lOOlOO\
OOl\
OO
->
lOOl\
O\
OOOO\
l\
O
=
0
;
#endif //
}
vo\
id
ll\
OllOl\
lOO
(
lOlOlllO\
ll
&
lOO\
lOOOlOl\
O\

)
{
lOOllOOOO\
O\

*
lOOl\
OOO\
lOll
=
lOO\
lO\
OO\
l\
OlO\

.
lOOOOO\
lOll\
l
;
lOOlOOOlO\
lO
.
lOO\
OOOl\
Ol\
ll\

=
lO\
O\
OOOlOlll
;
lOOOOOlOl\
ll
=
lOO\
lOOOlOll
;
if
(
lOOOOOlOlll
)
lOO\
OOOlOlll
->
lOOlOOOOO\
lO\

=
&
lOO\
OOOl\
Ol\
l\
l
;
if\

(
lOO\
lOOO\
lOl\
O\

.
lOO\
OOO\
lOlll
)
lOOlOO\
Ol\
O\
lO\

.
lO\
OOOO\
l\
Olll
->
lOOlOOOOO\
l\
O
=
&
lO\
O\
l\
OOOlOlO
.
lOOOO\
OlOlll\

;
}
void
lOOlO\
OO\
llOO
(
)
{
#ifdef _DEBUG
lO\
OllO\
OOOO
*
lO\
Ol\
OOO\
lOOl\

=
lOOOO\
O\
l\
Olll
;
wh\
ile
(
lOOlOO\
OlOOl
)
{
if
(
lOO\
lO\
OO\
lO\
Ol
->
lO\
OOOOlO\
OOl\

)
TA_A\
SSER\
T
(
lOOlOOOlOO\
l\

->
lOOO\
OOlOOOl
->
lOOl\
OOO\
OO\
lO
==
&
lOOl\
OOO\
lO\
O\
l
->
lOOOOOlOOO\
l
)
;
TA_\
ASSERT\

(
(
*
lOOlO\
O\
O\
lOO\
l
->
lO\
Ol\
OO\
OOO\
lO\

)
==
lOOlOOO\
lOOl
)
;
lOOlOOOlOOl
=
lO\
OlOOOl\
OOl
->
lO\
OOOOl\
OOOl
;
}
#endif //
}
bool
lO\
OlO\
OO\
l\
lO\
l
(
cons\
t
Typ\
e
*
lOOl\
ll\
OO\
Ol\

)
{
con\
s\
t
lOO\
l\
l\
OO\
OOO\

*
lOO\
l\
O\
OOO\
l\
OO
=
(
lOO\
ll\
OOOO\
O
*
)
(
lOOlllOOO\
l
)
;
lOO\
llOOOOO
*
lO\
OlOOOlOOl
=
lOOO\
OOlOlll
;
whi\
le
(
lOOl\
OO\
OlOOl
)
{
if
(
lOO\
lO\
OOlOO\
l
==
lOOlOOOOl\
O\
O
)
{
re\
tu\
rn
tru\
e\

;
}
lOOl\
OOOl\
O\
O\
l
=
lOO\
l\
OOOl\
OOl
->
lOOOO\
O\
lOO\
Ol
;
}
ret\
urn\

false
;
}
stat\
ic
vo\
i\
d\

TAC_CA\
LL
lO\
OlOOO\
l\
ll\
O
(
Ty\
pe
*
lOOlll\
O\
OOl
)
{
lOOl\
lO\
OOOO
*
lO\
OlOOOOlOO\

=
(
lO\
O\
llOOOOO
*
)
(
lO\
Oll\
l\
O\
OOl\

)
;
TA_ASSERT\

(
lOOlOOOOlOO
)
;
TA_A\
SSERT\

(
lO\
OlO\
OOO\
l\
O\
O
->
lOO\
lO\
O\
OOOlO
)
;
*
lO\
Ol\
OO\
OOlOO
->
lOOlOOOOOlO
=
lOOlOO\
O\
OlO\
O
->
lOOOOOlOOOl
;
if
(
lOO\
l\
OO\
OOlOO
->
lO\
OOOOlO\
O\
Ol\

)
lOO\
l\
OOOOl\
O\
O
->
lOOO\
O\
O\
lOOOl
->
lOOlOO\
O\
O\
OlO\

=
lOOlO\
OOO\
lOO
->
lO\
O\
lOOOOOlO
;
#ifdef _DEBUG
lOOlOO\
OOlOO
->
lOOO\
OOl\
O\
OOl
=
0
;
lOOlOOO\
OlOO
->
lOOlOOO\
OOlO\

=
0
;
#endif //
}
int
lOOO\
l\
ll\
OO\
l
(
)
{
in\
t
lOOlllOl\
lO\

=
0
;
for\

(
Ite\
rat\
or
lOlO\
OlOOlO
=
lOl\
OOO\
OlOO
(
)
;
!
lOlO\
Ol\
O\
OlO
.
AtEnd
(
)
;
++
lOlOOlOOlO
)
lOOl\
l\
lOllO\

++
;
ret\
ur\
n\

lO\
O\
lll\
O\
ll\
O
;
}
vo\
id
ll\
Ol\
lOlOOO
(
lOlOll\
l\
O\
ll
&
lOOlO\
OOlOlO
)
{
if\

(
lO\
OO\
O\
O\
l\
Oll\
l
)
{
lO\
Ol\
lOOOOO\

*
lOO\
lOOOll\
ll\

=
lOOO\
O\
OlO\
l\
ll
;
while\

(
lOOlOOOl\
lll
->
lOOO\
O\
OlOOO\
l\

)
lOOlO\
OOlll\
l
=
lOO\
l\
OO\
Ollll
->
lOOOOOlO\
OO\
l\

;
lOOl\
OOO\
lll\
l
->
lO\
OOOOl\
O\
O\
Ol\

=
lO\
OlOOOlOlO\

.
lO\
O\
O\
OO\
lO\
lll
;
lOOlOOOllll
->
lOOO\
OO\
lOOOl
->
lOOlOO\
OOOlO
=
&
lO\
OlOOO\
ll\
ll
->
lOOOO\
OlO\
OO\
l\

;
}
el\
se
{
lOOOOOlOll\
l
=
lOOlOOO\
lOlO
.
lOOOOOlOl\
ll
;
if\

(
lOOOOOlOll\
l\

&&
lOOOO\
OlOll\
l
->
lOOOOOl\
OOO\
l
)
lO\
OOOOlOl\
ll
->
lOOOO\
OlOO\
Ol
->
lO\
O\
lOOOOO\
l\
O\

=
&
lOOOOOlO\
lll
;
}
lO\
OlOOOlOlO\

.
lOOOOOlOll\
l
=
0
;
}
lOO\
llO\
OOO\
O
*
lO\
OlO\
O\
lOOO\
O
(
)
{
return
lOOO\
OO\
lO\
ll\
l
;
}
bo\
ol
lOO\
OOO\
lOl\
OO
(
)
{
re\
turn\

lOO\
O\
OO\
lO\
lll
==
0
;
}
pr\
ivate
:
lOOllO\
OO\
OO
*
lOOOOOlOll\
l\

;
}
;
clas\
s\

lOOlOOlO\
OO\
l
{
public\

:
cla\
ss
Iterator
{
pu\
b\
lic
:
It\
er\
ato\
r
(
)
{
lOOOOOl\
O\
OO\
O
=
0
;
}
~
Iterato\
r\

(
)
{
}
Iterator
(
Type
*
lO\
Ol\
llOO\
Ol
)
{
In\
itialise\

(
(
lOOll\
OOOOO
*
)
lOOlll\
OOOl
)
;
}
Iterator\

(
const
It\
e\
rator
&
lO\
O\
lOOOO\
O\
OO\

)
{
lO\
OOOOlOOOO
=
lOOl\
OOOOO\
OO\

.
lOOOOOlOOOO
;
}
void
Fi\
n\
alis\
e\

(
)
{
lOOOO\
OlOO\
OO\

=
0
;
}
vo\
i\
d
op\
era\
tor\

++
(
)
{
if
(
lO\
OOOO\
lOOO\
O\

)
lOO\
OOOl\
O\
OOO
=
lOOOOOlO\
O\
OO\

->
lOOOOOl\
OOOl
;
}
void
operat\
or\

--
(
)
{
lOOllOOOO\
O
*
lO\
OlOOOOO\
O\
l
=
(
lOO\
llO\
OOOO
*
)
(
(
u32
)
(
u8
*
)
lOO\
O\
OO\
lOO\
O\
O
->
lOOlOOOOOlO\

-
(
(
u32
)
(
u8\

*
)
&
lO\
OO\
OOlO\
OO\
O
->
lOOOOO\
lOOOl
-
(
u32
)
(
u8
*
)
lOOOOO\
lO\
O\
OO
)
)
;
TA_ASS\
ERT
(
lOOlO\
OOOO\
Ol
->
lOOOO\
OlO\
OOl
==
lO\
OOOO\
lOO\
O\
O\

)
;
lOO\
OOOl\
OOO\
O
=
lO\
Ol\
OO\
OOOOl
;
}
Iterato\
r
&
operator
=
(
co\
nst
Iterator
&
lOOl\
OO\
OOOOO\

)
{
lOOO\
OOl\
OOOO
=
lOO\
lOOO\
OOOO
.
lO\
OO\
OOlOOOO
;
ret\
urn\

*
th\
is
;
}
bool
oper\
at\
or
==
(
con\
st
Iterator
&
lO\
OlOO\
OOOOO
)
co\
nst\

{
return
lO\
OOO\
OlO\
OOO
==
lOOlOOOOOOO
.
lO\
OOO\
O\
lOO\
OO\

;
}
Typ\
e
&
opera\
tor
*
(
)
{
retu\
rn
lOO\
OO\
O\
l\
OO\
O\
O\

->
lOOOOOlOOl\
O
;
}
bo\
ol\

AtE\
nd
(
)
{
return
lO\
OOOOlOOOO
==
0
;
}
priv\
ate
:
frien\
d
cl\
ass
lO\
OlO\
O\
lOOOl\

;
Iterator
(
lOO\
llOOO\
OO
*
lO\
Oll\
l\
OOOl\

)
{
Initialise
(
lO\
OlllOOO\
l
)
;
}
void
In\
itiali\
se
(
lOOllO\
O\
OO\
O
*
lOO\
l\
llOO\
Ol
)
{
lO\
OOOOlOOOO\

=
lO\
OlllOO\
Ol
;
}
void
lOO\
lO\
OOOOl\
l\

(
Ty\
p\
e\

*
lO\
Olll\
O\
OO\
l
)
{
lOOO\
OO\
OllO\

(
lOO\
O\
OOlO\
O\
O\
O\

,
"Pool::Iterator::AddAfter. The iterator is off the end of the array")
;
lO\
OllOO\
O\
OO
*
lO\
OlOOOOlOO\

=
(
lO\
Ol\
l\
OOOOO
*
)
(
lO\
O\
lllO\
OOl
)
;
TA_\
A\
SSERT
(
lO\
O\
lOOOO\
lOO\

)
;
TA\
_AS\
SER\
T
(
lOOl\
OOO\
OlOO
->
lOO\
OOOl\
OO\
Ol\

==
0
)
;
TA\
_A\
S\
S\
E\
RT
(
lOO\
l\
OOOOlOO
->
lOO\
lOOOOOlO
==
0
)
;
lOOl\
OOOOlOO
->
lOO\
O\
OOlOOOl
=
lOOO\
O\
OlOOO\
O\

->
lOO\
OOOlO\
OOl
;
if\

(
lOOlOO\
OOlOO\

->
lOO\
OOOlOOOl
)
lO\
OlOO\
OOlOO\

->
lO\
OOOO\
lO\
OO\
l
->
lO\
OlOO\
OO\
OlO
=
&
lOOlOOO\
OlO\
O
->
lOOOOOlO\
O\
Ol
;
lOOOOOlOO\
OO\

->
lO\
OOOO\
l\
O\
OO\
l
=
lOOlO\
O\
OO\
lOO
;
lOOl\
OOO\
OlOO
->
lOOlOOO\
O\
O\
l\
O
=
&
lOOOOOlOOOO
->
lO\
OOOOlOO\
Ol
;
}
void
lO\
OlOOOOlOl
(
Type\

*
lO\
O\
ll\
lOOOl\

)
{
lO\
OOO\
O\
O\
llO
(
lOOO\
OOl\
OOOO
,
"Pool::Iterator::AddBefore. The iterator is off the end of the array")
;
lO\
O\
llOOOOO\

*
lOOl\
O\
OOOl\
OO
=
(
lO\
Oll\
OOO\
OO\

*
)
(
lOOlll\
OOOl\

)
;
TA\
_ASS\
ERT
(
lOOlOO\
O\
Ol\
OO
)
;
TA_ASSER\
T
(
lO\
Ol\
O\
OO\
OlO\
O\

->
lOOO\
OO\
lOOO\
l
==
0
)
;
TA_ASSER\
T\

(
lOOlO\
OOOlO\
O
->
lOO\
lOOO\
OO\
l\
O
==
0
)
;
lOOlOOOOl\
O\
O\

->
lOOOOO\
lOOOl
=
lOOO\
OOlOOOO
;
lO\
OlOO\
OOl\
OO
->
lOOl\
OO\
O\
OOlO\

=
lOOOOOl\
OOOO
->
lOOlOOOOOl\
O
;
*
lOO\
O\
O\
OlO\
OOO
->
lOOlOO\
OO\
Ol\
O
=
lO\
Ol\
OOOOlOO
;
lO\
OOOO\
lOO\
O\
O
->
lOOl\
O\
O\
OOOl\
O
=
&
lOOlOOO\
Ol\
OO
->
lOOOOOlOOOl
;
}
lOOllOO\
OOO\

*
lOOOOOlOOOO
;
}
;
lOOlOO\
lOOOl
(
)
{
lOO\
OOOl\
Ol\
l\
l\

=
0
;
lOOOO\
OllOO\
l
=
0
;
}
void\

Fina\
l\
ise
(
)
{
#ifdef _DEBUG
while\

(
lOOO\
OO\
lOlll
)
{
lOOllOOO\
OO
*
lOOlllO\
OOl
=
lOOOOOlOlll\

;
lOO\
lllOOOl
->
lOOOOOlOO\
Ol
=
0
;
lOOlllOOO\
l
->
lOOlO\
O\
OOO\
lO
=
0
;
lOO\
O\
OOlO\
l\
ll\

=
lOOOOO\
lOl\
ll\

->
lO\
OOO\
O\
l\
OOOl
;
}
#else //
lO\
OO\
OOlOl\
ll\

=
0
;
#endif //
lO\
OOOOllO\
O\
l
=
0
;
}
Iterato\
r
lOlOOOOl\
OO
(
)
{
return
Ite\
rator
(
lOOOO\
OlOll\
l
)
;
}
void
lOlOlOO\
OO\
l
(
Type\

*
lO\
Ol\
llOOOl
)
{
lOO\
l\
lOO\
OO\
O\

*
lOO\
lOO\
OOl\
O\
O
=
(
lOOllOOOOO
*
)
(
lOOlllOOOl
)
;
TA_\
A\
SS\
ERT\

(
lOOlOOOOlOO
)
;
TA_ASSERT\

(
lOOlO\
OOOl\
OO
->
lOOOO\
OlOO\
Ol
==
0
)
;
TA\
_ASS\
E\
RT\

(
lO\
O\
lO\
O\
O\
OlOO
->
lOOlOOOO\
OlO
==
0
)
;
lOOlO\
OOOl\
OO\

->
lOOOOOlOO\
O\
l\

=
lO\
OOOOlO\
lll\

;
if\

(
lOOlOOOOlOO
->
lOO\
OO\
OlO\
OOl
)
lOOlOO\
OOlOO
->
lOOOOOlO\
OO\
l\

->
lO\
OlOOOOOlO\

=
&
lO\
Ol\
OO\
O\
OlO\
O\

->
lOOOO\
O\
lOOO\
l
;
lOOOOOlO\
l\
l\
l
=
lOOlOO\
OOl\
OO
;
lO\
O\
l\
OO\
OO\
lOO\

->
lO\
Ol\
OOO\
OO\
l\
O
=
&
lO\
OOO\
O\
lOlll
;
if
(
lOOOO\
Ol\
lOOl
==
0
)
lOOOO\
Ol\
lOO\
l
=
lO\
Ol\
O\
OOO\
lOO\

;
TA_ASSERT
(
(
lOO\
OOOllOOl
&&
lOO\
OOOlO\
lll
)
||
(
!
lOOOO\
Ol\
lOOl
&&
!
lOOO\
O\
OlOl\
ll\

)
)
;
}
void\

lOOl\
OO\
O\
O\
llO
(
Typ\
e
*
lOOl\
llOOOl
)
{
lO\
O\
ll\
O\
O\
O\
OO
*
lO\
OlOOOOlOO
=
(
lOOllOOOOO
*
)
(
lOOll\
lOO\
Ol
)
;
TA_ASSE\
R\
T\

(
lO\
OlOOOO\
l\
OO\

)
;
TA_ASSERT
(
lOOlOOOOlO\
O
->
lOOOOOlOO\
Ol
==
0
)
;
TA_ASSERT
(
lOO\
lO\
O\
OOl\
O\
O\

->
lO\
Ol\
OOOO\
OlO
==
0
)
;
if
(
lOO\
OO\
OllOOl
)
{
lOOlO\
O\
OOlOO
->
lOO\
O\
O\
OlOOOl
=
lOOOOOl\
lOO\
l
->
lOOOOOlOOO\
l
;
if
(
lOOl\
O\
OOOl\
OO
->
lOOOOOl\
OO\
Ol
)
lO\
O\
lOO\
OOlOO\

->
lOOO\
OO\
lOO\
Ol
->
lO\
OlOO\
OO\
O\
l\
O
=
&
lOOlOOOOlO\
O
->
lOOO\
OOlOO\
Ol\

;
lOOO\
OO\
llOO\
l
->
lOO\
OO\
O\
lOO\
Ol
=
lOOlO\
OOOl\
OO
;
lOOlOOO\
OlOO
->
lO\
OlO\
OOOOlO\

=
&
lOOOOO\
llOOl
->
lOO\
O\
O\
Ol\
O\
O\
Ol
;
lO\
O\
OOOl\
lOO\
l
=
lOOlOOO\
Ol\
O\
O
;
}
else
{
TA_ASSERT
(
lOOOO\
OlO\
l\
ll
==
0
)
;
lO\
O\
O\
OOlOll\
l\

=
lO\
Ol\
OOOOlOO
;
lO\
OlO\
O\
OOlOO
->
lOOOOOlO\
OOl
=
0
;
lOOlOOO\
Ol\
OO
->
lOOl\
OOOO\
OlO
=
&
lOO\
OOOlO\
ll\
l\

;
lOOOOOllOOl
=
lOOl\
O\
OOOlO\
O
;
}
TA_A\
SS\
ERT\

(
(
lOOO\
O\
O\
llOOl\

&&
lO\
OOO\
OlOlll\

)
||
(
!
lOOOOO\
l\
l\
OOl
&&
!
lOOO\
OO\
l\
Olll
)
)
;
}
void\

lOOlOOOOOll\

(
Type
*
lOOll\
lOOOl
,
Ite\
r\
ator
lOlOO\
lOOl\
O
)
{
if
(
lOOOOOllOOl
==
lOlOOl\
OOl\
O
.
lOO\
OOOlOOOO\

)
lO\
OOOOllOOl
=
(
lO\
Ol\
l\
O\
O\
O\
O\
O
*
)
(
lOOlllOOOl
)
;
lO\
lOO\
lOOlO
.
lO\
O\
lOOOOO\
ll
(
lOOlllOOOl\

)
;
TA_\
A\
S\
SE\
RT
(
(
lOOOOOll\
O\
O\
l\

&&
lOOOOO\
l\
Olll\

)
||
(
!
lO\
OOO\
O\
llO\
Ol
&&
!
lOOOOO\
lO\
lll\

)
)
;
}
voi\
d
lOOlOOOOlO\
l\

(
Type
*
lO\
OlllO\
OOl
,
Ite\
ra\
tor\

lOl\
OO\
lO\
OlO
)
{
lOl\
OOlOOlO
.
lOOlOO\
OOl\
Ol\

(
lOOlllOOOl\

)
;
TA_ASSERT
(
(
lOO\
OOOll\
OOl
&&
lOOOOOlO\
lll
)
||
(
!
lOO\
OO\
O\
llOOl
&&
!
lOOOOOlOl\
ll
)
)
;
}
void
lO\
Ollll\
lll
(
Ty\
pe
*
lOO\
lllOO\
O\
l
)
{
TA_ASSERT
(
(
lOO\
OO\
O\
llO\
O\
l
&&
lO\
OOO\
OlO\
lll
)
||
(
!
lOOOOOllOOl
&&
!
lOOOOOlOlll
)
)
;
lOOllOOOO\
O
*
lOO\
lO\
OO\
O\
lOO
=
(
lO\
Ol\
l\
OOO\
OO
*
)
(
lOOlllOOOl
)
;
TA\
_AS\
S\
ERT\

(
lOO\
l\
OOOO\
lOO
)
;
TA_A\
S\
SERT
(
lOOlO\
OOOlOO
->
lOOlOOO\
OOlO\

)
;
#ifdef _DEBUG
if
(
lOOl\
O\
OOl\
lO
)
{
bool
lOO\
lOOOlOOO\

=
fa\
ls\
e\

;
lOO\
llOOOOO
*
lOOlOOOlOOl
=
lOOOO\
OlO\
lll
;
wh\
ile
(
lOOl\
OOOlOOl\

)
{
if
(
lOO\
lOOOlOO\
l
==
lOOl\
OO\
O\
Ol\
OO
)
{
lOOlOOOl\
OOO
=
true
;
break
;
}
lOOlOO\
OlOOl
=
lOOl\
OOOlOOl
->
lOO\
O\
OO\
lOOOl
;
}
TA_\
AS\
SERT\

(
lO\
O\
lOOOl\
O\
O\
O
)
;
}
#endif //
if\

(
lOOOOOllOOl
==
lOO\
lOOOO\
lOO\

)
{
if\

(
lO\
OOOOlOl\
l\
l
==
lOOlOOO\
OlO\
O
)
{
lOOOOOl\
lO\
Ol
=
0
;
}
el\
se
{
lOO\
l\
lOOO\
OO\

*
lOO\
lOO\
OOOOl
=
(
lOOll\
OO\
OOO
*
)
(
(
uSiz\
e\

)
(
u8
*
)
lOO\
O\
OO\
l\
lOOl
->
lOOl\
OOOOOlO
-
(
(
uS\
iz\
e
)
(
u8
*
)
&
lOOOOOllOOl
->
lOOOOOlOO\
Ol
-
(
uSize
)
(
u8
*
)
lOO\
O\
O\
O\
l\
lOOl\

)
)
;
TA_ASSER\
T
(
lOOlOOOOOOl
->
lO\
OO\
OOl\
OO\
O\
l
==
lOO\
OOO\
l\
lOOl
)
;
lOO\
OO\
Ol\
lO\
Ol
=
lOOl\
OO\
O\
O\
OOl
;
}
}
*
lOO\
lOOO\
OlOO\

->
lOOlOOOOO\
lO
=
lO\
O\
l\
O\
OOOlOO
->
lO\
OO\
OO\
lOO\
Ol
;
if
(
lOOl\
O\
OOOlOO\

->
lO\
O\
OOOlO\
O\
Ol
)
lOO\
lOO\
OO\
lOO
->
lOOOOOl\
OOOl
->
lOOlOOOOOlO\

=
lOOl\
O\
OOOlOO\

->
lO\
Ol\
OO\
OOOl\
O
;
#ifdef _DEBUG
lOO\
lOOOO\
lO\
O
->
lOOOOOl\
OO\
O\
l
=
0
;
lOOlOO\
OOlOO
->
lOOlOOOOO\
lO
=
0
;
#endif //
TA\
_A\
SSE\
R\
T
(
(
lOO\
OOOllOO\
l
&&
lOO\
OOO\
lOlll\

)
||
(
!
lOOOOOll\
OOl
&&
!
lOO\
OOOlOl\
ll
)
)
;
}
void
ll\
OllOllOO\

(
lOOlOO\
lOOOl
&
lOOlOOOlOlO
)
{
lOOllO\
OOOO
*
lO\
OlOOOlOll\

=
lOOlOOOlOl\
O
.
lOOO\
OOlOlll
;
lOOlO\
OO\
lO\
lO
.
lOO\
OOOlOlll
=
lOOOOOl\
O\
lll
;
lOOOOO\
lOll\
l
=
lO\
OlOOOlOll
;
if
(
lOOOO\
OlOlll
)
lOOOO\
OlO\
l\
ll
->
lO\
Ol\
O\
OOOO\
lO
=
&
lO\
O\
OOOlOl\
ll\

;
if
(
lOO\
lOOOlOlO\

.
lOOOOOlOlll
)
lOOlO\
O\
OlOl\
O
.
lOOOO\
OlOlll\

->
lOOl\
OOOO\
Ol\
O
=
&
lOOlOO\
OlOlO
.
lO\
OO\
OO\
lOll\
l
;
lOOlOOOlO\
ll
=
lOOlOOOlOlO\

.
lOOOOOllO\
Ol
;
lOOlOOOlOlO\

.
lO\
OOOO\
l\
lOO\
l
=
lO\
OOO\
O\
llOOl
;
lOOO\
OO\
l\
lO\
Ol
=
lOOl\
OOO\
lOll
;
TA_AS\
S\
E\
R\
T\

(
(
lOOOOOllOO\
l
&&
lOO\
OOO\
l\
Olll
)
||
(
!
lO\
OO\
O\
Oll\
OOl\

&&
!
lOOOOOlO\
lll
)
)
;
TA_\
ASS\
ERT
(
(
lOO\
lOOO\
lOlO
.
lO\
OOOOllO\
Ol\

&&
lO\
OlOOOlOlO
.
lO\
OOOOl\
Olll
)
||
(
!
lOOlOOOlOl\
O
.
lOOO\
OOllOOl
&&
!
lOO\
lOO\
O\
lOlO
.
lO\
OOOOlOl\
ll
)
)
;
}
vo\
id
lOO\
lO\
O\
OllO\
O
(
)
{
#ifdef _DEBUG
lOOllOO\
OOO
*
lOOlOOOlOOl
=
lO\
O\
OOOlOlll
;
while
(
lO\
OlOOOlO\
O\
l
)
{
if\

(
lO\
O\
lOOOl\
O\
Ol
->
lOO\
OOOl\
OOO\
l\

)
TA_\
ASSERT
(
lOO\
lOOO\
lOOl\

->
lO\
OO\
OOl\
OOO\
l
->
lO\
O\
l\
OO\
O\
OOlO
==
&
lOOl\
OOO\
lOO\
l
->
lO\
OOOO\
l\
OOOl
)
;
TA_ASS\
E\
RT\

(
(
*
lOO\
lOOOlOOl\

->
lO\
O\
lOO\
OOO\
lO
)
==
lO\
OlOO\
OlOO\
l
)
;
lOO\
lO\
OOl\
OOl
=
lOO\
lOO\
OlOO\
l
->
lOOOO\
OlO\
OOl\

;
}
#endif //
}
bool
lO\
O\
l\
OOOllOl
(
Ty\
pe
*
lOOlllOOOl
)
{
lOOllOO\
OOO
*
lOOlO\
O\
O\
OlOO
=
(
lOOllO\
O\
OOO
*
)
(
lOOll\
lOOOl
)
;
lO\
O\
llOOOOO
*
lOO\
lOOO\
lOO\
l
=
lOOOOOlO\
lll
;
while\

(
lOOlO\
OOl\
OOl\

)
{
if\

(
lOOl\
O\
O\
OlO\
Ol\

==
lOOlOOOO\
lOO
)
{
return
tru\
e\

;
}
lOO\
lO\
OOlOOl
=
lO\
O\
lOOOlOOl
->
lO\
OOOO\
lO\
O\
Ol
;
}
ret\
u\
rn
false\

;
}
int\

lO\
OOl\
llOOl
(
)
{
in\
t\

lO\
OlllOllO
=
0
;
for
(
Itera\
t\
or
lOlOOlOOlO
=
lO\
lO\
OOOlOO
(
)
;
!
lO\
lOO\
lOO\
lO
.
AtE\
n\
d
(
)
;
++
lOl\
OOlOOlO\

)
lOOlllOllO\

++
;
return\

lOO\
lllOllO
;
}
lOOll\
OO\
OOO
*
lOOlOOl\
OO\
OO\

(
)
{
return
lOOOOOlOlll\

;
}
lOOllOOO\
O\
O
*
lOOlOOlOOl\
O
(
)
{
re\
turn
lO\
OOOO\
llOO\
l
;
}
bool\

lOO\
O\
OOlO\
lOO
(
)
{
return
lOOOO\
Ol\
Olll\

==
0
;
}
privat\
e
:
lOOl\
lOOOOO
*
lO\
OO\
OOlOlll\

;
lOOllOOOOO
*
lOO\
O\
OOllOOl
;
}
;
lOlO\
lllOlO
(
)
;
~
lOlO\
ll\
l\
OlO
(
)
;
voi\
d
Ini\
tiali\
s\
e\

(
int
lOOlllO\
llO
)
;
void\

Fi\
na\
lise
(
)
;
bo\
ol
lOOlO\
Ol\
O\
Ol\
l
(
)
;
Type
*
Allo\
c
(
)
;
void
Free\

(
Type
*
lOOlll\
O\
OOl
)
;
voi\
d
ll\
Ol\
Ol\
OO\
ll\

(
lOlOl\
l\
lO\
ll\

&
lOOl\
OOOlOlO
)
;
int
lOOlO\
OlO\
lOO
(
)
;
bool
lOOlO\
OlOlO\
l\

(
)
;
int
lOOOlllOOl
(
)
;
pr\
iv\
ate
:
fr\
iend
class\

lO\
lO\
l\
llOll\

;
stru\
ct
lOOllOO\
OOO
{
Type
lOOO\
O\
OlO\
OlO\

;
lOOl\
lO\
OOOO
*
lOOOO\
Ol\
OOOl\

;
lOOllOOOOO
*
*
lOOlOO\
OO\
Ol\
O
;
}
;
str\
uct
lO\
OlOO\
lOllO
{
lO\
Oll\
OOOO\
O
*
lOO\
l\
OO\
lOl\
l\
l
;
lOOl\
OOlOl\
l\
O
*
lOOOOOlOOOl\

;
}
;
int
lOlOOOlOOl\

;
lOOl\
OOlOllO
lOOlOO\
llOO\
O
;
lOlOlll\
Oll\

lOOlOOllOOl
;
}
;
}
#include "../Common/zcta006.inl"
#endif //

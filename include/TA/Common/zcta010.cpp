//---------------------------------------------------------------------------------
// File Name: zcta010.cpp
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_DEPRECATE
#endif
#include "../Common/zcta007.h"
#ifndef TA_DEBUG_H
#include "Debug.h"
#endif //
#include <stdio.h>
#include <memory.h>
#ifndef lOlOlOOllO
#include <io.h>
#endif
names\
pace
TA\

{
static\

inlin\
e
FIL\
E
*
ll\
lllllllO
(
uSiz\
e\

ll\
lllll\
lll\

)
{
retur\
n\

(
FILE
*
)
ll\
llllllll\

;
}
stati\
c
inline\

uSi\
ze\

lO\
OOO\
OOOO\
OO
(
FI\
LE
*
lllOOOllOO\

)
{
return
(
uSi\
ze
)
ll\
l\
OOOll\
O\
O\

;
}
lO\
O\
OOOOOOOl\

::
lOOO\
O\
OOOOOl
(
)
{
lO\
OOO\
OOOOlO
=
0
;
}
lOOOOOOOOO\
l
::
~
lO\
OOOOO\
O\
OO\
l
(
)
{
Finalise\

(
)
;
}
bool\

lOOO\
OOOOOOl
::
Ini\
tialise
(
co\
n\
st
Cha\
r\

*
lll\
OO\
O\
l\
Oll
)
{
if
(
lOOOOOOO\
OlO\

!=
0
)
{
TA_ASSERT
(
0
)
;
Finalise
(
)
;
}
FILE
*
ll\
l\
OOOllOO
=
fope\
n\

(
lllO\
OOlOll\

,
"wb")
;
if
(
!
lllO\
OO\
ll\
OO
)
{
TA\
_ASSERT
(
0
)
;
ret\
u\
rn
false
;
}
lOO\
OOOOOOl\
O\

=
lO\
OOOOOO\
O\
OO
(
lllO\
OO\
ll\
OO
)
;
lOOOOOOOO\
l\
l\

=
ll\
lOOOlO\
ll
;
return
tr\
ue
;
}
void
lO\
OO\
OOOOOOl
::
Finalise
(
)
{
TA_ASSERT
(
lOOO\
O\
O\
O\
OOlO
)
;
FI\
LE\

*
lll\
OO\
Ol\
lOO
=
llllllll\
l\
O\

(
lOOOOOOOO\
l\
O
)
;
if\

(
!
lll\
OOOllOO\

)
retu\
rn
;
fcl\
os\
e\

(
ll\
lO\
O\
OllOO
)
;
lOOO\
O\
O\
OOO\
ll
.
Clear
(
)
;
}
vo\
id
lOOOO\
OO\
OOO\
l
::
lOlO\
Ol\
lOlO
(
void
*
lOOlll\
OO\
OO
,
int
lOOlll\
O\
llO\

)
{
TA\
_A\
S\
SE\
RT
(
lOOOOOOOOlO
)
;
FILE
*
lllO\
OO\
llOO
=
lll\
llllllO
(
lO\
OOOOOOO\
lO
)
;
size_t\

lO\
OOOO\
OOlO\
O
=
fwrite
(
lOOl\
llOO\
O\
O
,
lO\
OlllOllO
,
1
,
lll\
OO\
OllOO
)
;
TA_AS\
SER\
T
(
lOO\
OOOOOlOO
==
1
)
;
}
lOOOO\
OOOlOl
::
lOO\
O\
OOOOl\
O\
l
(
)
{
lOOO\
O\
OOO\
l\
l\
O
=
0
;
lOOOOOOOlll
=
0
;
lOl\
OOO\
lOOl
=
0
;
}
lOOOOOOOlOl
::
~
lOO\
OO\
OOOlO\
l\

(
)
{
Finali\
se
(
)
;
}
void
lOOOO\
OOO\
lOl
::
Init\
i\
alise
(
voi\
d
*
lOOll\
lOOOO
,
in\
t
lO\
O\
ll\
lO\
ll\
O
)
{
TA\
_A\
SSERT\

(
lOOll\
lOOOO
)
;
TA_A\
SSERT\

(
lOOl\
llOllO
)
;
lOOOO\
O\
O\
O\
l\
lO\

=
(
u8\

*
)
lOOlllOOOO
;
lOOOOOO\
Olll\

=
0
;
lOlOOOl\
OOl
=
lOOlllOl\
lO
;
}
void
lO\
OOOOOO\
lOl
::
Fi\
nalis\
e
(
)
{
lOOOOO\
O\
O\
llO
=
0
;
lOOO\
O\
OOOl\
ll\

=
0
;
lOlOOOlOOl
=
0
;
}
voi\
d
lOOO\
O\
OOO\
lOl
::
lOlOOllOl\
O
(
vo\
id\

*
lO\
O\
l\
l\
lO\
OO\
O
,
int\

lOOlll\
OllO
)
{
if
(
lO\
OOOO\
OOlll
+
lOOlllOllO\

<=
lOlO\
OOlOO\
l
)
memc\
py
(
&
lOOOOOOOl\
lO\

[
lOOO\
OOOO\
lll
]
,
lOOlll\
OOOO
,
lOO\
lll\
OllO
)
;
lO\
O\
OOO\
OOlll
+=
lOOlllOll\
O
;
}
lOOO\
O\
OOlOOO
::
lOOOO\
O\
OlOOO
(
)
{
lOOOOOOOOlO
=
0
;
}
lOOOOOOlOO\
O
::
~
lO\
OOOOOlOOO
(
)
{
Final\
ise
(
)
;
}
bool
lO\
OOOOOl\
OO\
O
::
Init\
iali\
se
(
co\
nst\

Char
*
lll\
O\
O\
OlO\
l\
l
)
{
if
(
lOOOO\
OO\
OOl\
O
!=
0
)
{
TA_ASSERT
(
0
)
;
Fin\
a\
lise
(
)
;
}
FILE
*
lllOOOllOO
=
fop\
e\
n
(
lllO\
OOlO\
ll\

,
"rb")
;
if\

(
!
lllOOO\
llO\
O
)
{
re\
turn
fals\
e
;
}
lO\
OOO\
O\
O\
OOlO
=
lOOO\
O\
O\
O\
OOOO
(
ll\
lO\
OO\
ll\
OO\

)
;
lO\
OOOOOO\
Oll
=
lllO\
OOl\
Ol\
l
;
re\
t\
urn
true
;
}
void\

lOOOOOOlOO\
O\

::
Fi\
na\
lise
(
)
{
if
(
lOOOOO\
OOOl\
O
)
{
FI\
L\
E
*
lllO\
OOllOO
=
lllll\
l\
ll\
lO\

(
lOOOOOOOO\
lO\

)
;
if\

(
!
lllOOOllO\
O
)
return\

;
fclose
(
lll\
OOO\
llOO
)
;
}
lOO\
OOOOO\
Oll
.
Cle\
ar
(
)
;
}
vo\
i\
d
lOOOOOOlOOO
::
lOlO\
Ol\
l\
Ol\
O\

(
voi\
d
*
lOOl\
llOO\
O\
O
,
int\

lOOlllOllO
)
{
TA_A\
SSERT\

(
lO\
OOOOOOO\
lO
)
;
FILE
*
ll\
l\
OOOllOO
=
lllll\
l\
l\
llO
(
lOO\
OOOOOOlO
)
;
size_t
lOOOOOOOlOO
=
fr\
e\
ad
(
lO\
Oll\
l\
OO\
OO
,
lOOl\
llOllO
,
1
,
lllOO\
Ol\
lOO
)
;
TA_ASSE\
RT
(
lOOO\
O\
O\
O\
OlOO
==
1
)
;
}
int
lOOO\
O\
OO\
lOOO
::
lOl\
OOllOOl
(
)
{
FIL\
E
*
lllO\
OOllO\
O
=
lll\
ll\
lll\
l\
O\

(
lOO\
OOO\
OOO\
lO
)
;
return
ftell
(
lllOOOllOO
)
;
}
int
lOOO\
OOOlO\
OO
::
lO\
O\
OlllOOl
(
)
{
#ifdef lOlOlOOllO
lOO\
OOOO\
ll\
O
(
0
,
"Error, IOStreamInputFile::GetSize() un-implemented in linux")
;
return\

0
;
#else
FILE
*
lllO\
OO\
llOO\

=
llll\
lllllO
(
lOOOO\
O\
O\
OO\
lO
)
;
re\
t\
ur\
n
_fi\
lelength\

(
_file\
no
(
lll\
OOOl\
l\
OO
)
)
;
#endif
}
lOOOOO\
OlOO\
l
::
lO\
OO\
O\
OOlOOl
(
)
{
lOO\
O\
O\
OO\
O\
llO
=
0
;
lO\
OOO\
OOOl\
ll
=
0
;
lOl\
OOOlOOl
=
0
;
}
lO\
O\
OOOOlOOl
::
~
lOO\
OOOOl\
OOl
(
)
{
Finalise\

(
)
;
}
voi\
d
lO\
OOOOO\
lOOl\

::
Init\
ia\
lise
(
void
*
lO\
Ol\
ll\
OO\
OO
,
int\

lOOl\
l\
l\
OllO
)
{
TA_\
ASS\
E\
R\
T
(
lO\
O\
l\
llOO\
OO
)
;
TA_ASS\
ERT\

(
lOOlll\
OllO\

)
;
lO\
O\
OOOOOllO\

=
(
u8
*
)
lOOlll\
OOOO
;
lOOOOO\
O\
Olll
=
0
;
lO\
lOOO\
lOOl\

=
lO\
Oll\
lOll\
O
;
}
voi\
d\

lOOOOO\
OlOO\
l
::
Fina\
li\
s\
e
(
)
{
lOO\
OO\
O\
OOll\
O\

=
0
;
lOO\
O\
OO\
OOlll
=
0
;
lOlOO\
Ol\
OOl\

=
0
;
}
vo\
id
lO\
OOOOOlOOl
::
lOlO\
OllOl\
O
(
vo\
id
*
lOOl\
l\
l\
O\
OO\
O
,
int
lOOlllOllO
)
{
if\

(
lOOO\
OO\
O\
Ol\
ll
+
lOOlllOl\
l\
O
<=
lOlOOOlOOl
)
me\
mc\
py
(
lOO\
l\
llO\
OOO
,
&
lOOO\
OOO\
OllO\

[
lOOOOO\
O\
O\
l\
ll
]
,
lOOlllOl\
lO
)
;
lOOO\
OO\
OO\
lll
+=
lOOl\
llOl\
lO
;
}
lOO\
O\
O\
OO\
lOlO
::
lOOOO\
O\
OlO\
lO\

(
)
{
lOlOOOl\
OOl
=
0
;
}
lOO\
OOOOl\
OlO
::
~
lO\
OOOOOl\
OlO
(
)
{
lO\
OOOOOlO\
lO
::
Finalise\

(
)
;
}
vo\
i\
d
lO\
OO\
OOOlOlO\

::
In\
it\
ia\
li\
se
(
)
{
lOl\
OOOlOOl
=
0
;
}
void
lOOOOOOlOlO
::
Fi\
n\
ali\
se
(
)
{
lOlO\
O\
O\
lO\
O\
l
=
0
;
}
vo\
id
lO\
OOOO\
OlO\
lO
::
lOlO\
O\
llO\
lO
(
void
*
lOOl\
ll\
O\
OOO
,
in\
t\

lO\
O\
l\
ll\
Ol\
lO
)
{
lOlOOOlOOl\

+=
lOO\
lllOllO
;
}
}

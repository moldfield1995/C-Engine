//---------------------------------------------------------------------------------
// File Name: zcta019.h
//
// Copyright (C) 2004 - 2006 True Axis Pty Ltd, Australia.
// All Rights Reserved.
//
//---------------------------------------------------------------------------------

#ifndef lOlOOOOOOOO
#define lOlOOOOOOOO
#ifndef DOXYGEN
namespace
TA
{
st\
ruc\
t
Vec3\

;
nam\
espa\
ce\

lO\
l\
O\
OOOOllO
{
TA_A\
LIGN_1\
6
str\
uct\

lO\
lO\
O\
OOOll\
l\

{
fl\
oat
x
;
fl\
oat
y
;
flo\
at
z
;
fl\
oat
w
;
__for\
cei\
n\
line
floa\
t
lOlOOO\
OlOO\
O
(
)
const\

{
re\
turn
x
;
}
__forceinlin\
e
float
lOlOO\
OOlOOl
(
)
const
{
ret\
urn\

y
;
}
__\
fo\
rcein\
line\

float
lOlO\
OOOl\
O\
lO
(
)
const
{
re\
turn
z
;
}
}
;
temp\
l\
ate\

<
cl\
as\
s\

Type
>
str\
uct
lO\
lO\
OOOl\
Ol\
l
:
public\

Type
,
publi\
c\

lOlOOO\
OOlll
{
}
;
templ\
at\
e
<
clas\
s
Type
>
str\
uct
lOlOOOOllO\
O\

{
__force\
inl\
ine
fl\
o\
at
lOlOOOOll\
Ol
(
)
co\
n\
st
{
retur\
n\

(
(
Type
&
)
(
*
this
)
)
.
lOl\
OOO\
OlOOO
(
)
;
}
__f\
or\
cei\
n\
line\

fl\
oa\
t
lOlOOOOlllO
(
)
const
{
return
(
(
Typ\
e
&
)
(
*
thi\
s
)
)
.
lOl\
OO\
OO\
lOOl
(
)
;
}
__f\
orceinl\
i\
ne\

flo\
a\
t
lO\
l\
OOOO\
llll
(
)
cons\
t
{
ret\
urn
(
(
Typ\
e
&
)
(
*
th\
is
)
)
.
lOlO\
OOO\
l\
O\
lO
(
)
;
}
tem\
p\
late\

<
cla\
ss
lO\
l\
O\
O\
O\
lO\
O\
OO\

,
cla\
s\
s
lOlOOO\
l\
OOO\
l
>
st\
atic\

__forceinlin\
e\

fl\
oat\

Dot
(
const
lOl\
OOOOl\
l\
OO
<
lOlOOOlOO\
OO
>
&
lll\
OOlllO\
O
,
co\
n\
st\

lOlO\
OOO\
llOO
<
lOlOOOlOOOl
>
&
lllOlOOOO\
O
)
{
ret\
u\
rn\

ll\
lOOlllOO\

.
lOl\
OOO\
OllO\
l\

(
)
*
lllOlOO\
OOO
.
lOlOO\
OOl\
lOl
(
)
+
lll\
OOlll\
OO
.
lOlO\
OO\
OlllO
(
)
*
ll\
lO\
lOOOOO
.
lOlO\
OO\
Oll\
l\
O
(
)
+
lll\
O\
OlllOO
.
lOlOOOO\
ll\
ll
(
)
*
lllOlO\
O\
OOO\

.
lOlOOO\
Ol\
l\
ll
(
)
;
}
tem\
plat\
e\

<
clas\
s
lOl\
OOOlO\
O\
O\
O
>
__force\
in\
l\
in\
e
fl\
o\
a\
t
Dot\

(
con\
s\
t
lO\
lOOOOll\
O\
O
<
lO\
l\
OO\
OlO\
O\
OO\

>
&
lOlO\
OOlO\
OlO
)
const
{
re\
tur\
n
Dot\

(
*
th\
is
,
lOl\
OOOl\
OOlO
)
;
}
templat\
e
<
cl\
as\
s
lOlOO\
Ol\
O\
O\
OO
,
cla\
s\
s
lOlOOOlO\
O\
O\
l
>
static\

__\
for\
cei\
n\
line\

lOlOOO\
Ol\
Ol\
l
<
lOlOOOO\
llOO
<
lOl\
OOO\
OOl\
ll
>
>
Cross
(
co\
ns\
t\

lO\
lO\
OOOll\
O\
O
<
lOl\
O\
OOlOOOO
>
&
ll\
lOOlllO\
O
,
co\
nst\

lOlO\
OOOllOO
<
lOlOO\
OlO\
OOl
>
&
lllOl\
OO\
OOO
)
{
lOlO\
O\
OOOl\
ll
ll\
l\
llllll\

;
llllll\
l\
ll
.
x
=
lllOOlll\
OO
.
lO\
l\
OOOOl\
lOl
(
)
;
lll\
lll\
l\
ll
.
y
=
lllOOl\
llOO
.
lOlOOOO\
lll\
O
(
)
;
ll\
lllllll\

.
z
=
lllOOll\
l\
OO
.
lO\
l\
OO\
O\
Olll\
l
(
)
;
lO\
lOO\
O\
OOlll
lOO\
OOOOOO\
O
;
lOOO\
O\
O\
OOOO
.
x
=
ll\
lO\
lOOO\
OO
.
lOlO\
OOOl\
lOl
(
)
;
lO\
OOOOOO\
OO
.
y
=
lllOlOOOO\
O\

.
lOlOOOO\
lllO
(
)
;
lOOO\
OOOOOO\

.
z
=
ll\
l\
OlOOOOO
.
lOl\
O\
OO\
Ol\
ll\
l
(
)
;
lOlOOOOl\
O\
ll
<
lOlO\
O\
OOl\
lOO
<
lOl\
OOOOOlll
>
>
lOO\
OO\
ll\
Olll\

;
lOO\
O\
OllOlll
.
x
=
lll\
lllll\
l\

.
y
*
lOO\
OOO\
OOOO
.
z
-
lll\
l\
lllll
.
z
*
lOOO\
O\
OO\
O\
OO
.
y
;
lO\
OOOllOl\
ll
.
y
=
llllll\
l\
ll
.
z
*
lOOO\
OOOOOO
.
x
-
ll\
lll\
llll
.
x
*
lOO\
OOO\
O\
OOO
.
z
;
lOOOOllOlll
.
z
=
ll\
ll\
lllll
.
x
*
lOOOOOOOOO\

.
y
-
llll\
llll\
l
.
y
*
lOOO\
OOOO\
OO
.
x
;
return
lOOOOllOlll
;
}
te\
mplate
<
class
lO\
lOOO\
lOOOO
>
__forcein\
l\
ine
lOl\
OOOOlOll
<
lOlOOO\
Oll\
OO\

<
lO\
l\
OOOOOl\
ll\

>
>
Cro\
ss\

(
cons\
t
lOlO\
OOOllO\
O
<
lOlO\
O\
O\
l\
OOOO
>
&
lllOlOOOO\
O
)
cons\
t
{
return\

Cro\
ss
(
*
this\

,
ll\
lO\
l\
OO\
O\
OO\

)
;
}
__forcein\
l\
ine\

flo\
at
Get\
M\
ag\
nitude
(
)
co\
nst
{
floa\
t
lO\
lOOOlOOl\
l\

=
lOlOO\
OOllOl
(
)
;
float\

lOlOOOlOl\
OO\

=
lOlOOOlOOll
*
lOlOO\
OlO\
Oll\

;
float
lOlOOOlOlO\
l\

=
lOl\
OOOOll\
lO
(
)
;
lO\
lOOOl\
OlOO
+=
lOlOOO\
lOlOl
*
lOlOOOlOl\
Ol
;
float\

lOlOOOl\
Oll\
O
=
lO\
lO\
OOOlll\
l
(
)
;
lOl\
OO\
OlOl\
OO
+=
lOlOO\
OlO\
l\
lO\

*
lO\
lOOOlO\
l\
lO
;
return
Sq\
rt
(
lOlOOOlOlOO\

)
;
}
templ\
a\
te
<
cla\
s\
s
lO\
lO\
OOlOOOO
>
st\
at\
ic
in\
l\
ine
float
TA_V\
E\
C3_\
CALL\

GetMag\
nitude
(
const
lOlO\
OOOll\
O\
O
<
lOlOOOlOOOO\

>
&
lll\
OO\
l\
llOO
)
{
return
lll\
O\
OlllO\
O
.
Ge\
tM\
ag\
nitude
(
)
;
}
__forcei\
nline
floa\
t
Get\
M\
ag\
n\
it\
udeSqrd\

(
)
con\
st
{
flo\
a\
t
lOl\
OOOlOOl\
l
=
lOlOO\
OOllOl
(
)
;
float\

lOl\
OOO\
lO\
lOO\

=
lOlOO\
OlOOll
*
lOlO\
O\
OlOO\
ll
;
fl\
o\
at
lOlOO\
OlOlOl
=
lOlOO\
O\
Ol\
llO\

(
)
;
lOl\
OOOlOlOO
+=
lOl\
OOOl\
OlOl
*
lOl\
OO\
O\
l\
O\
l\
Ol\

;
float
lOlOOOlOllO\

=
lOlOOOO\
llll
(
)
;
lOlOO\
Ol\
Ol\
O\
O\

+=
lOlOOOlOllO
*
lOlOOOlOllO
;
return
lOlOO\
O\
lOlOO
;
}
template
<
cla\
s\
s
lO\
lOOOlOOO\
O
>
stat\
ic
inlin\
e\

float
TA\
_VEC3_\
CAL\
L
GetMag\
nitu\
de\
Sqrd\

(
const
lOlO\
OOOllOO
<
lOlOOOlOO\
OO\

>
&
lllOOlllOO
)
{
retur\
n
ll\
lOO\
l\
l\
lOO\

.
Ge\
t\
M\
agn\
itudeS\
qrd
(
)
;
}
__fo\
rcei\
nl\
ine
Vec3
GetNormal
(
)
const
;
template
<
cl\
as\
s
lO\
lOOO\
lOOO\
O\

>
static\

__\
f\
orc\
e\
inli\
n\
e
lOl\
O\
OO\
OlOll
<
lO\
l\
OOO\
OllOO
<
lOlOO\
OOOlll
>
>
GetNormal
(
const
lOlOO\
OO\
llO\
O
<
lO\
lOOO\
lOOOO
>
&
lllOlOO\
OO\
O\

)
{
ret\
ur\
n
ll\
lOlOOOO\
O
.
Get\
N\
or\
mal
(
)
;
}
}
;
struct\

lOlOlOOO\
O\
l\

{
stati\
c\

__forcein\
li\
ne
float
lO\
lO\
O\
OOllO\
l
(
flo\
at
lllO\
Olll\
OO
,
float
ll\
l\
Ol\
OOOOO
)
{
return
lllO\
OlllOO
+
ll\
lOlOOOOO
;
}
stati\
c
__fo\
rceinlin\
e
fl\
oat
lOl\
OO\
OOll\
l\
O
(
float
lllOOlll\
OO
,
float
lll\
O\
lOOO\
OO
)
{
re\
turn
ll\
l\
O\
O\
lll\
OO\

+
lllOlO\
OO\
OO
;
}
st\
atic\

__forc\
e\
inline
flo\
a\
t\

lOlO\
O\
OOllll
(
flo\
a\
t\

lllO\
Ol\
l\
lOO
,
flo\
at
lll\
Ol\
OOO\
OO
)
{
ret\
urn
lllO\
OlllOO\

+
lllOlOO\
OOO\

;
}
stat\
ic
__forceinlin\
e\

flo\
at
lOl\
O\
OOlO\
l\
ll\

(
floa\
t
ll\
lO\
OlllOO
,
floa\
t
lllOl\
OO\
OOO
)
{
return
lllOOll\
lOO\

+
lll\
OlOOOOO
;
}
}
;
stru\
ct
lOlO\
OOl\
lO\
OO
{
static
__\
forcei\
nline
floa\
t
lOl\
OOO\
Ol\
lOl
(
float
lll\
OOl\
l\
lOO
,
flo\
at\

lllOlOOO\
O\
O
)
{
return\

lllOO\
lll\
OO\

-
lllOlOOO\
OO
;
}
static
__\
forc\
einline
float
lOlOOOOl\
llO\

(
float\

lllOO\
l\
llO\
O
,
flo\
a\
t
lllOlO\
OO\
O\
O
)
{
return
lllOOlllO\
O\

-
lllOlOOOOO
;
}
static
__\
force\
inline\

float
lO\
lOOOOl\
lll
(
flo\
at
lll\
O\
Olll\
OO
,
flo\
at
ll\
lOlO\
OOOO
)
{
re\
tur\
n
lllOO\
lll\
OO
-
ll\
lOlO\
OOOO
;
}
static
__forcei\
nline
floa\
t
lOl\
OOOlO\
lll
(
fl\
oat
lllOOlllOO\

,
flo\
a\
t
ll\
lOlOOOOO
)
{
return
lllOOlllO\
O
-
lll\
OlO\
OOOO
;
}
}
;
struct
Mul
{
static\

__\
forceinline
float
lOl\
O\
OOO\
llOl
(
floa\
t
lllOOl\
ll\
OO
,
float
lll\
OlOOOOO
)
{
re\
turn\

lllOO\
l\
ll\
OO
*
lll\
O\
l\
OOOO\
O
;
}
stati\
c
__fo\
rcei\
nline
float\

lO\
lOOO\
Oll\
lO
(
fl\
oat\

ll\
lOO\
lllOO\

,
fl\
oat
ll\
l\
O\
lO\
OOOO
)
{
return\

lllOO\
lllOO
*
lllO\
lOOOOO\

;
}
stat\
ic
__\
fo\
rceinl\
i\
ne\

floa\
t
lO\
l\
O\
OOOlll\
l
(
floa\
t\

lllO\
O\
l\
llO\
O
,
floa\
t
ll\
l\
O\
lOOOOO
)
{
return
lllOOll\
l\
OO\

*
lllOlO\
OOOO
;
}
stat\
i\
c
__for\
cein\
li\
ne\

fl\
oat
lO\
lOOOl\
Olll
(
float\

lllOOlllOO
,
float
lllOlOOO\
OO
)
{
retur\
n\

ll\
lOOlllOO
*
lllO\
l\
OOO\
OO
;
}
}
;
struct
lOlOO\
OllO\
O\
l
{
st\
atic\

__\
for\
ceinl\
ine
fl\
o\
a\
t
lOl\
O\
OOOllO\
l
(
flo\
at
lll\
O\
Olll\
OO
,
float
lllO\
lOOO\
O\
O
)
{
retur\
n\

lllOO\
lllOO
/
lll\
OlO\
OO\
OO
;
}
st\
at\
i\
c
__forceinl\
i\
ne
fl\
o\
at\

lO\
lOOOOlllO
(
float
lllOOlll\
OO\

,
flo\
at
lllOl\
OOOOO
)
{
ret\
ur\
n\

lllOOlll\
OO\

/
ll\
lOlOOOOO
;
}
stati\
c
__\
fo\
rcein\
lin\
e
float\

lOlOO\
O\
Ol\
lll
(
floa\
t
lllOO\
ll\
lOO\

,
fl\
o\
at
lllOlO\
O\
OO\
O\

)
{
return\

lllO\
Ol\
l\
lOO\

/
ll\
l\
O\
lO\
OO\
OO
;
}
static
__\
f\
or\
cei\
nline
fl\
oat\

lOl\
OOOlOlll\

(
float
lll\
OOlll\
O\
O
,
flo\
at
lll\
O\
l\
OO\
O\
OO\

)
{
retur\
n
lllO\
Ol\
l\
l\
OO
/
lllOlOOO\
OO
;
}
}
;
st\
ruct
lOlOO\
O\
l\
lOlO\

{
static
__\
fo\
rcein\
li\
ne
float
lOlO\
O\
O\
Ol\
lO\
l\

(
fl\
o\
a\
t
lllOOll\
lOO
)
{
ret\
urn\

lll\
O\
O\
lllOO\

;
}
st\
a\
tic\

__\
f\
orcei\
nl\
in\
e\

fl\
oat\

lOlOOOOl\
llO
(
float
lll\
OO\
ll\
lO\
O\

)
{
return\

lllOOl\
llOO
;
}
static\

__forc\
ei\
nline\

flo\
at
lOlOOOOlll\
l
(
floa\
t
lll\
OOlllOO
)
{
return
lllOO\
lllOO
;
}
stati\
c
__forceinl\
in\
e
flo\
at
lOl\
OOOl\
Olll\

(
float
lllO\
Ol\
l\
l\
O\
O
)
{
ret\
u\
rn\

lllO\
Oll\
l\
OO\

;
}
}
;
str\
uc\
t
lO\
lOOOl\
lO\
ll
{
st\
at\
ic
__f\
o\
rcei\
nline
fl\
oat\

lO\
lO\
OO\
OllOl\

(
float
lll\
OOlllO\
O
)
{
return\

-
lllOOl\
ll\
OO
;
}
sta\
tic\

__forceinlin\
e
fl\
oat
lOl\
O\
OOO\
lllO\

(
flo\
at
lllOOll\
l\
OO
)
{
return
-
ll\
lOOlllOO\

;
}
st\
atic
__f\
o\
rceinli\
ne
fl\
oat
lOlOOO\
O\
l\
ll\
l
(
fl\
oat\

lllOO\
lllOO\

)
{
ret\
u\
rn\

-
lll\
O\
OlllOO
;
}
stat\
ic
__forc\
e\
inli\
ne
floa\
t
lOlOOO\
lOlll
(
floa\
t
lllOO\
ll\
lOO
)
{
ret\
ur\
n
-
ll\
lO\
O\
lll\
OO
;
}
}
;
te\
mp\
late
<
cl\
as\
s\

lO\
lOOOlOOO\
O
,
cl\
ass
lOlOOOlOO\
Ol
,
cl\
a\
ss
lOl\
O\
OO\
lllOO
>
struct
lOlOOOlllOl
:
public\

lOlOOOO\
l\
lO\
O
<
lOlOOOlll\
Ol\

>
{
const
lOlOOOlOO\
O\
O
&
lOlOOOlll\
lO\

;
co\
nst\

lOl\
OOO\
l\
OO\
O\
l
&
lOlO\
OOl\
l\
l\
ll
;
__fo\
rc\
einli\
n\
e
lOlOOOlll\
Ol\

(
co\
ns\
t
lO\
lOOOlO\
OOO
&
lllOOlllOO
,
const
lOlO\
OO\
lO\
OOl
&
ll\
l\
OlOOOO\
O\

)
:
lO\
lO\
OOll\
llO\

(
lllO\
O\
lll\
OO
)
,
lOlOOOlllll
(
ll\
lOlOO\
OOO
)
{
}
__forcei\
nline\

fl\
oat\

lO\
lO\
O\
O\
Ol\
O\
OO
(
)
co\
nst
{
return
lO\
lOOOl\
llO\
O\

::
lO\
l\
OOO\
OllOl
(
lOlOOOl\
l\
ll\
O
.
lOlOOOOl\
l\
Ol
(
)
,
lOlOOOl\
l\
lll\

.
lOl\
O\
O\
OOll\
Ol
(
)
)
;
}
__for\
ce\
inli\
n\
e\

floa\
t
lOl\
OO\
OOlOOl
(
)
co\
nst
{
retu\
rn
lO\
lOOOll\
lOO
::
lOl\
O\
OOOlllO
(
lOl\
OO\
Oll\
l\
lO\

.
lO\
lOO\
OOl\
llO
(
)
,
lO\
lOOO\
l\
llll
.
lOlOO\
O\
Olll\
O
(
)
)
;
}
__forcein\
line
float
lOlOOOO\
lOlO
(
)
const
{
re\
turn\

lOlO\
OO\
ll\
l\
O\
O
::
lOlOOO\
Ollll
(
lOlOO\
O\
llllO
.
lO\
lOO\
OO\
llll
(
)
,
lOlO\
OOllll\
l\

.
lO\
lOOOOll\
ll
(
)
)
;
}
}
;
temp\
late\

<
class\

lOlOOOlOO\
OO
,
class\

lOlOOOlll\
OO
>
st\
ruct\

lOlO\
OlO\
OOO\
O
:
publi\
c
lOlO\
OOO\
llOO
<
lOlO\
O\
lOOOO\
O
>
{
const
lOl\
OO\
OlO\
O\
O\
O
&
lOlO\
OO\
lll\
l\
O
;
__\
for\
c\
e\
i\
n\
li\
ne
lO\
l\
O\
Ol\
OO\
OOO
(
con\
st
lOlOO\
O\
l\
OOOO
&
lllOOl\
llOO
)
:
lOl\
OOO\
ll\
l\
lO
(
lllO\
Oll\
lOO\

)
{
}
__fo\
r\
cei\
n\
lin\
e
float\

lOlOO\
O\
OlO\
OO
(
)
const\

{
re\
tu\
rn
lOl\
OOO\
ll\
l\
OO\

::
lOlOOOOllOl
(
lOlOO\
Oll\
llO
.
lOlOOOO\
llOl
(
)
)
;
}
__forceinline
floa\
t
lOlO\
OOO\
lOOl\

(
)
const
{
ret\
u\
rn
lOlO\
OO\
l\
l\
lOO
::
lOl\
O\
OO\
O\
l\
llO
(
lOl\
O\
O\
O\
lll\
lO
.
lOlO\
O\
OOlllO
(
)
)
;
}
__for\
ceinli\
n\
e\

float
lOlOO\
O\
OlOlO
(
)
co\
nst\

{
return\

lOlOO\
O\
lll\
OO
::
lO\
lO\
OOOllll
(
lO\
lOOOllllO
.
lOl\
OOOOl\
ll\
l
(
)
)
;
}
}
;
templa\
te
<
cl\
a\
ss
lOlOOOlOOOO
,
cla\
ss
lO\
lOOOlllOO
>
st\
r\
uct
lOlOO\
l\
OO\
OOl
:
publ\
ic
lOl\
OO\
OOllOO
<
lO\
l\
OOlOO\
OO\
l
>
{
const\

lO\
lOOOlOO\
OO
&
lOlOO\
OllllO
;
const
fl\
o\
at\

lOlOOO\
lllll\

;
__f\
or\
c\
ein\
li\
n\
e\

lOl\
O\
OlOOOOl
(
const
lOlOOOlOOOO
&
lllOOlllOO
,
co\
ns\
t
fl\
oa\
t
ll\
l\
Ol\
O\
OOO\
O
)
:
lO\
lOOOllll\
O
(
lll\
O\
Oll\
lOO\

)
,
lOlOOOl\
llll
(
lllOlOOOOO
)
{
}
__forcein\
lin\
e
fl\
o\
at
lOlO\
OOOlO\
OO\

(
)
const
{
retur\
n\

lOlOOO\
lllOO
::
lOl\
OOO\
O\
ll\
Ol
(
lO\
l\
OOO\
lll\
l\
O
.
lOlOOOOllOl
(
)
,
lOlOOOl\
ll\
l\
l\

)
;
}
__forceinl\
in\
e\

float
lO\
lO\
OOOlOOl\

(
)
const
{
ret\
ur\
n
lOlO\
OOlllOO
::
lOl\
O\
OOOlllO
(
lOlO\
OOllllO\

.
lOlOO\
OOl\
llO
(
)
,
lOlOO\
Ol\
lll\
l
)
;
}
__fo\
rc\
einlin\
e
fl\
oat
lOlOOO\
Ol\
Ol\
O
(
)
cons\
t\

{
re\
tur\
n
lOlOOOl\
l\
lO\
O\

::
lOlOOO\
Olll\
l\

(
lO\
lOOOllllO
.
lOlO\
OOOllll
(
)
,
lOl\
OOOlllll
)
;
}
}
;
temp\
late
<
clas\
s
lOlO\
OOl\
OOOl\

,
cla\
ss\

lOl\
OOOlllOO
>
struct\

lOlOOlOO\
O\
lO
:
pu\
bli\
c
lOlO\
OOOllOO\

<
lO\
lOOlO\
O\
O\
lO
>
{
const\

fl\
oat\

lO\
l\
OO\
OllllO
;
const
lO\
lO\
OOl\
OOOl
&
lOlOOOlllll
;
__\
f\
or\
cei\
nli\
ne
lOl\
OOlOOOlO
(
con\
st\

floa\
t
lllOOl\
llO\
O
,
con\
st
lO\
lOOOl\
OOOl
&
lll\
OlOOOOO\

)
:
lOlOOOllll\
O
(
ll\
l\
OOl\
llOO
)
,
lOlOO\
O\
l\
llll
(
lllOlO\
OOO\
O\

)
{
}
__fo\
rc\
ein\
l\
ine
float
lOlOO\
O\
OlOOO
(
)
con\
st
{
retur\
n
lOlO\
OOll\
lOO
::
lO\
lOOO\
Oll\
Ol
(
lOlOOOllllO
,
lOlOO\
O\
lllll\

.
lOlO\
OO\
OllOl\

(
)
)
;
}
__forceinli\
ne
fl\
oat
lOlOOOOlOO\
l\

(
)
const
{
retu\
rn
lOlOOOll\
lOO\

::
lO\
lOOOO\
l\
llO
(
lOlOOOllllO
,
lOlO\
OOl\
l\
l\
ll
.
lOlOOOOlllO
(
)
)
;
}
__forc\
einli\
ne
float
lO\
lOOO\
OlO\
lO
(
)
con\
st\

{
retu\
rn
lOlOOO\
l\
llOO
::
lO\
lOOO\
Oll\
ll
(
lOlOOOl\
ll\
lO\

,
lOlO\
OOll\
lll
.
lOlOOOOllll
(
)
)
;
}
}
;
}
struct\

TACOMMON_CL\
ASS
Vec3
:
publi\
c
lO\
lO\
OOOOll\
O
::
lOlO\
OOO\
O\
l\
l\
l
,
public
lOlOOOO\
O\
llO\

::
lOlOO\
OOl\
l\
O\
O
<
Vec3
>
{
en\
um
Axi\
s
{
AXIS_X
=
0
,
AXIS\
_Y
,
AXIS_Z\

,
}
;
Vec\
3
(
)
{
}
;
Vec\
3
(
const
Vec\
3
&
lll\
lOOl\
OOl\

)
{
x
=
llllO\
OlOO\
l
.
x
;
y
=
llll\
OOlOOl
.
y
;
z
=
llll\
OOlOOl
.
z
;
}
Vec3\

(
float
lOlOOOlOOll
,
float
lOlO\
OOlOlOl
,
float\

lOl\
OOO\
lOl\
lO\

)
{
x
=
lOlOO\
O\
lOOll
;
y
=
lOlOOOl\
O\
lO\
l
;
z
=
lO\
lOOOlO\
l\
lO\

;
}
tem\
plate
<
class
Ty\
pe
>
__f\
o\
rceinline\

Ve\
c\
3\

&
oper\
at\
o\
r\

=
(
con\
st
lOl\
OOOOO\
l\
lO\

::
lOlO\
OO\
Oll\
O\
O
<
Ty\
pe
>
&
lOlOOOlOOl\
O
)
{
x
=
lO\
l\
OOO\
lOOlO
.
lOlOOOOl\
l\
O\
l
(
)
;
y
=
lOlOOO\
lO\
Ol\
O
.
lO\
lOO\
OOlllO
(
)
;
z
=
lOlO\
OOlOOlO
.
lOl\
OO\
OOl\
lll
(
)
;
return
*
thi\
s
;
}
templ\
ate
<
cl\
ass
Ty\
pe\

>
__for\
ceinl\
i\
ne\

Vec\
3\

(
con\
s\
t
lOl\
OOOOO\
llO\

::
lOl\
OOOOll\
OO
<
Typ\
e
>
&
lOlOOOl\
OO\
lO\

)
{
x
=
lOlOOOl\
OOlO
.
lOlO\
O\
OO\
llOl
(
)
;
y
=
lO\
lOOOl\
OOlO
.
lOlOO\
OOlllO
(
)
;
z
=
lOlOOOlO\
Ol\
O
.
lO\
l\
O\
OOOl\
l\
ll
(
)
;
}
__f\
orc\
e\
inlin\
e
voi\
d
Init\
i\
alise
(
flo\
a\
t\

lO\
l\
OOO\
l\
OO\
ll
,
flo\
at
lOlOOOlOlO\
l
,
float
lO\
lOOOlOl\
lO\

)
{
x
=
lOlOO\
OlOO\
ll
;
y
=
lOlOO\
OlOlOl
;
z
=
lOlO\
OOlOll\
O
;
}
ope\
ra\
t\
o\
r
fl\
o\
at
*
(
)
{
return
(
float\

*
)
&
x
;
}
operato\
r
const
float
*
(
)
const
{
return
(
float
*
)
&
x
;
}
fl\
oat
&
operator
[
]
(
int
lO\
O\
OlOOl\
ll
)
{
return\

(
(
fl\
oat
*
)
&
x
)
[
lO\
O\
OlOO\
l\
l\
l
]
;
}
const
flo\
at
&
op\
er\
ator\

[
]
(
int\

lOO\
OlOOl\
ll
)
const
{
return
(
(
float\

*
)
&
x
)
[
lOOO\
lO\
Ol\
ll
]
;
}
temp\
la\
te
<
cla\
ss\

Type
>
__fo\
rc\
ei\
nlin\
e
Vec3\

&
ope\
rator
+=
(
const
lO\
l\
O\
OOO\
Ol\
lO\

::
lO\
lOOOOl\
lOO
<
Type
>
&
lOlOO\
O\
l\
OOlO
)
{
x
+=
lOlOOOl\
O\
OlO
.
lO\
lOOOOl\
lOl
(
)
;
y
+=
lOlOOOlO\
OlO
.
lOlOO\
OOlllO
(
)
;
z
+=
lOlOOOlOO\
lO
.
lOlOO\
O\
O\
l\
lll\

(
)
;
return
*
thi\
s
;
}
tem\
pl\
ate
<
clas\
s
Type
>
__f\
orceinline
Vec3
&
operato\
r\

-=
(
const
lOlO\
O\
O\
OOllO
::
lOlOOOOllO\
O
<
Ty\
pe
>
&
lOlOOOlOO\
l\
O
)
{
x
-=
lOlO\
OOlOOlO
.
lOl\
OOO\
OllOl
(
)
;
y
-=
lOl\
O\
OO\
l\
OO\
lO
.
lO\
lO\
OOOll\
lO
(
)
;
z
-=
lOlO\
OOlOO\
lO
.
lO\
lOOOOl\
lll\

(
)
;
return
*
th\
is
;
}
__for\
ceinlin\
e\

Vec3
&
operat\
or
*=
(
float
lOOOOOlllO
)
{
x
*=
lO\
OOOO\
lll\
O\

;
y
*=
lOOOOOlllO
;
z
*=
lOOOOOlll\
O\

;
re\
tur\
n
*
thi\
s
;
}
__forceinlin\
e
Vec3
&
operat\
o\
r
/=
(
flo\
at
lOOO\
OOll\
lO\

)
{
floa\
t\

lOlOOlOO\
Ol\
l
=
1.0f
/
lOOO\
OOll\
lO
;
x
*=
lOlOOl\
OO\
Oll
;
y
*=
lOlOOlO\
OO\
l\
l
;
z
*=
lOlOOl\
OOO\
l\
l
;
retur\
n
*
this
;
}
static
inline
Vec\
3\

TA_\
VE\
C\
3\
_\
CALL
CrossW\
i\
thUn\
itX
(
co\
nst\

Vec3
&
ll\
llOO\
lOOl
)
{
return
Vec\
3
(
0.0f
,
ll\
llOOlOO\
l
.
z
,
-
llll\
OOlOOl\

.
y
)
;
}
inline\

Ve\
c3
Cr\
o\
s\
sW\
ithUnitX
(
)
con\
st
{
retu\
rn
CrossWithUnitX
(
*
thi\
s
)
;
}
static\

inli\
ne\

Vec3
TA\
_V\
E\
C3_CALL
CrossW\
it\
hUnitY\

(
const
Ve\
c3
&
ll\
llOO\
lO\
Ol
)
{
re\
tur\
n
Vec3\

(
-
llll\
OO\
lOOl
.
z
,
0.0f
,
lll\
l\
OO\
lOOl
.
x
)
;
}
inlin\
e\

Vec3
Cr\
os\
sWith\
UnitY
(
)
cons\
t
{
retur\
n
Cro\
s\
sWithUni\
tY
(
*
this
)
;
}
static
inli\
n\
e
Vec3
TA\
_VE\
C3_\
CALL
CrossWithUnitZ
(
const
Ve\
c\
3
&
ll\
l\
lOOlOO\
l\

)
{
return
Vec\
3
(
llllOO\
lOOl
.
y
,
-
lll\
lO\
OlOOl
.
x
,
0.0f
)
;
}
inline
Vec3
CrossWithUnitZ
(
)
const
{
ret\
u\
r\
n
Cr\
oss\
WithUnitZ
(
*
th\
is
)
;
}
stati\
c
inline\

float
TA\
_VE\
C\
3\
_\
CAL\
L
Cro\
ssX
(
const
Ve\
c\
3
&
lllll\
ll\
ll\

,
const
Vec3\

&
lOOOOOOO\
OO
)
{
re\
turn
lllll\
llll
.
y
*
lOOOOOO\
OOO\

.
z
-
llll\
llll\
l
.
z
*
lOOOOOOOO\
O
.
y
;
}
inline
float
Cr\
ossX\

(
const
Vec3
&
ll\
llOOlOOl
)
con\
st
{
return
CrossX
(
*
th\
is
,
llll\
OOlOOl
)
;
}
static
inline
float
TA_VE\
C3_C\
A\
LL
CrossY
(
const\

Vec3
&
lll\
llllll
,
co\
n\
st
Vec3
&
lOOO\
OOOOOO
)
{
ret\
urn\

lllllllll
.
z
*
lOOO\
O\
OO\
OO\
O
.
x
-
ll\
l\
l\
ll\
lll
.
x
*
lOOOO\
OO\
OOO\

.
z
;
}
inline\

flo\
at
Cr\
os\
sY\

(
const
Vec3
&
llll\
O\
Ol\
OOl\

)
cons\
t
{
return
Cr\
oss\
Y\

(
*
th\
is
,
llll\
OOlOOl
)
;
}
sta\
tic
in\
li\
n\
e
float\

TA_\
VEC\
3_CA\
LL
Cros\
s\
Z
(
const
Ve\
c\
3\

&
llll\
l\
llll
,
co\
n\
st
Vec3
&
lO\
OO\
OOOOOO\

)
{
return
lll\
ll\
llll
.
x
*
lO\
O\
O\
OO\
OOOO
.
y
-
lllllll\
ll
.
y
*
lOOOOOOOOO
.
x
;
}
inline
float
Cr\
os\
sZ
(
co\
ns\
t
Vec3\

&
llll\
OO\
lO\
Ol
)
cons\
t\

{
re\
turn
Cro\
ssZ
(
*
this
,
ll\
l\
lOO\
lO\
O\
l\

)
;
}
sta\
tic
inline
Vec3\

TA_VEC3_CALL
Mi\
n
(
const
Ve\
c3\

&
lllllll\
ll
,
co\
ns\
t\

Vec\
3\

&
lO\
OO\
OO\
O\
OO\
O
)
{
Vec3
lOlOO\
l\
OO\
lO\
O
;
lOl\
OOlOOl\
OO\

.
x
=
lllll\
llll\

.
x
<
lO\
OOO\
OOOOO
.
x
?
lllllllll
.
x
:
lOO\
OOOOOOO
.
x
;
lO\
l\
OOl\
OOlO\
O\

.
y
=
lllllllll
.
y
<
lOOO\
OOOOOO\

.
y
?
lll\
llllll
.
y
:
lO\
OOOOO\
OOO
.
y
;
lOlOOlOO\
lOO
.
z
=
lll\
l\
lllll
.
z
<
lO\
O\
O\
O\
O\
OO\
OO
.
z
?
lllll\
llll
.
z
:
lOO\
OO\
OOO\
OO
.
z
;
ret\
u\
rn
lOlOOlO\
O\
lOO
;
}
static
inli\
ne\

Vec3
TA_VEC\
3_CA\
LL
Ma\
x
(
co\
ns\
t\

Vec3
&
lllll\
llll
,
const
Vec\
3\

&
lOOOOOOOOO
)
{
Ve\
c3\

lOlOOl\
OOlO\
O\

;
lO\
l\
O\
OlOOlOO
.
x
=
llllllll\
l
.
x
>
lO\
O\
OOOOOOO
.
x
?
ll\
llll\
ll\
l
.
x
:
lOOOOO\
OOO\
O
.
x
;
lOl\
O\
O\
lOOlO\
O
.
y
=
llll\
lllll
.
y
>
lOOO\
OO\
OOOO
.
y
?
lll\
llllll
.
y
:
lOOOOOOOOO
.
y
;
lOlOO\
lOOlOO\

.
z
=
lll\
l\
l\
llll
.
z
>
lOOO\
OOO\
OOO
.
z
?
llllll\
lll
.
z
:
lOO\
OOOOOOO
.
z
;
ret\
u\
rn
lOlOOlOO\
l\
OO
;
}
__for\
c\
einl\
ine
vo\
i\
d
Normalise
(
)
{
(
*
th\
is
)
*=
Rec\
iproc\
al\
Sqrt
(
GetMagn\
it\
udeS\
q\
rd\

(
)
)
;
}
__force\
inl\
ine
voi\
d\

Clea\
r
(
)
{
x
=
0.0f
;
y
=
0.0f
;
z
=
0.0f
;
}
__\
f\
orce\
i\
nline\

bo\
ol
Is\
Norm\
ali\
sed\

(
)
const
{
return
IsEqua\
lToO\
n\
eW\
ith\
In\
Er\
r\
o\
r\

(
Get\
Magnit\
udeSqr\
d
(
)
)
;
}
__f\
orceinline
bool
IsZer\
o
(
)
co\
nst
{
re\
turn
GetMa\
g\
nitudeSq\
r\
d
(
)
==
0.0f
;
}
__f\
orc\
einl\
ine\

int
Get\
Grea\
t\
estAxis
(
)
const
;
__\
for\
cei\
n\
li\
ne
flo\
at\

Get\
Max
(
)
const
{
retu\
rn
TA
::
Ma\
x
(
TA
::
Max\

(
x
,
y
)
,
z
)
;
}
__forc\
ei\
nli\
ne
float
GetM\
in
(
)
co\
nst
{
return\

TA
::
Min
(
TA
::
Min
(
x
,
y
)
,
z
)
;
}
__f\
o\
rc\
einline
void
Get\
AxisO\
rder
(
int
llllO\
OlO\
l\
l
[
3
]
)
const\

;
__\
forceinline
flo\
at\

Get\
A\
xi\
s
(
int
lO\
OOl\
OOl\
ll
)
const\

{
return
(
*
this
)
[
lO\
O\
OlOO\
l\
ll
]
;
}
static
__forc\
e\
i\
nli\
ne
co\
nst
Ve\
c3
&
TA\
_\
V\
EC3\
_C\
ALL
GetU\
nitVecto\
r
(
int
lOOOlOO\
ll\
l\

)
;
}
;
const
Vec3\

k_v3Zero
(
0.0f
,
0.0f
,
0.0f
)
;
co\
nst
Vec3
k_v3UnitX
(
1.0f
,
0.0f
,
0.0f
)
;
const
Vec3
k_v3\
Un\
it\
Y
(
0.0f
,
1.0f
,
0.0f
)
;
cons\
t
Vec3
k_\
v3\
Un\
it\
Z
(
0.0f
,
0.0f
,
1.0f
)
;
}
#include "../Common/zcta012.inl"
#endif //
#endif //
